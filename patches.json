{ "name": "hello world", "commits": [{"commit":"8e1ca32cec51a8884adff9ff63ad53f459ce5d8c","author":"Nick <massaalonso@yandex.ru>","date":"Sun May 17 16:40:02 2015 +0800","comment":"Initial commit","content":"Original"},{"commit":"bd0049f4d0639be5d3ff5f666c2568c7008cdaef","author":"Nick Stepanenko <massaalonso@yandex.ru>","date":"Sun May 17 16:46:31 2015 +0800","comment":"New commit","content":"diff --git a/.gitignore b/.gitignore\nnew file mode 100644\nindex 0000000..723ef36\n--- /dev/null\n+++ b/.gitignore\n@@ -0,0 +1 @@\n+.idea\n\\ No newline at end of file\ndiff --git a/main.js b/main.js\nnew file mode 100644\nindex 0000000..a4f68be\n--- /dev/null\n+++ b/main.js\n@@ -0,0 +1,65 @@\n+/**\n+ * Created by Nick on 16.03.2015.\n+ */\n+\n+var fs = require('fs');\n+\n+function findData(text, keyword) {\n+    var data = [];\n+    var splittext = text.split('\\n');\n+\n+    for(i=0; i<splittext.length; i++) {\n+        if(splittext[i].indexOf(keyword) > -1) {\n+            data[data.length] = splittext[i].slice(keyword.length+1).trim();\n+        }\n+    }\n+\n+    return data;\n+}\n+\n+function findComments(text) {\n+    var comments = [];\n+    var splittext = text.split('\\n\\n');\n+\n+    for(i=1; i<splittext.length; i+=2) {\n+        comments[comments.length] = splittext[i].trim();\n+    }\n+\n+    return comments;\n+}\n+\n+fs.exists('../.git', function (exists) {\n+    if(exists) {\n+        var cp = require('child_process');\n+\n+        cp.exec('git diff', function(error, stdout, stderr) {\n+            console.log(stdout);\n+\n+            //fs.writeFileSync(\"patches.sousp\", stdout);\n+\n+            if (error !== null) {\n+                console.log('stderr: ' + stderr);\n+                console.log('exec error: ' + error);\n+            }\n+        });\n+\n+        cp.exec('git log', function(error, stdout, stderr) {\n+            //console.log(stdout);\n+\n+            var authors = findData(stdout, \"Author:\");\n+            var dates = findData(stdout, \"Date:\");\n+            var comments = findComments(stdout);\n+            //console.log(authors);\n+            //console.log(comments);\n+            //console.log(dates);\n+\n+            //fs.writeFileSync(\"comments.sousc\", stdout);\n+\n+            if (error !== null) {\n+                console.log('stderr: ' + stderr);\n+                console.log('exec error: ' + error);\n+            }\n+        });\n+    }\n+    else console.log(\"Error.\");\n+});\n\\ No newline at end of file\ndiff --git a/package.json b/package.json\nnew file mode 100644\nindex 0000000..5f21627\n--- /dev/null\n+++ b/package.json\n@@ -0,0 +1,22 @@\n+{\n+  \"name\": \"sous\",\n+  \"version\": \"0.0.1\",\n+  \"description\": \"Sous project\",\n+  \"main\": \"main.js\",\n+  \"dependencies\": {\n+},\n+  \"devDependencies\": {},\n+  \"scripts\": {\n+    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n+  },\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"https://github.com/NickStepanenko/sous.git\"\n+  },\n+  \"author\": \"Nick Stepanenko <massaalonso@yandex.ru>\",\n+  \"license\": \"ISC\",\n+  \"bugs\": {\n+    \"url\": \"https://github.com/NickStepanenko/sous/issues\"\n+  },\n+  \"homepage\": \"https://github.com/NickStepanenko/sous\"\n+}\n"},{"commit":"be4929d2307043334b29b872760f31b1f2387a10","author":"Nick Stepanenko <massaalonso@yandex.ru>","date":"Sun May 17 16:54:24 2015 +0800","comment":"Clean main.js","content":"diff --git a/main.js b/main.js\nindex a4f68be..e69de29 100644\n--- a/main.js\n+++ b/main.js\n@@ -1,65 +0,0 @@\n-/**\n- * Created by Nick on 16.03.2015.\n- */\n-\n-var fs = require('fs');\n-\n-function findData(text, keyword) {\n-    var data = [];\n-    var splittext = text.split('\\n');\n-\n-    for(i=0; i<splittext.length; i++) {\n-        if(splittext[i].indexOf(keyword) > -1) {\n-            data[data.length] = splittext[i].slice(keyword.length+1).trim();\n-        }\n-    }\n-\n-    return data;\n-}\n-\n-function findComments(text) {\n-    var comments = [];\n-    var splittext = text.split('\\n\\n');\n-\n-    for(i=1; i<splittext.length; i+=2) {\n-        comments[comments.length] = splittext[i].trim();\n-    }\n-\n-    return comments;\n-}\n-\n-fs.exists('../.git', function (exists) {\n-    if(exists) {\n-        var cp = require('child_process');\n-\n-        cp.exec('git diff', function(error, stdout, stderr) {\n-            console.log(stdout);\n-\n-            //fs.writeFileSync(\"patches.sousp\", stdout);\n-\n-            if (error !== null) {\n-                console.log('stderr: ' + stderr);\n-                console.log('exec error: ' + error);\n-            }\n-        });\n-\n-        cp.exec('git log', function(error, stdout, stderr) {\n-            //console.log(stdout);\n-\n-            var authors = findData(stdout, \"Author:\");\n-            var dates = findData(stdout, \"Date:\");\n-            var comments = findComments(stdout);\n-            //console.log(authors);\n-            //console.log(comments);\n-            //console.log(dates);\n-\n-            //fs.writeFileSync(\"comments.sousc\", stdout);\n-\n-            if (error !== null) {\n-                console.log('stderr: ' + stderr);\n-                console.log('exec error: ' + error);\n-            }\n-        });\n-    }\n-    else console.log(\"Error.\");\n-});\n\\ No newline at end of file\n"},{"commit":"e3c853a4282dfe8f000685dc1d39bd55a4a946c4","author":"Nick Stepanenko <massaalonso@yandex.ru>","date":"Sun May 17 16:54:58 2015 +0800","comment":"Recovered main.js","content":"diff --git a/main.js b/main.js\nindex e69de29..f81b54e 100644\n--- a/main.js\n+++ b/main.js\n@@ -0,0 +1,65 @@\n+/**\n+ * Created by Nick on 16.03.2015.\n+ */\n+\n+var fs = require('fs');\n+\n+function findData(text, keyword) {\n+    var data = [];\n+    var splittext = text.split('\\n');\n+\n+    for(i=0; i<splittext.length; i++) {\n+        if(splittext[i].indexOf(keyword) > -1) {\n+            data[data.length] = splittext[i].slice(keyword.length+1).trim();\n+        }\n+    }\n+\n+    return data;\n+}\n+\n+function findComments(text) {\n+    var comments = [];\n+    var splittext = text.split('\\n\\n');\n+\n+    for(i=1; i<splittext.length; i+=2) {\n+        comments[comments.length] = splittext[i].trim();\n+    }\n+\n+    return comments;\n+}\n+\n+fs.exists('.git', function (exists) {\n+    if(exists) {\n+        var cp = require('child_process');\n+\n+        cp.exec('git diff', function(error, stdout, stderr) {\n+            console.log(stdout);\n+\n+            //fs.writeFileSync(\"patches.sousp\", stdout);\n+\n+            if (error !== null) {\n+                console.log('stderr: ' + stderr);\n+                console.log('exec error: ' + error);\n+            }\n+        });\n+\n+        cp.exec('git log', function(error, stdout, stderr) {\n+            //console.log(stdout);\n+\n+            var authors = findData(stdout, \"Author:\");\n+            var dates = findData(stdout, \"Date:\");\n+            var comments = findComments(stdout);\n+            console.log(authors);\n+            console.log(comments);\n+            console.log(dates);\n+\n+            //fs.writeFileSync(\"comments.sousc\", stdout);\n+\n+            if (error !== null) {\n+                console.log('stderr: ' + stderr);\n+                console.log('exec error: ' + error);\n+            }\n+        });\n+    }\n+    else console.log(\"Error.\");\n+});\n\\ No newline at end of file\n"},{"commit":"c9d318fea74ea288d544ecf72f00b12c130cf2ef","author":"Nick Stepanenko <massaalonso@yandex.ru>","date":"Sun May 17 16:59:40 2015 +0800","comment":"Create system files","content":"diff --git a/comments.sousc b/comments.sousc\nnew file mode 100644\nindex 0000000..150b0f6\n--- /dev/null\n+++ b/comments.sousc\n@@ -0,0 +1,23 @@\n+commit e3c853a4282dfe8f000685dc1d39bd55a4a946c4\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\n+Date:   Sun May 17 16:54:58 2015 +0800\n+\n+    Recovered main.js\n+\n+commit be4929d2307043334b29b872760f31b1f2387a10\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\n+Date:   Sun May 17 16:54:24 2015 +0800\n+\n+    Clean main.js\n+\n+commit bd0049f4d0639be5d3ff5f666c2568c7008cdaef\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\n+Date:   Sun May 17 16:46:31 2015 +0800\n+\n+    New commit\n+\n+commit 8e1ca32cec51a8884adff9ff63ad53f459ce5d8c\n+Author: Nick <massaalonso@yandex.ru>\n+Date:   Sun May 17 16:40:02 2015 +0800\n+\n+    Initial commit\ndiff --git a/main.js b/main.js\nindex f81b54e..744cdd5 100644\n--- a/main.js\n+++ b/main.js\n@@ -35,7 +35,7 @@ fs.exists('.git', function (exists) {\n         cp.exec('git diff', function(error, stdout, stderr) {\n             console.log(stdout);\n \n-            //fs.writeFileSync(\"patches.sousp\", stdout);\n+            fs.writeFileSync(\"patches.sousp\", stdout);\n \n             if (error !== null) {\n                 console.log('stderr: ' + stderr);\n@@ -44,7 +44,7 @@ fs.exists('.git', function (exists) {\n         });\n \n         cp.exec('git log', function(error, stdout, stderr) {\n-            //console.log(stdout);\n+            console.log(stdout);\n \n             var authors = findData(stdout, \"Author:\");\n             var dates = findData(stdout, \"Date:\");\n@@ -53,7 +53,7 @@ fs.exists('.git', function (exists) {\n             console.log(comments);\n             console.log(dates);\n \n-            //fs.writeFileSync(\"comments.sousc\", stdout);\n+            fs.writeFileSync(\"comments.sousc\", stdout);\n \n             if (error !== null) {\n                 console.log('stderr: ' + stderr);\ndiff --git a/patches.sousp b/patches.sousp\nnew file mode 100644\nindex 0000000..16405a3\n--- /dev/null\n+++ b/patches.sousp\n@@ -0,0 +1,31 @@\n+diff --git a/main.js b/main.js\n+index f81b54e..744cdd5 100644\n+--- a/main.js\n++++ b/main.js\n+@@ -35,7 +35,7 @@ fs.exists('.git', function (exists) {\n+         cp.exec('git diff', function(error, stdout, stderr) {\n+             console.log(stdout);\n+ \n+-            //fs.writeFileSync(\"patches.sousp\", stdout);\n++            fs.writeFileSync(\"patches.sousp\", stdout);\n+ \n+             if (error !== null) {\n+                 console.log('stderr: ' + stderr);\n+@@ -44,7 +44,7 @@ fs.exists('.git', function (exists) {\n+         });\n+ \n+         cp.exec('git log', function(error, stdout, stderr) {\n+-            //console.log(stdout);\n++            console.log(stdout);\n+ \n+             var authors = findData(stdout, \"Author:\");\n+             var dates = findData(stdout, \"Date:\");\n+@@ -53,7 +53,7 @@ fs.exists('.git', function (exists) {\n+             console.log(comments);\n+             console.log(dates);\n+ \n+-            //fs.writeFileSync(\"comments.sousc\", stdout);\n++            fs.writeFileSync(\"comments.sousc\", stdout);\n+ \n+             if (error !== null) {\n+                 console.log('stderr: ' + stderr);\n"},{"commit":"64814d140d2fab6ae153cac485008119f29bf230","author":"Nick Stepanenko <massaalonso@yandex.ru>","date":"Sun May 17 17:03:58 2015 +0800","comment":"From clear list","content":"diff --git a/main.js b/main.js\ndeleted file mode 100644\nindex 744cdd5..0000000\n--- a/main.js\n+++ /dev/null\n@@ -1,65 +0,0 @@\n-/**\n- * Created by Nick on 16.03.2015.\n- */\n-\n-var fs = require('fs');\n-\n-function findData(text, keyword) {\n-    var data = [];\n-    var splittext = text.split('\\n');\n-\n-    for(i=0; i<splittext.length; i++) {\n-        if(splittext[i].indexOf(keyword) > -1) {\n-            data[data.length] = splittext[i].slice(keyword.length+1).trim();\n-        }\n-    }\n-\n-    return data;\n-}\n-\n-function findComments(text) {\n-    var comments = [];\n-    var splittext = text.split('\\n\\n');\n-\n-    for(i=1; i<splittext.length; i+=2) {\n-        comments[comments.length] = splittext[i].trim();\n-    }\n-\n-    return comments;\n-}\n-\n-fs.exists('.git', function (exists) {\n-    if(exists) {\n-        var cp = require('child_process');\n-\n-        cp.exec('git diff', function(error, stdout, stderr) {\n-            console.log(stdout);\n-\n-            fs.writeFileSync(\"patches.sousp\", stdout);\n-\n-            if (error !== null) {\n-                console.log('stderr: ' + stderr);\n-                console.log('exec error: ' + error);\n-            }\n-        });\n-\n-        cp.exec('git log', function(error, stdout, stderr) {\n-            console.log(stdout);\n-\n-            var authors = findData(stdout, \"Author:\");\n-            var dates = findData(stdout, \"Date:\");\n-            var comments = findComments(stdout);\n-            console.log(authors);\n-            console.log(comments);\n-            console.log(dates);\n-\n-            fs.writeFileSync(\"comments.sousc\", stdout);\n-\n-            if (error !== null) {\n-                console.log('stderr: ' + stderr);\n-                console.log('exec error: ' + error);\n-            }\n-        });\n-    }\n-    else console.log(\"Error.\");\n-});\n\\ No newline at end of file\n"},{"commit":"9ef3d25fd4c3afdbcc3107a0abf6d7a2e29cb4dd","author":"Nick Stepanenko <massaalonso@yandex.ru>","date":"Sun May 17 17:04:52 2015 +0800","comment":"Adding new file","content":"diff --git a/main.js b/main.js\nnew file mode 100644\nindex 0000000..6793bb9\n--- /dev/null\n+++ b/main.js\n@@ -0,0 +1,3 @@\n+/**\n+ * Created by Nick on 17.05.2015.\n+ */\n"},{"commit":"4420cabefc1f470af341af11ed595df67e25c51f","author":"Nick Stepanenko <massaalonso@yandex.ru>","date":"Sun May 17 17:05:35 2015 +0800","comment":"Paste old program code","content":"diff --git a/main.js b/main.js\nindex 6793bb9..e34dc18 100644\n--- a/main.js\n+++ b/main.js\n@@ -1,3 +1,65 @@\n /**\n  * Created by Nick on 17.05.2015.\n  */\n+\n+var fs = require('fs');\n+\n+function findData(text, keyword) {\n+    var data = [];\n+    var splittext = text.split('\\n');\n+\n+    for(i=0; i<splittext.length; i++) {\n+        if(splittext[i].indexOf(keyword) > -1) {\n+            data[data.length] = splittext[i].slice(keyword.length+1).trim();\n+        }\n+    }\n+\n+    return data;\n+}\n+\n+function findComments(text) {\n+    var comments = [];\n+    var splittext = text.split('\\n\\n');\n+\n+    for(i=1; i<splittext.length; i+=2) {\n+        comments[comments.length] = splittext[i].trim();\n+    }\n+\n+    return comments;\n+}\n+\n+fs.exists('.git', function (exists) {\n+    if(exists) {\n+        var cp = require('child_process');\n+\n+        cp.exec('git diff', function(error, stdout, stderr) {\n+            console.log(stdout);\n+\n+            fs.writeFileSync(\"patches.sousp\", stdout);\n+\n+            if (error !== null) {\n+                console.log('stderr: ' + stderr);\n+                console.log('exec error: ' + error);\n+            }\n+        });\n+\n+        cp.exec('git log', function(error, stdout, stderr) {\n+            console.log(stdout);\n+\n+            var authors = findData(stdout, \"Author:\");\n+            var dates = findData(stdout, \"Date:\");\n+            var comments = findComments(stdout);\n+            console.log(authors);\n+            console.log(comments);\n+            console.log(dates);\n+\n+            fs.writeFileSync(\"comments.sousc\", stdout);\n+\n+            if (error !== null) {\n+                console.log('stderr: ' + stderr);\n+                console.log('exec error: ' + error);\n+            }\n+        });\n+    }\n+    else console.log(\"Error.\");\n+});\n\\ No newline at end of file\n"},{"commit":"1e947f613e976945de85ae35ed923aa470f0be72","author":"Nick Stepanenko <massaalonso@yandex.ru>","date":"Tue May 19 00:12:12 2015 +0800","comment":"Latest updates","content":"diff --git a/comments.sousc b/comments.sousc\nindex 150b0f6..cb3a850 100644\n--- a/comments.sousc\n+++ b/comments.sousc\n@@ -1,3 +1,27 @@\n+commit 4420cabefc1f470af341af11ed595df67e25c51f\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\n+Date:   Sun May 17 17:05:35 2015 +0800\n+\n+    Paste old program code\n+\n+commit 9ef3d25fd4c3afdbcc3107a0abf6d7a2e29cb4dd\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\n+Date:   Sun May 17 17:04:52 2015 +0800\n+\n+    Adding new file\n+\n+commit 64814d140d2fab6ae153cac485008119f29bf230\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\n+Date:   Sun May 17 17:03:58 2015 +0800\n+\n+    From clear list\n+\n+commit c9d318fea74ea288d544ecf72f00b12c130cf2ef\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\n+Date:   Sun May 17 16:59:40 2015 +0800\n+\n+    Create system files\n+\n commit e3c853a4282dfe8f000685dc1d39bd55a4a946c4\n Author: Nick Stepanenko <massaalonso@yandex.ru>\n Date:   Sun May 17 16:54:58 2015 +0800\ndiff --git a/main.js b/main.js\nindex e34dc18..86f30c2 100644\n--- a/main.js\n+++ b/main.js\n@@ -3,6 +3,56 @@\n  */\n \n var fs = require('fs');\n+var cp = require('child_process');\n+var data = [];\n+\n+var async = require('async');\n+    /*tasks = [\n+        function (callback) {\n+            cp.exec('git log', function(error, stdout, stderr) {\n+                var listOfCommits = [];\n+                var authors = findData(stdout, \"Author:\");\n+                var dates = findData(stdout, \"Date:\");\n+                var comments = findComments(stdout);\n+                var commitNumbers = findCommitNumbers(stdout);\n+\n+                for(i=0; i<authors.length; i++) {\n+                    var commit = {\n+                        \"commit\": commitNumbers[i],\n+                        \"author\": authors[i],\n+                        \"date\": dates[i],\n+                        \"comment\": comments[i],\n+                        \"content\": 'Original'\n+                    };\n+\n+                    listOfCommits[listOfCommits.length] = commit;\n+                }\n+\n+                data = listOfCommits.reverse();\n+\n+                callback(null, data);\n+\n+                if (error !== null) {\n+                    console.log('stderr: ' + stderr);\n+                    console.log('exec error: ' + error);\n+                }\n+            });\n+        }\n+    ],\n+    secondTasks = [\n+        function some_function(callback) {\n+            cp.exec('git diff', function(error, stdout, stderr) {\n+                var currentContent = stdout;\n+\n+                if (error !== null) {\n+                    console.log('stderr: ' + stderr);\n+                    console.log('exec error: ' + error);\n+                }\n+\n+                callback(null, currentContent);\n+            });\n+        }\n+    ];*/\n \n function findData(text, keyword) {\n     var data = [];\n@@ -28,38 +78,106 @@ function findComments(text) {\n     return comments;\n }\n \n+function findCommitNumbers(text) {\n+    var commits = [];\n+    var splittext = text.split('\\n');\n+\n+    for(i=0; i<splittext.length; i++) {\n+        if(splittext[i].slice(0, 6) == \"commit\") {\n+            commits[commits.length] = splittext[i].slice(6).trim();\n+        }\n+    }\n+\n+    return commits;\n+}\n+\n+/*function pullCommitContent(first, second) {\n+\n+    cp.exec('git diff' + ' ' + first + ' ' + second, function(error, stdout, stderr) {\n+        var currentContent = stdout;\n+\n+        if (error !== null) {\n+            console.log('stderr: ' + stderr);\n+            console.log('exec error: ' + error);\n+        }\n+\n+        return currentContent;\n+    });\n+}*/\n+\n+var commitsInfo = [];\n+\n fs.exists('.git', function (exists) {\n     if(exists) {\n-        var cp = require('child_process');\n+        /*async.series(tasks, function(err, result) {\n+            fs.writeFileSync(\"patches.sousp\", JSON.stringify(result));\n+\n+            var data = result[0];\n \n-        cp.exec('git diff', function(error, stdout, stderr) {\n-            console.log(stdout);\n+            /*function some_function(arg1, arg2, callback) {\n+                cp.exec('git diff' + ' ' + arg1 + ' ' + arg2, function(error, stdout, stderr) {\n+                    var currentContent = 54321;//stdout;\n \n-            fs.writeFileSync(\"patches.sousp\", stdout);\n+                    if (error !== null) {\n+                        console.log('stderr: ' + stderr);\n+                        console.log('exec error: ' + error);\n+                    }\n \n-            if (error !== null) {\n-                console.log('stderr: ' + stderr);\n-                console.log('exec error: ' + error);\n+                    callback(null, currentContent);\n+                });\n             }\n-        });\n+        });*/\n+\n+        async.waterfall([\n+            function getCommitsInfo(callback) {\n+                cp.exec('git log', function(error, stdout, stderr) {\n+                    var listOfCommits = [];\n+                    var authors = findData(stdout, \"Author:\");\n+                    var dates = findData(stdout, \"Date:\");\n+                    var comments = findComments(stdout);\n+                    var commitNumbers = findCommitNumbers(stdout);\n \n-        cp.exec('git log', function(error, stdout, stderr) {\n-            console.log(stdout);\n+                    for(i=0; i<authors.length; i++) {\n+                        var commit = {\n+                            \"commit\": commitNumbers[i],\n+                            \"author\": authors[i],\n+                            \"date\": dates[i],\n+                            \"comment\": comments[i],\n+                            \"content\": 'Original'\n+                        };\n+                        listOfCommits[listOfCommits.length] = commit;\n+                    }\n \n-            var authors = findData(stdout, \"Author:\");\n-            var dates = findData(stdout, \"Date:\");\n-            var comments = findComments(stdout);\n-            console.log(authors);\n-            console.log(comments);\n-            console.log(dates);\n+                    callback(null, listOfCommits.reverse());\n \n-            fs.writeFileSync(\"comments.sousc\", stdout);\n+                    if (error !== null) {\n+                        console.log('stderr: ' + stderr);\n+                        console.log('exec error: ' + error);\n+                    }\n+                });\n+            },\n+            function getCommitsContent(commits, callback) {\n+                console.log(commits);\n+                var commitsData = commits;\n \n-            if (error !== null) {\n-                console.log('stderr: ' + stderr);\n-                console.log('exec error: ' + error);\n+                for(i=1; i<commitsData.length; i++) {\n+                    cp.exec('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit, function(error, stdout, stderr) {\n+                        commitsData[i].content = stdout;\n+\n+                        if (error !== null) {\n+                            console.log('stderr: ' + stderr);\n+                            console.log('exec error: ' + error);\n+                        }\n+                    });\n+                }\n+\n+                callback(null, commitsData);\n             }\n+        ], function (err, result) {\n+            fs.writeFileSync(\"patches.sousp\", result);\n         });\n+\n+        //commitsInfo = JSON.parse(fs.readFileSync(\"patches.sousp\"));\n+        //console.log(commitsInfo);\n     }\n-    else console.log(\"Error.\");\n });\n\\ No newline at end of file\ndiff --git a/node_modules/async/.travis.yml b/node_modules/async/.travis.yml\nnew file mode 100644\nindex 0000000..6e5919d\n--- /dev/null\n+++ b/node_modules/async/.travis.yml\n@@ -0,0 +1,3 @@\n+language: node_js\n+node_js:\n+  - \"0.10\"\ndiff --git a/node_modules/async/LICENSE b/node_modules/async/LICENSE\nnew file mode 100644\nindex 0000000..8f29698\n--- /dev/null\n+++ b/node_modules/async/LICENSE\n@@ -0,0 +1,19 @@\n+Copyright (c) 2010-2014 Caolan McMahon\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+THE SOFTWARE.\ndiff --git a/node_modules/async/README.md b/node_modules/async/README.md\nnew file mode 100644\nindex 0000000..0bea531\n--- /dev/null\n+++ b/node_modules/async/README.md\n@@ -0,0 +1,1646 @@\n+# Async.js\n+\n+[![Build Status via Travis CI](https://travis-ci.org/caolan/async.svg?branch=master)](https://travis-ci.org/caolan/async)\n+\n+\n+Async is a utility module which provides straight-forward, powerful functions\n+for working with asynchronous JavaScript. Although originally designed for\n+use with [Node.js](http://nodejs.org), it can also be used directly in the\n+browser. Also supports [component](https://github.com/component/component).\n+\n+Async provides around 20 functions that include the usual 'functional'\n+suspects (`map`, `reduce`, `filter`, `each`…) as well as some common patterns\n+for asynchronous control flow (`parallel`, `series`, `waterfall`…). All these\n+functions assume you follow the Node.js convention of providing a single\n+callback as the last argument of your `async` function.\n+\n+\n+## Quick Examples\n+\n+```javascript\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\n+    // results is now an array of stats for each file\n+});\n+\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\n+    // results now equals an array of the existing files\n+});\n+\n+async.parallel([\n+    function(){ ... },\n+    function(){ ... }\n+], callback);\n+\n+async.series([\n+    function(){ ... },\n+    function(){ ... }\n+]);\n+```\n+\n+There are many more functions available so take a look at the docs below for a\n+full list. This module aims to be comprehensive, so if you feel anything is\n+missing please create a GitHub issue for it.\n+\n+## Common Pitfalls\n+\n+### Binding a context to an iterator\n+\n+This section is really about `bind`, not about `async`. If you are wondering how to\n+make `async` execute your iterators in a given context, or are confused as to why\n+a method of another library isn't working as an iterator, study this example:\n+\n+```js\n+// Here is a simple object with an (unnecessarily roundabout) squaring method\n+var AsyncSquaringLibrary = {\n+  squareExponent: 2,\n+  square: function(number, callback){ \n+    var result = Math.pow(number, this.squareExponent);\n+    setTimeout(function(){\n+      callback(null, result);\n+    }, 200);\n+  }\n+};\n+\n+async.map([1, 2, 3], AsyncSquaringLibrary.square, function(err, result){\n+  // result is [NaN, NaN, NaN]\n+  // This fails because the `this.squareExponent` expression in the square\n+  // function is not evaluated in the context of AsyncSquaringLibrary, and is\n+  // therefore undefined.\n+});\n+\n+async.map([1, 2, 3], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), function(err, result){\n+  // result is [1, 4, 9]\n+  // With the help of bind we can attach a context to the iterator before\n+  // passing it to async. Now the square function will be executed in its \n+  // 'home' AsyncSquaringLibrary context and the value of `this.squareExponent`\n+  // will be as expected.\n+});\n+```\n+\n+## Download\n+\n+The source is available for download from\n+[GitHub](http://github.com/caolan/async).\n+Alternatively, you can install using Node Package Manager (`npm`):\n+\n+    npm install async\n+\n+__Development:__ [async.js](https://github.com/caolan/async/raw/master/lib/async.js) - 29.6kb Uncompressed\n+\n+## In the Browser\n+\n+So far it's been tested in IE6, IE7, IE8, FF3.6 and Chrome 5. \n+\n+Usage:\n+\n+```html\n+<script type=\"text/javascript\" src=\"async.js\"></script>\n+<script type=\"text/javascript\">\n+\n+    async.map(data, asyncProcess, function(err, results){\n+        alert(results);\n+    });\n+\n+</script>\n+```\n+\n+## Documentation\n+\n+### Collections\n+\n+* [`each`](#each)\n+* [`eachSeries`](#eachSeries)\n+* [`eachLimit`](#eachLimit)\n+* [`map`](#map)\n+* [`mapSeries`](#mapSeries)\n+* [`mapLimit`](#mapLimit)\n+* [`filter`](#filter)\n+* [`filterSeries`](#filterSeries)\n+* [`reject`](#reject)\n+* [`rejectSeries`](#rejectSeries)\n+* [`reduce`](#reduce)\n+* [`reduceRight`](#reduceRight)\n+* [`detect`](#detect)\n+* [`detectSeries`](#detectSeries)\n+* [`sortBy`](#sortBy)\n+* [`some`](#some)\n+* [`every`](#every)\n+* [`concat`](#concat)\n+* [`concatSeries`](#concatSeries)\n+\n+### Control Flow\n+\n+* [`series`](#seriestasks-callback)\n+* [`parallel`](#parallel)\n+* [`parallelLimit`](#parallellimittasks-limit-callback)\n+* [`whilst`](#whilst)\n+* [`doWhilst`](#doWhilst)\n+* [`until`](#until)\n+* [`doUntil`](#doUntil)\n+* [`forever`](#forever)\n+* [`waterfall`](#waterfall)\n+* [`compose`](#compose)\n+* [`seq`](#seq)\n+* [`applyEach`](#applyEach)\n+* [`applyEachSeries`](#applyEachSeries)\n+* [`queue`](#queue)\n+* [`priorityQueue`](#priorityQueue)\n+* [`cargo`](#cargo)\n+* [`auto`](#auto)\n+* [`retry`](#retry)\n+* [`iterator`](#iterator)\n+* [`apply`](#apply)\n+* [`nextTick`](#nextTick)\n+* [`times`](#times)\n+* [`timesSeries`](#timesSeries)\n+\n+### Utils\n+\n+* [`memoize`](#memoize)\n+* [`unmemoize`](#unmemoize)\n+* [`log`](#log)\n+* [`dir`](#dir)\n+* [`noConflict`](#noConflict)\n+\n+\n+## Collections\n+\n+<a name=\"forEach\" />\n+<a name=\"each\" />\n+### each(arr, iterator, callback)\n+\n+Applies the function `iterator` to each item in `arr`, in parallel.\n+The `iterator` is called with an item from the list, and a callback for when it\n+has finished. If the `iterator` passes an error to its `callback`, the main\n+`callback` (for the `each` function) is immediately called with the error.\n+\n+Note, that since this function applies `iterator` to each item in parallel,\n+there is no guarantee that the iterator functions will complete in order.\n+\n+__Arguments__\n+\n+* `arr` - An array to iterate over.\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\n+  The iterator is passed a `callback(err)` which must be called once it has \n+  completed. If no error has occured, the `callback` should be run without \n+  arguments or with an explicit `null` argument.\n+* `callback(err)` - A callback which is called when all `iterator` functions\n+  have finished, or an error occurs.\n+\n+__Examples__\n+\n+\n+```js\n+// assuming openFiles is an array of file names and saveFile is a function\n+// to save the modified contents of that file:\n+\n+async.each(openFiles, saveFile, function(err){\n+    // if any of the saves produced an error, err would equal that error\n+});\n+```\n+\n+```js\n+// assuming openFiles is an array of file names \n+\n+async.each(openFiles, function( file, callback) {\n+  \n+  // Perform operation on file here.\n+  console.log('Processing file ' + file);\n+  \n+  if( file.length > 32 ) {\n+    console.log('This file name is too long');\n+    callback('File name too long');\n+  } else {\n+    // Do work to process file here\n+    console.log('File processed');\n+    callback();\n+  }\n+}, function(err){\n+    // if any of the file processing produced an error, err would equal that error\n+    if( err ) {\n+      // One of the iterations produced an error.\n+      // All processing will now stop.\n+      console.log('A file failed to process');\n+    } else {\n+      console.log('All files have been processed successfully');\n+    }\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"forEachSeries\" />\n+<a name=\"eachSeries\" />\n+### eachSeries(arr, iterator, callback)\n+\n+The same as [`each`](#each), only `iterator` is applied to each item in `arr` in\n+series. The next `iterator` is only called once the current one has completed. \n+This means the `iterator` functions will complete in order.\n+\n+\n+---------------------------------------\n+\n+<a name=\"forEachLimit\" />\n+<a name=\"eachLimit\" />\n+### eachLimit(arr, limit, iterator, callback)\n+\n+The same as [`each`](#each), only no more than `limit` `iterator`s will be simultaneously \n+running at any time.\n+\n+Note that the items in `arr` are not processed in batches, so there is no guarantee that \n+the first `limit` `iterator` functions will complete before any others are started.\n+\n+__Arguments__\n+\n+* `arr` - An array to iterate over.\n+* `limit` - The maximum number of `iterator`s to run at any time.\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\n+  The iterator is passed a `callback(err)` which must be called once it has \n+  completed. If no error has occured, the callback should be run without \n+  arguments or with an explicit `null` argument.\n+* `callback(err)` - A callback which is called when all `iterator` functions\n+  have finished, or an error occurs.\n+\n+__Example__\n+\n+```js\n+// Assume documents is an array of JSON objects and requestApi is a\n+// function that interacts with a rate-limited REST api.\n+\n+async.eachLimit(documents, 20, requestApi, function(err){\n+    // if any of the saves produced an error, err would equal that error\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"map\" />\n+### map(arr, iterator, callback)\n+\n+Produces a new array of values by mapping each value in `arr` through\n+the `iterator` function. The `iterator` is called with an item from `arr` and a\n+callback for when it has finished processing. Each of these callback takes 2 arguments: \n+an `error`, and the transformed item from `arr`. If `iterator` passes an error to this \n+callback, the main `callback` (for the `map` function) is immediately called with the error.\n+\n+Note, that since this function applies the `iterator` to each item in parallel,\n+there is no guarantee that the `iterator` functions will complete in order. \n+However, the results array will be in the same order as the original `arr`.\n+\n+__Arguments__\n+\n+* `arr` - An array to iterate over.\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\n+  The iterator is passed a `callback(err, transformed)` which must be called once \n+  it has completed with an error (which can be `null`) and a transformed item.\n+* `callback(err, results)` - A callback which is called when all `iterator`\n+  functions have finished, or an error occurs. Results is an array of the\n+  transformed items from the `arr`.\n+\n+__Example__\n+\n+```js\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\n+    // results is now an array of stats for each file\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"mapSeries\" />\n+### mapSeries(arr, iterator, callback)\n+\n+The same as [`map`](#map), only the `iterator` is applied to each item in `arr` in\n+series. The next `iterator` is only called once the current one has completed. \n+The results array will be in the same order as the original.\n+\n+\n+---------------------------------------\n+\n+<a name=\"mapLimit\" />\n+### mapLimit(arr, limit, iterator, callback)\n+\n+The same as [`map`](#map), only no more than `limit` `iterator`s will be simultaneously \n+running at any time.\n+\n+Note that the items are not processed in batches, so there is no guarantee that \n+the first `limit` `iterator` functions will complete before any others are started.\n+\n+__Arguments__\n+\n+* `arr` - An array to iterate over.\n+* `limit` - The maximum number of `iterator`s to run at any time.\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\n+  The iterator is passed a `callback(err, transformed)` which must be called once \n+  it has completed with an error (which can be `null`) and a transformed item.\n+* `callback(err, results)` - A callback which is called when all `iterator`\n+  calls have finished, or an error occurs. The result is an array of the\n+  transformed items from the original `arr`.\n+\n+__Example__\n+\n+```js\n+async.mapLimit(['file1','file2','file3'], 1, fs.stat, function(err, results){\n+    // results is now an array of stats for each file\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"select\" />\n+<a name=\"filter\" />\n+### filter(arr, iterator, callback)\n+\n+__Alias:__ `select`\n+\n+Returns a new array of all the values in `arr` which pass an async truth test.\n+_The callback for each `iterator` call only accepts a single argument of `true` or\n+`false`; it does not accept an error argument first!_ This is in-line with the\n+way node libraries work with truth tests like `fs.exists`. This operation is\n+performed in parallel, but the results array will be in the same order as the\n+original.\n+\n+__Arguments__\n+\n+* `arr` - An array to iterate over.\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\n+  The `iterator` is passed a `callback(truthValue)`, which must be called with a \n+  boolean argument once it has completed.\n+* `callback(results)` - A callback which is called after all the `iterator`\n+  functions have finished.\n+\n+__Example__\n+\n+```js\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\n+    // results now equals an array of the existing files\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"selectSeries\" />\n+<a name=\"filterSeries\" />\n+### filterSeries(arr, iterator, callback)\n+\n+__Alias:__ `selectSeries`\n+\n+The same as [`filter`](#filter) only the `iterator` is applied to each item in `arr` in\n+series. The next `iterator` is only called once the current one has completed. \n+The results array will be in the same order as the original.\n+\n+---------------------------------------\n+\n+<a name=\"reject\" />\n+### reject(arr, iterator, callback)\n+\n+The opposite of [`filter`](#filter). Removes values that pass an `async` truth test.\n+\n+---------------------------------------\n+\n+<a name=\"rejectSeries\" />\n+### rejectSeries(arr, iterator, callback)\n+\n+The same as [`reject`](#reject), only the `iterator` is applied to each item in `arr`\n+in series.\n+\n+\n+---------------------------------------\n+\n+<a name=\"reduce\" />\n+### reduce(arr, memo, iterator, callback)\n+\n+__Aliases:__ `inject`, `foldl`\n+\n+Reduces `arr` into a single value using an async `iterator` to return\n+each successive step. `memo` is the initial state of the reduction. \n+This function only operates in series. \n+\n+For performance reasons, it may make sense to split a call to this function into \n+a parallel map, and then use the normal `Array.prototype.reduce` on the results. \n+This function is for situations where each step in the reduction needs to be async; \n+if you can get the data before reducing it, then it's probably a good idea to do so.\n+\n+__Arguments__\n+\n+* `arr` - An array to iterate over.\n+* `memo` - The initial state of the reduction.\n+* `iterator(memo, item, callback)` - A function applied to each item in the\n+  array to produce the next step in the reduction. The `iterator` is passed a\n+  `callback(err, reduction)` which accepts an optional error as its first \n+  argument, and the state of the reduction as the second. If an error is \n+  passed to the callback, the reduction is stopped and the main `callback` is \n+  immediately called with the error.\n+* `callback(err, result)` - A callback which is called after all the `iterator`\n+  functions have finished. Result is the reduced value.\n+\n+__Example__\n+\n+```js\n+async.reduce([1,2,3], 0, function(memo, item, callback){\n+    // pointless async:\n+    process.nextTick(function(){\n+        callback(null, memo + item)\n+    });\n+}, function(err, result){\n+    // result is now equal to the last value of memo, which is 6\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"reduceRight\" />\n+### reduceRight(arr, memo, iterator, callback)\n+\n+__Alias:__ `foldr`\n+\n+Same as [`reduce`](#reduce), only operates on `arr` in reverse order.\n+\n+\n+---------------------------------------\n+\n+<a name=\"detect\" />\n+### detect(arr, iterator, callback)\n+\n+Returns the first value in `arr` that passes an async truth test. The\n+`iterator` is applied in parallel, meaning the first iterator to return `true` will\n+fire the detect `callback` with that result. That means the result might not be\n+the first item in the original `arr` (in terms of order) that passes the test.\n+\n+If order within the original `arr` is important, then look at [`detectSeries`](#detectSeries).\n+\n+__Arguments__\n+\n+* `arr` - An array to iterate over.\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\n+  The iterator is passed a `callback(truthValue)` which must be called with a \n+  boolean argument once it has completed.\n+* `callback(result)` - A callback which is called as soon as any iterator returns\n+  `true`, or after all the `iterator` functions have finished. Result will be\n+  the first item in the array that passes the truth test (iterator) or the\n+  value `undefined` if none passed.\n+\n+__Example__\n+\n+```js\n+async.detect(['file1','file2','file3'], fs.exists, function(result){\n+    // result now equals the first file in the list that exists\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"detectSeries\" />\n+### detectSeries(arr, iterator, callback)\n+\n+The same as [`detect`](#detect), only the `iterator` is applied to each item in `arr`\n+in series. This means the result is always the first in the original `arr` (in\n+terms of array order) that passes the truth test.\n+\n+\n+---------------------------------------\n+\n+<a name=\"sortBy\" />\n+### sortBy(arr, iterator, callback)\n+\n+Sorts a list by the results of running each `arr` value through an async `iterator`.\n+\n+__Arguments__\n+\n+* `arr` - An array to iterate over.\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\n+  The iterator is passed a `callback(err, sortValue)` which must be called once it\n+  has completed with an error (which can be `null`) and a value to use as the sort\n+  criteria.\n+* `callback(err, results)` - A callback which is called after all the `iterator`\n+  functions have finished, or an error occurs. Results is the items from\n+  the original `arr` sorted by the values returned by the `iterator` calls.\n+\n+__Example__\n+\n+```js\n+async.sortBy(['file1','file2','file3'], function(file, callback){\n+    fs.stat(file, function(err, stats){\n+        callback(err, stats.mtime);\n+    });\n+}, function(err, results){\n+    // results is now the original array of files sorted by\n+    // modified date\n+});\n+```\n+\n+__Sort Order__\n+\n+By modifying the callback parameter the sorting order can be influenced:\n+\n+```js\n+//ascending order\n+async.sortBy([1,9,3,5], function(x, callback){\n+    callback(err, x);\n+}, function(err,result){\n+    //result callback\n+} );\n+\n+//descending order\n+async.sortBy([1,9,3,5], function(x, callback){\n+    callback(err, x*-1);    //<- x*-1 instead of x, turns the order around\n+}, function(err,result){\n+    //result callback\n+} );\n+```\n+\n+---------------------------------------\n+\n+<a name=\"some\" />\n+### some(arr, iterator, callback)\n+\n+__Alias:__ `any`\n+\n+Returns `true` if at least one element in the `arr` satisfies an async test.\n+_The callback for each iterator call only accepts a single argument of `true` or\n+`false`; it does not accept an error argument first!_ This is in-line with the\n+way node libraries work with truth tests like `fs.exists`. Once any iterator\n+call returns `true`, the main `callback` is immediately called.\n+\n+__Arguments__\n+\n+* `arr` - An array to iterate over.\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\n+  in parallel. The iterator is passed a callback(truthValue) which must be \n+  called with a boolean argument once it has completed.\n+* `callback(result)` - A callback which is called as soon as any iterator returns\n+  `true`, or after all the iterator functions have finished. Result will be\n+  either `true` or `false` depending on the values of the async tests.\n+\n+__Example__\n+\n+```js\n+async.some(['file1','file2','file3'], fs.exists, function(result){\n+    // if result is true then at least one of the files exists\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"every\" />\n+### every(arr, iterator, callback)\n+\n+__Alias:__ `all`\n+\n+Returns `true` if every element in `arr` satisfies an async test.\n+_The callback for each `iterator` call only accepts a single argument of `true` or\n+`false`; it does not accept an error argument first!_ This is in-line with the\n+way node libraries work with truth tests like `fs.exists`.\n+\n+__Arguments__\n+\n+* `arr` - An array to iterate over.\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\n+  in parallel. The iterator is passed a callback(truthValue) which must be \n+  called with a  boolean argument once it has completed.\n+* `callback(result)` - A callback which is called after all the `iterator`\n+  functions have finished. Result will be either `true` or `false` depending on\n+  the values of the async tests.\n+\n+__Example__\n+\n+```js\n+async.every(['file1','file2','file3'], fs.exists, function(result){\n+    // if result is true then every file exists\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"concat\" />\n+### concat(arr, iterator, callback)\n+\n+Applies `iterator` to each item in `arr`, concatenating the results. Returns the\n+concatenated list. The `iterator`s are called in parallel, and the results are\n+concatenated as they return. There is no guarantee that the results array will\n+be returned in the original order of `arr` passed to the `iterator` function.\n+\n+__Arguments__\n+\n+* `arr` - An array to iterate over.\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\n+  The iterator is passed a `callback(err, results)` which must be called once it \n+  has completed with an error (which can be `null`) and an array of results.\n+* `callback(err, results)` - A callback which is called after all the `iterator`\n+  functions have finished, or an error occurs. Results is an array containing\n+  the concatenated results of the `iterator` function.\n+\n+__Example__\n+\n+```js\n+async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files){\n+    // files is now a list of filenames that exist in the 3 directories\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"concatSeries\" />\n+### concatSeries(arr, iterator, callback)\n+\n+Same as [`concat`](#concat), but executes in series instead of parallel.\n+\n+\n+## Control Flow\n+\n+<a name=\"series\" />\n+### series(tasks, [callback])\n+\n+Run the functions in the `tasks` array in series, each one running once the previous\n+function has completed. If any functions in the series pass an error to its\n+callback, no more functions are run, and `callback` is immediately called with the value of the error. \n+Otherwise, `callback` receives an array of results when `tasks` have completed.\n+\n+It is also possible to use an object instead of an array. Each property will be\n+run as a function, and the results will be passed to the final `callback` as an object\n+instead of an array. This can be a more readable way of handling results from\n+[`series`](#series).\n+\n+**Note** that while many implementations preserve the order of object properties, the\n+[ECMAScript Language Specifcation](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6) \n+explicitly states that\n+\n+> The mechanics and order of enumerating the properties is not specified.\n+\n+So if you rely on the order in which your series of functions are executed, and want\n+this to work on all platforms, consider using an array. \n+\n+__Arguments__\n+\n+* `tasks` - An array or object containing functions to run, each function is passed\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\n+  be `null`) and an optional `result` value.\n+* `callback(err, results)` - An optional callback to run once all the functions\n+  have completed. This function gets a results array (or object) containing all \n+  the result arguments passed to the `task` callbacks.\n+\n+__Example__\n+\n+```js\n+async.series([\n+    function(callback){\n+        // do some stuff ...\n+        callback(null, 'one');\n+    },\n+    function(callback){\n+        // do some more stuff ...\n+        callback(null, 'two');\n+    }\n+],\n+// optional callback\n+function(err, results){\n+    // results is now equal to ['one', 'two']\n+});\n+\n+\n+// an example using an object instead of an array\n+async.series({\n+    one: function(callback){\n+        setTimeout(function(){\n+            callback(null, 1);\n+        }, 200);\n+    },\n+    two: function(callback){\n+        setTimeout(function(){\n+            callback(null, 2);\n+        }, 100);\n+    }\n+},\n+function(err, results) {\n+    // results is now equal to: {one: 1, two: 2}\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"parallel\" />\n+### parallel(tasks, [callback])\n+\n+Run the `tasks` array of functions in parallel, without waiting until the previous\n+function has completed. If any of the functions pass an error to its\n+callback, the main `callback` is immediately called with the value of the error.\n+Once the `tasks` have completed, the results are passed to the final `callback` as an\n+array.\n+\n+It is also possible to use an object instead of an array. Each property will be\n+run as a function and the results will be passed to the final `callback` as an object\n+instead of an array. This can be a more readable way of handling results from\n+[`parallel`](#parallel).\n+\n+\n+__Arguments__\n+\n+* `tasks` - An array or object containing functions to run. Each function is passed \n+  a `callback(err, result)` which it must call on completion with an error `err` \n+  (which can be `null`) and an optional `result` value.\n+* `callback(err, results)` - An optional callback to run once all the functions\n+  have completed. This function gets a results array (or object) containing all \n+  the result arguments passed to the task callbacks.\n+\n+__Example__\n+\n+```js\n+async.parallel([\n+    function(callback){\n+        setTimeout(function(){\n+            callback(null, 'one');\n+        }, 200);\n+    },\n+    function(callback){\n+        setTimeout(function(){\n+            callback(null, 'two');\n+        }, 100);\n+    }\n+],\n+// optional callback\n+function(err, results){\n+    // the results array will equal ['one','two'] even though\n+    // the second function had a shorter timeout.\n+});\n+\n+\n+// an example using an object instead of an array\n+async.parallel({\n+    one: function(callback){\n+        setTimeout(function(){\n+            callback(null, 1);\n+        }, 200);\n+    },\n+    two: function(callback){\n+        setTimeout(function(){\n+            callback(null, 2);\n+        }, 100);\n+    }\n+},\n+function(err, results) {\n+    // results is now equals to: {one: 1, two: 2}\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"parallelLimit\" />\n+### parallelLimit(tasks, limit, [callback])\n+\n+The same as [`parallel`](#parallel), only `tasks` are executed in parallel \n+with a maximum of `limit` tasks executing at any time.\n+\n+Note that the `tasks` are not executed in batches, so there is no guarantee that \n+the first `limit` tasks will complete before any others are started.\n+\n+__Arguments__\n+\n+* `tasks` - An array or object containing functions to run, each function is passed \n+  a `callback(err, result)` it must call on completion with an error `err` (which can\n+  be `null`) and an optional `result` value.\n+* `limit` - The maximum number of `tasks` to run at any time.\n+* `callback(err, results)` - An optional callback to run once all the functions\n+  have completed. This function gets a results array (or object) containing all \n+  the result arguments passed to the `task` callbacks.\n+\n+---------------------------------------\n+\n+<a name=\"whilst\" />\n+### whilst(test, fn, callback)\n+\n+Repeatedly call `fn`, while `test` returns `true`. Calls `callback` when stopped,\n+or an error occurs.\n+\n+__Arguments__\n+\n+* `test()` - synchronous truth test to perform before each execution of `fn`.\n+* `fn(callback)` - A function which is called each time `test` passes. The function is\n+  passed a `callback(err)`, which must be called once it has completed with an \n+  optional `err` argument.\n+* `callback(err)` - A callback which is called after the test fails and repeated\n+  execution of `fn` has stopped.\n+\n+__Example__\n+\n+```js\n+var count = 0;\n+\n+async.whilst(\n+    function () { return count < 5; },\n+    function (callback) {\n+        count++;\n+        setTimeout(callback, 1000);\n+    },\n+    function (err) {\n+        // 5 seconds have passed\n+    }\n+);\n+```\n+\n+---------------------------------------\n+\n+<a name=\"doWhilst\" />\n+### doWhilst(fn, test, callback)\n+\n+The post-check version of [`whilst`](#whilst). To reflect the difference in \n+the order of operations, the arguments `test` and `fn` are switched. \n+\n+`doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\n+\n+---------------------------------------\n+\n+<a name=\"until\" />\n+### until(test, fn, callback)\n+\n+Repeatedly call `fn` until `test` returns `true`. Calls `callback` when stopped,\n+or an error occurs.\n+\n+The inverse of [`whilst`](#whilst).\n+\n+---------------------------------------\n+\n+<a name=\"doUntil\" />\n+### doUntil(fn, test, callback)\n+\n+Like [`doWhilst`](#doWhilst), except the `test` is inverted. Note the argument ordering differs from `until`.\n+\n+---------------------------------------\n+\n+<a name=\"forever\" />\n+### forever(fn, errback)\n+\n+Calls the asynchronous function `fn` with a callback parameter that allows it to\n+call itself again, in series, indefinitely.\n+\n+If an error is passed to the callback then `errback` is called with the\n+error, and execution stops, otherwise it will never be called.\n+\n+```js\n+async.forever(\n+    function(next) {\n+        // next is suitable for passing to things that need a callback(err [, whatever]);\n+        // it will result in this function being called again.\n+    },\n+    function(err) {\n+        // if next is called with a value in its first parameter, it will appear\n+        // in here as 'err', and execution will stop.\n+    }\n+);\n+```\n+\n+---------------------------------------\n+\n+<a name=\"waterfall\" />\n+### waterfall(tasks, [callback])\n+\n+Runs the `tasks` array of functions in series, each passing their results to the next in\n+the array. However, if any of the `tasks` pass an error to their own callback, the\n+next function is not executed, and the main `callback` is immediately called with\n+the error.\n+\n+__Arguments__\n+\n+* `tasks` - An array of functions to run, each function is passed a \n+  `callback(err, result1, result2, ...)` it must call on completion. The first\n+  argument is an error (which can be `null`) and any further arguments will be \n+  passed as arguments in order to the next task.\n+* `callback(err, [results])` - An optional callback to run once all the functions\n+  have completed. This will be passed the results of the last task's callback.\n+\n+\n+\n+__Example__\n+\n+```js\n+async.waterfall([\n+    function(callback){\n+        callback(null, 'one', 'two');\n+    },\n+    function(arg1, arg2, callback){\n+      // arg1 now equals 'one' and arg2 now equals 'two'\n+        callback(null, 'three');\n+    },\n+    function(arg1, callback){\n+        // arg1 now equals 'three'\n+        callback(null, 'done');\n+    }\n+], function (err, result) {\n+   // result now equals 'done'    \n+});\n+```\n+\n+---------------------------------------\n+<a name=\"compose\" />\n+### compose(fn1, fn2...)\n+\n+Creates a function which is a composition of the passed asynchronous\n+functions. Each function consumes the return value of the function that\n+follows. Composing functions `f()`, `g()`, and `h()` would produce the result of\n+`f(g(h()))`, only this version uses callbacks to obtain the return values.\n+\n+Each function is executed with the `this` binding of the composed function.\n+\n+__Arguments__\n+\n+* `functions...` - the asynchronous functions to compose\n+\n+\n+__Example__\n+\n+```js\n+function add1(n, callback) {\n+    setTimeout(function () {\n+        callback(null, n + 1);\n+    }, 10);\n+}\n+\n+function mul3(n, callback) {\n+    setTimeout(function () {\n+        callback(null, n * 3);\n+    }, 10);\n+}\n+\n+var add1mul3 = async.compose(mul3, add1);\n+\n+add1mul3(4, function (err, result) {\n+   // result now equals 15\n+});\n+```\n+\n+---------------------------------------\n+<a name=\"seq\" />\n+### seq(fn1, fn2...)\n+\n+Version of the compose function that is more natural to read.\n+Each following function consumes the return value of the latter function. \n+\n+Each function is executed with the `this` binding of the composed function.\n+\n+__Arguments__\n+\n+* functions... - the asynchronous functions to compose\n+\n+\n+__Example__\n+\n+```js\n+// Requires lodash (or underscore), express3 and dresende's orm2.\n+// Part of an app, that fetches cats of the logged user.\n+// This example uses `seq` function to avoid overnesting and error \n+// handling clutter.\n+app.get('/cats', function(request, response) {\n+  function handleError(err, data, callback) {\n+    if (err) {\n+      console.error(err);\n+      response.json({ status: 'error', message: err.message });\n+    }\n+    else {\n+      callback(data);\n+    }\n+  }\n+  var User = request.models.User;\n+  async.seq(\n+    _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\n+    handleError,\n+    function(user, fn) {\n+      user.getCats(fn);      // 'getCats' has signature (callback(err, data))\n+    },\n+    handleError,\n+    function(cats) {\n+      response.json({ status: 'ok', message: 'Cats found', data: cats });\n+    }\n+  )(req.session.user_id);\n+  }\n+});\n+```\n+\n+---------------------------------------\n+<a name=\"applyEach\" />\n+### applyEach(fns, args..., callback)\n+\n+Applies the provided arguments to each function in the array, calling \n+`callback` after all functions have completed. If you only provide the first\n+argument, then it will return a function which lets you pass in the\n+arguments as if it were a single function call.\n+\n+__Arguments__\n+\n+* `fns` - the asynchronous functions to all call with the same arguments\n+* `args...` - any number of separate arguments to pass to the function\n+* `callback` - the final argument should be the callback, called when all\n+  functions have completed processing\n+\n+\n+__Example__\n+\n+```js\n+async.applyEach([enableSearch, updateSchema], 'bucket', callback);\n+\n+// partial application example:\n+async.each(\n+    buckets,\n+    async.applyEach([enableSearch, updateSchema]),\n+    callback\n+);\n+```\n+\n+---------------------------------------\n+\n+<a name=\"applyEachSeries\" />\n+### applyEachSeries(arr, iterator, callback)\n+\n+The same as [`applyEach`](#applyEach) only the functions are applied in series.\n+\n+---------------------------------------\n+\n+<a name=\"queue\" />\n+### queue(worker, concurrency)\n+\n+Creates a `queue` object with the specified `concurrency`. Tasks added to the\n+`queue` are processed in parallel (up to the `concurrency` limit). If all\n+`worker`s are in progress, the task is queued until one becomes available. \n+Once a `worker` completes a `task`, that `task`'s callback is called.\n+\n+__Arguments__\n+\n+* `worker(task, callback)` - An asynchronous function for processing a queued\n+  task, which must call its `callback(err)` argument when finished, with an \n+  optional `error` as an argument.\n+* `concurrency` - An `integer` for determining how many `worker` functions should be\n+  run in parallel.\n+\n+__Queue objects__\n+\n+The `queue` object returned by this function has the following properties and\n+methods:\n+\n+* `length()` - a function returning the number of items waiting to be processed.\n+* `started` - a function returning whether or not any items have been pushed and processed by the queue\n+* `running()` - a function returning the number of items currently being processed.\n+* `idle()` - a function returning false if there are items waiting or being processed, or true if not.\n+* `concurrency` - an integer for determining how many `worker` functions should be\n+  run in parallel. This property can be changed after a `queue` is created to\n+  alter the concurrency on-the-fly.\n+* `push(task, [callback])` - add a new task to the `queue`. Calls `callback` once \n+  the `worker` has finished processing the task. Instead of a single task, a `tasks` array\n+  can be submitted. The respective callback is used for every task in the list.\n+* `unshift(task, [callback])` - add a new task to the front of the `queue`.\n+* `saturated` - a callback that is called when the `queue` length hits the `concurrency` limit, \n+   and further tasks will be queued.\n+* `empty` - a callback that is called when the last item from the `queue` is given to a `worker`.\n+* `drain` - a callback that is called when the last item from the `queue` has returned from the `worker`.\n+* `paused` - a boolean for determining whether the queue is in a paused state\n+* `pause()` - a function that pauses the processing of tasks until `resume()` is called.\n+* `resume()` - a function that resumes the processing of queued tasks when the queue is paused.\n+* `kill()` - a function that empties remaining tasks from the queue forcing it to go idle.\n+\n+__Example__\n+\n+```js\n+// create a queue object with concurrency 2\n+\n+var q = async.queue(function (task, callback) {\n+    console.log('hello ' + task.name);\n+    callback();\n+}, 2);\n+\n+\n+// assign a callback\n+q.drain = function() {\n+    console.log('all items have been processed');\n+}\n+\n+// add some items to the queue\n+\n+q.push({name: 'foo'}, function (err) {\n+    console.log('finished processing foo');\n+});\n+q.push({name: 'bar'}, function (err) {\n+    console.log('finished processing bar');\n+});\n+\n+// add some items to the queue (batch-wise)\n+\n+q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function (err) {\n+    console.log('finished processing bar');\n+});\n+\n+// add some items to the front of the queue\n+\n+q.unshift({name: 'bar'}, function (err) {\n+    console.log('finished processing bar');\n+});\n+```\n+\n+\n+---------------------------------------\n+\n+<a name=\"priorityQueue\" />\n+### priorityQueue(worker, concurrency)\n+\n+The same as [`queue`](#queue) only tasks are assigned a priority and completed in ascending priority order. There are two differences between `queue` and `priorityQueue` objects:\n+\n+* `push(task, priority, [callback])` - `priority` should be a number. If an array of\n+  `tasks` is given, all tasks will be assigned the same priority.\n+* The `unshift` method was removed.\n+\n+---------------------------------------\n+\n+<a name=\"cargo\" />\n+### cargo(worker, [payload])\n+\n+Creates a `cargo` object with the specified payload. Tasks added to the\n+cargo will be processed altogether (up to the `payload` limit). If the\n+`worker` is in progress, the task is queued until it becomes available. Once\n+the `worker` has completed some tasks, each callback of those tasks is called.\n+Check out [this animation](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) for how `cargo` and `queue` work.\n+\n+While [queue](#queue) passes only one task to one of a group of workers\n+at a time, cargo passes an array of tasks to a single worker, repeating\n+when the worker is finished.\n+\n+__Arguments__\n+\n+* `worker(tasks, callback)` - An asynchronous function for processing an array of\n+  queued tasks, which must call its `callback(err)` argument when finished, with \n+  an optional `err` argument.\n+* `payload` - An optional `integer` for determining how many tasks should be\n+  processed per round; if omitted, the default is unlimited.\n+\n+__Cargo objects__\n+\n+The `cargo` object returned by this function has the following properties and\n+methods:\n+\n+* `length()` - A function returning the number of items waiting to be processed.\n+* `payload` - An `integer` for determining how many tasks should be\n+  process per round. This property can be changed after a `cargo` is created to\n+  alter the payload on-the-fly.\n+* `push(task, [callback])` - Adds `task` to the `queue`. The callback is called\n+  once the `worker` has finished processing the task. Instead of a single task, an array of `tasks` \n+  can be submitted. The respective callback is used for every task in the list.\n+* `saturated` - A callback that is called when the `queue.length()` hits the concurrency and further tasks will be queued.\n+* `empty` - A callback that is called when the last item from the `queue` is given to a `worker`.\n+* `drain` - A callback that is called when the last item from the `queue` has returned from the `worker`.\n+\n+__Example__\n+\n+```js\n+// create a cargo object with payload 2\n+\n+var cargo = async.cargo(function (tasks, callback) {\n+    for(var i=0; i<tasks.length; i++){\n+      console.log('hello ' + tasks[i].name);\n+    }\n+    callback();\n+}, 2);\n+\n+\n+// add some items\n+\n+cargo.push({name: 'foo'}, function (err) {\n+    console.log('finished processing foo');\n+});\n+cargo.push({name: 'bar'}, function (err) {\n+    console.log('finished processing bar');\n+});\n+cargo.push({name: 'baz'}, function (err) {\n+    console.log('finished processing baz');\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"auto\" />\n+### auto(tasks, [callback])\n+\n+Determines the best order for running the functions in `tasks`, based on their \n+requirements. Each function can optionally depend on other functions being completed \n+first, and each function is run as soon as its requirements are satisfied. \n+\n+If any of the functions pass an error to their callback, it will not \n+complete (so any other functions depending on it will not run), and the main \n+`callback` is immediately called with the error. Functions also receive an \n+object containing the results of functions which have completed so far.\n+\n+Note, all functions are called with a `results` object as a second argument, \n+so it is unsafe to pass functions in the `tasks` object which cannot handle the\n+extra argument. \n+\n+For example, this snippet of code:\n+\n+```js\n+async.auto({\n+  readData: async.apply(fs.readFile, 'data.txt', 'utf-8')\n+}, callback);\n+```\n+\n+will have the effect of calling `readFile` with the results object as the last\n+argument, which will fail:\n+\n+```js\n+fs.readFile('data.txt', 'utf-8', cb, {});\n+```\n+\n+Instead, wrap the call to `readFile` in a function which does not forward the \n+`results` object:\n+\n+```js\n+async.auto({\n+  readData: function(cb, results){\n+    fs.readFile('data.txt', 'utf-8', cb);\n+  }\n+}, callback);\n+```\n+\n+__Arguments__\n+\n+* `tasks` - An object. Each of its properties is either a function or an array of\n+  requirements, with the function itself the last item in the array. The object's key\n+  of a property serves as the name of the task defined by that property,\n+  i.e. can be used when specifying requirements for other tasks.\n+  The function receives two arguments: (1) a `callback(err, result)` which must be \n+  called when finished, passing an `error` (which can be `null`) and the result of \n+  the function's execution, and (2) a `results` object, containing the results of\n+  the previously executed functions.\n+* `callback(err, results)` - An optional callback which is called when all the\n+  tasks have been completed. It receives the `err` argument if any `tasks` \n+  pass an error to their callback. Results are always returned; however, if \n+  an error occurs, no further `tasks` will be performed, and the results\n+  object will only contain partial results.\n+\n+\n+__Example__\n+\n+```js\n+async.auto({\n+    get_data: function(callback){\n+        console.log('in get_data');\n+        // async code to get some data\n+        callback(null, 'data', 'converted to array');\n+    },\n+    make_folder: function(callback){\n+        console.log('in make_folder');\n+        // async code to create a directory to store a file in\n+        // this is run at the same time as getting the data\n+        callback(null, 'folder');\n+    },\n+    write_file: ['get_data', 'make_folder', function(callback, results){\n+        console.log('in write_file', JSON.stringify(results));\n+        // once there is some data and the directory exists,\n+        // write the data to a file in the directory\n+        callback(null, 'filename');\n+    }],\n+    email_link: ['write_file', function(callback, results){\n+        console.log('in email_link', JSON.stringify(results));\n+        // once the file is written let's email a link to it...\n+        // results.write_file contains the filename returned by write_file.\n+        callback(null, {'file':results.write_file, 'email':'user@example.com'});\n+    }]\n+}, function(err, results) {\n+    console.log('err = ', err);\n+    console.log('results = ', results);\n+});\n+```\n+\n+This is a fairly trivial example, but to do this using the basic parallel and\n+series functions would look like this:\n+\n+```js\n+async.parallel([\n+    function(callback){\n+        console.log('in get_data');\n+        // async code to get some data\n+        callback(null, 'data', 'converted to array');\n+    },\n+    function(callback){\n+        console.log('in make_folder');\n+        // async code to create a directory to store a file in\n+        // this is run at the same time as getting the data\n+        callback(null, 'folder');\n+    }\n+],\n+function(err, results){\n+    async.series([\n+        function(callback){\n+            console.log('in write_file', JSON.stringify(results));\n+            // once there is some data and the directory exists,\n+            // write the data to a file in the directory\n+            results.push('filename');\n+            callback(null);\n+        },\n+        function(callback){\n+            console.log('in email_link', JSON.stringify(results));\n+            // once the file is written let's email a link to it...\n+            callback(null, {'file':results.pop(), 'email':'user@example.com'});\n+        }\n+    ]);\n+});\n+```\n+\n+For a complicated series of `async` tasks, using the [`auto`](#auto) function makes adding\n+new tasks much easier (and the code more readable).\n+\n+\n+---------------------------------------\n+\n+<a name=\"retry\" />\n+### retry([times = 5], task, [callback])\n+\n+Attempts to get a successful response from `task` no more than `times` times before\n+returning an error. If the task is successful, the `callback` will be passed the result\n+of the successfull task. If all attemps fail, the callback will be passed the error and\n+result (if any) of the final attempt.\n+\n+__Arguments__\n+\n+* `times` - An integer indicating how many times to attempt the `task` before giving up. Defaults to 5.\n+* `task(callback, results)` - A function which receives two arguments: (1) a `callback(err, result)`\n+  which must be called when finished, passing `err` (which can be `null`) and the `result` of \n+  the function's execution, and (2) a `results` object, containing the results of\n+  the previously executed functions (if nested inside another control flow).\n+* `callback(err, results)` - An optional callback which is called when the\n+  task has succeeded, or after the final failed attempt. It receives the `err` and `result` arguments of the last attempt at completing the `task`.\n+\n+The [`retry`](#retry) function can be used as a stand-alone control flow by passing a\n+callback, as shown below:\n+\n+```js\n+async.retry(3, apiMethod, function(err, result) {\n+    // do something with the result\n+});\n+```\n+\n+It can also be embeded within other control flow functions to retry individual methods\n+that are not as reliable, like this:\n+\n+```js\n+async.auto({\n+    users: api.getUsers.bind(api),\n+    payments: async.retry(3, api.getPayments.bind(api))\n+}, function(err, results) {\n+  // do something with the results\n+});\n+```\n+\n+\n+---------------------------------------\n+\n+<a name=\"iterator\" />\n+### iterator(tasks)\n+\n+Creates an iterator function which calls the next function in the `tasks` array,\n+returning a continuation to call the next one after that. It's also possible to\n+“peek” at the next iterator with `iterator.next()`.\n+\n+This function is used internally by the `async` module, but can be useful when\n+you want to manually control the flow of functions in series.\n+\n+__Arguments__\n+\n+* `tasks` - An array of functions to run.\n+\n+__Example__\n+\n+```js\n+var iterator = async.iterator([\n+    function(){ sys.p('one'); },\n+    function(){ sys.p('two'); },\n+    function(){ sys.p('three'); }\n+]);\n+\n+node> var iterator2 = iterator();\n+'one'\n+node> var iterator3 = iterator2();\n+'two'\n+node> iterator3();\n+'three'\n+node> var nextfn = iterator2.next();\n+node> nextfn();\n+'three'\n+```\n+\n+---------------------------------------\n+\n+<a name=\"apply\" />\n+### apply(function, arguments..)\n+\n+Creates a continuation function with some arguments already applied. \n+\n+Useful as a shorthand when combined with other control flow functions. Any arguments\n+passed to the returned function are added to the arguments originally passed\n+to apply.\n+\n+__Arguments__\n+\n+* `function` - The function you want to eventually apply all arguments to.\n+* `arguments...` - Any number of arguments to automatically apply when the\n+  continuation is called.\n+\n+__Example__\n+\n+```js\n+// using apply\n+\n+async.parallel([\n+    async.apply(fs.writeFile, 'testfile1', 'test1'),\n+    async.apply(fs.writeFile, 'testfile2', 'test2'),\n+]);\n+\n+\n+// the same process without using apply\n+\n+async.parallel([\n+    function(callback){\n+        fs.writeFile('testfile1', 'test1', callback);\n+    },\n+    function(callback){\n+        fs.writeFile('testfile2', 'test2', callback);\n+    }\n+]);\n+```\n+\n+It's possible to pass any number of additional arguments when calling the\n+continuation:\n+\n+```js\n+node> var fn = async.apply(sys.puts, 'one');\n+node> fn('two', 'three');\n+one\n+two\n+three\n+```\n+\n+---------------------------------------\n+\n+<a name=\"nextTick\" />\n+### nextTick(callback)\n+\n+Calls `callback` on a later loop around the event loop. In Node.js this just\n+calls `process.nextTick`; in the browser it falls back to `setImmediate(callback)`\n+if available, otherwise `setTimeout(callback, 0)`, which means other higher priority\n+events may precede the execution of `callback`.\n+\n+This is used internally for browser-compatibility purposes.\n+\n+__Arguments__\n+\n+* `callback` - The function to call on a later loop around the event loop.\n+\n+__Example__\n+\n+```js\n+var call_order = [];\n+async.nextTick(function(){\n+    call_order.push('two');\n+    // call_order now equals ['one','two']\n+});\n+call_order.push('one')\n+```\n+\n+<a name=\"times\" />\n+### times(n, callback)\n+\n+Calls the `callback` function `n` times, and accumulates results in the same manner\n+you would use with [`map`](#map).\n+\n+__Arguments__\n+\n+* `n` - The number of times to run the function.\n+* `callback` - The function to call `n` times.\n+\n+__Example__\n+\n+```js\n+// Pretend this is some complicated async factory\n+var createUser = function(id, callback) {\n+  callback(null, {\n+    id: 'user' + id\n+  })\n+}\n+// generate 5 users\n+async.times(5, function(n, next){\n+    createUser(n, function(err, user) {\n+      next(err, user)\n+    })\n+}, function(err, users) {\n+  // we should now have 5 users\n+});\n+```\n+\n+<a name=\"timesSeries\" />\n+### timesSeries(n, callback)\n+\n+The same as [`times`](#times), only the iterator is applied to each item in `arr` in\n+series. The next `iterator` is only called once the current one has completed. \n+The results array will be in the same order as the original.\n+\n+\n+## Utils\n+\n+<a name=\"memoize\" />\n+### memoize(fn, [hasher])\n+\n+Caches the results of an `async` function. When creating a hash to store function\n+results against, the callback is omitted from the hash and an optional hash\n+function can be used.\n+\n+The cache of results is exposed as the `memo` property of the function returned\n+by `memoize`.\n+\n+__Arguments__\n+\n+* `fn` - The function to proxy and cache results from.\n+* `hasher` - Tn optional function for generating a custom hash for storing\n+  results. It has all the arguments applied to it apart from the callback, and\n+  must be synchronous.\n+\n+__Example__\n+\n+```js\n+var slow_fn = function (name, callback) {\n+    // do something\n+    callback(null, result);\n+};\n+var fn = async.memoize(slow_fn);\n+\n+// fn can now be used as if it were slow_fn\n+fn('some name', function () {\n+    // callback\n+});\n+```\n+\n+<a name=\"unmemoize\" />\n+### unmemoize(fn)\n+\n+Undoes a [`memoize`](#memoize)d function, reverting it to the original, unmemoized\n+form. Handy for testing.\n+\n+__Arguments__\n+\n+* `fn` - the memoized function\n+\n+<a name=\"log\" />\n+### log(function, arguments)\n+\n+Logs the result of an `async` function to the `console`. Only works in Node.js or\n+in browsers that support `console.log` and `console.error` (such as FF and Chrome).\n+If multiple arguments are returned from the async function, `console.log` is\n+called on each argument in order.\n+\n+__Arguments__\n+\n+* `function` - The function you want to eventually apply all arguments to.\n+* `arguments...` - Any number of arguments to apply to the function.\n+\n+__Example__\n+\n+```js\n+var hello = function(name, callback){\n+    setTimeout(function(){\n+        callback(null, 'hello ' + name);\n+    }, 1000);\n+};\n+```\n+```js\n+node> async.log(hello, 'world');\n+'hello world'\n+```\n+\n+---------------------------------------\n+\n+<a name=\"dir\" />\n+### dir(function, arguments)\n+\n+Logs the result of an `async` function to the `console` using `console.dir` to\n+display the properties of the resulting object. Only works in Node.js or\n+in browsers that support `console.dir` and `console.error` (such as FF and Chrome).\n+If multiple arguments are returned from the async function, `console.dir` is\n+called on each argument in order.\n+\n+__Arguments__\n+\n+* `function` - The function you want to eventually apply all arguments to.\n+* `arguments...` - Any number of arguments to apply to the function.\n+\n+__Example__\n+\n+```js\n+var hello = function(name, callback){\n+    setTimeout(function(){\n+        callback(null, {hello: name});\n+    }, 1000);\n+};\n+```\n+```js\n+node> async.dir(hello, 'world');\n+{hello: 'world'}\n+```\n+\n+---------------------------------------\n+\n+<a name=\"noConflict\" />\n+### noConflict()\n+\n+Changes the value of `async` back to its original value, returning a reference to the\n+`async` object.\ndiff --git a/node_modules/async/component.json b/node_modules/async/component.json\nnew file mode 100644\nindex 0000000..bbb0115\n--- /dev/null\n+++ b/node_modules/async/component.json\n@@ -0,0 +1,11 @@\n+{\n+  \"name\": \"async\",\n+  \"repo\": \"caolan/async\",\n+  \"description\": \"Higher-order functions and common patterns for asynchronous code\",\n+  \"version\": \"0.1.23\",\n+  \"keywords\": [],\n+  \"dependencies\": {},\n+  \"development\": {},\n+  \"main\": \"lib/async.js\",\n+  \"scripts\": [ \"lib/async.js\" ]\n+}\ndiff --git a/node_modules/async/lib/async.js b/node_modules/async/lib/async.js\nnew file mode 100644\nindex 0000000..01e8afc\n--- /dev/null\n+++ b/node_modules/async/lib/async.js\n@@ -0,0 +1,1123 @@\n+/*!\n+ * async\n+ * https://github.com/caolan/async\n+ *\n+ * Copyright 2010-2014 Caolan McMahon\n+ * Released under the MIT license\n+ */\n+/*jshint onevar: false, indent:4 */\n+/*global setImmediate: false, setTimeout: false, console: false */\n+(function () {\n+\n+    var async = {};\n+\n+    // global on the server, window in the browser\n+    var root, previous_async;\n+\n+    root = this;\n+    if (root != null) {\n+      previous_async = root.async;\n+    }\n+\n+    async.noConflict = function () {\n+        root.async = previous_async;\n+        return async;\n+    };\n+\n+    function only_once(fn) {\n+        var called = false;\n+        return function() {\n+            if (called) throw new Error(\"Callback was already called.\");\n+            called = true;\n+            fn.apply(root, arguments);\n+        }\n+    }\n+\n+    //// cross-browser compatiblity functions ////\n+\n+    var _toString = Object.prototype.toString;\n+\n+    var _isArray = Array.isArray || function (obj) {\n+        return _toString.call(obj) === '[object Array]';\n+    };\n+\n+    var _each = function (arr, iterator) {\n+        if (arr.forEach) {\n+            return arr.forEach(iterator);\n+        }\n+        for (var i = 0; i < arr.length; i += 1) {\n+            iterator(arr[i], i, arr);\n+        }\n+    };\n+\n+    var _map = function (arr, iterator) {\n+        if (arr.map) {\n+            return arr.map(iterator);\n+        }\n+        var results = [];\n+        _each(arr, function (x, i, a) {\n+            results.push(iterator(x, i, a));\n+        });\n+        return results;\n+    };\n+\n+    var _reduce = function (arr, iterator, memo) {\n+        if (arr.reduce) {\n+            return arr.reduce(iterator, memo);\n+        }\n+        _each(arr, function (x, i, a) {\n+            memo = iterator(memo, x, i, a);\n+        });\n+        return memo;\n+    };\n+\n+    var _keys = function (obj) {\n+        if (Object.keys) {\n+            return Object.keys(obj);\n+        }\n+        var keys = [];\n+        for (var k in obj) {\n+            if (obj.hasOwnProperty(k)) {\n+                keys.push(k);\n+            }\n+        }\n+        return keys;\n+    };\n+\n+    //// exported async module functions ////\n+\n+    //// nextTick implementation with browser-compatible fallback ////\n+    if (typeof process === 'undefined' || !(process.nextTick)) {\n+        if (typeof setImmediate === 'function') {\n+            async.nextTick = function (fn) {\n+                // not a direct alias for IE10 compatibility\n+                setImmediate(fn);\n+            };\n+            async.setImmediate = async.nextTick;\n+        }\n+        else {\n+            async.nextTick = function (fn) {\n+                setTimeout(fn, 0);\n+            };\n+            async.setImmediate = async.nextTick;\n+        }\n+    }\n+    else {\n+        async.nextTick = process.nextTick;\n+        if (typeof setImmediate !== 'undefined') {\n+            async.setImmediate = function (fn) {\n+              // not a direct alias for IE10 compatibility\n+              setImmediate(fn);\n+            };\n+        }\n+        else {\n+            async.setImmediate = async.nextTick;\n+        }\n+    }\n+\n+    async.each = function (arr, iterator, callback) {\n+        callback = callback || function () {};\n+        if (!arr.length) {\n+            return callback();\n+        }\n+        var completed = 0;\n+        _each(arr, function (x) {\n+            iterator(x, only_once(done) );\n+        });\n+        function done(err) {\n+          if (err) {\n+              callback(err);\n+              callback = function () {};\n+          }\n+          else {\n+              completed += 1;\n+              if (completed >= arr.length) {\n+                  callback();\n+              }\n+          }\n+        }\n+    };\n+    async.forEach = async.each;\n+\n+    async.eachSeries = function (arr, iterator, callback) {\n+        callback = callback || function () {};\n+        if (!arr.length) {\n+            return callback();\n+        }\n+        var completed = 0;\n+        var iterate = function () {\n+            iterator(arr[completed], function (err) {\n+                if (err) {\n+                    callback(err);\n+                    callback = function () {};\n+                }\n+                else {\n+                    completed += 1;\n+                    if (completed >= arr.length) {\n+                        callback();\n+                    }\n+                    else {\n+                        iterate();\n+                    }\n+                }\n+            });\n+        };\n+        iterate();\n+    };\n+    async.forEachSeries = async.eachSeries;\n+\n+    async.eachLimit = function (arr, limit, iterator, callback) {\n+        var fn = _eachLimit(limit);\n+        fn.apply(null, [arr, iterator, callback]);\n+    };\n+    async.forEachLimit = async.eachLimit;\n+\n+    var _eachLimit = function (limit) {\n+\n+        return function (arr, iterator, callback) {\n+            callback = callback || function () {};\n+            if (!arr.length || limit <= 0) {\n+                return callback();\n+            }\n+            var completed = 0;\n+            var started = 0;\n+            var running = 0;\n+\n+            (function replenish () {\n+                if (completed >= arr.length) {\n+                    return callback();\n+                }\n+\n+                while (running < limit && started < arr.length) {\n+                    started += 1;\n+                    running += 1;\n+                    iterator(arr[started - 1], function (err) {\n+                        if (err) {\n+                            callback(err);\n+                            callback = function () {};\n+                        }\n+                        else {\n+                            completed += 1;\n+                            running -= 1;\n+                            if (completed >= arr.length) {\n+                                callback();\n+                            }\n+                            else {\n+                                replenish();\n+                            }\n+                        }\n+                    });\n+                }\n+            })();\n+        };\n+    };\n+\n+\n+    var doParallel = function (fn) {\n+        return function () {\n+            var args = Array.prototype.slice.call(arguments);\n+            return fn.apply(null, [async.each].concat(args));\n+        };\n+    };\n+    var doParallelLimit = function(limit, fn) {\n+        return function () {\n+            var args = Array.prototype.slice.call(arguments);\n+            return fn.apply(null, [_eachLimit(limit)].concat(args));\n+        };\n+    };\n+    var doSeries = function (fn) {\n+        return function () {\n+            var args = Array.prototype.slice.call(arguments);\n+            return fn.apply(null, [async.eachSeries].concat(args));\n+        };\n+    };\n+\n+\n+    var _asyncMap = function (eachfn, arr, iterator, callback) {\n+        arr = _map(arr, function (x, i) {\n+            return {index: i, value: x};\n+        });\n+        if (!callback) {\n+            eachfn(arr, function (x, callback) {\n+                iterator(x.value, function (err) {\n+                    callback(err);\n+                });\n+            });\n+        } else {\n+            var results = [];\n+            eachfn(arr, function (x, callback) {\n+                iterator(x.value, function (err, v) {\n+                    results[x.index] = v;\n+                    callback(err);\n+                });\n+            }, function (err) {\n+                callback(err, results);\n+            });\n+        }\n+    };\n+    async.map = doParallel(_asyncMap);\n+    async.mapSeries = doSeries(_asyncMap);\n+    async.mapLimit = function (arr, limit, iterator, callback) {\n+        return _mapLimit(limit)(arr, iterator, callback);\n+    };\n+\n+    var _mapLimit = function(limit) {\n+        return doParallelLimit(limit, _asyncMap);\n+    };\n+\n+    // reduce only has a series version, as doing reduce in parallel won't\n+    // work in many situations.\n+    async.reduce = function (arr, memo, iterator, callback) {\n+        async.eachSeries(arr, function (x, callback) {\n+            iterator(memo, x, function (err, v) {\n+                memo = v;\n+                callback(err);\n+            });\n+        }, function (err) {\n+            callback(err, memo);\n+        });\n+    };\n+    // inject alias\n+    async.inject = async.reduce;\n+    // foldl alias\n+    async.foldl = async.reduce;\n+\n+    async.reduceRight = function (arr, memo, iterator, callback) {\n+        var reversed = _map(arr, function (x) {\n+            return x;\n+        }).reverse();\n+        async.reduce(reversed, memo, iterator, callback);\n+    };\n+    // foldr alias\n+    async.foldr = async.reduceRight;\n+\n+    var _filter = function (eachfn, arr, iterator, callback) {\n+        var results = [];\n+        arr = _map(arr, function (x, i) {\n+            return {index: i, value: x};\n+        });\n+        eachfn(arr, function (x, callback) {\n+            iterator(x.value, function (v) {\n+                if (v) {\n+                    results.push(x);\n+                }\n+                callback();\n+            });\n+        }, function (err) {\n+            callback(_map(results.sort(function (a, b) {\n+                return a.index - b.index;\n+            }), function (x) {\n+                return x.value;\n+            }));\n+        });\n+    };\n+    async.filter = doParallel(_filter);\n+    async.filterSeries = doSeries(_filter);\n+    // select alias\n+    async.select = async.filter;\n+    async.selectSeries = async.filterSeries;\n+\n+    var _reject = function (eachfn, arr, iterator, callback) {\n+        var results = [];\n+        arr = _map(arr, function (x, i) {\n+            return {index: i, value: x};\n+        });\n+        eachfn(arr, function (x, callback) {\n+            iterator(x.value, function (v) {\n+                if (!v) {\n+                    results.push(x);\n+                }\n+                callback();\n+            });\n+        }, function (err) {\n+            callback(_map(results.sort(function (a, b) {\n+                return a.index - b.index;\n+            }), function (x) {\n+                return x.value;\n+            }));\n+        });\n+    };\n+    async.reject = doParallel(_reject);\n+    async.rejectSeries = doSeries(_reject);\n+\n+    var _detect = function (eachfn, arr, iterator, main_callback) {\n+        eachfn(arr, function (x, callback) {\n+            iterator(x, function (result) {\n+                if (result) {\n+                    main_callback(x);\n+                    main_callback = function () {};\n+                }\n+                else {\n+                    callback();\n+                }\n+            });\n+        }, function (err) {\n+            main_callback();\n+        });\n+    };\n+    async.detect = doParallel(_detect);\n+    async.detectSeries = doSeries(_detect);\n+\n+    async.some = function (arr, iterator, main_callback) {\n+        async.each(arr, function (x, callback) {\n+            iterator(x, function (v) {\n+                if (v) {\n+                    main_callback(true);\n+                    main_callback = function () {};\n+                }\n+                callback();\n+            });\n+        }, function (err) {\n+            main_callback(false);\n+        });\n+    };\n+    // any alias\n+    async.any = async.some;\n+\n+    async.every = function (arr, iterator, main_callback) {\n+        async.each(arr, function (x, callback) {\n+            iterator(x, function (v) {\n+                if (!v) {\n+                    main_callback(false);\n+                    main_callback = function () {};\n+                }\n+                callback();\n+            });\n+        }, function (err) {\n+            main_callback(true);\n+        });\n+    };\n+    // all alias\n+    async.all = async.every;\n+\n+    async.sortBy = function (arr, iterator, callback) {\n+        async.map(arr, function (x, callback) {\n+            iterator(x, function (err, criteria) {\n+                if (err) {\n+                    callback(err);\n+                }\n+                else {\n+                    callback(null, {value: x, criteria: criteria});\n+                }\n+            });\n+        }, function (err, results) {\n+            if (err) {\n+                return callback(err);\n+            }\n+            else {\n+                var fn = function (left, right) {\n+                    var a = left.criteria, b = right.criteria;\n+                    return a < b ? -1 : a > b ? 1 : 0;\n+                };\n+                callback(null, _map(results.sort(fn), function (x) {\n+                    return x.value;\n+                }));\n+            }\n+        });\n+    };\n+\n+    async.auto = function (tasks, callback) {\n+        callback = callback || function () {};\n+        var keys = _keys(tasks);\n+        var remainingTasks = keys.length\n+        if (!remainingTasks) {\n+            return callback();\n+        }\n+\n+        var results = {};\n+\n+        var listeners = [];\n+        var addListener = function (fn) {\n+            listeners.unshift(fn);\n+        };\n+        var removeListener = function (fn) {\n+            for (var i = 0; i < listeners.length; i += 1) {\n+                if (listeners[i] === fn) {\n+                    listeners.splice(i, 1);\n+                    return;\n+                }\n+            }\n+        };\n+        var taskComplete = function () {\n+            remainingTasks--\n+            _each(listeners.slice(0), function (fn) {\n+                fn();\n+            });\n+        };\n+\n+        addListener(function () {\n+            if (!remainingTasks) {\n+                var theCallback = callback;\n+                // prevent final callback from calling itself if it errors\n+                callback = function () {};\n+\n+                theCallback(null, results);\n+            }\n+        });\n+\n+        _each(keys, function (k) {\n+            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\n+            var taskCallback = function (err) {\n+                var args = Array.prototype.slice.call(arguments, 1);\n+                if (args.length <= 1) {\n+                    args = args[0];\n+                }\n+                if (err) {\n+                    var safeResults = {};\n+                    _each(_keys(results), function(rkey) {\n+                        safeResults[rkey] = results[rkey];\n+                    });\n+                    safeResults[k] = args;\n+                    callback(err, safeResults);\n+                    // stop subsequent errors hitting callback multiple times\n+                    callback = function () {};\n+                }\n+                else {\n+                    results[k] = args;\n+                    async.setImmediate(taskComplete);\n+                }\n+            };\n+            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n+            var ready = function () {\n+                return _reduce(requires, function (a, x) {\n+                    return (a && results.hasOwnProperty(x));\n+                }, true) && !results.hasOwnProperty(k);\n+            };\n+            if (ready()) {\n+                task[task.length - 1](taskCallback, results);\n+            }\n+            else {\n+                var listener = function () {\n+                    if (ready()) {\n+                        removeListener(listener);\n+                        task[task.length - 1](taskCallback, results);\n+                    }\n+                };\n+                addListener(listener);\n+            }\n+        });\n+    };\n+\n+    async.retry = function(times, task, callback) {\n+        var DEFAULT_TIMES = 5;\n+        var attempts = [];\n+        // Use defaults if times not passed\n+        if (typeof times === 'function') {\n+            callback = task;\n+            task = times;\n+            times = DEFAULT_TIMES;\n+        }\n+        // Make sure times is a number\n+        times = parseInt(times, 10) || DEFAULT_TIMES;\n+        var wrappedTask = function(wrappedCallback, wrappedResults) {\n+            var retryAttempt = function(task, finalAttempt) {\n+                return function(seriesCallback) {\n+                    task(function(err, result){\n+                        seriesCallback(!err || finalAttempt, {err: err, result: result});\n+                    }, wrappedResults);\n+                };\n+            };\n+            while (times) {\n+                attempts.push(retryAttempt(task, !(times-=1)));\n+            }\n+            async.series(attempts, function(done, data){\n+                data = data[data.length - 1];\n+                (wrappedCallback || callback)(data.err, data.result);\n+            });\n+        }\n+        // If a callback is passed, run this as a controll flow\n+        return callback ? wrappedTask() : wrappedTask\n+    };\n+\n+    async.waterfall = function (tasks, callback) {\n+        callback = callback || function () {};\n+        if (!_isArray(tasks)) {\n+          var err = new Error('First argument to waterfall must be an array of functions');\n+          return callback(err);\n+        }\n+        if (!tasks.length) {\n+            return callback();\n+        }\n+        var wrapIterator = function (iterator) {\n+            return function (err) {\n+                if (err) {\n+                    callback.apply(null, arguments);\n+                    callback = function () {};\n+                }\n+                else {\n+                    var args = Array.prototype.slice.call(arguments, 1);\n+                    var next = iterator.next();\n+                    if (next) {\n+                        args.push(wrapIterator(next));\n+                    }\n+                    else {\n+                        args.push(callback);\n+                    }\n+                    async.setImmediate(function () {\n+                        iterator.apply(null, args);\n+                    });\n+                }\n+            };\n+        };\n+        wrapIterator(async.iterator(tasks))();\n+    };\n+\n+    var _parallel = function(eachfn, tasks, callback) {\n+        callback = callback || function () {};\n+        if (_isArray(tasks)) {\n+            eachfn.map(tasks, function (fn, callback) {\n+                if (fn) {\n+                    fn(function (err) {\n+                        var args = Array.prototype.slice.call(arguments, 1);\n+                        if (args.length <= 1) {\n+                            args = args[0];\n+                        }\n+                        callback.call(null, err, args);\n+                    });\n+                }\n+            }, callback);\n+        }\n+        else {\n+            var results = {};\n+            eachfn.each(_keys(tasks), function (k, callback) {\n+                tasks[k](function (err) {\n+                    var args = Array.prototype.slice.call(arguments, 1);\n+                    if (args.length <= 1) {\n+                        args = args[0];\n+                    }\n+                    results[k] = args;\n+                    callback(err);\n+                });\n+            }, function (err) {\n+                callback(err, results);\n+            });\n+        }\n+    };\n+\n+    async.parallel = function (tasks, callback) {\n+        _parallel({ map: async.map, each: async.each }, tasks, callback);\n+    };\n+\n+    async.parallelLimit = function(tasks, limit, callback) {\n+        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n+    };\n+\n+    async.series = function (tasks, callback) {\n+        callback = callback || function () {};\n+        if (_isArray(tasks)) {\n+            async.mapSeries(tasks, function (fn, callback) {\n+                if (fn) {\n+                    fn(function (err) {\n+                        var args = Array.prototype.slice.call(arguments, 1);\n+                        if (args.length <= 1) {\n+                            args = args[0];\n+                        }\n+                        callback.call(null, err, args);\n+                    });\n+                }\n+            }, callback);\n+        }\n+        else {\n+            var results = {};\n+            async.eachSeries(_keys(tasks), function (k, callback) {\n+                tasks[k](function (err) {\n+                    var args = Array.prototype.slice.call(arguments, 1);\n+                    if (args.length <= 1) {\n+                        args = args[0];\n+                    }\n+                    results[k] = args;\n+                    callback(err);\n+                });\n+            }, function (err) {\n+                callback(err, results);\n+            });\n+        }\n+    };\n+\n+    async.iterator = function (tasks) {\n+        var makeCallback = function (index) {\n+            var fn = function () {\n+                if (tasks.length) {\n+                    tasks[index].apply(null, arguments);\n+                }\n+                return fn.next();\n+            };\n+            fn.next = function () {\n+                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n+            };\n+            return fn;\n+        };\n+        return makeCallback(0);\n+    };\n+\n+    async.apply = function (fn) {\n+        var args = Array.prototype.slice.call(arguments, 1);\n+        return function () {\n+            return fn.apply(\n+                null, args.concat(Array.prototype.slice.call(arguments))\n+            );\n+        };\n+    };\n+\n+    var _concat = function (eachfn, arr, fn, callback) {\n+        var r = [];\n+        eachfn(arr, function (x, cb) {\n+            fn(x, function (err, y) {\n+                r = r.concat(y || []);\n+                cb(err);\n+            });\n+        }, function (err) {\n+            callback(err, r);\n+        });\n+    };\n+    async.concat = doParallel(_concat);\n+    async.concatSeries = doSeries(_concat);\n+\n+    async.whilst = function (test, iterator, callback) {\n+        if (test()) {\n+            iterator(function (err) {\n+                if (err) {\n+                    return callback(err);\n+                }\n+                async.whilst(test, iterator, callback);\n+            });\n+        }\n+        else {\n+            callback();\n+        }\n+    };\n+\n+    async.doWhilst = function (iterator, test, callback) {\n+        iterator(function (err) {\n+            if (err) {\n+                return callback(err);\n+            }\n+            var args = Array.prototype.slice.call(arguments, 1);\n+            if (test.apply(null, args)) {\n+                async.doWhilst(iterator, test, callback);\n+            }\n+            else {\n+                callback();\n+            }\n+        });\n+    };\n+\n+    async.until = function (test, iterator, callback) {\n+        if (!test()) {\n+            iterator(function (err) {\n+                if (err) {\n+                    return callback(err);\n+                }\n+                async.until(test, iterator, callback);\n+            });\n+        }\n+        else {\n+            callback();\n+        }\n+    };\n+\n+    async.doUntil = function (iterator, test, callback) {\n+        iterator(function (err) {\n+            if (err) {\n+                return callback(err);\n+            }\n+            var args = Array.prototype.slice.call(arguments, 1);\n+            if (!test.apply(null, args)) {\n+                async.doUntil(iterator, test, callback);\n+            }\n+            else {\n+                callback();\n+            }\n+        });\n+    };\n+\n+    async.queue = function (worker, concurrency) {\n+        if (concurrency === undefined) {\n+            concurrency = 1;\n+        }\n+        function _insert(q, data, pos, callback) {\n+          if (!q.started){\n+            q.started = true;\n+          }\n+          if (!_isArray(data)) {\n+              data = [data];\n+          }\n+          if(data.length == 0) {\n+             // call drain immediately if there are no tasks\n+             return async.setImmediate(function() {\n+                 if (q.drain) {\n+                     q.drain();\n+                 }\n+             });\n+          }\n+          _each(data, function(task) {\n+              var item = {\n+                  data: task,\n+                  callback: typeof callback === 'function' ? callback : null\n+              };\n+\n+              if (pos) {\n+                q.tasks.unshift(item);\n+              } else {\n+                q.tasks.push(item);\n+              }\n+\n+              if (q.saturated && q.tasks.length === q.concurrency) {\n+                  q.saturated();\n+              }\n+              async.setImmediate(q.process);\n+          });\n+        }\n+\n+        var workers = 0;\n+        var q = {\n+            tasks: [],\n+            concurrency: concurrency,\n+            saturated: null,\n+            empty: null,\n+            drain: null,\n+            started: false,\n+            paused: false,\n+            push: function (data, callback) {\n+              _insert(q, data, false, callback);\n+            },\n+            kill: function () {\n+              q.drain = null;\n+              q.tasks = [];\n+            },\n+            unshift: function (data, callback) {\n+              _insert(q, data, true, callback);\n+            },\n+            process: function () {\n+                if (!q.paused && workers < q.concurrency && q.tasks.length) {\n+                    var task = q.tasks.shift();\n+                    if (q.empty && q.tasks.length === 0) {\n+                        q.empty();\n+                    }\n+                    workers += 1;\n+                    var next = function () {\n+                        workers -= 1;\n+                        if (task.callback) {\n+                            task.callback.apply(task, arguments);\n+                        }\n+                        if (q.drain && q.tasks.length + workers === 0) {\n+                            q.drain();\n+                        }\n+                        q.process();\n+                    };\n+                    var cb = only_once(next);\n+                    worker(task.data, cb);\n+                }\n+            },\n+            length: function () {\n+                return q.tasks.length;\n+            },\n+            running: function () {\n+                return workers;\n+            },\n+            idle: function() {\n+                return q.tasks.length + workers === 0;\n+            },\n+            pause: function () {\n+                if (q.paused === true) { return; }\n+                q.paused = true;\n+                q.process();\n+            },\n+            resume: function () {\n+                if (q.paused === false) { return; }\n+                q.paused = false;\n+                q.process();\n+            }\n+        };\n+        return q;\n+    };\n+    \n+    async.priorityQueue = function (worker, concurrency) {\n+        \n+        function _compareTasks(a, b){\n+          return a.priority - b.priority;\n+        };\n+        \n+        function _binarySearch(sequence, item, compare) {\n+          var beg = -1,\n+              end = sequence.length - 1;\n+          while (beg < end) {\n+            var mid = beg + ((end - beg + 1) >>> 1);\n+            if (compare(item, sequence[mid]) >= 0) {\n+              beg = mid;\n+            } else {\n+              end = mid - 1;\n+            }\n+          }\n+          return beg;\n+        }\n+        \n+        function _insert(q, data, priority, callback) {\n+          if (!q.started){\n+            q.started = true;\n+          }\n+          if (!_isArray(data)) {\n+              data = [data];\n+          }\n+          if(data.length == 0) {\n+             // call drain immediately if there are no tasks\n+             return async.setImmediate(function() {\n+                 if (q.drain) {\n+                     q.drain();\n+                 }\n+             });\n+          }\n+          _each(data, function(task) {\n+              var item = {\n+                  data: task,\n+                  priority: priority,\n+                  callback: typeof callback === 'function' ? callback : null\n+              };\n+              \n+              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\n+\n+              if (q.saturated && q.tasks.length === q.concurrency) {\n+                  q.saturated();\n+              }\n+              async.setImmediate(q.process);\n+          });\n+        }\n+        \n+        // Start with a normal queue\n+        var q = async.queue(worker, concurrency);\n+        \n+        // Override push to accept second parameter representing priority\n+        q.push = function (data, priority, callback) {\n+          _insert(q, data, priority, callback);\n+        };\n+        \n+        // Remove unshift function\n+        delete q.unshift;\n+\n+        return q;\n+    };\n+\n+    async.cargo = function (worker, payload) {\n+        var working     = false,\n+            tasks       = [];\n+\n+        var cargo = {\n+            tasks: tasks,\n+            payload: payload,\n+            saturated: null,\n+            empty: null,\n+            drain: null,\n+            drained: true,\n+            push: function (data, callback) {\n+                if (!_isArray(data)) {\n+                    data = [data];\n+                }\n+                _each(data, function(task) {\n+                    tasks.push({\n+                        data: task,\n+                        callback: typeof callback === 'function' ? callback : null\n+                    });\n+                    cargo.drained = false;\n+                    if (cargo.saturated && tasks.length === payload) {\n+                        cargo.saturated();\n+                    }\n+                });\n+                async.setImmediate(cargo.process);\n+            },\n+            process: function process() {\n+                if (working) return;\n+                if (tasks.length === 0) {\n+                    if(cargo.drain && !cargo.drained) cargo.drain();\n+                    cargo.drained = true;\n+                    return;\n+                }\n+\n+                var ts = typeof payload === 'number'\n+                            ? tasks.splice(0, payload)\n+                            : tasks.splice(0, tasks.length);\n+\n+                var ds = _map(ts, function (task) {\n+                    return task.data;\n+                });\n+\n+                if(cargo.empty) cargo.empty();\n+                working = true;\n+                worker(ds, function () {\n+                    working = false;\n+\n+                    var args = arguments;\n+                    _each(ts, function (data) {\n+                        if (data.callback) {\n+                            data.callback.apply(null, args);\n+                        }\n+                    });\n+\n+                    process();\n+                });\n+            },\n+            length: function () {\n+                return tasks.length;\n+            },\n+            running: function () {\n+                return working;\n+            }\n+        };\n+        return cargo;\n+    };\n+\n+    var _console_fn = function (name) {\n+        return function (fn) {\n+            var args = Array.prototype.slice.call(arguments, 1);\n+            fn.apply(null, args.concat([function (err) {\n+                var args = Array.prototype.slice.call(arguments, 1);\n+                if (typeof console !== 'undefined') {\n+                    if (err) {\n+                        if (console.error) {\n+                            console.error(err);\n+                        }\n+                    }\n+                    else if (console[name]) {\n+                        _each(args, function (x) {\n+                            console[name](x);\n+                        });\n+                    }\n+                }\n+            }]));\n+        };\n+    };\n+    async.log = _console_fn('log');\n+    async.dir = _console_fn('dir');\n+    /*async.info = _console_fn('info');\n+    async.warn = _console_fn('warn');\n+    async.error = _console_fn('error');*/\n+\n+    async.memoize = function (fn, hasher) {\n+        var memo = {};\n+        var queues = {};\n+        hasher = hasher || function (x) {\n+            return x;\n+        };\n+        var memoized = function () {\n+            var args = Array.prototype.slice.call(arguments);\n+            var callback = args.pop();\n+            var key = hasher.apply(null, args);\n+            if (key in memo) {\n+                async.nextTick(function () {\n+                    callback.apply(null, memo[key]);\n+                });\n+            }\n+            else if (key in queues) {\n+                queues[key].push(callback);\n+            }\n+            else {\n+                queues[key] = [callback];\n+                fn.apply(null, args.concat([function () {\n+                    memo[key] = arguments;\n+                    var q = queues[key];\n+                    delete queues[key];\n+                    for (var i = 0, l = q.length; i < l; i++) {\n+                      q[i].apply(null, arguments);\n+                    }\n+                }]));\n+            }\n+        };\n+        memoized.memo = memo;\n+        memoized.unmemoized = fn;\n+        return memoized;\n+    };\n+\n+    async.unmemoize = function (fn) {\n+      return function () {\n+        return (fn.unmemoized || fn).apply(null, arguments);\n+      };\n+    };\n+\n+    async.times = function (count, iterator, callback) {\n+        var counter = [];\n+        for (var i = 0; i < count; i++) {\n+            counter.push(i);\n+        }\n+        return async.map(counter, iterator, callback);\n+    };\n+\n+    async.timesSeries = function (count, iterator, callback) {\n+        var counter = [];\n+        for (var i = 0; i < count; i++) {\n+            counter.push(i);\n+        }\n+        return async.mapSeries(counter, iterator, callback);\n+    };\n+\n+    async.seq = function (/* functions... */) {\n+        var fns = arguments;\n+        return function () {\n+            var that = this;\n+            var args = Array.prototype.slice.call(arguments);\n+            var callback = args.pop();\n+            async.reduce(fns, args, function (newargs, fn, cb) {\n+                fn.apply(that, newargs.concat([function () {\n+                    var err = arguments[0];\n+                    var nextargs = Array.prototype.slice.call(arguments, 1);\n+                    cb(err, nextargs);\n+                }]))\n+            },\n+            function (err, results) {\n+                callback.apply(that, [err].concat(results));\n+            });\n+        };\n+    };\n+\n+    async.compose = function (/* functions... */) {\n+      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\n+    };\n+\n+    var _applyEach = function (eachfn, fns /*args...*/) {\n+        var go = function () {\n+            var that = this;\n+            var args = Array.prototype.slice.call(arguments);\n+            var callback = args.pop();\n+            return eachfn(fns, function (fn, cb) {\n+                fn.apply(that, args.concat([cb]));\n+            },\n+            callback);\n+        };\n+        if (arguments.length > 2) {\n+            var args = Array.prototype.slice.call(arguments, 2);\n+            return go.apply(this, args);\n+        }\n+        else {\n+            return go;\n+        }\n+    };\n+    async.applyEach = doParallel(_applyEach);\n+    async.applyEachSeries = doSeries(_applyEach);\n+\n+    async.forever = function (fn, callback) {\n+        function next(err) {\n+            if (err) {\n+                if (callback) {\n+                    return callback(err);\n+                }\n+                throw err;\n+            }\n+            fn(next);\n+        }\n+        next();\n+    };\n+\n+    // Node.js\n+    if (typeof module !== 'undefined' && module.exports) {\n+        module.exports = async;\n+    }\n+    // AMD / RequireJS\n+    else if (typeof define !== 'undefined' && define.amd) {\n+        define([], function () {\n+            return async;\n+        });\n+    }\n+    // included directly via <script> tag\n+    else {\n+        root.async = async;\n+    }\n+\n+}());\ndiff --git a/node_modules/async/package.json b/node_modules/async/package.json\nnew file mode 100644\nindex 0000000..31a5200\n--- /dev/null\n+++ b/node_modules/async/package.json\n@@ -0,0 +1,59 @@\n+{\n+  \"name\": \"async\",\n+  \"description\": \"Higher-order functions and common patterns for asynchronous code\",\n+  \"main\": \"./lib/async\",\n+  \"author\": {\n+    \"name\": \"Caolan McMahon\"\n+  },\n+  \"version\": \"0.9.0\",\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"https://github.com/caolan/async.git\"\n+  },\n+  \"bugs\": {\n+    \"url\": \"https://github.com/caolan/async/issues\"\n+  },\n+  \"licenses\": [\n+    {\n+      \"type\": \"MIT\",\n+      \"url\": \"https://github.com/caolan/async/raw/master/LICENSE\"\n+    }\n+  ],\n+  \"devDependencies\": {\n+    \"nodeunit\": \">0.0.0\",\n+    \"uglify-js\": \"1.2.x\",\n+    \"nodelint\": \">0.0.0\"\n+  },\n+  \"jam\": {\n+    \"main\": \"lib/async.js\",\n+    \"include\": [\n+      \"lib/async.js\",\n+      \"README.md\",\n+      \"LICENSE\"\n+    ]\n+  },\n+  \"scripts\": {\n+    \"test\": \"nodeunit test/test-async.js\"\n+  },\n+  \"homepage\": \"https://github.com/caolan/async\",\n+  \"_id\": \"async@0.9.0\",\n+  \"dist\": {\n+    \"shasum\": \"ac3613b1da9bed1b47510bb4651b8931e47146c7\",\n+    \"tarball\": \"http://registry.npmjs.org/async/-/async-0.9.0.tgz\"\n+  },\n+  \"_from\": \"async@*\",\n+  \"_npmVersion\": \"1.4.3\",\n+  \"_npmUser\": {\n+    \"name\": \"caolan\",\n+    \"email\": \"caolan.mcmahon@gmail.com\"\n+  },\n+  \"maintainers\": [\n+    {\n+      \"name\": \"caolan\",\n+      \"email\": \"caolan@caolanmcmahon.com\"\n+    }\n+  ],\n+  \"directories\": {},\n+  \"_shasum\": \"ac3613b1da9bed1b47510bb4651b8931e47146c7\",\n+  \"_resolved\": \"https://registry.npmjs.org/async/-/async-0.9.0.tgz\"\n+}\ndiff --git a/package.json b/package.json\nindex 5f21627..6033d43 100644\n--- a/package.json\n+++ b/package.json\n@@ -4,7 +4,8 @@\n   \"description\": \"Sous project\",\n   \"main\": \"main.js\",\n   \"dependencies\": {\n-},\n+    \"async\": \"*\"\n+  },\n   \"devDependencies\": {},\n   \"scripts\": {\n     \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\ndiff --git a/patches.sousp b/patches.sousp\nindex 16405a3..d71e511 100644\n--- a/patches.sousp\n+++ b/patches.sousp\n@@ -1,31 +1 @@\n-diff --git a/main.js b/main.js\n-index f81b54e..744cdd5 100644\n---- a/main.js\n-+++ b/main.js\n-@@ -35,7 +35,7 @@ fs.exists('.git', function (exists) {\n-         cp.exec('git diff', function(error, stdout, stderr) {\n-             console.log(stdout);\n- \n--            //fs.writeFileSync(\"patches.sousp\", stdout);\n-+            fs.writeFileSync(\"patches.sousp\", stdout);\n- \n-             if (error !== null) {\n-                 console.log('stderr: ' + stderr);\n-@@ -44,7 +44,7 @@ fs.exists('.git', function (exists) {\n-         });\n- \n-         cp.exec('git log', function(error, stdout, stderr) {\n--            //console.log(stdout);\n-+            console.log(stdout);\n- \n-             var authors = findData(stdout, \"Author:\");\n-             var dates = findData(stdout, \"Date:\");\n-@@ -53,7 +53,7 @@ fs.exists('.git', function (exists) {\n-             console.log(comments);\n-             console.log(dates);\n- \n--            //fs.writeFileSync(\"comments.sousc\", stdout);\n-+            fs.writeFileSync(\"comments.sousc\", stdout);\n- \n-             if (error !== null) {\n-                 console.log('stderr: ' + stderr);\n+[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]\n\\ No newline at end of file\ndiff --git a/test.js b/test.js\nnew file mode 100644\nindex 0000000..5ca759c\n--- /dev/null\n+++ b/test.js\n@@ -0,0 +1,21 @@\n+/**\n+ * Created by Nick on 18.05.2015.\n+ */\n+var async = require('async')\n+    , tasksIndex = [\n+        function (callback) {\n+            // Вымышленный метод который вернет 231\n+            var viewsNumber = models.stat.viewsNumber();\n+            callback(null, viewsNumber);\n+        }\n+        , function (callback) {\n+            // Вымышленный метод который вернет 24\n+            var growFactor = models.stat.growFactor();\n+            callback(null, growFactor);\n+        }\n+    ];\n+\n+async.series(tasksIndex, function (err, results) {\n+    // Результат будет массивом\n+    console.log(results); // [231, 24]\n+});\n\\ No newline at end of file\n"},{"commit":"dbe72b9889081e5856c1e2d72723e8ab2dc898bd","author":"Nick Stepanenko <massaalonso@yandex.ru>","date":"Tue May 19 01:41:21 2015 +0800","comment":"Content will be added now.","content":"diff --git a/main.js b/main.js\nindex 86f30c2..ca7473f 100644\n--- a/main.js\n+++ b/main.js\n@@ -148,7 +148,9 @@ fs.exists('.git', function (exists) {\n                         listOfCommits[listOfCommits.length] = commit;\n                     }\n \n-                    callback(null, listOfCommits.reverse());\n+                    var commitsData = listOfCommits.reverse();\n+\n+                    callback(null, commitsData);\n \n                     if (error !== null) {\n                         console.log('stderr: ' + stderr);\n@@ -157,27 +159,18 @@ fs.exists('.git', function (exists) {\n                 });\n             },\n             function getCommitsContent(commits, callback) {\n-                console.log(commits);\n                 var commitsData = commits;\n \n                 for(i=1; i<commitsData.length; i++) {\n-                    cp.exec('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit, function(error, stdout, stderr) {\n-                        commitsData[i].content = stdout;\n-\n-                        if (error !== null) {\n-                            console.log('stderr: ' + stderr);\n-                            console.log('exec error: ' + error);\n-                        }\n-                    });\n+                    commitsData[i].content = cp.execSync('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit).toString('utf8');\n                 }\n \n                 callback(null, commitsData);\n             }\n         ], function (err, result) {\n-            fs.writeFileSync(\"patches.sousp\", result);\n+            for(i=0; i<result.length; i++) {\n+                fs.writeFileSync(\"patches.sousp\", JSON.stringify(result[i]));\n+            }\n         });\n-\n-        //commitsInfo = JSON.parse(fs.readFileSync(\"patches.sousp\"));\n-        //console.log(commitsInfo);\n     }\n });\n\\ No newline at end of file\ndiff --git a/patches.sousp b/patches.sousp\nindex d71e511..300c6a9 100644\n--- a/patches.sousp\n+++ b/patches.sousp\n@@ -1 +1 @@\n-[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]\n\\ No newline at end of file\n+{\"commit\":\"1e947f613e976945de85ae35ed923aa470f0be72\",\"author\":\"Nick Stepanenko <massaalonso@yandex.ru>\",\"date\":\"Tue May 19 00:12:12 2015 +0800\",\"comment\":\"Latest updates\",\"content\":\"diff --git a/comments.sousc b/comments.sousc\\nindex 150b0f6..cb3a850 100644\\n--- a/comments.sousc\\n+++ b/comments.sousc\\n@@ -1,3 +1,27 @@\\n+commit 4420cabefc1f470af341af11ed595df67e25c51f\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\n+Date:   Sun May 17 17:05:35 2015 +0800\\n+\\n+    Paste old program code\\n+\\n+commit 9ef3d25fd4c3afdbcc3107a0abf6d7a2e29cb4dd\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\n+Date:   Sun May 17 17:04:52 2015 +0800\\n+\\n+    Adding new file\\n+\\n+commit 64814d140d2fab6ae153cac485008119f29bf230\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\n+Date:   Sun May 17 17:03:58 2015 +0800\\n+\\n+    From clear list\\n+\\n+commit c9d318fea74ea288d544ecf72f00b12c130cf2ef\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\n+Date:   Sun May 17 16:59:40 2015 +0800\\n+\\n+    Create system files\\n+\\n commit e3c853a4282dfe8f000685dc1d39bd55a4a946c4\\n Author: Nick Stepanenko <massaalonso@yandex.ru>\\n Date:   Sun May 17 16:54:58 2015 +0800\\ndiff --git a/main.js b/main.js\\nindex e34dc18..86f30c2 100644\\n--- a/main.js\\n+++ b/main.js\\n@@ -3,6 +3,56 @@\\n  */\\n \\n var fs = require('fs');\\n+var cp = require('child_process');\\n+var data = [];\\n+\\n+var async = require('async');\\n+    /*tasks = [\\n+        function (callback) {\\n+            cp.exec('git log', function(error, stdout, stderr) {\\n+                var listOfCommits = [];\\n+                var authors = findData(stdout, \\\"Author:\\\");\\n+                var dates = findData(stdout, \\\"Date:\\\");\\n+                var comments = findComments(stdout);\\n+                var commitNumbers = findCommitNumbers(stdout);\\n+\\n+                for(i=0; i<authors.length; i++) {\\n+                    var commit = {\\n+                        \\\"commit\\\": commitNumbers[i],\\n+                        \\\"author\\\": authors[i],\\n+                        \\\"date\\\": dates[i],\\n+                        \\\"comment\\\": comments[i],\\n+                        \\\"content\\\": 'Original'\\n+                    };\\n+\\n+                    listOfCommits[listOfCommits.length] = commit;\\n+                }\\n+\\n+                data = listOfCommits.reverse();\\n+\\n+                callback(null, data);\\n+\\n+                if (error !== null) {\\n+                    console.log('stderr: ' + stderr);\\n+                    console.log('exec error: ' + error);\\n+                }\\n+            });\\n+        }\\n+    ],\\n+    secondTasks = [\\n+        function some_function(callback) {\\n+            cp.exec('git diff', function(error, stdout, stderr) {\\n+                var currentContent = stdout;\\n+\\n+                if (error !== null) {\\n+                    console.log('stderr: ' + stderr);\\n+                    console.log('exec error: ' + error);\\n+                }\\n+\\n+                callback(null, currentContent);\\n+            });\\n+        }\\n+    ];*/\\n \\n function findData(text, keyword) {\\n     var data = [];\\n@@ -28,38 +78,106 @@ function findComments(text) {\\n     return comments;\\n }\\n \\n+function findCommitNumbers(text) {\\n+    var commits = [];\\n+    var splittext = text.split('\\\\n');\\n+\\n+    for(i=0; i<splittext.length; i++) {\\n+        if(splittext[i].slice(0, 6) == \\\"commit\\\") {\\n+            commits[commits.length] = splittext[i].slice(6).trim();\\n+        }\\n+    }\\n+\\n+    return commits;\\n+}\\n+\\n+/*function pullCommitContent(first, second) {\\n+\\n+    cp.exec('git diff' + ' ' + first + ' ' + second, function(error, stdout, stderr) {\\n+        var currentContent = stdout;\\n+\\n+        if (error !== null) {\\n+            console.log('stderr: ' + stderr);\\n+            console.log('exec error: ' + error);\\n+        }\\n+\\n+        return currentContent;\\n+    });\\n+}*/\\n+\\n+var commitsInfo = [];\\n+\\n fs.exists('.git', function (exists) {\\n     if(exists) {\\n-        var cp = require('child_process');\\n+        /*async.series(tasks, function(err, result) {\\n+            fs.writeFileSync(\\\"patches.sousp\\\", JSON.stringify(result));\\n+\\n+            var data = result[0];\\n \\n-        cp.exec('git diff', function(error, stdout, stderr) {\\n-            console.log(stdout);\\n+            /*function some_function(arg1, arg2, callback) {\\n+                cp.exec('git diff' + ' ' + arg1 + ' ' + arg2, function(error, stdout, stderr) {\\n+                    var currentContent = 54321;//stdout;\\n \\n-            fs.writeFileSync(\\\"patches.sousp\\\", stdout);\\n+                    if (error !== null) {\\n+                        console.log('stderr: ' + stderr);\\n+                        console.log('exec error: ' + error);\\n+                    }\\n \\n-            if (error !== null) {\\n-                console.log('stderr: ' + stderr);\\n-                console.log('exec error: ' + error);\\n+                    callback(null, currentContent);\\n+                });\\n             }\\n-        });\\n+        });*/\\n+\\n+        async.waterfall([\\n+            function getCommitsInfo(callback) {\\n+                cp.exec('git log', function(error, stdout, stderr) {\\n+                    var listOfCommits = [];\\n+                    var authors = findData(stdout, \\\"Author:\\\");\\n+                    var dates = findData(stdout, \\\"Date:\\\");\\n+                    var comments = findComments(stdout);\\n+                    var commitNumbers = findCommitNumbers(stdout);\\n \\n-        cp.exec('git log', function(error, stdout, stderr) {\\n-            console.log(stdout);\\n+                    for(i=0; i<authors.length; i++) {\\n+                        var commit = {\\n+                            \\\"commit\\\": commitNumbers[i],\\n+                            \\\"author\\\": authors[i],\\n+                            \\\"date\\\": dates[i],\\n+                            \\\"comment\\\": comments[i],\\n+                            \\\"content\\\": 'Original'\\n+                        };\\n+                        listOfCommits[listOfCommits.length] = commit;\\n+                    }\\n \\n-            var authors = findData(stdout, \\\"Author:\\\");\\n-            var dates = findData(stdout, \\\"Date:\\\");\\n-            var comments = findComments(stdout);\\n-            console.log(authors);\\n-            console.log(comments);\\n-            console.log(dates);\\n+                    callback(null, listOfCommits.reverse());\\n \\n-            fs.writeFileSync(\\\"comments.sousc\\\", stdout);\\n+                    if (error !== null) {\\n+                        console.log('stderr: ' + stderr);\\n+                        console.log('exec error: ' + error);\\n+                    }\\n+                });\\n+            },\\n+            function getCommitsContent(commits, callback) {\\n+                console.log(commits);\\n+                var commitsData = commits;\\n \\n-            if (error !== null) {\\n-                console.log('stderr: ' + stderr);\\n-                console.log('exec error: ' + error);\\n+                for(i=1; i<commitsData.length; i++) {\\n+                    cp.exec('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit, function(error, stdout, stderr) {\\n+                        commitsData[i].content = stdout;\\n+\\n+                        if (error !== null) {\\n+                            console.log('stderr: ' + stderr);\\n+                            console.log('exec error: ' + error);\\n+                        }\\n+                    });\\n+                }\\n+\\n+                callback(null, commitsData);\\n             }\\n+        ], function (err, result) {\\n+            fs.writeFileSync(\\\"patches.sousp\\\", result);\\n         });\\n+\\n+        //commitsInfo = JSON.parse(fs.readFileSync(\\\"patches.sousp\\\"));\\n+        //console.log(commitsInfo);\\n     }\\n-    else console.log(\\\"Error.\\\");\\n });\\n\\\\ No newline at end of file\\ndiff --git a/node_modules/async/.travis.yml b/node_modules/async/.travis.yml\\nnew file mode 100644\\nindex 0000000..6e5919d\\n--- /dev/null\\n+++ b/node_modules/async/.travis.yml\\n@@ -0,0 +1,3 @@\\n+language: node_js\\n+node_js:\\n+  - \\\"0.10\\\"\\ndiff --git a/node_modules/async/LICENSE b/node_modules/async/LICENSE\\nnew file mode 100644\\nindex 0000000..8f29698\\n--- /dev/null\\n+++ b/node_modules/async/LICENSE\\n@@ -0,0 +1,19 @@\\n+Copyright (c) 2010-2014 Caolan McMahon\\n+\\n+Permission is hereby granted, free of charge, to any person obtaining a copy\\n+of this software and associated documentation files (the \\\"Software\\\"), to deal\\n+in the Software without restriction, including without limitation the rights\\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n+copies of the Software, and to permit persons to whom the Software is\\n+furnished to do so, subject to the following conditions:\\n+\\n+The above copyright notice and this permission notice shall be included in\\n+all copies or substantial portions of the Software.\\n+\\n+THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n+THE SOFTWARE.\\ndiff --git a/node_modules/async/README.md b/node_modules/async/README.md\\nnew file mode 100644\\nindex 0000000..0bea531\\n--- /dev/null\\n+++ b/node_modules/async/README.md\\n@@ -0,0 +1,1646 @@\\n+# Async.js\\n+\\n+[![Build Status via Travis CI](https://travis-ci.org/caolan/async.svg?branch=master)](https://travis-ci.org/caolan/async)\\n+\\n+\\n+Async is a utility module which provides straight-forward, powerful functions\\n+for working with asynchronous JavaScript. Although originally designed for\\n+use with [Node.js](http://nodejs.org), it can also be used directly in the\\n+browser. Also supports [component](https://github.com/component/component).\\n+\\n+Async provides around 20 functions that include the usual 'functional'\\n+suspects (`map`, `reduce`, `filter`, `each`…) as well as some common patterns\\n+for asynchronous control flow (`parallel`, `series`, `waterfall`…). All these\\n+functions assume you follow the Node.js convention of providing a single\\n+callback as the last argument of your `async` function.\\n+\\n+\\n+## Quick Examples\\n+\\n+```javascript\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\n+    // results is now an array of stats for each file\\n+});\\n+\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\n+    // results now equals an array of the existing files\\n+});\\n+\\n+async.parallel([\\n+    function(){ ... },\\n+    function(){ ... }\\n+], callback);\\n+\\n+async.series([\\n+    function(){ ... },\\n+    function(){ ... }\\n+]);\\n+```\\n+\\n+There are many more functions available so take a look at the docs below for a\\n+full list. This module aims to be comprehensive, so if you feel anything is\\n+missing please create a GitHub issue for it.\\n+\\n+## Common Pitfalls\\n+\\n+### Binding a context to an iterator\\n+\\n+This section is really about `bind`, not about `async`. If you are wondering how to\\n+make `async` execute your iterators in a given context, or are confused as to why\\n+a method of another library isn't working as an iterator, study this example:\\n+\\n+```js\\n+// Here is a simple object with an (unnecessarily roundabout) squaring method\\n+var AsyncSquaringLibrary = {\\n+  squareExponent: 2,\\n+  square: function(number, callback){ \\n+    var result = Math.pow(number, this.squareExponent);\\n+    setTimeout(function(){\\n+      callback(null, result);\\n+    }, 200);\\n+  }\\n+};\\n+\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square, function(err, result){\\n+  // result is [NaN, NaN, NaN]\\n+  // This fails because the `this.squareExponent` expression in the square\\n+  // function is not evaluated in the context of AsyncSquaringLibrary, and is\\n+  // therefore undefined.\\n+});\\n+\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), function(err, result){\\n+  // result is [1, 4, 9]\\n+  // With the help of bind we can attach a context to the iterator before\\n+  // passing it to async. Now the square function will be executed in its \\n+  // 'home' AsyncSquaringLibrary context and the value of `this.squareExponent`\\n+  // will be as expected.\\n+});\\n+```\\n+\\n+## Download\\n+\\n+The source is available for download from\\n+[GitHub](http://github.com/caolan/async).\\n+Alternatively, you can install using Node Package Manager (`npm`):\\n+\\n+    npm install async\\n+\\n+__Development:__ [async.js](https://github.com/caolan/async/raw/master/lib/async.js) - 29.6kb Uncompressed\\n+\\n+## In the Browser\\n+\\n+So far it's been tested in IE6, IE7, IE8, FF3.6 and Chrome 5. \\n+\\n+Usage:\\n+\\n+```html\\n+<script type=\\\"text/javascript\\\" src=\\\"async.js\\\"></script>\\n+<script type=\\\"text/javascript\\\">\\n+\\n+    async.map(data, asyncProcess, function(err, results){\\n+        alert(results);\\n+    });\\n+\\n+</script>\\n+```\\n+\\n+## Documentation\\n+\\n+### Collections\\n+\\n+* [`each`](#each)\\n+* [`eachSeries`](#eachSeries)\\n+* [`eachLimit`](#eachLimit)\\n+* [`map`](#map)\\n+* [`mapSeries`](#mapSeries)\\n+* [`mapLimit`](#mapLimit)\\n+* [`filter`](#filter)\\n+* [`filterSeries`](#filterSeries)\\n+* [`reject`](#reject)\\n+* [`rejectSeries`](#rejectSeries)\\n+* [`reduce`](#reduce)\\n+* [`reduceRight`](#reduceRight)\\n+* [`detect`](#detect)\\n+* [`detectSeries`](#detectSeries)\\n+* [`sortBy`](#sortBy)\\n+* [`some`](#some)\\n+* [`every`](#every)\\n+* [`concat`](#concat)\\n+* [`concatSeries`](#concatSeries)\\n+\\n+### Control Flow\\n+\\n+* [`series`](#seriestasks-callback)\\n+* [`parallel`](#parallel)\\n+* [`parallelLimit`](#parallellimittasks-limit-callback)\\n+* [`whilst`](#whilst)\\n+* [`doWhilst`](#doWhilst)\\n+* [`until`](#until)\\n+* [`doUntil`](#doUntil)\\n+* [`forever`](#forever)\\n+* [`waterfall`](#waterfall)\\n+* [`compose`](#compose)\\n+* [`seq`](#seq)\\n+* [`applyEach`](#applyEach)\\n+* [`applyEachSeries`](#applyEachSeries)\\n+* [`queue`](#queue)\\n+* [`priorityQueue`](#priorityQueue)\\n+* [`cargo`](#cargo)\\n+* [`auto`](#auto)\\n+* [`retry`](#retry)\\n+* [`iterator`](#iterator)\\n+* [`apply`](#apply)\\n+* [`nextTick`](#nextTick)\\n+* [`times`](#times)\\n+* [`timesSeries`](#timesSeries)\\n+\\n+### Utils\\n+\\n+* [`memoize`](#memoize)\\n+* [`unmemoize`](#unmemoize)\\n+* [`log`](#log)\\n+* [`dir`](#dir)\\n+* [`noConflict`](#noConflict)\\n+\\n+\\n+## Collections\\n+\\n+<a name=\\\"forEach\\\" />\\n+<a name=\\\"each\\\" />\\n+### each(arr, iterator, callback)\\n+\\n+Applies the function `iterator` to each item in `arr`, in parallel.\\n+The `iterator` is called with an item from the list, and a callback for when it\\n+has finished. If the `iterator` passes an error to its `callback`, the main\\n+`callback` (for the `each` function) is immediately called with the error.\\n+\\n+Note, that since this function applies `iterator` to each item in parallel,\\n+there is no guarantee that the iterator functions will complete in order.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err)` which must be called once it has \\n+  completed. If no error has occured, the `callback` should be run without \\n+  arguments or with an explicit `null` argument.\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\n+  have finished, or an error occurs.\\n+\\n+__Examples__\\n+\\n+\\n+```js\\n+// assuming openFiles is an array of file names and saveFile is a function\\n+// to save the modified contents of that file:\\n+\\n+async.each(openFiles, saveFile, function(err){\\n+    // if any of the saves produced an error, err would equal that error\\n+});\\n+```\\n+\\n+```js\\n+// assuming openFiles is an array of file names \\n+\\n+async.each(openFiles, function( file, callback) {\\n+  \\n+  // Perform operation on file here.\\n+  console.log('Processing file ' + file);\\n+  \\n+  if( file.length > 32 ) {\\n+    console.log('This file name is too long');\\n+    callback('File name too long');\\n+  } else {\\n+    // Do work to process file here\\n+    console.log('File processed');\\n+    callback();\\n+  }\\n+}, function(err){\\n+    // if any of the file processing produced an error, err would equal that error\\n+    if( err ) {\\n+      // One of the iterations produced an error.\\n+      // All processing will now stop.\\n+      console.log('A file failed to process');\\n+    } else {\\n+      console.log('All files have been processed successfully');\\n+    }\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"forEachSeries\\\" />\\n+<a name=\\\"eachSeries\\\" />\\n+### eachSeries(arr, iterator, callback)\\n+\\n+The same as [`each`](#each), only `iterator` is applied to each item in `arr` in\\n+series. The next `iterator` is only called once the current one has completed. \\n+This means the `iterator` functions will complete in order.\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"forEachLimit\\\" />\\n+<a name=\\\"eachLimit\\\" />\\n+### eachLimit(arr, limit, iterator, callback)\\n+\\n+The same as [`each`](#each), only no more than `limit` `iterator`s will be simultaneously \\n+running at any time.\\n+\\n+Note that the items in `arr` are not processed in batches, so there is no guarantee that \\n+the first `limit` `iterator` functions will complete before any others are started.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err)` which must be called once it has \\n+  completed. If no error has occured, the callback should be run without \\n+  arguments or with an explicit `null` argument.\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\n+  have finished, or an error occurs.\\n+\\n+__Example__\\n+\\n+```js\\n+// Assume documents is an array of JSON objects and requestApi is a\\n+// function that interacts with a rate-limited REST api.\\n+\\n+async.eachLimit(documents, 20, requestApi, function(err){\\n+    // if any of the saves produced an error, err would equal that error\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"map\\\" />\\n+### map(arr, iterator, callback)\\n+\\n+Produces a new array of values by mapping each value in `arr` through\\n+the `iterator` function. The `iterator` is called with an item from `arr` and a\\n+callback for when it has finished processing. Each of these callback takes 2 arguments: \\n+an `error`, and the transformed item from `arr`. If `iterator` passes an error to this \\n+callback, the main `callback` (for the `map` function) is immediately called with the error.\\n+\\n+Note, that since this function applies the `iterator` to each item in parallel,\\n+there is no guarantee that the `iterator` functions will complete in order. \\n+However, the results array will be in the same order as the original `arr`.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\n+  it has completed with an error (which can be `null`) and a transformed item.\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\n+  functions have finished, or an error occurs. Results is an array of the\\n+  transformed items from the `arr`.\\n+\\n+__Example__\\n+\\n+```js\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\n+    // results is now an array of stats for each file\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"mapSeries\\\" />\\n+### mapSeries(arr, iterator, callback)\\n+\\n+The same as [`map`](#map), only the `iterator` is applied to each item in `arr` in\\n+series. The next `iterator` is only called once the current one has completed. \\n+The results array will be in the same order as the original.\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"mapLimit\\\" />\\n+### mapLimit(arr, limit, iterator, callback)\\n+\\n+The same as [`map`](#map), only no more than `limit` `iterator`s will be simultaneously \\n+running at any time.\\n+\\n+Note that the items are not processed in batches, so there is no guarantee that \\n+the first `limit` `iterator` functions will complete before any others are started.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\n+  it has completed with an error (which can be `null`) and a transformed item.\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\n+  calls have finished, or an error occurs. The result is an array of the\\n+  transformed items from the original `arr`.\\n+\\n+__Example__\\n+\\n+```js\\n+async.mapLimit(['file1','file2','file3'], 1, fs.stat, function(err, results){\\n+    // results is now an array of stats for each file\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"select\\\" />\\n+<a name=\\\"filter\\\" />\\n+### filter(arr, iterator, callback)\\n+\\n+__Alias:__ `select`\\n+\\n+Returns a new array of all the values in `arr` which pass an async truth test.\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\n+way node libraries work with truth tests like `fs.exists`. This operation is\\n+performed in parallel, but the results array will be in the same order as the\\n+original.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\n+  The `iterator` is passed a `callback(truthValue)`, which must be called with a \\n+  boolean argument once it has completed.\\n+* `callback(results)` - A callback which is called after all the `iterator`\\n+  functions have finished.\\n+\\n+__Example__\\n+\\n+```js\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\n+    // results now equals an array of the existing files\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"selectSeries\\\" />\\n+<a name=\\\"filterSeries\\\" />\\n+### filterSeries(arr, iterator, callback)\\n+\\n+__Alias:__ `selectSeries`\\n+\\n+The same as [`filter`](#filter) only the `iterator` is applied to each item in `arr` in\\n+series. The next `iterator` is only called once the current one has completed. \\n+The results array will be in the same order as the original.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"reject\\\" />\\n+### reject(arr, iterator, callback)\\n+\\n+The opposite of [`filter`](#filter). Removes values that pass an `async` truth test.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"rejectSeries\\\" />\\n+### rejectSeries(arr, iterator, callback)\\n+\\n+The same as [`reject`](#reject), only the `iterator` is applied to each item in `arr`\\n+in series.\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"reduce\\\" />\\n+### reduce(arr, memo, iterator, callback)\\n+\\n+__Aliases:__ `inject`, `foldl`\\n+\\n+Reduces `arr` into a single value using an async `iterator` to return\\n+each successive step. `memo` is the initial state of the reduction. \\n+This function only operates in series. \\n+\\n+For performance reasons, it may make sense to split a call to this function into \\n+a parallel map, and then use the normal `Array.prototype.reduce` on the results. \\n+This function is for situations where each step in the reduction needs to be async; \\n+if you can get the data before reducing it, then it's probably a good idea to do so.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `memo` - The initial state of the reduction.\\n+* `iterator(memo, item, callback)` - A function applied to each item in the\\n+  array to produce the next step in the reduction. The `iterator` is passed a\\n+  `callback(err, reduction)` which accepts an optional error as its first \\n+  argument, and the state of the reduction as the second. If an error is \\n+  passed to the callback, the reduction is stopped and the main `callback` is \\n+  immediately called with the error.\\n+* `callback(err, result)` - A callback which is called after all the `iterator`\\n+  functions have finished. Result is the reduced value.\\n+\\n+__Example__\\n+\\n+```js\\n+async.reduce([1,2,3], 0, function(memo, item, callback){\\n+    // pointless async:\\n+    process.nextTick(function(){\\n+        callback(null, memo + item)\\n+    });\\n+}, function(err, result){\\n+    // result is now equal to the last value of memo, which is 6\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"reduceRight\\\" />\\n+### reduceRight(arr, memo, iterator, callback)\\n+\\n+__Alias:__ `foldr`\\n+\\n+Same as [`reduce`](#reduce), only operates on `arr` in reverse order.\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"detect\\\" />\\n+### detect(arr, iterator, callback)\\n+\\n+Returns the first value in `arr` that passes an async truth test. The\\n+`iterator` is applied in parallel, meaning the first iterator to return `true` will\\n+fire the detect `callback` with that result. That means the result might not be\\n+the first item in the original `arr` (in terms of order) that passes the test.\\n+\\n+If order within the original `arr` is important, then look at [`detectSeries`](#detectSeries).\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\n+  The iterator is passed a `callback(truthValue)` which must be called with a \\n+  boolean argument once it has completed.\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\n+  `true`, or after all the `iterator` functions have finished. Result will be\\n+  the first item in the array that passes the truth test (iterator) or the\\n+  value `undefined` if none passed.\\n+\\n+__Example__\\n+\\n+```js\\n+async.detect(['file1','file2','file3'], fs.exists, function(result){\\n+    // result now equals the first file in the list that exists\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"detectSeries\\\" />\\n+### detectSeries(arr, iterator, callback)\\n+\\n+The same as [`detect`](#detect), only the `iterator` is applied to each item in `arr`\\n+in series. This means the result is always the first in the original `arr` (in\\n+terms of array order) that passes the truth test.\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"sortBy\\\" />\\n+### sortBy(arr, iterator, callback)\\n+\\n+Sorts a list by the results of running each `arr` value through an async `iterator`.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err, sortValue)` which must be called once it\\n+  has completed with an error (which can be `null`) and a value to use as the sort\\n+  criteria.\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\n+  functions have finished, or an error occurs. Results is the items from\\n+  the original `arr` sorted by the values returned by the `iterator` calls.\\n+\\n+__Example__\\n+\\n+```js\\n+async.sortBy(['file1','file2','file3'], function(file, callback){\\n+    fs.stat(file, function(err, stats){\\n+        callback(err, stats.mtime);\\n+    });\\n+}, function(err, results){\\n+    // results is now the original array of files sorted by\\n+    // modified date\\n+});\\n+```\\n+\\n+__Sort Order__\\n+\\n+By modifying the callback parameter the sorting order can be influenced:\\n+\\n+```js\\n+//ascending order\\n+async.sortBy([1,9,3,5], function(x, callback){\\n+    callback(err, x);\\n+}, function(err,result){\\n+    //result callback\\n+} );\\n+\\n+//descending order\\n+async.sortBy([1,9,3,5], function(x, callback){\\n+    callback(err, x*-1);    //<- x*-1 instead of x, turns the order around\\n+}, function(err,result){\\n+    //result callback\\n+} );\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"some\\\" />\\n+### some(arr, iterator, callback)\\n+\\n+__Alias:__ `any`\\n+\\n+Returns `true` if at least one element in the `arr` satisfies an async test.\\n+_The callback for each iterator call only accepts a single argument of `true` or\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\n+way node libraries work with truth tests like `fs.exists`. Once any iterator\\n+call returns `true`, the main `callback` is immediately called.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\n+  called with a boolean argument once it has completed.\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\n+  `true`, or after all the iterator functions have finished. Result will be\\n+  either `true` or `false` depending on the values of the async tests.\\n+\\n+__Example__\\n+\\n+```js\\n+async.some(['file1','file2','file3'], fs.exists, function(result){\\n+    // if result is true then at least one of the files exists\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"every\\\" />\\n+### every(arr, iterator, callback)\\n+\\n+__Alias:__ `all`\\n+\\n+Returns `true` if every element in `arr` satisfies an async test.\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\n+way node libraries work with truth tests like `fs.exists`.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\n+  called with a  boolean argument once it has completed.\\n+* `callback(result)` - A callback which is called after all the `iterator`\\n+  functions have finished. Result will be either `true` or `false` depending on\\n+  the values of the async tests.\\n+\\n+__Example__\\n+\\n+```js\\n+async.every(['file1','file2','file3'], fs.exists, function(result){\\n+    // if result is true then every file exists\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"concat\\\" />\\n+### concat(arr, iterator, callback)\\n+\\n+Applies `iterator` to each item in `arr`, concatenating the results. Returns the\\n+concatenated list. The `iterator`s are called in parallel, and the results are\\n+concatenated as they return. There is no guarantee that the results array will\\n+be returned in the original order of `arr` passed to the `iterator` function.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err, results)` which must be called once it \\n+  has completed with an error (which can be `null`) and an array of results.\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\n+  functions have finished, or an error occurs. Results is an array containing\\n+  the concatenated results of the `iterator` function.\\n+\\n+__Example__\\n+\\n+```js\\n+async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files){\\n+    // files is now a list of filenames that exist in the 3 directories\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"concatSeries\\\" />\\n+### concatSeries(arr, iterator, callback)\\n+\\n+Same as [`concat`](#concat), but executes in series instead of parallel.\\n+\\n+\\n+## Control Flow\\n+\\n+<a name=\\\"series\\\" />\\n+### series(tasks, [callback])\\n+\\n+Run the functions in the `tasks` array in series, each one running once the previous\\n+function has completed. If any functions in the series pass an error to its\\n+callback, no more functions are run, and `callback` is immediately called with the value of the error. \\n+Otherwise, `callback` receives an array of results when `tasks` have completed.\\n+\\n+It is also possible to use an object instead of an array. Each property will be\\n+run as a function, and the results will be passed to the final `callback` as an object\\n+instead of an array. This can be a more readable way of handling results from\\n+[`series`](#series).\\n+\\n+**Note** that while many implementations preserve the order of object properties, the\\n+[ECMAScript Language Specifcation](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6) \\n+explicitly states that\\n+\\n+> The mechanics and order of enumerating the properties is not specified.\\n+\\n+So if you rely on the order in which your series of functions are executed, and want\\n+this to work on all platforms, consider using an array. \\n+\\n+__Arguments__\\n+\\n+* `tasks` - An array or object containing functions to run, each function is passed\\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\n+  be `null`) and an optional `result` value.\\n+* `callback(err, results)` - An optional callback to run once all the functions\\n+  have completed. This function gets a results array (or object) containing all \\n+  the result arguments passed to the `task` callbacks.\\n+\\n+__Example__\\n+\\n+```js\\n+async.series([\\n+    function(callback){\\n+        // do some stuff ...\\n+        callback(null, 'one');\\n+    },\\n+    function(callback){\\n+        // do some more stuff ...\\n+        callback(null, 'two');\\n+    }\\n+],\\n+// optional callback\\n+function(err, results){\\n+    // results is now equal to ['one', 'two']\\n+});\\n+\\n+\\n+// an example using an object instead of an array\\n+async.series({\\n+    one: function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 1);\\n+        }, 200);\\n+    },\\n+    two: function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 2);\\n+        }, 100);\\n+    }\\n+},\\n+function(err, results) {\\n+    // results is now equal to: {one: 1, two: 2}\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"parallel\\\" />\\n+### parallel(tasks, [callback])\\n+\\n+Run the `tasks` array of functions in parallel, without waiting until the previous\\n+function has completed. If any of the functions pass an error to its\\n+callback, the main `callback` is immediately called with the value of the error.\\n+Once the `tasks` have completed, the results are passed to the final `callback` as an\\n+array.\\n+\\n+It is also possible to use an object instead of an array. Each property will be\\n+run as a function and the results will be passed to the final `callback` as an object\\n+instead of an array. This can be a more readable way of handling results from\\n+[`parallel`](#parallel).\\n+\\n+\\n+__Arguments__\\n+\\n+* `tasks` - An array or object containing functions to run. Each function is passed \\n+  a `callback(err, result)` which it must call on completion with an error `err` \\n+  (which can be `null`) and an optional `result` value.\\n+* `callback(err, results)` - An optional callback to run once all the functions\\n+  have completed. This function gets a results array (or object) containing all \\n+  the result arguments passed to the task callbacks.\\n+\\n+__Example__\\n+\\n+```js\\n+async.parallel([\\n+    function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 'one');\\n+        }, 200);\\n+    },\\n+    function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 'two');\\n+        }, 100);\\n+    }\\n+],\\n+// optional callback\\n+function(err, results){\\n+    // the results array will equal ['one','two'] even though\\n+    // the second function had a shorter timeout.\\n+});\\n+\\n+\\n+// an example using an object instead of an array\\n+async.parallel({\\n+    one: function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 1);\\n+        }, 200);\\n+    },\\n+    two: function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 2);\\n+        }, 100);\\n+    }\\n+},\\n+function(err, results) {\\n+    // results is now equals to: {one: 1, two: 2}\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"parallelLimit\\\" />\\n+### parallelLimit(tasks, limit, [callback])\\n+\\n+The same as [`parallel`](#parallel), only `tasks` are executed in parallel \\n+with a maximum of `limit` tasks executing at any time.\\n+\\n+Note that the `tasks` are not executed in batches, so there is no guarantee that \\n+the first `limit` tasks will complete before any others are started.\\n+\\n+__Arguments__\\n+\\n+* `tasks` - An array or object containing functions to run, each function is passed \\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\n+  be `null`) and an optional `result` value.\\n+* `limit` - The maximum number of `tasks` to run at any time.\\n+* `callback(err, results)` - An optional callback to run once all the functions\\n+  have completed. This function gets a results array (or object) containing all \\n+  the result arguments passed to the `task` callbacks.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"whilst\\\" />\\n+### whilst(test, fn, callback)\\n+\\n+Repeatedly call `fn`, while `test` returns `true`. Calls `callback` when stopped,\\n+or an error occurs.\\n+\\n+__Arguments__\\n+\\n+* `test()` - synchronous truth test to perform before each execution of `fn`.\\n+* `fn(callback)` - A function which is called each time `test` passes. The function is\\n+  passed a `callback(err)`, which must be called once it has completed with an \\n+  optional `err` argument.\\n+* `callback(err)` - A callback which is called after the test fails and repeated\\n+  execution of `fn` has stopped.\\n+\\n+__Example__\\n+\\n+```js\\n+var count = 0;\\n+\\n+async.whilst(\\n+    function () { return count < 5; },\\n+    function (callback) {\\n+        count++;\\n+        setTimeout(callback, 1000);\\n+    },\\n+    function (err) {\\n+        // 5 seconds have passed\\n+    }\\n+);\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"doWhilst\\\" />\\n+### doWhilst(fn, test, callback)\\n+\\n+The post-check version of [`whilst`](#whilst). To reflect the difference in \\n+the order of operations, the arguments `test` and `fn` are switched. \\n+\\n+`doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"until\\\" />\\n+### until(test, fn, callback)\\n+\\n+Repeatedly call `fn` until `test` returns `true`. Calls `callback` when stopped,\\n+or an error occurs.\\n+\\n+The inverse of [`whilst`](#whilst).\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"doUntil\\\" />\\n+### doUntil(fn, test, callback)\\n+\\n+Like [`doWhilst`](#doWhilst), except the `test` is inverted. Note the argument ordering differs from `until`.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"forever\\\" />\\n+### forever(fn, errback)\\n+\\n+Calls the asynchronous function `fn` with a callback parameter that allows it to\\n+call itself again, in series, indefinitely.\\n+\\n+If an error is passed to the callback then `errback` is called with the\\n+error, and execution stops, otherwise it will never be called.\\n+\\n+```js\\n+async.forever(\\n+    function(next) {\\n+        // next is suitable for passing to things that need a callback(err [, whatever]);\\n+        // it will result in this function being called again.\\n+    },\\n+    function(err) {\\n+        // if next is called with a value in its first parameter, it will appear\\n+        // in here as 'err', and execution will stop.\\n+    }\\n+);\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"waterfall\\\" />\\n+### waterfall(tasks, [callback])\\n+\\n+Runs the `tasks` array of functions in series, each passing their results to the next in\\n+the array. However, if any of the `tasks` pass an error to their own callback, the\\n+next function is not executed, and the main `callback` is immediately called with\\n+the error.\\n+\\n+__Arguments__\\n+\\n+* `tasks` - An array of functions to run, each function is passed a \\n+  `callback(err, result1, result2, ...)` it must call on completion. The first\\n+  argument is an error (which can be `null`) and any further arguments will be \\n+  passed as arguments in order to the next task.\\n+* `callback(err, [results])` - An optional callback to run once all the functions\\n+  have completed. This will be passed the results of the last task's callback.\\n+\\n+\\n+\\n+__Example__\\n+\\n+```js\\n+async.waterfall([\\n+    function(callback){\\n+        callback(null, 'one', 'two');\\n+    },\\n+    function(arg1, arg2, callback){\\n+      // arg1 now equals 'one' and arg2 now equals 'two'\\n+        callback(null, 'three');\\n+    },\\n+    function(arg1, callback){\\n+        // arg1 now equals 'three'\\n+        callback(null, 'done');\\n+    }\\n+], function (err, result) {\\n+   // result now equals 'done'    \\n+});\\n+```\\n+\\n+---------------------------------------\\n+<a name=\\\"compose\\\" />\\n+### compose(fn1, fn2...)\\n+\\n+Creates a function which is a composition of the passed asynchronous\\n+functions. Each function consumes the return value of the function that\\n+follows. Composing functions `f()`, `g()`, and `h()` would produce the result of\\n+`f(g(h()))`, only this version uses callbacks to obtain the return values.\\n+\\n+Each function is executed with the `this` binding of the composed function.\\n+\\n+__Arguments__\\n+\\n+* `functions...` - the asynchronous functions to compose\\n+\\n+\\n+__Example__\\n+\\n+```js\\n+function add1(n, callback) {\\n+    setTimeout(function () {\\n+        callback(null, n + 1);\\n+    }, 10);\\n+}\\n+\\n+function mul3(n, callback) {\\n+    setTimeout(function () {\\n+        callback(null, n * 3);\\n+    }, 10);\\n+}\\n+\\n+var add1mul3 = async.compose(mul3, add1);\\n+\\n+add1mul3(4, function (err, result) {\\n+   // result now equals 15\\n+});\\n+```\\n+\\n+---------------------------------------\\n+<a name=\\\"seq\\\" />\\n+### seq(fn1, fn2...)\\n+\\n+Version of the compose function that is more natural to read.\\n+Each following function consumes the return value of the latter function. \\n+\\n+Each function is executed with the `this` binding of the composed function.\\n+\\n+__Arguments__\\n+\\n+* functions... - the asynchronous functions to compose\\n+\\n+\\n+__Example__\\n+\\n+```js\\n+// Requires lodash (or underscore), express3 and dresende's orm2.\\n+// Part of an app, that fetches cats of the logged user.\\n+// This example uses `seq` function to avoid overnesting and error \\n+// handling clutter.\\n+app.get('/cats', function(request, response) {\\n+  function handleError(err, data, callback) {\\n+    if (err) {\\n+      console.error(err);\\n+      response.json({ status: 'error', message: err.message });\\n+    }\\n+    else {\\n+      callback(data);\\n+    }\\n+  }\\n+  var User = request.models.User;\\n+  async.seq(\\n+    _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\\n+    handleError,\\n+    function(user, fn) {\\n+      user.getCats(fn);      // 'getCats' has signature (callback(err, data))\\n+    },\\n+    handleError,\\n+    function(cats) {\\n+      response.json({ status: 'ok', message: 'Cats found', data: cats });\\n+    }\\n+  )(req.session.user_id);\\n+  }\\n+});\\n+```\\n+\\n+---------------------------------------\\n+<a name=\\\"applyEach\\\" />\\n+### applyEach(fns, args..., callback)\\n+\\n+Applies the provided arguments to each function in the array, calling \\n+`callback` after all functions have completed. If you only provide the first\\n+argument, then it will return a function which lets you pass in the\\n+arguments as if it were a single function call.\\n+\\n+__Arguments__\\n+\\n+* `fns` - the asynchronous functions to all call with the same arguments\\n+* `args...` - any number of separate arguments to pass to the function\\n+* `callback` - the final argument should be the callback, called when all\\n+  functions have completed processing\\n+\\n+\\n+__Example__\\n+\\n+```js\\n+async.applyEach([enableSearch, updateSchema], 'bucket', callback);\\n+\\n+// partial application example:\\n+async.each(\\n+    buckets,\\n+    async.applyEach([enableSearch, updateSchema]),\\n+    callback\\n+);\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"applyEachSeries\\\" />\\n+### applyEachSeries(arr, iterator, callback)\\n+\\n+The same as [`applyEach`](#applyEach) only the functions are applied in series.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"queue\\\" />\\n+### queue(worker, concurrency)\\n+\\n+Creates a `queue` object with the specified `concurrency`. Tasks added to the\\n+`queue` are processed in parallel (up to the `concurrency` limit). If all\\n+`worker`s are in progress, the task is queued until one becomes available. \\n+Once a `worker` completes a `task`, that `task`'s callback is called.\\n+\\n+__Arguments__\\n+\\n+* `worker(task, callback)` - An asynchronous function for processing a queued\\n+  task, which must call its `callback(err)` argument when finished, with an \\n+  optional `error` as an argument.\\n+* `concurrency` - An `integer` for determining how many `worker` functions should be\\n+  run in parallel.\\n+\\n+__Queue objects__\\n+\\n+The `queue` object returned by this function has the following properties and\\n+methods:\\n+\\n+* `length()` - a function returning the number of items waiting to be processed.\\n+* `started` - a function returning whether or not any items have been pushed and processed by the queue\\n+* `running()` - a function returning the number of items currently being processed.\\n+* `idle()` - a function returning false if there are items waiting or being processed, or true if not.\\n+* `concurrency` - an integer for determining how many `worker` functions should be\\n+  run in parallel. This property can be changed after a `queue` is created to\\n+  alter the concurrency on-the-fly.\\n+* `push(task, [callback])` - add a new task to the `queue`. Calls `callback` once \\n+  the `worker` has finished processing the task. Instead of a single task, a `tasks` array\\n+  can be submitted. The respective callback is used for every task in the list.\\n+* `unshift(task, [callback])` - add a new task to the front of the `queue`.\\n+* `saturated` - a callback that is called when the `queue` length hits the `concurrency` limit, \\n+   and further tasks will be queued.\\n+* `empty` - a callback that is called when the last item from the `queue` is given to a `worker`.\\n+* `drain` - a callback that is called when the last item from the `queue` has returned from the `worker`.\\n+* `paused` - a boolean for determining whether the queue is in a paused state\\n+* `pause()` - a function that pauses the processing of tasks until `resume()` is called.\\n+* `resume()` - a function that resumes the processing of queued tasks when the queue is paused.\\n+* `kill()` - a function that empties remaining tasks from the queue forcing it to go idle.\\n+\\n+__Example__\\n+\\n+```js\\n+// create a queue object with concurrency 2\\n+\\n+var q = async.queue(function (task, callback) {\\n+    console.log('hello ' + task.name);\\n+    callback();\\n+}, 2);\\n+\\n+\\n+// assign a callback\\n+q.drain = function() {\\n+    console.log('all items have been processed');\\n+}\\n+\\n+// add some items to the queue\\n+\\n+q.push({name: 'foo'}, function (err) {\\n+    console.log('finished processing foo');\\n+});\\n+q.push({name: 'bar'}, function (err) {\\n+    console.log('finished processing bar');\\n+});\\n+\\n+// add some items to the queue (batch-wise)\\n+\\n+q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function (err) {\\n+    console.log('finished processing bar');\\n+});\\n+\\n+// add some items to the front of the queue\\n+\\n+q.unshift({name: 'bar'}, function (err) {\\n+    console.log('finished processing bar');\\n+});\\n+```\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"priorityQueue\\\" />\\n+### priorityQueue(worker, concurrency)\\n+\\n+The same as [`queue`](#queue) only tasks are assigned a priority and completed in ascending priority order. There are two differences between `queue` and `priorityQueue` objects:\\n+\\n+* `push(task, priority, [callback])` - `priority` should be a number. If an array of\\n+  `tasks` is given, all tasks will be assigned the same priority.\\n+* The `unshift` method was removed.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"cargo\\\" />\\n+### cargo(worker, [payload])\\n+\\n+Creates a `cargo` object with the specified payload. Tasks added to the\\n+cargo will be processed altogether (up to the `payload` limit). If the\\n+`worker` is in progress, the task is queued until it becomes available. Once\\n+the `worker` has completed some tasks, each callback of those tasks is called.\\n+Check out [this animation](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) for how `cargo` and `queue` work.\\n+\\n+While [queue](#queue) passes only one task to one of a group of workers\\n+at a time, cargo passes an array of tasks to a single worker, repeating\\n+when the worker is finished.\\n+\\n+__Arguments__\\n+\\n+* `worker(tasks, callback)` - An asynchronous function for processing an array of\\n+  queued tasks, which must call its `callback(err)` argument when finished, with \\n+  an optional `err` argument.\\n+* `payload` - An optional `integer` for determining how many tasks should be\\n+  processed per round; if omitted, the default is unlimited.\\n+\\n+__Cargo objects__\\n+\\n+The `cargo` object returned by this function has the following properties and\\n+methods:\\n+\\n+* `length()` - A function returning the number of items waiting to be processed.\\n+* `payload` - An `integer` for determining how many tasks should be\\n+  process per round. This property can be changed after a `cargo` is created to\\n+  alter the payload on-the-fly.\\n+* `push(task, [callback])` - Adds `task` to the `queue`. The callback is called\\n+  once the `worker` has finished processing the task. Instead of a single task, an array of `tasks` \\n+  can be submitted. The respective callback is used for every task in the list.\\n+* `saturated` - A callback that is called when the `queue.length()` hits the concurrency and further tasks will be queued.\\n+* `empty` - A callback that is called when the last item from the `queue` is given to a `worker`.\\n+* `drain` - A callback that is called when the last item from the `queue` has returned from the `worker`.\\n+\\n+__Example__\\n+\\n+```js\\n+// create a cargo object with payload 2\\n+\\n+var cargo = async.cargo(function (tasks, callback) {\\n+    for(var i=0; i<tasks.length; i++){\\n+      console.log('hello ' + tasks[i].name);\\n+    }\\n+    callback();\\n+}, 2);\\n+\\n+\\n+// add some items\\n+\\n+cargo.push({name: 'foo'}, function (err) {\\n+    console.log('finished processing foo');\\n+});\\n+cargo.push({name: 'bar'}, function (err) {\\n+    console.log('finished processing bar');\\n+});\\n+cargo.push({name: 'baz'}, function (err) {\\n+    console.log('finished processing baz');\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"auto\\\" />\\n+### auto(tasks, [callback])\\n+\\n+Determines the best order for running the functions in `tasks`, based on their \\n+requirements. Each function can optionally depend on other functions being completed \\n+first, and each function is run as soon as its requirements are satisfied. \\n+\\n+If any of the functions pass an error to their callback, it will not \\n+complete (so any other functions depending on it will not run), and the main \\n+`callback` is immediately called with the error. Functions also receive an \\n+object containing the results of functions which have completed so far.\\n+\\n+Note, all functions are called with a `results` object as a second argument, \\n+so it is unsafe to pass functions in the `tasks` object which cannot handle the\\n+extra argument. \\n+\\n+For example, this snippet of code:\\n+\\n+```js\\n+async.auto({\\n+  readData: async.apply(fs.readFile, 'data.txt', 'utf-8')\\n+}, callback);\\n+```\\n+\\n+will have the effect of calling `readFile` with the results object as the last\\n+argument, which will fail:\\n+\\n+```js\\n+fs.readFile('data.txt', 'utf-8', cb, {});\\n+```\\n+\\n+Instead, wrap the call to `readFile` in a function which does not forward the \\n+`results` object:\\n+\\n+```js\\n+async.auto({\\n+  readData: function(cb, results){\\n+    fs.readFile('data.txt', 'utf-8', cb);\\n+  }\\n+}, callback);\\n+```\\n+\\n+__Arguments__\\n+\\n+* `tasks` - An object. Each of its properties is either a function or an array of\\n+  requirements, with the function itself the last item in the array. The object's key\\n+  of a property serves as the name of the task defined by that property,\\n+  i.e. can be used when specifying requirements for other tasks.\\n+  The function receives two arguments: (1) a `callback(err, result)` which must be \\n+  called when finished, passing an `error` (which can be `null`) and the result of \\n+  the function's execution, and (2) a `results` object, containing the results of\\n+  the previously executed functions.\\n+* `callback(err, results)` - An optional callback which is called when all the\\n+  tasks have been completed. It receives the `err` argument if any `tasks` \\n+  pass an error to their callback. Results are always returned; however, if \\n+  an error occurs, no further `tasks` will be performed, and the results\\n+  object will only contain partial results.\\n+\\n+\\n+__Example__\\n+\\n+```js\\n+async.auto({\\n+    get_data: function(callback){\\n+        console.log('in get_data');\\n+        // async code to get some data\\n+        callback(null, 'data', 'converted to array');\\n+    },\\n+    make_folder: function(callback){\\n+        console.log('in make_folder');\\n+        // async code to create a directory to store a file in\\n+        // this is run at the same time as getting the data\\n+        callback(null, 'folder');\\n+    },\\n+    write_file: ['get_data', 'make_folder', function(callback, results){\\n+        console.log('in write_file', JSON.stringify(results));\\n+        // once there is some data and the directory exists,\\n+        // write the data to a file in the directory\\n+        callback(null, 'filename');\\n+    }],\\n+    email_link: ['write_file', function(callback, results){\\n+        console.log('in email_link', JSON.stringify(results));\\n+        // once the file is written let's email a link to it...\\n+        // results.write_file contains the filename returned by write_file.\\n+        callback(null, {'file':results.write_file, 'email':'user@example.com'});\\n+    }]\\n+}, function(err, results) {\\n+    console.log('err = ', err);\\n+    console.log('results = ', results);\\n+});\\n+```\\n+\\n+This is a fairly trivial example, but to do this using the basic parallel and\\n+series functions would look like this:\\n+\\n+```js\\n+async.parallel([\\n+    function(callback){\\n+        console.log('in get_data');\\n+        // async code to get some data\\n+        callback(null, 'data', 'converted to array');\\n+    },\\n+    function(callback){\\n+        console.log('in make_folder');\\n+        // async code to create a directory to store a file in\\n+        // this is run at the same time as getting the data\\n+        callback(null, 'folder');\\n+    }\\n+],\\n+function(err, results){\\n+    async.series([\\n+        function(callback){\\n+            console.log('in write_file', JSON.stringify(results));\\n+            // once there is some data and the directory exists,\\n+            // write the data to a file in the directory\\n+            results.push('filename');\\n+            callback(null);\\n+        },\\n+        function(callback){\\n+            console.log('in email_link', JSON.stringify(results));\\n+            // once the file is written let's email a link to it...\\n+            callback(null, {'file':results.pop(), 'email':'user@example.com'});\\n+        }\\n+    ]);\\n+});\\n+```\\n+\\n+For a complicated series of `async` tasks, using the [`auto`](#auto) function makes adding\\n+new tasks much easier (and the code more readable).\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"retry\\\" />\\n+### retry([times = 5], task, [callback])\\n+\\n+Attempts to get a successful response from `task` no more than `times` times before\\n+returning an error. If the task is successful, the `callback` will be passed the result\\n+of the successfull task. If all attemps fail, the callback will be passed the error and\\n+result (if any) of the final attempt.\\n+\\n+__Arguments__\\n+\\n+* `times` - An integer indicating how many times to attempt the `task` before giving up. Defaults to 5.\\n+* `task(callback, results)` - A function which receives two arguments: (1) a `callback(err, result)`\\n+  which must be called when finished, passing `err` (which can be `null`) and the `result` of \\n+  the function's execution, and (2) a `results` object, containing the results of\\n+  the previously executed functions (if nested inside another control flow).\\n+* `callback(err, results)` - An optional callback which is called when the\\n+  task has succeeded, or after the final failed attempt. It receives the `err` and `result` arguments of the last attempt at completing the `task`.\\n+\\n+The [`retry`](#retry) function can be used as a stand-alone control flow by passing a\\n+callback, as shown below:\\n+\\n+```js\\n+async.retry(3, apiMethod, function(err, result) {\\n+    // do something with the result\\n+});\\n+```\\n+\\n+It can also be embeded within other control flow functions to retry individual methods\\n+that are not as reliable, like this:\\n+\\n+```js\\n+async.auto({\\n+    users: api.getUsers.bind(api),\\n+    payments: async.retry(3, api.getPayments.bind(api))\\n+}, function(err, results) {\\n+  // do something with the results\\n+});\\n+```\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"iterator\\\" />\\n+### iterator(tasks)\\n+\\n+Creates an iterator function which calls the next function in the `tasks` array,\\n+returning a continuation to call the next one after that. It's also possible to\\n+“peek” at the next iterator with `iterator.next()`.\\n+\\n+This function is used internally by the `async` module, but can be useful when\\n+you want to manually control the flow of functions in series.\\n+\\n+__Arguments__\\n+\\n+* `tasks` - An array of functions to run.\\n+\\n+__Example__\\n+\\n+```js\\n+var iterator = async.iterator([\\n+    function(){ sys.p('one'); },\\n+    function(){ sys.p('two'); },\\n+    function(){ sys.p('three'); }\\n+]);\\n+\\n+node> var iterator2 = iterator();\\n+'one'\\n+node> var iterator3 = iterator2();\\n+'two'\\n+node> iterator3();\\n+'three'\\n+node> var nextfn = iterator2.next();\\n+node> nextfn();\\n+'three'\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"apply\\\" />\\n+### apply(function, arguments..)\\n+\\n+Creates a continuation function with some arguments already applied. \\n+\\n+Useful as a shorthand when combined with other control flow functions. Any arguments\\n+passed to the returned function are added to the arguments originally passed\\n+to apply.\\n+\\n+__Arguments__\\n+\\n+* `function` - The function you want to eventually apply all arguments to.\\n+* `arguments...` - Any number of arguments to automatically apply when the\\n+  continuation is called.\\n+\\n+__Example__\\n+\\n+```js\\n+// using apply\\n+\\n+async.parallel([\\n+    async.apply(fs.writeFile, 'testfile1', 'test1'),\\n+    async.apply(fs.writeFile, 'testfile2', 'test2'),\\n+]);\\n+\\n+\\n+// the same process without using apply\\n+\\n+async.parallel([\\n+    function(callback){\\n+        fs.writeFile('testfile1', 'test1', callback);\\n+    },\\n+    function(callback){\\n+        fs.writeFile('testfile2', 'test2', callback);\\n+    }\\n+]);\\n+```\\n+\\n+It's possible to pass any number of additional arguments when calling the\\n+continuation:\\n+\\n+```js\\n+node> var fn = async.apply(sys.puts, 'one');\\n+node> fn('two', 'three');\\n+one\\n+two\\n+three\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"nextTick\\\" />\\n+### nextTick(callback)\\n+\\n+Calls `callback` on a later loop around the event loop. In Node.js this just\\n+calls `process.nextTick`; in the browser it falls back to `setImmediate(callback)`\\n+if available, otherwise `setTimeout(callback, 0)`, which means other higher priority\\n+events may precede the execution of `callback`.\\n+\\n+This is used internally for browser-compatibility purposes.\\n+\\n+__Arguments__\\n+\\n+* `callback` - The function to call on a later loop around the event loop.\\n+\\n+__Example__\\n+\\n+```js\\n+var call_order = [];\\n+async.nextTick(function(){\\n+    call_order.push('two');\\n+    // call_order now equals ['one','two']\\n+});\\n+call_order.push('one')\\n+```\\n+\\n+<a name=\\\"times\\\" />\\n+### times(n, callback)\\n+\\n+Calls the `callback` function `n` times, and accumulates results in the same manner\\n+you would use with [`map`](#map).\\n+\\n+__Arguments__\\n+\\n+* `n` - The number of times to run the function.\\n+* `callback` - The function to call `n` times.\\n+\\n+__Example__\\n+\\n+```js\\n+// Pretend this is some complicated async factory\\n+var createUser = function(id, callback) {\\n+  callback(null, {\\n+    id: 'user' + id\\n+  })\\n+}\\n+// generate 5 users\\n+async.times(5, function(n, next){\\n+    createUser(n, function(err, user) {\\n+      next(err, user)\\n+    })\\n+}, function(err, users) {\\n+  // we should now have 5 users\\n+});\\n+```\\n+\\n+<a name=\\\"timesSeries\\\" />\\n+### timesSeries(n, callback)\\n+\\n+The same as [`times`](#times), only the iterator is applied to each item in `arr` in\\n+series. The next `iterator` is only called once the current one has completed. \\n+The results array will be in the same order as the original.\\n+\\n+\\n+## Utils\\n+\\n+<a name=\\\"memoize\\\" />\\n+### memoize(fn, [hasher])\\n+\\n+Caches the results of an `async` function. When creating a hash to store function\\n+results against, the callback is omitted from the hash and an optional hash\\n+function can be used.\\n+\\n+The cache of results is exposed as the `memo` property of the function returned\\n+by `memoize`.\\n+\\n+__Arguments__\\n+\\n+* `fn` - The function to proxy and cache results from.\\n+* `hasher` - Tn optional function for generating a custom hash for storing\\n+  results. It has all the arguments applied to it apart from the callback, and\\n+  must be synchronous.\\n+\\n+__Example__\\n+\\n+```js\\n+var slow_fn = function (name, callback) {\\n+    // do something\\n+    callback(null, result);\\n+};\\n+var fn = async.memoize(slow_fn);\\n+\\n+// fn can now be used as if it were slow_fn\\n+fn('some name', function () {\\n+    // callback\\n+});\\n+```\\n+\\n+<a name=\\\"unmemoize\\\" />\\n+### unmemoize(fn)\\n+\\n+Undoes a [`memoize`](#memoize)d function, reverting it to the original, unmemoized\\n+form. Handy for testing.\\n+\\n+__Arguments__\\n+\\n+* `fn` - the memoized function\\n+\\n+<a name=\\\"log\\\" />\\n+### log(function, arguments)\\n+\\n+Logs the result of an `async` function to the `console`. Only works in Node.js or\\n+in browsers that support `console.log` and `console.error` (such as FF and Chrome).\\n+If multiple arguments are returned from the async function, `console.log` is\\n+called on each argument in order.\\n+\\n+__Arguments__\\n+\\n+* `function` - The function you want to eventually apply all arguments to.\\n+* `arguments...` - Any number of arguments to apply to the function.\\n+\\n+__Example__\\n+\\n+```js\\n+var hello = function(name, callback){\\n+    setTimeout(function(){\\n+        callback(null, 'hello ' + name);\\n+    }, 1000);\\n+};\\n+```\\n+```js\\n+node> async.log(hello, 'world');\\n+'hello world'\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"dir\\\" />\\n+### dir(function, arguments)\\n+\\n+Logs the result of an `async` function to the `console` using `console.dir` to\\n+display the properties of the resulting object. Only works in Node.js or\\n+in browsers that support `console.dir` and `console.error` (such as FF and Chrome).\\n+If multiple arguments are returned from the async function, `console.dir` is\\n+called on each argument in order.\\n+\\n+__Arguments__\\n+\\n+* `function` - The function you want to eventually apply all arguments to.\\n+* `arguments...` - Any number of arguments to apply to the function.\\n+\\n+__Example__\\n+\\n+```js\\n+var hello = function(name, callback){\\n+    setTimeout(function(){\\n+        callback(null, {hello: name});\\n+    }, 1000);\\n+};\\n+```\\n+```js\\n+node> async.dir(hello, 'world');\\n+{hello: 'world'}\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"noConflict\\\" />\\n+### noConflict()\\n+\\n+Changes the value of `async` back to its original value, returning a reference to the\\n+`async` object.\\ndiff --git a/node_modules/async/component.json b/node_modules/async/component.json\\nnew file mode 100644\\nindex 0000000..bbb0115\\n--- /dev/null\\n+++ b/node_modules/async/component.json\\n@@ -0,0 +1,11 @@\\n+{\\n+  \\\"name\\\": \\\"async\\\",\\n+  \\\"repo\\\": \\\"caolan/async\\\",\\n+  \\\"description\\\": \\\"Higher-order functions and common patterns for asynchronous code\\\",\\n+  \\\"version\\\": \\\"0.1.23\\\",\\n+  \\\"keywords\\\": [],\\n+  \\\"dependencies\\\": {},\\n+  \\\"development\\\": {},\\n+  \\\"main\\\": \\\"lib/async.js\\\",\\n+  \\\"scripts\\\": [ \\\"lib/async.js\\\" ]\\n+}\\ndiff --git a/node_modules/async/lib/async.js b/node_modules/async/lib/async.js\\nnew file mode 100644\\nindex 0000000..01e8afc\\n--- /dev/null\\n+++ b/node_modules/async/lib/async.js\\n@@ -0,0 +1,1123 @@\\n+/*!\\n+ * async\\n+ * https://github.com/caolan/async\\n+ *\\n+ * Copyright 2010-2014 Caolan McMahon\\n+ * Released under the MIT license\\n+ */\\n+/*jshint onevar: false, indent:4 */\\n+/*global setImmediate: false, setTimeout: false, console: false */\\n+(function () {\\n+\\n+    var async = {};\\n+\\n+    // global on the server, window in the browser\\n+    var root, previous_async;\\n+\\n+    root = this;\\n+    if (root != null) {\\n+      previous_async = root.async;\\n+    }\\n+\\n+    async.noConflict = function () {\\n+        root.async = previous_async;\\n+        return async;\\n+    };\\n+\\n+    function only_once(fn) {\\n+        var called = false;\\n+        return function() {\\n+            if (called) throw new Error(\\\"Callback was already called.\\\");\\n+            called = true;\\n+            fn.apply(root, arguments);\\n+        }\\n+    }\\n+\\n+    //// cross-browser compatiblity functions ////\\n+\\n+    var _toString = Object.prototype.toString;\\n+\\n+    var _isArray = Array.isArray || function (obj) {\\n+        return _toString.call(obj) === '[object Array]';\\n+    };\\n+\\n+    var _each = function (arr, iterator) {\\n+        if (arr.forEach) {\\n+            return arr.forEach(iterator);\\n+        }\\n+        for (var i = 0; i < arr.length; i += 1) {\\n+            iterator(arr[i], i, arr);\\n+        }\\n+    };\\n+\\n+    var _map = function (arr, iterator) {\\n+        if (arr.map) {\\n+            return arr.map(iterator);\\n+        }\\n+        var results = [];\\n+        _each(arr, function (x, i, a) {\\n+            results.push(iterator(x, i, a));\\n+        });\\n+        return results;\\n+    };\\n+\\n+    var _reduce = function (arr, iterator, memo) {\\n+        if (arr.reduce) {\\n+            return arr.reduce(iterator, memo);\\n+        }\\n+        _each(arr, function (x, i, a) {\\n+            memo = iterator(memo, x, i, a);\\n+        });\\n+        return memo;\\n+    };\\n+\\n+    var _keys = function (obj) {\\n+        if (Object.keys) {\\n+            return Object.keys(obj);\\n+        }\\n+        var keys = [];\\n+        for (var k in obj) {\\n+            if (obj.hasOwnProperty(k)) {\\n+                keys.push(k);\\n+            }\\n+        }\\n+        return keys;\\n+    };\\n+\\n+    //// exported async module functions ////\\n+\\n+    //// nextTick implementation with browser-compatible fallback ////\\n+    if (typeof process === 'undefined' || !(process.nextTick)) {\\n+        if (typeof setImmediate === 'function') {\\n+            async.nextTick = function (fn) {\\n+                // not a direct alias for IE10 compatibility\\n+                setImmediate(fn);\\n+            };\\n+            async.setImmediate = async.nextTick;\\n+        }\\n+        else {\\n+            async.nextTick = function (fn) {\\n+                setTimeout(fn, 0);\\n+            };\\n+            async.setImmediate = async.nextTick;\\n+        }\\n+    }\\n+    else {\\n+        async.nextTick = process.nextTick;\\n+        if (typeof setImmediate !== 'undefined') {\\n+            async.setImmediate = function (fn) {\\n+              // not a direct alias for IE10 compatibility\\n+              setImmediate(fn);\\n+            };\\n+        }\\n+        else {\\n+            async.setImmediate = async.nextTick;\\n+        }\\n+    }\\n+\\n+    async.each = function (arr, iterator, callback) {\\n+        callback = callback || function () {};\\n+        if (!arr.length) {\\n+            return callback();\\n+        }\\n+        var completed = 0;\\n+        _each(arr, function (x) {\\n+            iterator(x, only_once(done) );\\n+        });\\n+        function done(err) {\\n+          if (err) {\\n+              callback(err);\\n+              callback = function () {};\\n+          }\\n+          else {\\n+              completed += 1;\\n+              if (completed >= arr.length) {\\n+                  callback();\\n+              }\\n+          }\\n+        }\\n+    };\\n+    async.forEach = async.each;\\n+\\n+    async.eachSeries = function (arr, iterator, callback) {\\n+        callback = callback || function () {};\\n+        if (!arr.length) {\\n+            return callback();\\n+        }\\n+        var completed = 0;\\n+        var iterate = function () {\\n+            iterator(arr[completed], function (err) {\\n+                if (err) {\\n+                    callback(err);\\n+                    callback = function () {};\\n+                }\\n+                else {\\n+                    completed += 1;\\n+                    if (completed >= arr.length) {\\n+                        callback();\\n+                    }\\n+                    else {\\n+                        iterate();\\n+                    }\\n+                }\\n+            });\\n+        };\\n+        iterate();\\n+    };\\n+    async.forEachSeries = async.eachSeries;\\n+\\n+    async.eachLimit = function (arr, limit, iterator, callback) {\\n+        var fn = _eachLimit(limit);\\n+        fn.apply(null, [arr, iterator, callback]);\\n+    };\\n+    async.forEachLimit = async.eachLimit;\\n+\\n+    var _eachLimit = function (limit) {\\n+\\n+        return function (arr, iterator, callback) {\\n+            callback = callback || function () {};\\n+            if (!arr.length || limit <= 0) {\\n+                return callback();\\n+            }\\n+            var completed = 0;\\n+            var started = 0;\\n+            var running = 0;\\n+\\n+            (function replenish () {\\n+                if (completed >= arr.length) {\\n+                    return callback();\\n+                }\\n+\\n+                while (running < limit && started < arr.length) {\\n+                    started += 1;\\n+                    running += 1;\\n+                    iterator(arr[started - 1], function (err) {\\n+                        if (err) {\\n+                            callback(err);\\n+                            callback = function () {};\\n+                        }\\n+                        else {\\n+                            completed += 1;\\n+                            running -= 1;\\n+                            if (completed >= arr.length) {\\n+                                callback();\\n+                            }\\n+                            else {\\n+                                replenish();\\n+                            }\\n+                        }\\n+                    });\\n+                }\\n+            })();\\n+        };\\n+    };\\n+\\n+\\n+    var doParallel = function (fn) {\\n+        return function () {\\n+            var args = Array.prototype.slice.call(arguments);\\n+            return fn.apply(null, [async.each].concat(args));\\n+        };\\n+    };\\n+    var doParallelLimit = function(limit, fn) {\\n+        return function () {\\n+            var args = Array.prototype.slice.call(arguments);\\n+            return fn.apply(null, [_eachLimit(limit)].concat(args));\\n+        };\\n+    };\\n+    var doSeries = function (fn) {\\n+        return function () {\\n+            var args = Array.prototype.slice.call(arguments);\\n+            return fn.apply(null, [async.eachSeries].concat(args));\\n+        };\\n+    };\\n+\\n+\\n+    var _asyncMap = function (eachfn, arr, iterator, callback) {\\n+        arr = _map(arr, function (x, i) {\\n+            return {index: i, value: x};\\n+        });\\n+        if (!callback) {\\n+            eachfn(arr, function (x, callback) {\\n+                iterator(x.value, function (err) {\\n+                    callback(err);\\n+                });\\n+            });\\n+        } else {\\n+            var results = [];\\n+            eachfn(arr, function (x, callback) {\\n+                iterator(x.value, function (err, v) {\\n+                    results[x.index] = v;\\n+                    callback(err);\\n+                });\\n+            }, function (err) {\\n+                callback(err, results);\\n+            });\\n+        }\\n+    };\\n+    async.map = doParallel(_asyncMap);\\n+    async.mapSeries = doSeries(_asyncMap);\\n+    async.mapLimit = function (arr, limit, iterator, callback) {\\n+        return _mapLimit(limit)(arr, iterator, callback);\\n+    };\\n+\\n+    var _mapLimit = function(limit) {\\n+        return doParallelLimit(limit, _asyncMap);\\n+    };\\n+\\n+    // reduce only has a series version, as doing reduce in parallel won't\\n+    // work in many situations.\\n+    async.reduce = function (arr, memo, iterator, callback) {\\n+        async.eachSeries(arr, function (x, callback) {\\n+            iterator(memo, x, function (err, v) {\\n+                memo = v;\\n+                callback(err);\\n+            });\\n+        }, function (err) {\\n+            callback(err, memo);\\n+        });\\n+    };\\n+    // inject alias\\n+    async.inject = async.reduce;\\n+    // foldl alias\\n+    async.foldl = async.reduce;\\n+\\n+    async.reduceRight = function (arr, memo, iterator, callback) {\\n+        var reversed = _map(arr, function (x) {\\n+            return x;\\n+        }).reverse();\\n+        async.reduce(reversed, memo, iterator, callback);\\n+    };\\n+    // foldr alias\\n+    async.foldr = async.reduceRight;\\n+\\n+    var _filter = function (eachfn, arr, iterator, callback) {\\n+        var results = [];\\n+        arr = _map(arr, function (x, i) {\\n+            return {index: i, value: x};\\n+        });\\n+        eachfn(arr, function (x, callback) {\\n+            iterator(x.value, function (v) {\\n+                if (v) {\\n+                    results.push(x);\\n+                }\\n+                callback();\\n+            });\\n+        }, function (err) {\\n+            callback(_map(results.sort(function (a, b) {\\n+                return a.index - b.index;\\n+            }), function (x) {\\n+                return x.value;\\n+            }));\\n+        });\\n+    };\\n+    async.filter = doParallel(_filter);\\n+    async.filterSeries = doSeries(_filter);\\n+    // select alias\\n+    async.select = async.filter;\\n+    async.selectSeries = async.filterSeries;\\n+\\n+    var _reject = function (eachfn, arr, iterator, callback) {\\n+        var results = [];\\n+        arr = _map(arr, function (x, i) {\\n+            return {index: i, value: x};\\n+        });\\n+        eachfn(arr, function (x, callback) {\\n+            iterator(x.value, function (v) {\\n+                if (!v) {\\n+                    results.push(x);\\n+                }\\n+                callback();\\n+            });\\n+        }, function (err) {\\n+            callback(_map(results.sort(function (a, b) {\\n+                return a.index - b.index;\\n+            }), function (x) {\\n+                return x.value;\\n+            }));\\n+        });\\n+    };\\n+    async.reject = doParallel(_reject);\\n+    async.rejectSeries = doSeries(_reject);\\n+\\n+    var _detect = function (eachfn, arr, iterator, main_callback) {\\n+        eachfn(arr, function (x, callback) {\\n+            iterator(x, function (result) {\\n+                if (result) {\\n+                    main_callback(x);\\n+                    main_callback = function () {};\\n+                }\\n+                else {\\n+                    callback();\\n+                }\\n+            });\\n+        }, function (err) {\\n+            main_callback();\\n+        });\\n+    };\\n+    async.detect = doParallel(_detect);\\n+    async.detectSeries = doSeries(_detect);\\n+\\n+    async.some = function (arr, iterator, main_callback) {\\n+        async.each(arr, function (x, callback) {\\n+            iterator(x, function (v) {\\n+                if (v) {\\n+                    main_callback(true);\\n+                    main_callback = function () {};\\n+                }\\n+                callback();\\n+            });\\n+        }, function (err) {\\n+            main_callback(false);\\n+        });\\n+    };\\n+    // any alias\\n+    async.any = async.some;\\n+\\n+    async.every = function (arr, iterator, main_callback) {\\n+        async.each(arr, function (x, callback) {\\n+            iterator(x, function (v) {\\n+                if (!v) {\\n+                    main_callback(false);\\n+                    main_callback = function () {};\\n+                }\\n+                callback();\\n+            });\\n+        }, function (err) {\\n+            main_callback(true);\\n+        });\\n+    };\\n+    // all alias\\n+    async.all = async.every;\\n+\\n+    async.sortBy = function (arr, iterator, callback) {\\n+        async.map(arr, function (x, callback) {\\n+            iterator(x, function (err, criteria) {\\n+                if (err) {\\n+                    callback(err);\\n+                }\\n+                else {\\n+                    callback(null, {value: x, criteria: criteria});\\n+                }\\n+            });\\n+        }, function (err, results) {\\n+            if (err) {\\n+                return callback(err);\\n+            }\\n+            else {\\n+                var fn = function (left, right) {\\n+                    var a = left.criteria, b = right.criteria;\\n+                    return a < b ? -1 : a > b ? 1 : 0;\\n+                };\\n+                callback(null, _map(results.sort(fn), function (x) {\\n+                    return x.value;\\n+                }));\\n+            }\\n+        });\\n+    };\\n+\\n+    async.auto = function (tasks, callback) {\\n+        callback = callback || function () {};\\n+        var keys = _keys(tasks);\\n+        var remainingTasks = keys.length\\n+        if (!remainingTasks) {\\n+            return callback();\\n+        }\\n+\\n+        var results = {};\\n+\\n+        var listeners = [];\\n+        var addListener = function (fn) {\\n+            listeners.unshift(fn);\\n+        };\\n+        var removeListener = function (fn) {\\n+            for (var i = 0; i < listeners.length; i += 1) {\\n+                if (listeners[i] === fn) {\\n+                    listeners.splice(i, 1);\\n+                    return;\\n+                }\\n+            }\\n+        };\\n+        var taskComplete = function () {\\n+            remainingTasks--\\n+            _each(listeners.slice(0), function (fn) {\\n+                fn();\\n+            });\\n+        };\\n+\\n+        addListener(function () {\\n+            if (!remainingTasks) {\\n+                var theCallback = callback;\\n+                // prevent final callback from calling itself if it errors\\n+                callback = function () {};\\n+\\n+                theCallback(null, results);\\n+            }\\n+        });\\n+\\n+        _each(keys, function (k) {\\n+            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\\n+            var taskCallback = function (err) {\\n+                var args = Array.prototype.slice.call(arguments, 1);\\n+                if (args.length <= 1) {\\n+                    args = args[0];\\n+                }\\n+                if (err) {\\n+                    var safeResults = {};\\n+                    _each(_keys(results), function(rkey) {\\n+                        safeResults[rkey] = results[rkey];\\n+                    });\\n+                    safeResults[k] = args;\\n+                    callback(err, safeResults);\\n+                    // stop subsequent errors hitting callback multiple times\\n+                    callback = function () {};\\n+                }\\n+                else {\\n+                    results[k] = args;\\n+                    async.setImmediate(taskComplete);\\n+                }\\n+            };\\n+            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\\n+            var ready = function () {\\n+                return _reduce(requires, function (a, x) {\\n+                    return (a && results.hasOwnProperty(x));\\n+                }, true) && !results.hasOwnProperty(k);\\n+            };\\n+            if (ready()) {\\n+                task[task.length - 1](taskCallback, results);\\n+            }\\n+            else {\\n+                var listener = function () {\\n+                    if (ready()) {\\n+                        removeListener(listener);\\n+                        task[task.length - 1](taskCallback, results);\\n+                    }\\n+                };\\n+                addListener(listener);\\n+            }\\n+        });\\n+    };\\n+\\n+    async.retry = function(times, task, callback) {\\n+        var DEFAULT_TIMES = 5;\\n+        var attempts = [];\\n+        // Use defaults if times not passed\\n+        if (typeof times === 'function') {\\n+            callback = task;\\n+            task = times;\\n+            times = DEFAULT_TIMES;\\n+        }\\n+        // Make sure times is a number\\n+        times = parseInt(times, 10) || DEFAULT_TIMES;\\n+        var wrappedTask = function(wrappedCallback, wrappedResults) {\\n+            var retryAttempt = function(task, finalAttempt) {\\n+                return function(seriesCallback) {\\n+                    task(function(err, result){\\n+                        seriesCallback(!err || finalAttempt, {err: err, result: result});\\n+                    }, wrappedResults);\\n+                };\\n+            };\\n+            while (times) {\\n+                attempts.push(retryAttempt(task, !(times-=1)));\\n+            }\\n+            async.series(attempts, function(done, data){\\n+                data = data[data.length - 1];\\n+                (wrappedCallback || callback)(data.err, data.result);\\n+            });\\n+        }\\n+        // If a callback is passed, run this as a controll flow\\n+        return callback ? wrappedTask() : wrappedTask\\n+    };\\n+\\n+    async.waterfall = function (tasks, callback) {\\n+        callback = callback || function () {};\\n+        if (!_isArray(tasks)) {\\n+          var err = new Error('First argument to waterfall must be an array of functions');\\n+          return callback(err);\\n+        }\\n+        if (!tasks.length) {\\n+            return callback();\\n+        }\\n+        var wrapIterator = function (iterator) {\\n+            return function (err) {\\n+                if (err) {\\n+                    callback.apply(null, arguments);\\n+                    callback = function () {};\\n+                }\\n+                else {\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\n+                    var next = iterator.next();\\n+                    if (next) {\\n+                        args.push(wrapIterator(next));\\n+                    }\\n+                    else {\\n+                        args.push(callback);\\n+                    }\\n+                    async.setImmediate(function () {\\n+                        iterator.apply(null, args);\\n+                    });\\n+                }\\n+            };\\n+        };\\n+        wrapIterator(async.iterator(tasks))();\\n+    };\\n+\\n+    var _parallel = function(eachfn, tasks, callback) {\\n+        callback = callback || function () {};\\n+        if (_isArray(tasks)) {\\n+            eachfn.map(tasks, function (fn, callback) {\\n+                if (fn) {\\n+                    fn(function (err) {\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\n+                        if (args.length <= 1) {\\n+                            args = args[0];\\n+                        }\\n+                        callback.call(null, err, args);\\n+                    });\\n+                }\\n+            }, callback);\\n+        }\\n+        else {\\n+            var results = {};\\n+            eachfn.each(_keys(tasks), function (k, callback) {\\n+                tasks[k](function (err) {\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\n+                    if (args.length <= 1) {\\n+                        args = args[0];\\n+                    }\\n+                    results[k] = args;\\n+                    callback(err);\\n+                });\\n+            }, function (err) {\\n+                callback(err, results);\\n+            });\\n+        }\\n+    };\\n+\\n+    async.parallel = function (tasks, callback) {\\n+        _parallel({ map: async.map, each: async.each }, tasks, callback);\\n+    };\\n+\\n+    async.parallelLimit = function(tasks, limit, callback) {\\n+        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\\n+    };\\n+\\n+    async.series = function (tasks, callback) {\\n+        callback = callback || function () {};\\n+        if (_isArray(tasks)) {\\n+            async.mapSeries(tasks, function (fn, callback) {\\n+                if (fn) {\\n+                    fn(function (err) {\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\n+                        if (args.length <= 1) {\\n+                            args = args[0];\\n+                        }\\n+                        callback.call(null, err, args);\\n+                    });\\n+                }\\n+            }, callback);\\n+        }\\n+        else {\\n+            var results = {};\\n+            async.eachSeries(_keys(tasks), function (k, callback) {\\n+                tasks[k](function (err) {\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\n+                    if (args.length <= 1) {\\n+                        args = args[0];\\n+                    }\\n+                    results[k] = args;\\n+                    callback(err);\\n+                });\\n+            }, function (err) {\\n+                callback(err, results);\\n+            });\\n+        }\\n+    };\\n+\\n+    async.iterator = function (tasks) {\\n+        var makeCallback = function (index) {\\n+            var fn = function () {\\n+                if (tasks.length) {\\n+                    tasks[index].apply(null, arguments);\\n+                }\\n+                return fn.next();\\n+            };\\n+            fn.next = function () {\\n+                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\\n+            };\\n+            return fn;\\n+        };\\n+        return makeCallback(0);\\n+    };\\n+\\n+    async.apply = function (fn) {\\n+        var args = Array.prototype.slice.call(arguments, 1);\\n+        return function () {\\n+            return fn.apply(\\n+                null, args.concat(Array.prototype.slice.call(arguments))\\n+            );\\n+        };\\n+    };\\n+\\n+    var _concat = function (eachfn, arr, fn, callback) {\\n+        var r = [];\\n+        eachfn(arr, function (x, cb) {\\n+            fn(x, function (err, y) {\\n+                r = r.concat(y || []);\\n+                cb(err);\\n+            });\\n+        }, function (err) {\\n+            callback(err, r);\\n+        });\\n+    };\\n+    async.concat = doParallel(_concat);\\n+    async.concatSeries = doSeries(_concat);\\n+\\n+    async.whilst = function (test, iterator, callback) {\\n+        if (test()) {\\n+            iterator(function (err) {\\n+                if (err) {\\n+                    return callback(err);\\n+                }\\n+                async.whilst(test, iterator, callback);\\n+            });\\n+        }\\n+        else {\\n+            callback();\\n+        }\\n+    };\\n+\\n+    async.doWhilst = function (iterator, test, callback) {\\n+        iterator(function (err) {\\n+            if (err) {\\n+                return callback(err);\\n+            }\\n+            var args = Array.prototype.slice.call(arguments, 1);\\n+            if (test.apply(null, args)) {\\n+                async.doWhilst(iterator, test, callback);\\n+            }\\n+            else {\\n+                callback();\\n+            }\\n+        });\\n+    };\\n+\\n+    async.until = function (test, iterator, callback) {\\n+        if (!test()) {\\n+            iterator(function (err) {\\n+                if (err) {\\n+                    return callback(err);\\n+                }\\n+                async.until(test, iterator, callback);\\n+            });\\n+        }\\n+        else {\\n+            callback();\\n+        }\\n+    };\\n+\\n+    async.doUntil = function (iterator, test, callback) {\\n+        iterator(function (err) {\\n+            if (err) {\\n+                return callback(err);\\n+            }\\n+            var args = Array.prototype.slice.call(arguments, 1);\\n+            if (!test.apply(null, args)) {\\n+                async.doUntil(iterator, test, callback);\\n+            }\\n+            else {\\n+                callback();\\n+            }\\n+        });\\n+    };\\n+\\n+    async.queue = function (worker, concurrency) {\\n+        if (concurrency === undefined) {\\n+            concurrency = 1;\\n+        }\\n+        function _insert(q, data, pos, callback) {\\n+          if (!q.started){\\n+            q.started = true;\\n+          }\\n+          if (!_isArray(data)) {\\n+              data = [data];\\n+          }\\n+          if(data.length == 0) {\\n+             // call drain immediately if there are no tasks\\n+             return async.setImmediate(function() {\\n+                 if (q.drain) {\\n+                     q.drain();\\n+                 }\\n+             });\\n+          }\\n+          _each(data, function(task) {\\n+              var item = {\\n+                  data: task,\\n+                  callback: typeof callback === 'function' ? callback : null\\n+              };\\n+\\n+              if (pos) {\\n+                q.tasks.unshift(item);\\n+              } else {\\n+                q.tasks.push(item);\\n+              }\\n+\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\n+                  q.saturated();\\n+              }\\n+              async.setImmediate(q.process);\\n+          });\\n+        }\\n+\\n+        var workers = 0;\\n+        var q = {\\n+            tasks: [],\\n+            concurrency: concurrency,\\n+            saturated: null,\\n+            empty: null,\\n+            drain: null,\\n+            started: false,\\n+            paused: false,\\n+            push: function (data, callback) {\\n+              _insert(q, data, false, callback);\\n+            },\\n+            kill: function () {\\n+              q.drain = null;\\n+              q.tasks = [];\\n+            },\\n+            unshift: function (data, callback) {\\n+              _insert(q, data, true, callback);\\n+            },\\n+            process: function () {\\n+                if (!q.paused && workers < q.concurrency && q.tasks.length) {\\n+                    var task = q.tasks.shift();\\n+                    if (q.empty && q.tasks.length === 0) {\\n+                        q.empty();\\n+                    }\\n+                    workers += 1;\\n+                    var next = function () {\\n+                        workers -= 1;\\n+                        if (task.callback) {\\n+                            task.callback.apply(task, arguments);\\n+                        }\\n+                        if (q.drain && q.tasks.length + workers === 0) {\\n+                            q.drain();\\n+                        }\\n+                        q.process();\\n+                    };\\n+                    var cb = only_once(next);\\n+                    worker(task.data, cb);\\n+                }\\n+            },\\n+            length: function () {\\n+                return q.tasks.length;\\n+            },\\n+            running: function () {\\n+                return workers;\\n+            },\\n+            idle: function() {\\n+                return q.tasks.length + workers === 0;\\n+            },\\n+            pause: function () {\\n+                if (q.paused === true) { return; }\\n+                q.paused = true;\\n+                q.process();\\n+            },\\n+            resume: function () {\\n+                if (q.paused === false) { return; }\\n+                q.paused = false;\\n+                q.process();\\n+            }\\n+        };\\n+        return q;\\n+    };\\n+    \\n+    async.priorityQueue = function (worker, concurrency) {\\n+        \\n+        function _compareTasks(a, b){\\n+          return a.priority - b.priority;\\n+        };\\n+        \\n+        function _binarySearch(sequence, item, compare) {\\n+          var beg = -1,\\n+              end = sequence.length - 1;\\n+          while (beg < end) {\\n+            var mid = beg + ((end - beg + 1) >>> 1);\\n+            if (compare(item, sequence[mid]) >= 0) {\\n+              beg = mid;\\n+            } else {\\n+              end = mid - 1;\\n+            }\\n+          }\\n+          return beg;\\n+        }\\n+        \\n+        function _insert(q, data, priority, callback) {\\n+          if (!q.started){\\n+            q.started = true;\\n+          }\\n+          if (!_isArray(data)) {\\n+              data = [data];\\n+          }\\n+          if(data.length == 0) {\\n+             // call drain immediately if there are no tasks\\n+             return async.setImmediate(function() {\\n+                 if (q.drain) {\\n+                     q.drain();\\n+                 }\\n+             });\\n+          }\\n+          _each(data, function(task) {\\n+              var item = {\\n+                  data: task,\\n+                  priority: priority,\\n+                  callback: typeof callback === 'function' ? callback : null\\n+              };\\n+              \\n+              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\\n+\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\n+                  q.saturated();\\n+              }\\n+              async.setImmediate(q.process);\\n+          });\\n+        }\\n+        \\n+        // Start with a normal queue\\n+        var q = async.queue(worker, concurrency);\\n+        \\n+        // Override push to accept second parameter representing priority\\n+        q.push = function (data, priority, callback) {\\n+          _insert(q, data, priority, callback);\\n+        };\\n+        \\n+        // Remove unshift function\\n+        delete q.unshift;\\n+\\n+        return q;\\n+    };\\n+\\n+    async.cargo = function (worker, payload) {\\n+        var working     = false,\\n+            tasks       = [];\\n+\\n+        var cargo = {\\n+            tasks: tasks,\\n+            payload: payload,\\n+            saturated: null,\\n+            empty: null,\\n+            drain: null,\\n+            drained: true,\\n+            push: function (data, callback) {\\n+                if (!_isArray(data)) {\\n+                    data = [data];\\n+                }\\n+                _each(data, function(task) {\\n+                    tasks.push({\\n+                        data: task,\\n+                        callback: typeof callback === 'function' ? callback : null\\n+                    });\\n+                    cargo.drained = false;\\n+                    if (cargo.saturated && tasks.length === payload) {\\n+                        cargo.saturated();\\n+                    }\\n+                });\\n+                async.setImmediate(cargo.process);\\n+            },\\n+            process: function process() {\\n+                if (working) return;\\n+                if (tasks.length === 0) {\\n+                    if(cargo.drain && !cargo.drained) cargo.drain();\\n+                    cargo.drained = true;\\n+                    return;\\n+                }\\n+\\n+                var ts = typeof payload === 'number'\\n+                            ? tasks.splice(0, payload)\\n+                            : tasks.splice(0, tasks.length);\\n+\\n+                var ds = _map(ts, function (task) {\\n+                    return task.data;\\n+                });\\n+\\n+                if(cargo.empty) cargo.empty();\\n+                working = true;\\n+                worker(ds, function () {\\n+                    working = false;\\n+\\n+                    var args = arguments;\\n+                    _each(ts, function (data) {\\n+                        if (data.callback) {\\n+                            data.callback.apply(null, args);\\n+                        }\\n+                    });\\n+\\n+                    process();\\n+                });\\n+            },\\n+            length: function () {\\n+                return tasks.length;\\n+            },\\n+            running: function () {\\n+                return working;\\n+            }\\n+        };\\n+        return cargo;\\n+    };\\n+\\n+    var _console_fn = function (name) {\\n+        return function (fn) {\\n+            var args = Array.prototype.slice.call(arguments, 1);\\n+            fn.apply(null, args.concat([function (err) {\\n+                var args = Array.prototype.slice.call(arguments, 1);\\n+                if (typeof console !== 'undefined') {\\n+                    if (err) {\\n+                        if (console.error) {\\n+                            console.error(err);\\n+                        }\\n+                    }\\n+                    else if (console[name]) {\\n+                        _each(args, function (x) {\\n+                            console[name](x);\\n+                        });\\n+                    }\\n+                }\\n+            }]));\\n+        };\\n+    };\\n+    async.log = _console_fn('log');\\n+    async.dir = _console_fn('dir');\\n+    /*async.info = _console_fn('info');\\n+    async.warn = _console_fn('warn');\\n+    async.error = _console_fn('error');*/\\n+\\n+    async.memoize = function (fn, hasher) {\\n+        var memo = {};\\n+        var queues = {};\\n+        hasher = hasher || function (x) {\\n+            return x;\\n+        };\\n+        var memoized = function () {\\n+            var args = Array.prototype.slice.call(arguments);\\n+            var callback = args.pop();\\n+            var key = hasher.apply(null, args);\\n+            if (key in memo) {\\n+                async.nextTick(function () {\\n+                    callback.apply(null, memo[key]);\\n+                });\\n+            }\\n+            else if (key in queues) {\\n+                queues[key].push(callback);\\n+            }\\n+            else {\\n+                queues[key] = [callback];\\n+                fn.apply(null, args.concat([function () {\\n+                    memo[key] = arguments;\\n+                    var q = queues[key];\\n+                    delete queues[key];\\n+                    for (var i = 0, l = q.length; i < l; i++) {\\n+                      q[i].apply(null, arguments);\\n+                    }\\n+                }]));\\n+            }\\n+        };\\n+        memoized.memo = memo;\\n+        memoized.unmemoized = fn;\\n+        return memoized;\\n+    };\\n+\\n+    async.unmemoize = function (fn) {\\n+      return function () {\\n+        return (fn.unmemoized || fn).apply(null, arguments);\\n+      };\\n+    };\\n+\\n+    async.times = function (count, iterator, callback) {\\n+        var counter = [];\\n+        for (var i = 0; i < count; i++) {\\n+            counter.push(i);\\n+        }\\n+        return async.map(counter, iterator, callback);\\n+    };\\n+\\n+    async.timesSeries = function (count, iterator, callback) {\\n+        var counter = [];\\n+        for (var i = 0; i < count; i++) {\\n+            counter.push(i);\\n+        }\\n+        return async.mapSeries(counter, iterator, callback);\\n+    };\\n+\\n+    async.seq = function (/* functions... */) {\\n+        var fns = arguments;\\n+        return function () {\\n+            var that = this;\\n+            var args = Array.prototype.slice.call(arguments);\\n+            var callback = args.pop();\\n+            async.reduce(fns, args, function (newargs, fn, cb) {\\n+                fn.apply(that, newargs.concat([function () {\\n+                    var err = arguments[0];\\n+                    var nextargs = Array.prototype.slice.call(arguments, 1);\\n+                    cb(err, nextargs);\\n+                }]))\\n+            },\\n+            function (err, results) {\\n+                callback.apply(that, [err].concat(results));\\n+            });\\n+        };\\n+    };\\n+\\n+    async.compose = function (/* functions... */) {\\n+      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\\n+    };\\n+\\n+    var _applyEach = function (eachfn, fns /*args...*/) {\\n+        var go = function () {\\n+            var that = this;\\n+            var args = Array.prototype.slice.call(arguments);\\n+            var callback = args.pop();\\n+            return eachfn(fns, function (fn, cb) {\\n+                fn.apply(that, args.concat([cb]));\\n+            },\\n+            callback);\\n+        };\\n+        if (arguments.length > 2) {\\n+            var args = Array.prototype.slice.call(arguments, 2);\\n+            return go.apply(this, args);\\n+        }\\n+        else {\\n+            return go;\\n+        }\\n+    };\\n+    async.applyEach = doParallel(_applyEach);\\n+    async.applyEachSeries = doSeries(_applyEach);\\n+\\n+    async.forever = function (fn, callback) {\\n+        function next(err) {\\n+            if (err) {\\n+                if (callback) {\\n+                    return callback(err);\\n+                }\\n+                throw err;\\n+            }\\n+            fn(next);\\n+        }\\n+        next();\\n+    };\\n+\\n+    // Node.js\\n+    if (typeof module !== 'undefined' && module.exports) {\\n+        module.exports = async;\\n+    }\\n+    // AMD / RequireJS\\n+    else if (typeof define !== 'undefined' && define.amd) {\\n+        define([], function () {\\n+            return async;\\n+        });\\n+    }\\n+    // included directly via <script> tag\\n+    else {\\n+        root.async = async;\\n+    }\\n+\\n+}());\\ndiff --git a/node_modules/async/package.json b/node_modules/async/package.json\\nnew file mode 100644\\nindex 0000000..31a5200\\n--- /dev/null\\n+++ b/node_modules/async/package.json\\n@@ -0,0 +1,59 @@\\n+{\\n+  \\\"name\\\": \\\"async\\\",\\n+  \\\"description\\\": \\\"Higher-order functions and common patterns for asynchronous code\\\",\\n+  \\\"main\\\": \\\"./lib/async\\\",\\n+  \\\"author\\\": {\\n+    \\\"name\\\": \\\"Caolan McMahon\\\"\\n+  },\\n+  \\\"version\\\": \\\"0.9.0\\\",\\n+  \\\"repository\\\": {\\n+    \\\"type\\\": \\\"git\\\",\\n+    \\\"url\\\": \\\"https://github.com/caolan/async.git\\\"\\n+  },\\n+  \\\"bugs\\\": {\\n+    \\\"url\\\": \\\"https://github.com/caolan/async/issues\\\"\\n+  },\\n+  \\\"licenses\\\": [\\n+    {\\n+      \\\"type\\\": \\\"MIT\\\",\\n+      \\\"url\\\": \\\"https://github.com/caolan/async/raw/master/LICENSE\\\"\\n+    }\\n+  ],\\n+  \\\"devDependencies\\\": {\\n+    \\\"nodeunit\\\": \\\">0.0.0\\\",\\n+    \\\"uglify-js\\\": \\\"1.2.x\\\",\\n+    \\\"nodelint\\\": \\\">0.0.0\\\"\\n+  },\\n+  \\\"jam\\\": {\\n+    \\\"main\\\": \\\"lib/async.js\\\",\\n+    \\\"include\\\": [\\n+      \\\"lib/async.js\\\",\\n+      \\\"README.md\\\",\\n+      \\\"LICENSE\\\"\\n+    ]\\n+  },\\n+  \\\"scripts\\\": {\\n+    \\\"test\\\": \\\"nodeunit test/test-async.js\\\"\\n+  },\\n+  \\\"homepage\\\": \\\"https://github.com/caolan/async\\\",\\n+  \\\"_id\\\": \\\"async@0.9.0\\\",\\n+  \\\"dist\\\": {\\n+    \\\"shasum\\\": \\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\",\\n+    \\\"tarball\\\": \\\"http://registry.npmjs.org/async/-/async-0.9.0.tgz\\\"\\n+  },\\n+  \\\"_from\\\": \\\"async@*\\\",\\n+  \\\"_npmVersion\\\": \\\"1.4.3\\\",\\n+  \\\"_npmUser\\\": {\\n+    \\\"name\\\": \\\"caolan\\\",\\n+    \\\"email\\\": \\\"caolan.mcmahon@gmail.com\\\"\\n+  },\\n+  \\\"maintainers\\\": [\\n+    {\\n+      \\\"name\\\": \\\"caolan\\\",\\n+      \\\"email\\\": \\\"caolan@caolanmcmahon.com\\\"\\n+    }\\n+  ],\\n+  \\\"directories\\\": {},\\n+  \\\"_shasum\\\": \\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\",\\n+  \\\"_resolved\\\": \\\"https://registry.npmjs.org/async/-/async-0.9.0.tgz\\\"\\n+}\\ndiff --git a/package.json b/package.json\\nindex 5f21627..6033d43 100644\\n--- a/package.json\\n+++ b/package.json\\n@@ -4,7 +4,8 @@\\n   \\\"description\\\": \\\"Sous project\\\",\\n   \\\"main\\\": \\\"main.js\\\",\\n   \\\"dependencies\\\": {\\n-},\\n+    \\\"async\\\": \\\"*\\\"\\n+  },\\n   \\\"devDependencies\\\": {},\\n   \\\"scripts\\\": {\\n     \\\"test\\\": \\\"echo \\\\\\\"Error: no test specified\\\\\\\" && exit 1\\\"\\ndiff --git a/patches.sousp b/patches.sousp\\nindex 16405a3..d71e511 100644\\n--- a/patches.sousp\\n+++ b/patches.sousp\\n@@ -1,31 +1 @@\\n-diff --git a/main.js b/main.js\\n-index f81b54e..744cdd5 100644\\n---- a/main.js\\n-+++ b/main.js\\n-@@ -35,7 +35,7 @@ fs.exists('.git', function (exists) {\\n-         cp.exec('git diff', function(error, stdout, stderr) {\\n-             console.log(stdout);\\n- \\n--            //fs.writeFileSync(\\\"patches.sousp\\\", stdout);\\n-+            fs.writeFileSync(\\\"patches.sousp\\\", stdout);\\n- \\n-             if (error !== null) {\\n-                 console.log('stderr: ' + stderr);\\n-@@ -44,7 +44,7 @@ fs.exists('.git', function (exists) {\\n-         });\\n- \\n-         cp.exec('git log', function(error, stdout, stderr) {\\n--            //console.log(stdout);\\n-+            console.log(stdout);\\n- \\n-             var authors = findData(stdout, \\\"Author:\\\");\\n-             var dates = findData(stdout, \\\"Date:\\\");\\n-@@ -53,7 +53,7 @@ fs.exists('.git', function (exists) {\\n-             console.log(comments);\\n-             console.log(dates);\\n- \\n--            //fs.writeFileSync(\\\"comments.sousc\\\", stdout);\\n-+            fs.writeFileSync(\\\"comments.sousc\\\", stdout);\\n- \\n-             if (error !== null) {\\n-                 console.log('stderr: ' + stderr);\\n+[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]\\n\\\\ No newline at end of file\\ndiff --git a/test.js b/test.js\\nnew file mode 100644\\nindex 0000000..5ca759c\\n--- /dev/null\\n+++ b/test.js\\n@@ -0,0 +1,21 @@\\n+/**\\n+ * Created by Nick on 18.05.2015.\\n+ */\\n+var async = require('async')\\n+    , tasksIndex = [\\n+        function (callback) {\\n+            // Вымышленный метод который вернет 231\\n+            var viewsNumber = models.stat.viewsNumber();\\n+            callback(null, viewsNumber);\\n+        }\\n+        , function (callback) {\\n+            // Вымышленный метод который вернет 24\\n+            var growFactor = models.stat.growFactor();\\n+            callback(null, growFactor);\\n+        }\\n+    ];\\n+\\n+async.series(tasksIndex, function (err, results) {\\n+    // Результат будет массивом\\n+    console.log(results); // [231, 24]\\n+});\\n\\\\ No newline at end of file\\n\"}\n\\ No newline at end of file\ndiff --git a/patches.txt b/patches.txt\nnew file mode 100644\nindex 0000000..300c6a9\n--- /dev/null\n+++ b/patches.txt\n@@ -0,0 +1 @@\n+{\"commit\":\"1e947f613e976945de85ae35ed923aa470f0be72\",\"author\":\"Nick Stepanenko <massaalonso@yandex.ru>\",\"date\":\"Tue May 19 00:12:12 2015 +0800\",\"comment\":\"Latest updates\",\"content\":\"diff --git a/comments.sousc b/comments.sousc\\nindex 150b0f6..cb3a850 100644\\n--- a/comments.sousc\\n+++ b/comments.sousc\\n@@ -1,3 +1,27 @@\\n+commit 4420cabefc1f470af341af11ed595df67e25c51f\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\n+Date:   Sun May 17 17:05:35 2015 +0800\\n+\\n+    Paste old program code\\n+\\n+commit 9ef3d25fd4c3afdbcc3107a0abf6d7a2e29cb4dd\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\n+Date:   Sun May 17 17:04:52 2015 +0800\\n+\\n+    Adding new file\\n+\\n+commit 64814d140d2fab6ae153cac485008119f29bf230\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\n+Date:   Sun May 17 17:03:58 2015 +0800\\n+\\n+    From clear list\\n+\\n+commit c9d318fea74ea288d544ecf72f00b12c130cf2ef\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\n+Date:   Sun May 17 16:59:40 2015 +0800\\n+\\n+    Create system files\\n+\\n commit e3c853a4282dfe8f000685dc1d39bd55a4a946c4\\n Author: Nick Stepanenko <massaalonso@yandex.ru>\\n Date:   Sun May 17 16:54:58 2015 +0800\\ndiff --git a/main.js b/main.js\\nindex e34dc18..86f30c2 100644\\n--- a/main.js\\n+++ b/main.js\\n@@ -3,6 +3,56 @@\\n  */\\n \\n var fs = require('fs');\\n+var cp = require('child_process');\\n+var data = [];\\n+\\n+var async = require('async');\\n+    /*tasks = [\\n+        function (callback) {\\n+            cp.exec('git log', function(error, stdout, stderr) {\\n+                var listOfCommits = [];\\n+                var authors = findData(stdout, \\\"Author:\\\");\\n+                var dates = findData(stdout, \\\"Date:\\\");\\n+                var comments = findComments(stdout);\\n+                var commitNumbers = findCommitNumbers(stdout);\\n+\\n+                for(i=0; i<authors.length; i++) {\\n+                    var commit = {\\n+                        \\\"commit\\\": commitNumbers[i],\\n+                        \\\"author\\\": authors[i],\\n+                        \\\"date\\\": dates[i],\\n+                        \\\"comment\\\": comments[i],\\n+                        \\\"content\\\": 'Original'\\n+                    };\\n+\\n+                    listOfCommits[listOfCommits.length] = commit;\\n+                }\\n+\\n+                data = listOfCommits.reverse();\\n+\\n+                callback(null, data);\\n+\\n+                if (error !== null) {\\n+                    console.log('stderr: ' + stderr);\\n+                    console.log('exec error: ' + error);\\n+                }\\n+            });\\n+        }\\n+    ],\\n+    secondTasks = [\\n+        function some_function(callback) {\\n+            cp.exec('git diff', function(error, stdout, stderr) {\\n+                var currentContent = stdout;\\n+\\n+                if (error !== null) {\\n+                    console.log('stderr: ' + stderr);\\n+                    console.log('exec error: ' + error);\\n+                }\\n+\\n+                callback(null, currentContent);\\n+            });\\n+        }\\n+    ];*/\\n \\n function findData(text, keyword) {\\n     var data = [];\\n@@ -28,38 +78,106 @@ function findComments(text) {\\n     return comments;\\n }\\n \\n+function findCommitNumbers(text) {\\n+    var commits = [];\\n+    var splittext = text.split('\\\\n');\\n+\\n+    for(i=0; i<splittext.length; i++) {\\n+        if(splittext[i].slice(0, 6) == \\\"commit\\\") {\\n+            commits[commits.length] = splittext[i].slice(6).trim();\\n+        }\\n+    }\\n+\\n+    return commits;\\n+}\\n+\\n+/*function pullCommitContent(first, second) {\\n+\\n+    cp.exec('git diff' + ' ' + first + ' ' + second, function(error, stdout, stderr) {\\n+        var currentContent = stdout;\\n+\\n+        if (error !== null) {\\n+            console.log('stderr: ' + stderr);\\n+            console.log('exec error: ' + error);\\n+        }\\n+\\n+        return currentContent;\\n+    });\\n+}*/\\n+\\n+var commitsInfo = [];\\n+\\n fs.exists('.git', function (exists) {\\n     if(exists) {\\n-        var cp = require('child_process');\\n+        /*async.series(tasks, function(err, result) {\\n+            fs.writeFileSync(\\\"patches.sousp\\\", JSON.stringify(result));\\n+\\n+            var data = result[0];\\n \\n-        cp.exec('git diff', function(error, stdout, stderr) {\\n-            console.log(stdout);\\n+            /*function some_function(arg1, arg2, callback) {\\n+                cp.exec('git diff' + ' ' + arg1 + ' ' + arg2, function(error, stdout, stderr) {\\n+                    var currentContent = 54321;//stdout;\\n \\n-            fs.writeFileSync(\\\"patches.sousp\\\", stdout);\\n+                    if (error !== null) {\\n+                        console.log('stderr: ' + stderr);\\n+                        console.log('exec error: ' + error);\\n+                    }\\n \\n-            if (error !== null) {\\n-                console.log('stderr: ' + stderr);\\n-                console.log('exec error: ' + error);\\n+                    callback(null, currentContent);\\n+                });\\n             }\\n-        });\\n+        });*/\\n+\\n+        async.waterfall([\\n+            function getCommitsInfo(callback) {\\n+                cp.exec('git log', function(error, stdout, stderr) {\\n+                    var listOfCommits = [];\\n+                    var authors = findData(stdout, \\\"Author:\\\");\\n+                    var dates = findData(stdout, \\\"Date:\\\");\\n+                    var comments = findComments(stdout);\\n+                    var commitNumbers = findCommitNumbers(stdout);\\n \\n-        cp.exec('git log', function(error, stdout, stderr) {\\n-            console.log(stdout);\\n+                    for(i=0; i<authors.length; i++) {\\n+                        var commit = {\\n+                            \\\"commit\\\": commitNumbers[i],\\n+                            \\\"author\\\": authors[i],\\n+                            \\\"date\\\": dates[i],\\n+                            \\\"comment\\\": comments[i],\\n+                            \\\"content\\\": 'Original'\\n+                        };\\n+                        listOfCommits[listOfCommits.length] = commit;\\n+                    }\\n \\n-            var authors = findData(stdout, \\\"Author:\\\");\\n-            var dates = findData(stdout, \\\"Date:\\\");\\n-            var comments = findComments(stdout);\\n-            console.log(authors);\\n-            console.log(comments);\\n-            console.log(dates);\\n+                    callback(null, listOfCommits.reverse());\\n \\n-            fs.writeFileSync(\\\"comments.sousc\\\", stdout);\\n+                    if (error !== null) {\\n+                        console.log('stderr: ' + stderr);\\n+                        console.log('exec error: ' + error);\\n+                    }\\n+                });\\n+            },\\n+            function getCommitsContent(commits, callback) {\\n+                console.log(commits);\\n+                var commitsData = commits;\\n \\n-            if (error !== null) {\\n-                console.log('stderr: ' + stderr);\\n-                console.log('exec error: ' + error);\\n+                for(i=1; i<commitsData.length; i++) {\\n+                    cp.exec('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit, function(error, stdout, stderr) {\\n+                        commitsData[i].content = stdout;\\n+\\n+                        if (error !== null) {\\n+                            console.log('stderr: ' + stderr);\\n+                            console.log('exec error: ' + error);\\n+                        }\\n+                    });\\n+                }\\n+\\n+                callback(null, commitsData);\\n             }\\n+        ], function (err, result) {\\n+            fs.writeFileSync(\\\"patches.sousp\\\", result);\\n         });\\n+\\n+        //commitsInfo = JSON.parse(fs.readFileSync(\\\"patches.sousp\\\"));\\n+        //console.log(commitsInfo);\\n     }\\n-    else console.log(\\\"Error.\\\");\\n });\\n\\\\ No newline at end of file\\ndiff --git a/node_modules/async/.travis.yml b/node_modules/async/.travis.yml\\nnew file mode 100644\\nindex 0000000..6e5919d\\n--- /dev/null\\n+++ b/node_modules/async/.travis.yml\\n@@ -0,0 +1,3 @@\\n+language: node_js\\n+node_js:\\n+  - \\\"0.10\\\"\\ndiff --git a/node_modules/async/LICENSE b/node_modules/async/LICENSE\\nnew file mode 100644\\nindex 0000000..8f29698\\n--- /dev/null\\n+++ b/node_modules/async/LICENSE\\n@@ -0,0 +1,19 @@\\n+Copyright (c) 2010-2014 Caolan McMahon\\n+\\n+Permission is hereby granted, free of charge, to any person obtaining a copy\\n+of this software and associated documentation files (the \\\"Software\\\"), to deal\\n+in the Software without restriction, including without limitation the rights\\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n+copies of the Software, and to permit persons to whom the Software is\\n+furnished to do so, subject to the following conditions:\\n+\\n+The above copyright notice and this permission notice shall be included in\\n+all copies or substantial portions of the Software.\\n+\\n+THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n+THE SOFTWARE.\\ndiff --git a/node_modules/async/README.md b/node_modules/async/README.md\\nnew file mode 100644\\nindex 0000000..0bea531\\n--- /dev/null\\n+++ b/node_modules/async/README.md\\n@@ -0,0 +1,1646 @@\\n+# Async.js\\n+\\n+[![Build Status via Travis CI](https://travis-ci.org/caolan/async.svg?branch=master)](https://travis-ci.org/caolan/async)\\n+\\n+\\n+Async is a utility module which provides straight-forward, powerful functions\\n+for working with asynchronous JavaScript. Although originally designed for\\n+use with [Node.js](http://nodejs.org), it can also be used directly in the\\n+browser. Also supports [component](https://github.com/component/component).\\n+\\n+Async provides around 20 functions that include the usual 'functional'\\n+suspects (`map`, `reduce`, `filter`, `each`…) as well as some common patterns\\n+for asynchronous control flow (`parallel`, `series`, `waterfall`…). All these\\n+functions assume you follow the Node.js convention of providing a single\\n+callback as the last argument of your `async` function.\\n+\\n+\\n+## Quick Examples\\n+\\n+```javascript\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\n+    // results is now an array of stats for each file\\n+});\\n+\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\n+    // results now equals an array of the existing files\\n+});\\n+\\n+async.parallel([\\n+    function(){ ... },\\n+    function(){ ... }\\n+], callback);\\n+\\n+async.series([\\n+    function(){ ... },\\n+    function(){ ... }\\n+]);\\n+```\\n+\\n+There are many more functions available so take a look at the docs below for a\\n+full list. This module aims to be comprehensive, so if you feel anything is\\n+missing please create a GitHub issue for it.\\n+\\n+## Common Pitfalls\\n+\\n+### Binding a context to an iterator\\n+\\n+This section is really about `bind`, not about `async`. If you are wondering how to\\n+make `async` execute your iterators in a given context, or are confused as to why\\n+a method of another library isn't working as an iterator, study this example:\\n+\\n+```js\\n+// Here is a simple object with an (unnecessarily roundabout) squaring method\\n+var AsyncSquaringLibrary = {\\n+  squareExponent: 2,\\n+  square: function(number, callback){ \\n+    var result = Math.pow(number, this.squareExponent);\\n+    setTimeout(function(){\\n+      callback(null, result);\\n+    }, 200);\\n+  }\\n+};\\n+\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square, function(err, result){\\n+  // result is [NaN, NaN, NaN]\\n+  // This fails because the `this.squareExponent` expression in the square\\n+  // function is not evaluated in the context of AsyncSquaringLibrary, and is\\n+  // therefore undefined.\\n+});\\n+\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), function(err, result){\\n+  // result is [1, 4, 9]\\n+  // With the help of bind we can attach a context to the iterator before\\n+  // passing it to async. Now the square function will be executed in its \\n+  // 'home' AsyncSquaringLibrary context and the value of `this.squareExponent`\\n+  // will be as expected.\\n+});\\n+```\\n+\\n+## Download\\n+\\n+The source is available for download from\\n+[GitHub](http://github.com/caolan/async).\\n+Alternatively, you can install using Node Package Manager (`npm`):\\n+\\n+    npm install async\\n+\\n+__Development:__ [async.js](https://github.com/caolan/async/raw/master/lib/async.js) - 29.6kb Uncompressed\\n+\\n+## In the Browser\\n+\\n+So far it's been tested in IE6, IE7, IE8, FF3.6 and Chrome 5. \\n+\\n+Usage:\\n+\\n+```html\\n+<script type=\\\"text/javascript\\\" src=\\\"async.js\\\"></script>\\n+<script type=\\\"text/javascript\\\">\\n+\\n+    async.map(data, asyncProcess, function(err, results){\\n+        alert(results);\\n+    });\\n+\\n+</script>\\n+```\\n+\\n+## Documentation\\n+\\n+### Collections\\n+\\n+* [`each`](#each)\\n+* [`eachSeries`](#eachSeries)\\n+* [`eachLimit`](#eachLimit)\\n+* [`map`](#map)\\n+* [`mapSeries`](#mapSeries)\\n+* [`mapLimit`](#mapLimit)\\n+* [`filter`](#filter)\\n+* [`filterSeries`](#filterSeries)\\n+* [`reject`](#reject)\\n+* [`rejectSeries`](#rejectSeries)\\n+* [`reduce`](#reduce)\\n+* [`reduceRight`](#reduceRight)\\n+* [`detect`](#detect)\\n+* [`detectSeries`](#detectSeries)\\n+* [`sortBy`](#sortBy)\\n+* [`some`](#some)\\n+* [`every`](#every)\\n+* [`concat`](#concat)\\n+* [`concatSeries`](#concatSeries)\\n+\\n+### Control Flow\\n+\\n+* [`series`](#seriestasks-callback)\\n+* [`parallel`](#parallel)\\n+* [`parallelLimit`](#parallellimittasks-limit-callback)\\n+* [`whilst`](#whilst)\\n+* [`doWhilst`](#doWhilst)\\n+* [`until`](#until)\\n+* [`doUntil`](#doUntil)\\n+* [`forever`](#forever)\\n+* [`waterfall`](#waterfall)\\n+* [`compose`](#compose)\\n+* [`seq`](#seq)\\n+* [`applyEach`](#applyEach)\\n+* [`applyEachSeries`](#applyEachSeries)\\n+* [`queue`](#queue)\\n+* [`priorityQueue`](#priorityQueue)\\n+* [`cargo`](#cargo)\\n+* [`auto`](#auto)\\n+* [`retry`](#retry)\\n+* [`iterator`](#iterator)\\n+* [`apply`](#apply)\\n+* [`nextTick`](#nextTick)\\n+* [`times`](#times)\\n+* [`timesSeries`](#timesSeries)\\n+\\n+### Utils\\n+\\n+* [`memoize`](#memoize)\\n+* [`unmemoize`](#unmemoize)\\n+* [`log`](#log)\\n+* [`dir`](#dir)\\n+* [`noConflict`](#noConflict)\\n+\\n+\\n+## Collections\\n+\\n+<a name=\\\"forEach\\\" />\\n+<a name=\\\"each\\\" />\\n+### each(arr, iterator, callback)\\n+\\n+Applies the function `iterator` to each item in `arr`, in parallel.\\n+The `iterator` is called with an item from the list, and a callback for when it\\n+has finished. If the `iterator` passes an error to its `callback`, the main\\n+`callback` (for the `each` function) is immediately called with the error.\\n+\\n+Note, that since this function applies `iterator` to each item in parallel,\\n+there is no guarantee that the iterator functions will complete in order.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err)` which must be called once it has \\n+  completed. If no error has occured, the `callback` should be run without \\n+  arguments or with an explicit `null` argument.\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\n+  have finished, or an error occurs.\\n+\\n+__Examples__\\n+\\n+\\n+```js\\n+// assuming openFiles is an array of file names and saveFile is a function\\n+// to save the modified contents of that file:\\n+\\n+async.each(openFiles, saveFile, function(err){\\n+    // if any of the saves produced an error, err would equal that error\\n+});\\n+```\\n+\\n+```js\\n+// assuming openFiles is an array of file names \\n+\\n+async.each(openFiles, function( file, callback) {\\n+  \\n+  // Perform operation on file here.\\n+  console.log('Processing file ' + file);\\n+  \\n+  if( file.length > 32 ) {\\n+    console.log('This file name is too long');\\n+    callback('File name too long');\\n+  } else {\\n+    // Do work to process file here\\n+    console.log('File processed');\\n+    callback();\\n+  }\\n+}, function(err){\\n+    // if any of the file processing produced an error, err would equal that error\\n+    if( err ) {\\n+      // One of the iterations produced an error.\\n+      // All processing will now stop.\\n+      console.log('A file failed to process');\\n+    } else {\\n+      console.log('All files have been processed successfully');\\n+    }\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"forEachSeries\\\" />\\n+<a name=\\\"eachSeries\\\" />\\n+### eachSeries(arr, iterator, callback)\\n+\\n+The same as [`each`](#each), only `iterator` is applied to each item in `arr` in\\n+series. The next `iterator` is only called once the current one has completed. \\n+This means the `iterator` functions will complete in order.\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"forEachLimit\\\" />\\n+<a name=\\\"eachLimit\\\" />\\n+### eachLimit(arr, limit, iterator, callback)\\n+\\n+The same as [`each`](#each), only no more than `limit` `iterator`s will be simultaneously \\n+running at any time.\\n+\\n+Note that the items in `arr` are not processed in batches, so there is no guarantee that \\n+the first `limit` `iterator` functions will complete before any others are started.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err)` which must be called once it has \\n+  completed. If no error has occured, the callback should be run without \\n+  arguments or with an explicit `null` argument.\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\n+  have finished, or an error occurs.\\n+\\n+__Example__\\n+\\n+```js\\n+// Assume documents is an array of JSON objects and requestApi is a\\n+// function that interacts with a rate-limited REST api.\\n+\\n+async.eachLimit(documents, 20, requestApi, function(err){\\n+    // if any of the saves produced an error, err would equal that error\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"map\\\" />\\n+### map(arr, iterator, callback)\\n+\\n+Produces a new array of values by mapping each value in `arr` through\\n+the `iterator` function. The `iterator` is called with an item from `arr` and a\\n+callback for when it has finished processing. Each of these callback takes 2 arguments: \\n+an `error`, and the transformed item from `arr`. If `iterator` passes an error to this \\n+callback, the main `callback` (for the `map` function) is immediately called with the error.\\n+\\n+Note, that since this function applies the `iterator` to each item in parallel,\\n+there is no guarantee that the `iterator` functions will complete in order. \\n+However, the results array will be in the same order as the original `arr`.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\n+  it has completed with an error (which can be `null`) and a transformed item.\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\n+  functions have finished, or an error occurs. Results is an array of the\\n+  transformed items from the `arr`.\\n+\\n+__Example__\\n+\\n+```js\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\n+    // results is now an array of stats for each file\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"mapSeries\\\" />\\n+### mapSeries(arr, iterator, callback)\\n+\\n+The same as [`map`](#map), only the `iterator` is applied to each item in `arr` in\\n+series. The next `iterator` is only called once the current one has completed. \\n+The results array will be in the same order as the original.\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"mapLimit\\\" />\\n+### mapLimit(arr, limit, iterator, callback)\\n+\\n+The same as [`map`](#map), only no more than `limit` `iterator`s will be simultaneously \\n+running at any time.\\n+\\n+Note that the items are not processed in batches, so there is no guarantee that \\n+the first `limit` `iterator` functions will complete before any others are started.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\n+  it has completed with an error (which can be `null`) and a transformed item.\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\n+  calls have finished, or an error occurs. The result is an array of the\\n+  transformed items from the original `arr`.\\n+\\n+__Example__\\n+\\n+```js\\n+async.mapLimit(['file1','file2','file3'], 1, fs.stat, function(err, results){\\n+    // results is now an array of stats for each file\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"select\\\" />\\n+<a name=\\\"filter\\\" />\\n+### filter(arr, iterator, callback)\\n+\\n+__Alias:__ `select`\\n+\\n+Returns a new array of all the values in `arr` which pass an async truth test.\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\n+way node libraries work with truth tests like `fs.exists`. This operation is\\n+performed in parallel, but the results array will be in the same order as the\\n+original.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\n+  The `iterator` is passed a `callback(truthValue)`, which must be called with a \\n+  boolean argument once it has completed.\\n+* `callback(results)` - A callback which is called after all the `iterator`\\n+  functions have finished.\\n+\\n+__Example__\\n+\\n+```js\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\n+    // results now equals an array of the existing files\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"selectSeries\\\" />\\n+<a name=\\\"filterSeries\\\" />\\n+### filterSeries(arr, iterator, callback)\\n+\\n+__Alias:__ `selectSeries`\\n+\\n+The same as [`filter`](#filter) only the `iterator` is applied to each item in `arr` in\\n+series. The next `iterator` is only called once the current one has completed. \\n+The results array will be in the same order as the original.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"reject\\\" />\\n+### reject(arr, iterator, callback)\\n+\\n+The opposite of [`filter`](#filter). Removes values that pass an `async` truth test.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"rejectSeries\\\" />\\n+### rejectSeries(arr, iterator, callback)\\n+\\n+The same as [`reject`](#reject), only the `iterator` is applied to each item in `arr`\\n+in series.\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"reduce\\\" />\\n+### reduce(arr, memo, iterator, callback)\\n+\\n+__Aliases:__ `inject`, `foldl`\\n+\\n+Reduces `arr` into a single value using an async `iterator` to return\\n+each successive step. `memo` is the initial state of the reduction. \\n+This function only operates in series. \\n+\\n+For performance reasons, it may make sense to split a call to this function into \\n+a parallel map, and then use the normal `Array.prototype.reduce` on the results. \\n+This function is for situations where each step in the reduction needs to be async; \\n+if you can get the data before reducing it, then it's probably a good idea to do so.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `memo` - The initial state of the reduction.\\n+* `iterator(memo, item, callback)` - A function applied to each item in the\\n+  array to produce the next step in the reduction. The `iterator` is passed a\\n+  `callback(err, reduction)` which accepts an optional error as its first \\n+  argument, and the state of the reduction as the second. If an error is \\n+  passed to the callback, the reduction is stopped and the main `callback` is \\n+  immediately called with the error.\\n+* `callback(err, result)` - A callback which is called after all the `iterator`\\n+  functions have finished. Result is the reduced value.\\n+\\n+__Example__\\n+\\n+```js\\n+async.reduce([1,2,3], 0, function(memo, item, callback){\\n+    // pointless async:\\n+    process.nextTick(function(){\\n+        callback(null, memo + item)\\n+    });\\n+}, function(err, result){\\n+    // result is now equal to the last value of memo, which is 6\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"reduceRight\\\" />\\n+### reduceRight(arr, memo, iterator, callback)\\n+\\n+__Alias:__ `foldr`\\n+\\n+Same as [`reduce`](#reduce), only operates on `arr` in reverse order.\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"detect\\\" />\\n+### detect(arr, iterator, callback)\\n+\\n+Returns the first value in `arr` that passes an async truth test. The\\n+`iterator` is applied in parallel, meaning the first iterator to return `true` will\\n+fire the detect `callback` with that result. That means the result might not be\\n+the first item in the original `arr` (in terms of order) that passes the test.\\n+\\n+If order within the original `arr` is important, then look at [`detectSeries`](#detectSeries).\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\n+  The iterator is passed a `callback(truthValue)` which must be called with a \\n+  boolean argument once it has completed.\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\n+  `true`, or after all the `iterator` functions have finished. Result will be\\n+  the first item in the array that passes the truth test (iterator) or the\\n+  value `undefined` if none passed.\\n+\\n+__Example__\\n+\\n+```js\\n+async.detect(['file1','file2','file3'], fs.exists, function(result){\\n+    // result now equals the first file in the list that exists\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"detectSeries\\\" />\\n+### detectSeries(arr, iterator, callback)\\n+\\n+The same as [`detect`](#detect), only the `iterator` is applied to each item in `arr`\\n+in series. This means the result is always the first in the original `arr` (in\\n+terms of array order) that passes the truth test.\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"sortBy\\\" />\\n+### sortBy(arr, iterator, callback)\\n+\\n+Sorts a list by the results of running each `arr` value through an async `iterator`.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err, sortValue)` which must be called once it\\n+  has completed with an error (which can be `null`) and a value to use as the sort\\n+  criteria.\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\n+  functions have finished, or an error occurs. Results is the items from\\n+  the original `arr` sorted by the values returned by the `iterator` calls.\\n+\\n+__Example__\\n+\\n+```js\\n+async.sortBy(['file1','file2','file3'], function(file, callback){\\n+    fs.stat(file, function(err, stats){\\n+        callback(err, stats.mtime);\\n+    });\\n+}, function(err, results){\\n+    // results is now the original array of files sorted by\\n+    // modified date\\n+});\\n+```\\n+\\n+__Sort Order__\\n+\\n+By modifying the callback parameter the sorting order can be influenced:\\n+\\n+```js\\n+//ascending order\\n+async.sortBy([1,9,3,5], function(x, callback){\\n+    callback(err, x);\\n+}, function(err,result){\\n+    //result callback\\n+} );\\n+\\n+//descending order\\n+async.sortBy([1,9,3,5], function(x, callback){\\n+    callback(err, x*-1);    //<- x*-1 instead of x, turns the order around\\n+}, function(err,result){\\n+    //result callback\\n+} );\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"some\\\" />\\n+### some(arr, iterator, callback)\\n+\\n+__Alias:__ `any`\\n+\\n+Returns `true` if at least one element in the `arr` satisfies an async test.\\n+_The callback for each iterator call only accepts a single argument of `true` or\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\n+way node libraries work with truth tests like `fs.exists`. Once any iterator\\n+call returns `true`, the main `callback` is immediately called.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\n+  called with a boolean argument once it has completed.\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\n+  `true`, or after all the iterator functions have finished. Result will be\\n+  either `true` or `false` depending on the values of the async tests.\\n+\\n+__Example__\\n+\\n+```js\\n+async.some(['file1','file2','file3'], fs.exists, function(result){\\n+    // if result is true then at least one of the files exists\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"every\\\" />\\n+### every(arr, iterator, callback)\\n+\\n+__Alias:__ `all`\\n+\\n+Returns `true` if every element in `arr` satisfies an async test.\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\n+way node libraries work with truth tests like `fs.exists`.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\n+  called with a  boolean argument once it has completed.\\n+* `callback(result)` - A callback which is called after all the `iterator`\\n+  functions have finished. Result will be either `true` or `false` depending on\\n+  the values of the async tests.\\n+\\n+__Example__\\n+\\n+```js\\n+async.every(['file1','file2','file3'], fs.exists, function(result){\\n+    // if result is true then every file exists\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"concat\\\" />\\n+### concat(arr, iterator, callback)\\n+\\n+Applies `iterator` to each item in `arr`, concatenating the results. Returns the\\n+concatenated list. The `iterator`s are called in parallel, and the results are\\n+concatenated as they return. There is no guarantee that the results array will\\n+be returned in the original order of `arr` passed to the `iterator` function.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err, results)` which must be called once it \\n+  has completed with an error (which can be `null`) and an array of results.\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\n+  functions have finished, or an error occurs. Results is an array containing\\n+  the concatenated results of the `iterator` function.\\n+\\n+__Example__\\n+\\n+```js\\n+async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files){\\n+    // files is now a list of filenames that exist in the 3 directories\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"concatSeries\\\" />\\n+### concatSeries(arr, iterator, callback)\\n+\\n+Same as [`concat`](#concat), but executes in series instead of parallel.\\n+\\n+\\n+## Control Flow\\n+\\n+<a name=\\\"series\\\" />\\n+### series(tasks, [callback])\\n+\\n+Run the functions in the `tasks` array in series, each one running once the previous\\n+function has completed. If any functions in the series pass an error to its\\n+callback, no more functions are run, and `callback` is immediately called with the value of the error. \\n+Otherwise, `callback` receives an array of results when `tasks` have completed.\\n+\\n+It is also possible to use an object instead of an array. Each property will be\\n+run as a function, and the results will be passed to the final `callback` as an object\\n+instead of an array. This can be a more readable way of handling results from\\n+[`series`](#series).\\n+\\n+**Note** that while many implementations preserve the order of object properties, the\\n+[ECMAScript Language Specifcation](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6) \\n+explicitly states that\\n+\\n+> The mechanics and order of enumerating the properties is not specified.\\n+\\n+So if you rely on the order in which your series of functions are executed, and want\\n+this to work on all platforms, consider using an array. \\n+\\n+__Arguments__\\n+\\n+* `tasks` - An array or object containing functions to run, each function is passed\\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\n+  be `null`) and an optional `result` value.\\n+* `callback(err, results)` - An optional callback to run once all the functions\\n+  have completed. This function gets a results array (or object) containing all \\n+  the result arguments passed to the `task` callbacks.\\n+\\n+__Example__\\n+\\n+```js\\n+async.series([\\n+    function(callback){\\n+        // do some stuff ...\\n+        callback(null, 'one');\\n+    },\\n+    function(callback){\\n+        // do some more stuff ...\\n+        callback(null, 'two');\\n+    }\\n+],\\n+// optional callback\\n+function(err, results){\\n+    // results is now equal to ['one', 'two']\\n+});\\n+\\n+\\n+// an example using an object instead of an array\\n+async.series({\\n+    one: function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 1);\\n+        }, 200);\\n+    },\\n+    two: function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 2);\\n+        }, 100);\\n+    }\\n+},\\n+function(err, results) {\\n+    // results is now equal to: {one: 1, two: 2}\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"parallel\\\" />\\n+### parallel(tasks, [callback])\\n+\\n+Run the `tasks` array of functions in parallel, without waiting until the previous\\n+function has completed. If any of the functions pass an error to its\\n+callback, the main `callback` is immediately called with the value of the error.\\n+Once the `tasks` have completed, the results are passed to the final `callback` as an\\n+array.\\n+\\n+It is also possible to use an object instead of an array. Each property will be\\n+run as a function and the results will be passed to the final `callback` as an object\\n+instead of an array. This can be a more readable way of handling results from\\n+[`parallel`](#parallel).\\n+\\n+\\n+__Arguments__\\n+\\n+* `tasks` - An array or object containing functions to run. Each function is passed \\n+  a `callback(err, result)` which it must call on completion with an error `err` \\n+  (which can be `null`) and an optional `result` value.\\n+* `callback(err, results)` - An optional callback to run once all the functions\\n+  have completed. This function gets a results array (or object) containing all \\n+  the result arguments passed to the task callbacks.\\n+\\n+__Example__\\n+\\n+```js\\n+async.parallel([\\n+    function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 'one');\\n+        }, 200);\\n+    },\\n+    function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 'two');\\n+        }, 100);\\n+    }\\n+],\\n+// optional callback\\n+function(err, results){\\n+    // the results array will equal ['one','two'] even though\\n+    // the second function had a shorter timeout.\\n+});\\n+\\n+\\n+// an example using an object instead of an array\\n+async.parallel({\\n+    one: function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 1);\\n+        }, 200);\\n+    },\\n+    two: function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 2);\\n+        }, 100);\\n+    }\\n+},\\n+function(err, results) {\\n+    // results is now equals to: {one: 1, two: 2}\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"parallelLimit\\\" />\\n+### parallelLimit(tasks, limit, [callback])\\n+\\n+The same as [`parallel`](#parallel), only `tasks` are executed in parallel \\n+with a maximum of `limit` tasks executing at any time.\\n+\\n+Note that the `tasks` are not executed in batches, so there is no guarantee that \\n+the first `limit` tasks will complete before any others are started.\\n+\\n+__Arguments__\\n+\\n+* `tasks` - An array or object containing functions to run, each function is passed \\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\n+  be `null`) and an optional `result` value.\\n+* `limit` - The maximum number of `tasks` to run at any time.\\n+* `callback(err, results)` - An optional callback to run once all the functions\\n+  have completed. This function gets a results array (or object) containing all \\n+  the result arguments passed to the `task` callbacks.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"whilst\\\" />\\n+### whilst(test, fn, callback)\\n+\\n+Repeatedly call `fn`, while `test` returns `true`. Calls `callback` when stopped,\\n+or an error occurs.\\n+\\n+__Arguments__\\n+\\n+* `test()` - synchronous truth test to perform before each execution of `fn`.\\n+* `fn(callback)` - A function which is called each time `test` passes. The function is\\n+  passed a `callback(err)`, which must be called once it has completed with an \\n+  optional `err` argument.\\n+* `callback(err)` - A callback which is called after the test fails and repeated\\n+  execution of `fn` has stopped.\\n+\\n+__Example__\\n+\\n+```js\\n+var count = 0;\\n+\\n+async.whilst(\\n+    function () { return count < 5; },\\n+    function (callback) {\\n+        count++;\\n+        setTimeout(callback, 1000);\\n+    },\\n+    function (err) {\\n+        // 5 seconds have passed\\n+    }\\n+);\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"doWhilst\\\" />\\n+### doWhilst(fn, test, callback)\\n+\\n+The post-check version of [`whilst`](#whilst). To reflect the difference in \\n+the order of operations, the arguments `test` and `fn` are switched. \\n+\\n+`doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"until\\\" />\\n+### until(test, fn, callback)\\n+\\n+Repeatedly call `fn` until `test` returns `true`. Calls `callback` when stopped,\\n+or an error occurs.\\n+\\n+The inverse of [`whilst`](#whilst).\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"doUntil\\\" />\\n+### doUntil(fn, test, callback)\\n+\\n+Like [`doWhilst`](#doWhilst), except the `test` is inverted. Note the argument ordering differs from `until`.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"forever\\\" />\\n+### forever(fn, errback)\\n+\\n+Calls the asynchronous function `fn` with a callback parameter that allows it to\\n+call itself again, in series, indefinitely.\\n+\\n+If an error is passed to the callback then `errback` is called with the\\n+error, and execution stops, otherwise it will never be called.\\n+\\n+```js\\n+async.forever(\\n+    function(next) {\\n+        // next is suitable for passing to things that need a callback(err [, whatever]);\\n+        // it will result in this function being called again.\\n+    },\\n+    function(err) {\\n+        // if next is called with a value in its first parameter, it will appear\\n+        // in here as 'err', and execution will stop.\\n+    }\\n+);\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"waterfall\\\" />\\n+### waterfall(tasks, [callback])\\n+\\n+Runs the `tasks` array of functions in series, each passing their results to the next in\\n+the array. However, if any of the `tasks` pass an error to their own callback, the\\n+next function is not executed, and the main `callback` is immediately called with\\n+the error.\\n+\\n+__Arguments__\\n+\\n+* `tasks` - An array of functions to run, each function is passed a \\n+  `callback(err, result1, result2, ...)` it must call on completion. The first\\n+  argument is an error (which can be `null`) and any further arguments will be \\n+  passed as arguments in order to the next task.\\n+* `callback(err, [results])` - An optional callback to run once all the functions\\n+  have completed. This will be passed the results of the last task's callback.\\n+\\n+\\n+\\n+__Example__\\n+\\n+```js\\n+async.waterfall([\\n+    function(callback){\\n+        callback(null, 'one', 'two');\\n+    },\\n+    function(arg1, arg2, callback){\\n+      // arg1 now equals 'one' and arg2 now equals 'two'\\n+        callback(null, 'three');\\n+    },\\n+    function(arg1, callback){\\n+        // arg1 now equals 'three'\\n+        callback(null, 'done');\\n+    }\\n+], function (err, result) {\\n+   // result now equals 'done'    \\n+});\\n+```\\n+\\n+---------------------------------------\\n+<a name=\\\"compose\\\" />\\n+### compose(fn1, fn2...)\\n+\\n+Creates a function which is a composition of the passed asynchronous\\n+functions. Each function consumes the return value of the function that\\n+follows. Composing functions `f()`, `g()`, and `h()` would produce the result of\\n+`f(g(h()))`, only this version uses callbacks to obtain the return values.\\n+\\n+Each function is executed with the `this` binding of the composed function.\\n+\\n+__Arguments__\\n+\\n+* `functions...` - the asynchronous functions to compose\\n+\\n+\\n+__Example__\\n+\\n+```js\\n+function add1(n, callback) {\\n+    setTimeout(function () {\\n+        callback(null, n + 1);\\n+    }, 10);\\n+}\\n+\\n+function mul3(n, callback) {\\n+    setTimeout(function () {\\n+        callback(null, n * 3);\\n+    }, 10);\\n+}\\n+\\n+var add1mul3 = async.compose(mul3, add1);\\n+\\n+add1mul3(4, function (err, result) {\\n+   // result now equals 15\\n+});\\n+```\\n+\\n+---------------------------------------\\n+<a name=\\\"seq\\\" />\\n+### seq(fn1, fn2...)\\n+\\n+Version of the compose function that is more natural to read.\\n+Each following function consumes the return value of the latter function. \\n+\\n+Each function is executed with the `this` binding of the composed function.\\n+\\n+__Arguments__\\n+\\n+* functions... - the asynchronous functions to compose\\n+\\n+\\n+__Example__\\n+\\n+```js\\n+// Requires lodash (or underscore), express3 and dresende's orm2.\\n+// Part of an app, that fetches cats of the logged user.\\n+// This example uses `seq` function to avoid overnesting and error \\n+// handling clutter.\\n+app.get('/cats', function(request, response) {\\n+  function handleError(err, data, callback) {\\n+    if (err) {\\n+      console.error(err);\\n+      response.json({ status: 'error', message: err.message });\\n+    }\\n+    else {\\n+      callback(data);\\n+    }\\n+  }\\n+  var User = request.models.User;\\n+  async.seq(\\n+    _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\\n+    handleError,\\n+    function(user, fn) {\\n+      user.getCats(fn);      // 'getCats' has signature (callback(err, data))\\n+    },\\n+    handleError,\\n+    function(cats) {\\n+      response.json({ status: 'ok', message: 'Cats found', data: cats });\\n+    }\\n+  )(req.session.user_id);\\n+  }\\n+});\\n+```\\n+\\n+---------------------------------------\\n+<a name=\\\"applyEach\\\" />\\n+### applyEach(fns, args..., callback)\\n+\\n+Applies the provided arguments to each function in the array, calling \\n+`callback` after all functions have completed. If you only provide the first\\n+argument, then it will return a function which lets you pass in the\\n+arguments as if it were a single function call.\\n+\\n+__Arguments__\\n+\\n+* `fns` - the asynchronous functions to all call with the same arguments\\n+* `args...` - any number of separate arguments to pass to the function\\n+* `callback` - the final argument should be the callback, called when all\\n+  functions have completed processing\\n+\\n+\\n+__Example__\\n+\\n+```js\\n+async.applyEach([enableSearch, updateSchema], 'bucket', callback);\\n+\\n+// partial application example:\\n+async.each(\\n+    buckets,\\n+    async.applyEach([enableSearch, updateSchema]),\\n+    callback\\n+);\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"applyEachSeries\\\" />\\n+### applyEachSeries(arr, iterator, callback)\\n+\\n+The same as [`applyEach`](#applyEach) only the functions are applied in series.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"queue\\\" />\\n+### queue(worker, concurrency)\\n+\\n+Creates a `queue` object with the specified `concurrency`. Tasks added to the\\n+`queue` are processed in parallel (up to the `concurrency` limit). If all\\n+`worker`s are in progress, the task is queued until one becomes available. \\n+Once a `worker` completes a `task`, that `task`'s callback is called.\\n+\\n+__Arguments__\\n+\\n+* `worker(task, callback)` - An asynchronous function for processing a queued\\n+  task, which must call its `callback(err)` argument when finished, with an \\n+  optional `error` as an argument.\\n+* `concurrency` - An `integer` for determining how many `worker` functions should be\\n+  run in parallel.\\n+\\n+__Queue objects__\\n+\\n+The `queue` object returned by this function has the following properties and\\n+methods:\\n+\\n+* `length()` - a function returning the number of items waiting to be processed.\\n+* `started` - a function returning whether or not any items have been pushed and processed by the queue\\n+* `running()` - a function returning the number of items currently being processed.\\n+* `idle()` - a function returning false if there are items waiting or being processed, or true if not.\\n+* `concurrency` - an integer for determining how many `worker` functions should be\\n+  run in parallel. This property can be changed after a `queue` is created to\\n+  alter the concurrency on-the-fly.\\n+* `push(task, [callback])` - add a new task to the `queue`. Calls `callback` once \\n+  the `worker` has finished processing the task. Instead of a single task, a `tasks` array\\n+  can be submitted. The respective callback is used for every task in the list.\\n+* `unshift(task, [callback])` - add a new task to the front of the `queue`.\\n+* `saturated` - a callback that is called when the `queue` length hits the `concurrency` limit, \\n+   and further tasks will be queued.\\n+* `empty` - a callback that is called when the last item from the `queue` is given to a `worker`.\\n+* `drain` - a callback that is called when the last item from the `queue` has returned from the `worker`.\\n+* `paused` - a boolean for determining whether the queue is in a paused state\\n+* `pause()` - a function that pauses the processing of tasks until `resume()` is called.\\n+* `resume()` - a function that resumes the processing of queued tasks when the queue is paused.\\n+* `kill()` - a function that empties remaining tasks from the queue forcing it to go idle.\\n+\\n+__Example__\\n+\\n+```js\\n+// create a queue object with concurrency 2\\n+\\n+var q = async.queue(function (task, callback) {\\n+    console.log('hello ' + task.name);\\n+    callback();\\n+}, 2);\\n+\\n+\\n+// assign a callback\\n+q.drain = function() {\\n+    console.log('all items have been processed');\\n+}\\n+\\n+// add some items to the queue\\n+\\n+q.push({name: 'foo'}, function (err) {\\n+    console.log('finished processing foo');\\n+});\\n+q.push({name: 'bar'}, function (err) {\\n+    console.log('finished processing bar');\\n+});\\n+\\n+// add some items to the queue (batch-wise)\\n+\\n+q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function (err) {\\n+    console.log('finished processing bar');\\n+});\\n+\\n+// add some items to the front of the queue\\n+\\n+q.unshift({name: 'bar'}, function (err) {\\n+    console.log('finished processing bar');\\n+});\\n+```\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"priorityQueue\\\" />\\n+### priorityQueue(worker, concurrency)\\n+\\n+The same as [`queue`](#queue) only tasks are assigned a priority and completed in ascending priority order. There are two differences between `queue` and `priorityQueue` objects:\\n+\\n+* `push(task, priority, [callback])` - `priority` should be a number. If an array of\\n+  `tasks` is given, all tasks will be assigned the same priority.\\n+* The `unshift` method was removed.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"cargo\\\" />\\n+### cargo(worker, [payload])\\n+\\n+Creates a `cargo` object with the specified payload. Tasks added to the\\n+cargo will be processed altogether (up to the `payload` limit). If the\\n+`worker` is in progress, the task is queued until it becomes available. Once\\n+the `worker` has completed some tasks, each callback of those tasks is called.\\n+Check out [this animation](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) for how `cargo` and `queue` work.\\n+\\n+While [queue](#queue) passes only one task to one of a group of workers\\n+at a time, cargo passes an array of tasks to a single worker, repeating\\n+when the worker is finished.\\n+\\n+__Arguments__\\n+\\n+* `worker(tasks, callback)` - An asynchronous function for processing an array of\\n+  queued tasks, which must call its `callback(err)` argument when finished, with \\n+  an optional `err` argument.\\n+* `payload` - An optional `integer` for determining how many tasks should be\\n+  processed per round; if omitted, the default is unlimited.\\n+\\n+__Cargo objects__\\n+\\n+The `cargo` object returned by this function has the following properties and\\n+methods:\\n+\\n+* `length()` - A function returning the number of items waiting to be processed.\\n+* `payload` - An `integer` for determining how many tasks should be\\n+  process per round. This property can be changed after a `cargo` is created to\\n+  alter the payload on-the-fly.\\n+* `push(task, [callback])` - Adds `task` to the `queue`. The callback is called\\n+  once the `worker` has finished processing the task. Instead of a single task, an array of `tasks` \\n+  can be submitted. The respective callback is used for every task in the list.\\n+* `saturated` - A callback that is called when the `queue.length()` hits the concurrency and further tasks will be queued.\\n+* `empty` - A callback that is called when the last item from the `queue` is given to a `worker`.\\n+* `drain` - A callback that is called when the last item from the `queue` has returned from the `worker`.\\n+\\n+__Example__\\n+\\n+```js\\n+// create a cargo object with payload 2\\n+\\n+var cargo = async.cargo(function (tasks, callback) {\\n+    for(var i=0; i<tasks.length; i++){\\n+      console.log('hello ' + tasks[i].name);\\n+    }\\n+    callback();\\n+}, 2);\\n+\\n+\\n+// add some items\\n+\\n+cargo.push({name: 'foo'}, function (err) {\\n+    console.log('finished processing foo');\\n+});\\n+cargo.push({name: 'bar'}, function (err) {\\n+    console.log('finished processing bar');\\n+});\\n+cargo.push({name: 'baz'}, function (err) {\\n+    console.log('finished processing baz');\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"auto\\\" />\\n+### auto(tasks, [callback])\\n+\\n+Determines the best order for running the functions in `tasks`, based on their \\n+requirements. Each function can optionally depend on other functions being completed \\n+first, and each function is run as soon as its requirements are satisfied. \\n+\\n+If any of the functions pass an error to their callback, it will not \\n+complete (so any other functions depending on it will not run), and the main \\n+`callback` is immediately called with the error. Functions also receive an \\n+object containing the results of functions which have completed so far.\\n+\\n+Note, all functions are called with a `results` object as a second argument, \\n+so it is unsafe to pass functions in the `tasks` object which cannot handle the\\n+extra argument. \\n+\\n+For example, this snippet of code:\\n+\\n+```js\\n+async.auto({\\n+  readData: async.apply(fs.readFile, 'data.txt', 'utf-8')\\n+}, callback);\\n+```\\n+\\n+will have the effect of calling `readFile` with the results object as the last\\n+argument, which will fail:\\n+\\n+```js\\n+fs.readFile('data.txt', 'utf-8', cb, {});\\n+```\\n+\\n+Instead, wrap the call to `readFile` in a function which does not forward the \\n+`results` object:\\n+\\n+```js\\n+async.auto({\\n+  readData: function(cb, results){\\n+    fs.readFile('data.txt', 'utf-8', cb);\\n+  }\\n+}, callback);\\n+```\\n+\\n+__Arguments__\\n+\\n+* `tasks` - An object. Each of its properties is either a function or an array of\\n+  requirements, with the function itself the last item in the array. The object's key\\n+  of a property serves as the name of the task defined by that property,\\n+  i.e. can be used when specifying requirements for other tasks.\\n+  The function receives two arguments: (1) a `callback(err, result)` which must be \\n+  called when finished, passing an `error` (which can be `null`) and the result of \\n+  the function's execution, and (2) a `results` object, containing the results of\\n+  the previously executed functions.\\n+* `callback(err, results)` - An optional callback which is called when all the\\n+  tasks have been completed. It receives the `err` argument if any `tasks` \\n+  pass an error to their callback. Results are always returned; however, if \\n+  an error occurs, no further `tasks` will be performed, and the results\\n+  object will only contain partial results.\\n+\\n+\\n+__Example__\\n+\\n+```js\\n+async.auto({\\n+    get_data: function(callback){\\n+        console.log('in get_data');\\n+        // async code to get some data\\n+        callback(null, 'data', 'converted to array');\\n+    },\\n+    make_folder: function(callback){\\n+        console.log('in make_folder');\\n+        // async code to create a directory to store a file in\\n+        // this is run at the same time as getting the data\\n+        callback(null, 'folder');\\n+    },\\n+    write_file: ['get_data', 'make_folder', function(callback, results){\\n+        console.log('in write_file', JSON.stringify(results));\\n+        // once there is some data and the directory exists,\\n+        // write the data to a file in the directory\\n+        callback(null, 'filename');\\n+    }],\\n+    email_link: ['write_file', function(callback, results){\\n+        console.log('in email_link', JSON.stringify(results));\\n+        // once the file is written let's email a link to it...\\n+        // results.write_file contains the filename returned by write_file.\\n+        callback(null, {'file':results.write_file, 'email':'user@example.com'});\\n+    }]\\n+}, function(err, results) {\\n+    console.log('err = ', err);\\n+    console.log('results = ', results);\\n+});\\n+```\\n+\\n+This is a fairly trivial example, but to do this using the basic parallel and\\n+series functions would look like this:\\n+\\n+```js\\n+async.parallel([\\n+    function(callback){\\n+        console.log('in get_data');\\n+        // async code to get some data\\n+        callback(null, 'data', 'converted to array');\\n+    },\\n+    function(callback){\\n+        console.log('in make_folder');\\n+        // async code to create a directory to store a file in\\n+        // this is run at the same time as getting the data\\n+        callback(null, 'folder');\\n+    }\\n+],\\n+function(err, results){\\n+    async.series([\\n+        function(callback){\\n+            console.log('in write_file', JSON.stringify(results));\\n+            // once there is some data and the directory exists,\\n+            // write the data to a file in the directory\\n+            results.push('filename');\\n+            callback(null);\\n+        },\\n+        function(callback){\\n+            console.log('in email_link', JSON.stringify(results));\\n+            // once the file is written let's email a link to it...\\n+            callback(null, {'file':results.pop(), 'email':'user@example.com'});\\n+        }\\n+    ]);\\n+});\\n+```\\n+\\n+For a complicated series of `async` tasks, using the [`auto`](#auto) function makes adding\\n+new tasks much easier (and the code more readable).\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"retry\\\" />\\n+### retry([times = 5], task, [callback])\\n+\\n+Attempts to get a successful response from `task` no more than `times` times before\\n+returning an error. If the task is successful, the `callback` will be passed the result\\n+of the successfull task. If all attemps fail, the callback will be passed the error and\\n+result (if any) of the final attempt.\\n+\\n+__Arguments__\\n+\\n+* `times` - An integer indicating how many times to attempt the `task` before giving up. Defaults to 5.\\n+* `task(callback, results)` - A function which receives two arguments: (1) a `callback(err, result)`\\n+  which must be called when finished, passing `err` (which can be `null`) and the `result` of \\n+  the function's execution, and (2) a `results` object, containing the results of\\n+  the previously executed functions (if nested inside another control flow).\\n+* `callback(err, results)` - An optional callback which is called when the\\n+  task has succeeded, or after the final failed attempt. It receives the `err` and `result` arguments of the last attempt at completing the `task`.\\n+\\n+The [`retry`](#retry) function can be used as a stand-alone control flow by passing a\\n+callback, as shown below:\\n+\\n+```js\\n+async.retry(3, apiMethod, function(err, result) {\\n+    // do something with the result\\n+});\\n+```\\n+\\n+It can also be embeded within other control flow functions to retry individual methods\\n+that are not as reliable, like this:\\n+\\n+```js\\n+async.auto({\\n+    users: api.getUsers.bind(api),\\n+    payments: async.retry(3, api.getPayments.bind(api))\\n+}, function(err, results) {\\n+  // do something with the results\\n+});\\n+```\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"iterator\\\" />\\n+### iterator(tasks)\\n+\\n+Creates an iterator function which calls the next function in the `tasks` array,\\n+returning a continuation to call the next one after that. It's also possible to\\n+“peek” at the next iterator with `iterator.next()`.\\n+\\n+This function is used internally by the `async` module, but can be useful when\\n+you want to manually control the flow of functions in series.\\n+\\n+__Arguments__\\n+\\n+* `tasks` - An array of functions to run.\\n+\\n+__Example__\\n+\\n+```js\\n+var iterator = async.iterator([\\n+    function(){ sys.p('one'); },\\n+    function(){ sys.p('two'); },\\n+    function(){ sys.p('three'); }\\n+]);\\n+\\n+node> var iterator2 = iterator();\\n+'one'\\n+node> var iterator3 = iterator2();\\n+'two'\\n+node> iterator3();\\n+'three'\\n+node> var nextfn = iterator2.next();\\n+node> nextfn();\\n+'three'\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"apply\\\" />\\n+### apply(function, arguments..)\\n+\\n+Creates a continuation function with some arguments already applied. \\n+\\n+Useful as a shorthand when combined with other control flow functions. Any arguments\\n+passed to the returned function are added to the arguments originally passed\\n+to apply.\\n+\\n+__Arguments__\\n+\\n+* `function` - The function you want to eventually apply all arguments to.\\n+* `arguments...` - Any number of arguments to automatically apply when the\\n+  continuation is called.\\n+\\n+__Example__\\n+\\n+```js\\n+// using apply\\n+\\n+async.parallel([\\n+    async.apply(fs.writeFile, 'testfile1', 'test1'),\\n+    async.apply(fs.writeFile, 'testfile2', 'test2'),\\n+]);\\n+\\n+\\n+// the same process without using apply\\n+\\n+async.parallel([\\n+    function(callback){\\n+        fs.writeFile('testfile1', 'test1', callback);\\n+    },\\n+    function(callback){\\n+        fs.writeFile('testfile2', 'test2', callback);\\n+    }\\n+]);\\n+```\\n+\\n+It's possible to pass any number of additional arguments when calling the\\n+continuation:\\n+\\n+```js\\n+node> var fn = async.apply(sys.puts, 'one');\\n+node> fn('two', 'three');\\n+one\\n+two\\n+three\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"nextTick\\\" />\\n+### nextTick(callback)\\n+\\n+Calls `callback` on a later loop around the event loop. In Node.js this just\\n+calls `process.nextTick`; in the browser it falls back to `setImmediate(callback)`\\n+if available, otherwise `setTimeout(callback, 0)`, which means other higher priority\\n+events may precede the execution of `callback`.\\n+\\n+This is used internally for browser-compatibility purposes.\\n+\\n+__Arguments__\\n+\\n+* `callback` - The function to call on a later loop around the event loop.\\n+\\n+__Example__\\n+\\n+```js\\n+var call_order = [];\\n+async.nextTick(function(){\\n+    call_order.push('two');\\n+    // call_order now equals ['one','two']\\n+});\\n+call_order.push('one')\\n+```\\n+\\n+<a name=\\\"times\\\" />\\n+### times(n, callback)\\n+\\n+Calls the `callback` function `n` times, and accumulates results in the same manner\\n+you would use with [`map`](#map).\\n+\\n+__Arguments__\\n+\\n+* `n` - The number of times to run the function.\\n+* `callback` - The function to call `n` times.\\n+\\n+__Example__\\n+\\n+```js\\n+// Pretend this is some complicated async factory\\n+var createUser = function(id, callback) {\\n+  callback(null, {\\n+    id: 'user' + id\\n+  })\\n+}\\n+// generate 5 users\\n+async.times(5, function(n, next){\\n+    createUser(n, function(err, user) {\\n+      next(err, user)\\n+    })\\n+}, function(err, users) {\\n+  // we should now have 5 users\\n+});\\n+```\\n+\\n+<a name=\\\"timesSeries\\\" />\\n+### timesSeries(n, callback)\\n+\\n+The same as [`times`](#times), only the iterator is applied to each item in `arr` in\\n+series. The next `iterator` is only called once the current one has completed. \\n+The results array will be in the same order as the original.\\n+\\n+\\n+## Utils\\n+\\n+<a name=\\\"memoize\\\" />\\n+### memoize(fn, [hasher])\\n+\\n+Caches the results of an `async` function. When creating a hash to store function\\n+results against, the callback is omitted from the hash and an optional hash\\n+function can be used.\\n+\\n+The cache of results is exposed as the `memo` property of the function returned\\n+by `memoize`.\\n+\\n+__Arguments__\\n+\\n+* `fn` - The function to proxy and cache results from.\\n+* `hasher` - Tn optional function for generating a custom hash for storing\\n+  results. It has all the arguments applied to it apart from the callback, and\\n+  must be synchronous.\\n+\\n+__Example__\\n+\\n+```js\\n+var slow_fn = function (name, callback) {\\n+    // do something\\n+    callback(null, result);\\n+};\\n+var fn = async.memoize(slow_fn);\\n+\\n+// fn can now be used as if it were slow_fn\\n+fn('some name', function () {\\n+    // callback\\n+});\\n+```\\n+\\n+<a name=\\\"unmemoize\\\" />\\n+### unmemoize(fn)\\n+\\n+Undoes a [`memoize`](#memoize)d function, reverting it to the original, unmemoized\\n+form. Handy for testing.\\n+\\n+__Arguments__\\n+\\n+* `fn` - the memoized function\\n+\\n+<a name=\\\"log\\\" />\\n+### log(function, arguments)\\n+\\n+Logs the result of an `async` function to the `console`. Only works in Node.js or\\n+in browsers that support `console.log` and `console.error` (such as FF and Chrome).\\n+If multiple arguments are returned from the async function, `console.log` is\\n+called on each argument in order.\\n+\\n+__Arguments__\\n+\\n+* `function` - The function you want to eventually apply all arguments to.\\n+* `arguments...` - Any number of arguments to apply to the function.\\n+\\n+__Example__\\n+\\n+```js\\n+var hello = function(name, callback){\\n+    setTimeout(function(){\\n+        callback(null, 'hello ' + name);\\n+    }, 1000);\\n+};\\n+```\\n+```js\\n+node> async.log(hello, 'world');\\n+'hello world'\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"dir\\\" />\\n+### dir(function, arguments)\\n+\\n+Logs the result of an `async` function to the `console` using `console.dir` to\\n+display the properties of the resulting object. Only works in Node.js or\\n+in browsers that support `console.dir` and `console.error` (such as FF and Chrome).\\n+If multiple arguments are returned from the async function, `console.dir` is\\n+called on each argument in order.\\n+\\n+__Arguments__\\n+\\n+* `function` - The function you want to eventually apply all arguments to.\\n+* `arguments...` - Any number of arguments to apply to the function.\\n+\\n+__Example__\\n+\\n+```js\\n+var hello = function(name, callback){\\n+    setTimeout(function(){\\n+        callback(null, {hello: name});\\n+    }, 1000);\\n+};\\n+```\\n+```js\\n+node> async.dir(hello, 'world');\\n+{hello: 'world'}\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"noConflict\\\" />\\n+### noConflict()\\n+\\n+Changes the value of `async` back to its original value, returning a reference to the\\n+`async` object.\\ndiff --git a/node_modules/async/component.json b/node_modules/async/component.json\\nnew file mode 100644\\nindex 0000000..bbb0115\\n--- /dev/null\\n+++ b/node_modules/async/component.json\\n@@ -0,0 +1,11 @@\\n+{\\n+  \\\"name\\\": \\\"async\\\",\\n+  \\\"repo\\\": \\\"caolan/async\\\",\\n+  \\\"description\\\": \\\"Higher-order functions and common patterns for asynchronous code\\\",\\n+  \\\"version\\\": \\\"0.1.23\\\",\\n+  \\\"keywords\\\": [],\\n+  \\\"dependencies\\\": {},\\n+  \\\"development\\\": {},\\n+  \\\"main\\\": \\\"lib/async.js\\\",\\n+  \\\"scripts\\\": [ \\\"lib/async.js\\\" ]\\n+}\\ndiff --git a/node_modules/async/lib/async.js b/node_modules/async/lib/async.js\\nnew file mode 100644\\nindex 0000000..01e8afc\\n--- /dev/null\\n+++ b/node_modules/async/lib/async.js\\n@@ -0,0 +1,1123 @@\\n+/*!\\n+ * async\\n+ * https://github.com/caolan/async\\n+ *\\n+ * Copyright 2010-2014 Caolan McMahon\\n+ * Released under the MIT license\\n+ */\\n+/*jshint onevar: false, indent:4 */\\n+/*global setImmediate: false, setTimeout: false, console: false */\\n+(function () {\\n+\\n+    var async = {};\\n+\\n+    // global on the server, window in the browser\\n+    var root, previous_async;\\n+\\n+    root = this;\\n+    if (root != null) {\\n+      previous_async = root.async;\\n+    }\\n+\\n+    async.noConflict = function () {\\n+        root.async = previous_async;\\n+        return async;\\n+    };\\n+\\n+    function only_once(fn) {\\n+        var called = false;\\n+        return function() {\\n+            if (called) throw new Error(\\\"Callback was already called.\\\");\\n+            called = true;\\n+            fn.apply(root, arguments);\\n+        }\\n+    }\\n+\\n+    //// cross-browser compatiblity functions ////\\n+\\n+    var _toString = Object.prototype.toString;\\n+\\n+    var _isArray = Array.isArray || function (obj) {\\n+        return _toString.call(obj) === '[object Array]';\\n+    };\\n+\\n+    var _each = function (arr, iterator) {\\n+        if (arr.forEach) {\\n+            return arr.forEach(iterator);\\n+        }\\n+        for (var i = 0; i < arr.length; i += 1) {\\n+            iterator(arr[i], i, arr);\\n+        }\\n+    };\\n+\\n+    var _map = function (arr, iterator) {\\n+        if (arr.map) {\\n+            return arr.map(iterator);\\n+        }\\n+        var results = [];\\n+        _each(arr, function (x, i, a) {\\n+            results.push(iterator(x, i, a));\\n+        });\\n+        return results;\\n+    };\\n+\\n+    var _reduce = function (arr, iterator, memo) {\\n+        if (arr.reduce) {\\n+            return arr.reduce(iterator, memo);\\n+        }\\n+        _each(arr, function (x, i, a) {\\n+            memo = iterator(memo, x, i, a);\\n+        });\\n+        return memo;\\n+    };\\n+\\n+    var _keys = function (obj) {\\n+        if (Object.keys) {\\n+            return Object.keys(obj);\\n+        }\\n+        var keys = [];\\n+        for (var k in obj) {\\n+            if (obj.hasOwnProperty(k)) {\\n+                keys.push(k);\\n+            }\\n+        }\\n+        return keys;\\n+    };\\n+\\n+    //// exported async module functions ////\\n+\\n+    //// nextTick implementation with browser-compatible fallback ////\\n+    if (typeof process === 'undefined' || !(process.nextTick)) {\\n+        if (typeof setImmediate === 'function') {\\n+            async.nextTick = function (fn) {\\n+                // not a direct alias for IE10 compatibility\\n+                setImmediate(fn);\\n+            };\\n+            async.setImmediate = async.nextTick;\\n+        }\\n+        else {\\n+            async.nextTick = function (fn) {\\n+                setTimeout(fn, 0);\\n+            };\\n+            async.setImmediate = async.nextTick;\\n+        }\\n+    }\\n+    else {\\n+        async.nextTick = process.nextTick;\\n+        if (typeof setImmediate !== 'undefined') {\\n+            async.setImmediate = function (fn) {\\n+              // not a direct alias for IE10 compatibility\\n+              setImmediate(fn);\\n+            };\\n+        }\\n+        else {\\n+            async.setImmediate = async.nextTick;\\n+        }\\n+    }\\n+\\n+    async.each = function (arr, iterator, callback) {\\n+        callback = callback || function () {};\\n+        if (!arr.length) {\\n+            return callback();\\n+        }\\n+        var completed = 0;\\n+        _each(arr, function (x) {\\n+            iterator(x, only_once(done) );\\n+        });\\n+        function done(err) {\\n+          if (err) {\\n+              callback(err);\\n+              callback = function () {};\\n+          }\\n+          else {\\n+              completed += 1;\\n+              if (completed >= arr.length) {\\n+                  callback();\\n+              }\\n+          }\\n+        }\\n+    };\\n+    async.forEach = async.each;\\n+\\n+    async.eachSeries = function (arr, iterator, callback) {\\n+        callback = callback || function () {};\\n+        if (!arr.length) {\\n+            return callback();\\n+        }\\n+        var completed = 0;\\n+        var iterate = function () {\\n+            iterator(arr[completed], function (err) {\\n+                if (err) {\\n+                    callback(err);\\n+                    callback = function () {};\\n+                }\\n+                else {\\n+                    completed += 1;\\n+                    if (completed >= arr.length) {\\n+                        callback();\\n+                    }\\n+                    else {\\n+                        iterate();\\n+                    }\\n+                }\\n+            });\\n+        };\\n+        iterate();\\n+    };\\n+    async.forEachSeries = async.eachSeries;\\n+\\n+    async.eachLimit = function (arr, limit, iterator, callback) {\\n+        var fn = _eachLimit(limit);\\n+        fn.apply(null, [arr, iterator, callback]);\\n+    };\\n+    async.forEachLimit = async.eachLimit;\\n+\\n+    var _eachLimit = function (limit) {\\n+\\n+        return function (arr, iterator, callback) {\\n+            callback = callback || function () {};\\n+            if (!arr.length || limit <= 0) {\\n+                return callback();\\n+            }\\n+            var completed = 0;\\n+            var started = 0;\\n+            var running = 0;\\n+\\n+            (function replenish () {\\n+                if (completed >= arr.length) {\\n+                    return callback();\\n+                }\\n+\\n+                while (running < limit && started < arr.length) {\\n+                    started += 1;\\n+                    running += 1;\\n+                    iterator(arr[started - 1], function (err) {\\n+                        if (err) {\\n+                            callback(err);\\n+                            callback = function () {};\\n+                        }\\n+                        else {\\n+                            completed += 1;\\n+                            running -= 1;\\n+                            if (completed >= arr.length) {\\n+                                callback();\\n+                            }\\n+                            else {\\n+                                replenish();\\n+                            }\\n+                        }\\n+                    });\\n+                }\\n+            })();\\n+        };\\n+    };\\n+\\n+\\n+    var doParallel = function (fn) {\\n+        return function () {\\n+            var args = Array.prototype.slice.call(arguments);\\n+            return fn.apply(null, [async.each].concat(args));\\n+        };\\n+    };\\n+    var doParallelLimit = function(limit, fn) {\\n+        return function () {\\n+            var args = Array.prototype.slice.call(arguments);\\n+            return fn.apply(null, [_eachLimit(limit)].concat(args));\\n+        };\\n+    };\\n+    var doSeries = function (fn) {\\n+        return function () {\\n+            var args = Array.prototype.slice.call(arguments);\\n+            return fn.apply(null, [async.eachSeries].concat(args));\\n+        };\\n+    };\\n+\\n+\\n+    var _asyncMap = function (eachfn, arr, iterator, callback) {\\n+        arr = _map(arr, function (x, i) {\\n+            return {index: i, value: x};\\n+        });\\n+        if (!callback) {\\n+            eachfn(arr, function (x, callback) {\\n+                iterator(x.value, function (err) {\\n+                    callback(err);\\n+                });\\n+            });\\n+        } else {\\n+            var results = [];\\n+            eachfn(arr, function (x, callback) {\\n+                iterator(x.value, function (err, v) {\\n+                    results[x.index] = v;\\n+                    callback(err);\\n+                });\\n+            }, function (err) {\\n+                callback(err, results);\\n+            });\\n+        }\\n+    };\\n+    async.map = doParallel(_asyncMap);\\n+    async.mapSeries = doSeries(_asyncMap);\\n+    async.mapLimit = function (arr, limit, iterator, callback) {\\n+        return _mapLimit(limit)(arr, iterator, callback);\\n+    };\\n+\\n+    var _mapLimit = function(limit) {\\n+        return doParallelLimit(limit, _asyncMap);\\n+    };\\n+\\n+    // reduce only has a series version, as doing reduce in parallel won't\\n+    // work in many situations.\\n+    async.reduce = function (arr, memo, iterator, callback) {\\n+        async.eachSeries(arr, function (x, callback) {\\n+            iterator(memo, x, function (err, v) {\\n+                memo = v;\\n+                callback(err);\\n+            });\\n+        }, function (err) {\\n+            callback(err, memo);\\n+        });\\n+    };\\n+    // inject alias\\n+    async.inject = async.reduce;\\n+    // foldl alias\\n+    async.foldl = async.reduce;\\n+\\n+    async.reduceRight = function (arr, memo, iterator, callback) {\\n+        var reversed = _map(arr, function (x) {\\n+            return x;\\n+        }).reverse();\\n+        async.reduce(reversed, memo, iterator, callback);\\n+    };\\n+    // foldr alias\\n+    async.foldr = async.reduceRight;\\n+\\n+    var _filter = function (eachfn, arr, iterator, callback) {\\n+        var results = [];\\n+        arr = _map(arr, function (x, i) {\\n+            return {index: i, value: x};\\n+        });\\n+        eachfn(arr, function (x, callback) {\\n+            iterator(x.value, function (v) {\\n+                if (v) {\\n+                    results.push(x);\\n+                }\\n+                callback();\\n+            });\\n+        }, function (err) {\\n+            callback(_map(results.sort(function (a, b) {\\n+                return a.index - b.index;\\n+            }), function (x) {\\n+                return x.value;\\n+            }));\\n+        });\\n+    };\\n+    async.filter = doParallel(_filter);\\n+    async.filterSeries = doSeries(_filter);\\n+    // select alias\\n+    async.select = async.filter;\\n+    async.selectSeries = async.filterSeries;\\n+\\n+    var _reject = function (eachfn, arr, iterator, callback) {\\n+        var results = [];\\n+        arr = _map(arr, function (x, i) {\\n+            return {index: i, value: x};\\n+        });\\n+        eachfn(arr, function (x, callback) {\\n+            iterator(x.value, function (v) {\\n+                if (!v) {\\n+                    results.push(x);\\n+                }\\n+                callback();\\n+            });\\n+        }, function (err) {\\n+            callback(_map(results.sort(function (a, b) {\\n+                return a.index - b.index;\\n+            }), function (x) {\\n+                return x.value;\\n+            }));\\n+        });\\n+    };\\n+    async.reject = doParallel(_reject);\\n+    async.rejectSeries = doSeries(_reject);\\n+\\n+    var _detect = function (eachfn, arr, iterator, main_callback) {\\n+        eachfn(arr, function (x, callback) {\\n+            iterator(x, function (result) {\\n+                if (result) {\\n+                    main_callback(x);\\n+                    main_callback = function () {};\\n+                }\\n+                else {\\n+                    callback();\\n+                }\\n+            });\\n+        }, function (err) {\\n+            main_callback();\\n+        });\\n+    };\\n+    async.detect = doParallel(_detect);\\n+    async.detectSeries = doSeries(_detect);\\n+\\n+    async.some = function (arr, iterator, main_callback) {\\n+        async.each(arr, function (x, callback) {\\n+            iterator(x, function (v) {\\n+                if (v) {\\n+                    main_callback(true);\\n+                    main_callback = function () {};\\n+                }\\n+                callback();\\n+            });\\n+        }, function (err) {\\n+            main_callback(false);\\n+        });\\n+    };\\n+    // any alias\\n+    async.any = async.some;\\n+\\n+    async.every = function (arr, iterator, main_callback) {\\n+        async.each(arr, function (x, callback) {\\n+            iterator(x, function (v) {\\n+                if (!v) {\\n+                    main_callback(false);\\n+                    main_callback = function () {};\\n+                }\\n+                callback();\\n+            });\\n+        }, function (err) {\\n+            main_callback(true);\\n+        });\\n+    };\\n+    // all alias\\n+    async.all = async.every;\\n+\\n+    async.sortBy = function (arr, iterator, callback) {\\n+        async.map(arr, function (x, callback) {\\n+            iterator(x, function (err, criteria) {\\n+                if (err) {\\n+                    callback(err);\\n+                }\\n+                else {\\n+                    callback(null, {value: x, criteria: criteria});\\n+                }\\n+            });\\n+        }, function (err, results) {\\n+            if (err) {\\n+                return callback(err);\\n+            }\\n+            else {\\n+                var fn = function (left, right) {\\n+                    var a = left.criteria, b = right.criteria;\\n+                    return a < b ? -1 : a > b ? 1 : 0;\\n+                };\\n+                callback(null, _map(results.sort(fn), function (x) {\\n+                    return x.value;\\n+                }));\\n+            }\\n+        });\\n+    };\\n+\\n+    async.auto = function (tasks, callback) {\\n+        callback = callback || function () {};\\n+        var keys = _keys(tasks);\\n+        var remainingTasks = keys.length\\n+        if (!remainingTasks) {\\n+            return callback();\\n+        }\\n+\\n+        var results = {};\\n+\\n+        var listeners = [];\\n+        var addListener = function (fn) {\\n+            listeners.unshift(fn);\\n+        };\\n+        var removeListener = function (fn) {\\n+            for (var i = 0; i < listeners.length; i += 1) {\\n+                if (listeners[i] === fn) {\\n+                    listeners.splice(i, 1);\\n+                    return;\\n+                }\\n+            }\\n+        };\\n+        var taskComplete = function () {\\n+            remainingTasks--\\n+            _each(listeners.slice(0), function (fn) {\\n+                fn();\\n+            });\\n+        };\\n+\\n+        addListener(function () {\\n+            if (!remainingTasks) {\\n+                var theCallback = callback;\\n+                // prevent final callback from calling itself if it errors\\n+                callback = function () {};\\n+\\n+                theCallback(null, results);\\n+            }\\n+        });\\n+\\n+        _each(keys, function (k) {\\n+            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\\n+            var taskCallback = function (err) {\\n+                var args = Array.prototype.slice.call(arguments, 1);\\n+                if (args.length <= 1) {\\n+                    args = args[0];\\n+                }\\n+                if (err) {\\n+                    var safeResults = {};\\n+                    _each(_keys(results), function(rkey) {\\n+                        safeResults[rkey] = results[rkey];\\n+                    });\\n+                    safeResults[k] = args;\\n+                    callback(err, safeResults);\\n+                    // stop subsequent errors hitting callback multiple times\\n+                    callback = function () {};\\n+                }\\n+                else {\\n+                    results[k] = args;\\n+                    async.setImmediate(taskComplete);\\n+                }\\n+            };\\n+            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\\n+            var ready = function () {\\n+                return _reduce(requires, function (a, x) {\\n+                    return (a && results.hasOwnProperty(x));\\n+                }, true) && !results.hasOwnProperty(k);\\n+            };\\n+            if (ready()) {\\n+                task[task.length - 1](taskCallback, results);\\n+            }\\n+            else {\\n+                var listener = function () {\\n+                    if (ready()) {\\n+                        removeListener(listener);\\n+                        task[task.length - 1](taskCallback, results);\\n+                    }\\n+                };\\n+                addListener(listener);\\n+            }\\n+        });\\n+    };\\n+\\n+    async.retry = function(times, task, callback) {\\n+        var DEFAULT_TIMES = 5;\\n+        var attempts = [];\\n+        // Use defaults if times not passed\\n+        if (typeof times === 'function') {\\n+            callback = task;\\n+            task = times;\\n+            times = DEFAULT_TIMES;\\n+        }\\n+        // Make sure times is a number\\n+        times = parseInt(times, 10) || DEFAULT_TIMES;\\n+        var wrappedTask = function(wrappedCallback, wrappedResults) {\\n+            var retryAttempt = function(task, finalAttempt) {\\n+                return function(seriesCallback) {\\n+                    task(function(err, result){\\n+                        seriesCallback(!err || finalAttempt, {err: err, result: result});\\n+                    }, wrappedResults);\\n+                };\\n+            };\\n+            while (times) {\\n+                attempts.push(retryAttempt(task, !(times-=1)));\\n+            }\\n+            async.series(attempts, function(done, data){\\n+                data = data[data.length - 1];\\n+                (wrappedCallback || callback)(data.err, data.result);\\n+            });\\n+        }\\n+        // If a callback is passed, run this as a controll flow\\n+        return callback ? wrappedTask() : wrappedTask\\n+    };\\n+\\n+    async.waterfall = function (tasks, callback) {\\n+        callback = callback || function () {};\\n+        if (!_isArray(tasks)) {\\n+          var err = new Error('First argument to waterfall must be an array of functions');\\n+          return callback(err);\\n+        }\\n+        if (!tasks.length) {\\n+            return callback();\\n+        }\\n+        var wrapIterator = function (iterator) {\\n+            return function (err) {\\n+                if (err) {\\n+                    callback.apply(null, arguments);\\n+                    callback = function () {};\\n+                }\\n+                else {\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\n+                    var next = iterator.next();\\n+                    if (next) {\\n+                        args.push(wrapIterator(next));\\n+                    }\\n+                    else {\\n+                        args.push(callback);\\n+                    }\\n+                    async.setImmediate(function () {\\n+                        iterator.apply(null, args);\\n+                    });\\n+                }\\n+            };\\n+        };\\n+        wrapIterator(async.iterator(tasks))();\\n+    };\\n+\\n+    var _parallel = function(eachfn, tasks, callback) {\\n+        callback = callback || function () {};\\n+        if (_isArray(tasks)) {\\n+            eachfn.map(tasks, function (fn, callback) {\\n+                if (fn) {\\n+                    fn(function (err) {\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\n+                        if (args.length <= 1) {\\n+                            args = args[0];\\n+                        }\\n+                        callback.call(null, err, args);\\n+                    });\\n+                }\\n+            }, callback);\\n+        }\\n+        else {\\n+            var results = {};\\n+            eachfn.each(_keys(tasks), function (k, callback) {\\n+                tasks[k](function (err) {\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\n+                    if (args.length <= 1) {\\n+                        args = args[0];\\n+                    }\\n+                    results[k] = args;\\n+                    callback(err);\\n+                });\\n+            }, function (err) {\\n+                callback(err, results);\\n+            });\\n+        }\\n+    };\\n+\\n+    async.parallel = function (tasks, callback) {\\n+        _parallel({ map: async.map, each: async.each }, tasks, callback);\\n+    };\\n+\\n+    async.parallelLimit = function(tasks, limit, callback) {\\n+        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\\n+    };\\n+\\n+    async.series = function (tasks, callback) {\\n+        callback = callback || function () {};\\n+        if (_isArray(tasks)) {\\n+            async.mapSeries(tasks, function (fn, callback) {\\n+                if (fn) {\\n+                    fn(function (err) {\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\n+                        if (args.length <= 1) {\\n+                            args = args[0];\\n+                        }\\n+                        callback.call(null, err, args);\\n+                    });\\n+                }\\n+            }, callback);\\n+        }\\n+        else {\\n+            var results = {};\\n+            async.eachSeries(_keys(tasks), function (k, callback) {\\n+                tasks[k](function (err) {\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\n+                    if (args.length <= 1) {\\n+                        args = args[0];\\n+                    }\\n+                    results[k] = args;\\n+                    callback(err);\\n+                });\\n+            }, function (err) {\\n+                callback(err, results);\\n+            });\\n+        }\\n+    };\\n+\\n+    async.iterator = function (tasks) {\\n+        var makeCallback = function (index) {\\n+            var fn = function () {\\n+                if (tasks.length) {\\n+                    tasks[index].apply(null, arguments);\\n+                }\\n+                return fn.next();\\n+            };\\n+            fn.next = function () {\\n+                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\\n+            };\\n+            return fn;\\n+        };\\n+        return makeCallback(0);\\n+    };\\n+\\n+    async.apply = function (fn) {\\n+        var args = Array.prototype.slice.call(arguments, 1);\\n+        return function () {\\n+            return fn.apply(\\n+                null, args.concat(Array.prototype.slice.call(arguments))\\n+            );\\n+        };\\n+    };\\n+\\n+    var _concat = function (eachfn, arr, fn, callback) {\\n+        var r = [];\\n+        eachfn(arr, function (x, cb) {\\n+            fn(x, function (err, y) {\\n+                r = r.concat(y || []);\\n+                cb(err);\\n+            });\\n+        }, function (err) {\\n+            callback(err, r);\\n+        });\\n+    };\\n+    async.concat = doParallel(_concat);\\n+    async.concatSeries = doSeries(_concat);\\n+\\n+    async.whilst = function (test, iterator, callback) {\\n+        if (test()) {\\n+            iterator(function (err) {\\n+                if (err) {\\n+                    return callback(err);\\n+                }\\n+                async.whilst(test, iterator, callback);\\n+            });\\n+        }\\n+        else {\\n+            callback();\\n+        }\\n+    };\\n+\\n+    async.doWhilst = function (iterator, test, callback) {\\n+        iterator(function (err) {\\n+            if (err) {\\n+                return callback(err);\\n+            }\\n+            var args = Array.prototype.slice.call(arguments, 1);\\n+            if (test.apply(null, args)) {\\n+                async.doWhilst(iterator, test, callback);\\n+            }\\n+            else {\\n+                callback();\\n+            }\\n+        });\\n+    };\\n+\\n+    async.until = function (test, iterator, callback) {\\n+        if (!test()) {\\n+            iterator(function (err) {\\n+                if (err) {\\n+                    return callback(err);\\n+                }\\n+                async.until(test, iterator, callback);\\n+            });\\n+        }\\n+        else {\\n+            callback();\\n+        }\\n+    };\\n+\\n+    async.doUntil = function (iterator, test, callback) {\\n+        iterator(function (err) {\\n+            if (err) {\\n+                return callback(err);\\n+            }\\n+            var args = Array.prototype.slice.call(arguments, 1);\\n+            if (!test.apply(null, args)) {\\n+                async.doUntil(iterator, test, callback);\\n+            }\\n+            else {\\n+                callback();\\n+            }\\n+        });\\n+    };\\n+\\n+    async.queue = function (worker, concurrency) {\\n+        if (concurrency === undefined) {\\n+            concurrency = 1;\\n+        }\\n+        function _insert(q, data, pos, callback) {\\n+          if (!q.started){\\n+            q.started = true;\\n+          }\\n+          if (!_isArray(data)) {\\n+              data = [data];\\n+          }\\n+          if(data.length == 0) {\\n+             // call drain immediately if there are no tasks\\n+             return async.setImmediate(function() {\\n+                 if (q.drain) {\\n+                     q.drain();\\n+                 }\\n+             });\\n+          }\\n+          _each(data, function(task) {\\n+              var item = {\\n+                  data: task,\\n+                  callback: typeof callback === 'function' ? callback : null\\n+              };\\n+\\n+              if (pos) {\\n+                q.tasks.unshift(item);\\n+              } else {\\n+                q.tasks.push(item);\\n+              }\\n+\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\n+                  q.saturated();\\n+              }\\n+              async.setImmediate(q.process);\\n+          });\\n+        }\\n+\\n+        var workers = 0;\\n+        var q = {\\n+            tasks: [],\\n+            concurrency: concurrency,\\n+            saturated: null,\\n+            empty: null,\\n+            drain: null,\\n+            started: false,\\n+            paused: false,\\n+            push: function (data, callback) {\\n+              _insert(q, data, false, callback);\\n+            },\\n+            kill: function () {\\n+              q.drain = null;\\n+              q.tasks = [];\\n+            },\\n+            unshift: function (data, callback) {\\n+              _insert(q, data, true, callback);\\n+            },\\n+            process: function () {\\n+                if (!q.paused && workers < q.concurrency && q.tasks.length) {\\n+                    var task = q.tasks.shift();\\n+                    if (q.empty && q.tasks.length === 0) {\\n+                        q.empty();\\n+                    }\\n+                    workers += 1;\\n+                    var next = function () {\\n+                        workers -= 1;\\n+                        if (task.callback) {\\n+                            task.callback.apply(task, arguments);\\n+                        }\\n+                        if (q.drain && q.tasks.length + workers === 0) {\\n+                            q.drain();\\n+                        }\\n+                        q.process();\\n+                    };\\n+                    var cb = only_once(next);\\n+                    worker(task.data, cb);\\n+                }\\n+            },\\n+            length: function () {\\n+                return q.tasks.length;\\n+            },\\n+            running: function () {\\n+                return workers;\\n+            },\\n+            idle: function() {\\n+                return q.tasks.length + workers === 0;\\n+            },\\n+            pause: function () {\\n+                if (q.paused === true) { return; }\\n+                q.paused = true;\\n+                q.process();\\n+            },\\n+            resume: function () {\\n+                if (q.paused === false) { return; }\\n+                q.paused = false;\\n+                q.process();\\n+            }\\n+        };\\n+        return q;\\n+    };\\n+    \\n+    async.priorityQueue = function (worker, concurrency) {\\n+        \\n+        function _compareTasks(a, b){\\n+          return a.priority - b.priority;\\n+        };\\n+        \\n+        function _binarySearch(sequence, item, compare) {\\n+          var beg = -1,\\n+              end = sequence.length - 1;\\n+          while (beg < end) {\\n+            var mid = beg + ((end - beg + 1) >>> 1);\\n+            if (compare(item, sequence[mid]) >= 0) {\\n+              beg = mid;\\n+            } else {\\n+              end = mid - 1;\\n+            }\\n+          }\\n+          return beg;\\n+        }\\n+        \\n+        function _insert(q, data, priority, callback) {\\n+          if (!q.started){\\n+            q.started = true;\\n+          }\\n+          if (!_isArray(data)) {\\n+              data = [data];\\n+          }\\n+          if(data.length == 0) {\\n+             // call drain immediately if there are no tasks\\n+             return async.setImmediate(function() {\\n+                 if (q.drain) {\\n+                     q.drain();\\n+                 }\\n+             });\\n+          }\\n+          _each(data, function(task) {\\n+              var item = {\\n+                  data: task,\\n+                  priority: priority,\\n+                  callback: typeof callback === 'function' ? callback : null\\n+              };\\n+              \\n+              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\\n+\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\n+                  q.saturated();\\n+              }\\n+              async.setImmediate(q.process);\\n+          });\\n+        }\\n+        \\n+        // Start with a normal queue\\n+        var q = async.queue(worker, concurrency);\\n+        \\n+        // Override push to accept second parameter representing priority\\n+        q.push = function (data, priority, callback) {\\n+          _insert(q, data, priority, callback);\\n+        };\\n+        \\n+        // Remove unshift function\\n+        delete q.unshift;\\n+\\n+        return q;\\n+    };\\n+\\n+    async.cargo = function (worker, payload) {\\n+        var working     = false,\\n+            tasks       = [];\\n+\\n+        var cargo = {\\n+            tasks: tasks,\\n+            payload: payload,\\n+            saturated: null,\\n+            empty: null,\\n+            drain: null,\\n+            drained: true,\\n+            push: function (data, callback) {\\n+                if (!_isArray(data)) {\\n+                    data = [data];\\n+                }\\n+                _each(data, function(task) {\\n+                    tasks.push({\\n+                        data: task,\\n+                        callback: typeof callback === 'function' ? callback : null\\n+                    });\\n+                    cargo.drained = false;\\n+                    if (cargo.saturated && tasks.length === payload) {\\n+                        cargo.saturated();\\n+                    }\\n+                });\\n+                async.setImmediate(cargo.process);\\n+            },\\n+            process: function process() {\\n+                if (working) return;\\n+                if (tasks.length === 0) {\\n+                    if(cargo.drain && !cargo.drained) cargo.drain();\\n+                    cargo.drained = true;\\n+                    return;\\n+                }\\n+\\n+                var ts = typeof payload === 'number'\\n+                            ? tasks.splice(0, payload)\\n+                            : tasks.splice(0, tasks.length);\\n+\\n+                var ds = _map(ts, function (task) {\\n+                    return task.data;\\n+                });\\n+\\n+                if(cargo.empty) cargo.empty();\\n+                working = true;\\n+                worker(ds, function () {\\n+                    working = false;\\n+\\n+                    var args = arguments;\\n+                    _each(ts, function (data) {\\n+                        if (data.callback) {\\n+                            data.callback.apply(null, args);\\n+                        }\\n+                    });\\n+\\n+                    process();\\n+                });\\n+            },\\n+            length: function () {\\n+                return tasks.length;\\n+            },\\n+            running: function () {\\n+                return working;\\n+            }\\n+        };\\n+        return cargo;\\n+    };\\n+\\n+    var _console_fn = function (name) {\\n+        return function (fn) {\\n+            var args = Array.prototype.slice.call(arguments, 1);\\n+            fn.apply(null, args.concat([function (err) {\\n+                var args = Array.prototype.slice.call(arguments, 1);\\n+                if (typeof console !== 'undefined') {\\n+                    if (err) {\\n+                        if (console.error) {\\n+                            console.error(err);\\n+                        }\\n+                    }\\n+                    else if (console[name]) {\\n+                        _each(args, function (x) {\\n+                            console[name](x);\\n+                        });\\n+                    }\\n+                }\\n+            }]));\\n+        };\\n+    };\\n+    async.log = _console_fn('log');\\n+    async.dir = _console_fn('dir');\\n+    /*async.info = _console_fn('info');\\n+    async.warn = _console_fn('warn');\\n+    async.error = _console_fn('error');*/\\n+\\n+    async.memoize = function (fn, hasher) {\\n+        var memo = {};\\n+        var queues = {};\\n+        hasher = hasher || function (x) {\\n+            return x;\\n+        };\\n+        var memoized = function () {\\n+            var args = Array.prototype.slice.call(arguments);\\n+            var callback = args.pop();\\n+            var key = hasher.apply(null, args);\\n+            if (key in memo) {\\n+                async.nextTick(function () {\\n+                    callback.apply(null, memo[key]);\\n+                });\\n+            }\\n+            else if (key in queues) {\\n+                queues[key].push(callback);\\n+            }\\n+            else {\\n+                queues[key] = [callback];\\n+                fn.apply(null, args.concat([function () {\\n+                    memo[key] = arguments;\\n+                    var q = queues[key];\\n+                    delete queues[key];\\n+                    for (var i = 0, l = q.length; i < l; i++) {\\n+                      q[i].apply(null, arguments);\\n+                    }\\n+                }]));\\n+            }\\n+        };\\n+        memoized.memo = memo;\\n+        memoized.unmemoized = fn;\\n+        return memoized;\\n+    };\\n+\\n+    async.unmemoize = function (fn) {\\n+      return function () {\\n+        return (fn.unmemoized || fn).apply(null, arguments);\\n+      };\\n+    };\\n+\\n+    async.times = function (count, iterator, callback) {\\n+        var counter = [];\\n+        for (var i = 0; i < count; i++) {\\n+            counter.push(i);\\n+        }\\n+        return async.map(counter, iterator, callback);\\n+    };\\n+\\n+    async.timesSeries = function (count, iterator, callback) {\\n+        var counter = [];\\n+        for (var i = 0; i < count; i++) {\\n+            counter.push(i);\\n+        }\\n+        return async.mapSeries(counter, iterator, callback);\\n+    };\\n+\\n+    async.seq = function (/* functions... */) {\\n+        var fns = arguments;\\n+        return function () {\\n+            var that = this;\\n+            var args = Array.prototype.slice.call(arguments);\\n+            var callback = args.pop();\\n+            async.reduce(fns, args, function (newargs, fn, cb) {\\n+                fn.apply(that, newargs.concat([function () {\\n+                    var err = arguments[0];\\n+                    var nextargs = Array.prototype.slice.call(arguments, 1);\\n+                    cb(err, nextargs);\\n+                }]))\\n+            },\\n+            function (err, results) {\\n+                callback.apply(that, [err].concat(results));\\n+            });\\n+        };\\n+    };\\n+\\n+    async.compose = function (/* functions... */) {\\n+      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\\n+    };\\n+\\n+    var _applyEach = function (eachfn, fns /*args...*/) {\\n+        var go = function () {\\n+            var that = this;\\n+            var args = Array.prototype.slice.call(arguments);\\n+            var callback = args.pop();\\n+            return eachfn(fns, function (fn, cb) {\\n+                fn.apply(that, args.concat([cb]));\\n+            },\\n+            callback);\\n+        };\\n+        if (arguments.length > 2) {\\n+            var args = Array.prototype.slice.call(arguments, 2);\\n+            return go.apply(this, args);\\n+        }\\n+        else {\\n+            return go;\\n+        }\\n+    };\\n+    async.applyEach = doParallel(_applyEach);\\n+    async.applyEachSeries = doSeries(_applyEach);\\n+\\n+    async.forever = function (fn, callback) {\\n+        function next(err) {\\n+            if (err) {\\n+                if (callback) {\\n+                    return callback(err);\\n+                }\\n+                throw err;\\n+            }\\n+            fn(next);\\n+        }\\n+        next();\\n+    };\\n+\\n+    // Node.js\\n+    if (typeof module !== 'undefined' && module.exports) {\\n+        module.exports = async;\\n+    }\\n+    // AMD / RequireJS\\n+    else if (typeof define !== 'undefined' && define.amd) {\\n+        define([], function () {\\n+            return async;\\n+        });\\n+    }\\n+    // included directly via <script> tag\\n+    else {\\n+        root.async = async;\\n+    }\\n+\\n+}());\\ndiff --git a/node_modules/async/package.json b/node_modules/async/package.json\\nnew file mode 100644\\nindex 0000000..31a5200\\n--- /dev/null\\n+++ b/node_modules/async/package.json\\n@@ -0,0 +1,59 @@\\n+{\\n+  \\\"name\\\": \\\"async\\\",\\n+  \\\"description\\\": \\\"Higher-order functions and common patterns for asynchronous code\\\",\\n+  \\\"main\\\": \\\"./lib/async\\\",\\n+  \\\"author\\\": {\\n+    \\\"name\\\": \\\"Caolan McMahon\\\"\\n+  },\\n+  \\\"version\\\": \\\"0.9.0\\\",\\n+  \\\"repository\\\": {\\n+    \\\"type\\\": \\\"git\\\",\\n+    \\\"url\\\": \\\"https://github.com/caolan/async.git\\\"\\n+  },\\n+  \\\"bugs\\\": {\\n+    \\\"url\\\": \\\"https://github.com/caolan/async/issues\\\"\\n+  },\\n+  \\\"licenses\\\": [\\n+    {\\n+      \\\"type\\\": \\\"MIT\\\",\\n+      \\\"url\\\": \\\"https://github.com/caolan/async/raw/master/LICENSE\\\"\\n+    }\\n+  ],\\n+  \\\"devDependencies\\\": {\\n+    \\\"nodeunit\\\": \\\">0.0.0\\\",\\n+    \\\"uglify-js\\\": \\\"1.2.x\\\",\\n+    \\\"nodelint\\\": \\\">0.0.0\\\"\\n+  },\\n+  \\\"jam\\\": {\\n+    \\\"main\\\": \\\"lib/async.js\\\",\\n+    \\\"include\\\": [\\n+      \\\"lib/async.js\\\",\\n+      \\\"README.md\\\",\\n+      \\\"LICENSE\\\"\\n+    ]\\n+  },\\n+  \\\"scripts\\\": {\\n+    \\\"test\\\": \\\"nodeunit test/test-async.js\\\"\\n+  },\\n+  \\\"homepage\\\": \\\"https://github.com/caolan/async\\\",\\n+  \\\"_id\\\": \\\"async@0.9.0\\\",\\n+  \\\"dist\\\": {\\n+    \\\"shasum\\\": \\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\",\\n+    \\\"tarball\\\": \\\"http://registry.npmjs.org/async/-/async-0.9.0.tgz\\\"\\n+  },\\n+  \\\"_from\\\": \\\"async@*\\\",\\n+  \\\"_npmVersion\\\": \\\"1.4.3\\\",\\n+  \\\"_npmUser\\\": {\\n+    \\\"name\\\": \\\"caolan\\\",\\n+    \\\"email\\\": \\\"caolan.mcmahon@gmail.com\\\"\\n+  },\\n+  \\\"maintainers\\\": [\\n+    {\\n+      \\\"name\\\": \\\"caolan\\\",\\n+      \\\"email\\\": \\\"caolan@caolanmcmahon.com\\\"\\n+    }\\n+  ],\\n+  \\\"directories\\\": {},\\n+  \\\"_shasum\\\": \\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\",\\n+  \\\"_resolved\\\": \\\"https://registry.npmjs.org/async/-/async-0.9.0.tgz\\\"\\n+}\\ndiff --git a/package.json b/package.json\\nindex 5f21627..6033d43 100644\\n--- a/package.json\\n+++ b/package.json\\n@@ -4,7 +4,8 @@\\n   \\\"description\\\": \\\"Sous project\\\",\\n   \\\"main\\\": \\\"main.js\\\",\\n   \\\"dependencies\\\": {\\n-},\\n+    \\\"async\\\": \\\"*\\\"\\n+  },\\n   \\\"devDependencies\\\": {},\\n   \\\"scripts\\\": {\\n     \\\"test\\\": \\\"echo \\\\\\\"Error: no test specified\\\\\\\" && exit 1\\\"\\ndiff --git a/patches.sousp b/patches.sousp\\nindex 16405a3..d71e511 100644\\n--- a/patches.sousp\\n+++ b/patches.sousp\\n@@ -1,31 +1 @@\\n-diff --git a/main.js b/main.js\\n-index f81b54e..744cdd5 100644\\n---- a/main.js\\n-+++ b/main.js\\n-@@ -35,7 +35,7 @@ fs.exists('.git', function (exists) {\\n-         cp.exec('git diff', function(error, stdout, stderr) {\\n-             console.log(stdout);\\n- \\n--            //fs.writeFileSync(\\\"patches.sousp\\\", stdout);\\n-+            fs.writeFileSync(\\\"patches.sousp\\\", stdout);\\n- \\n-             if (error !== null) {\\n-                 console.log('stderr: ' + stderr);\\n-@@ -44,7 +44,7 @@ fs.exists('.git', function (exists) {\\n-         });\\n- \\n-         cp.exec('git log', function(error, stdout, stderr) {\\n--            //console.log(stdout);\\n-+            console.log(stdout);\\n- \\n-             var authors = findData(stdout, \\\"Author:\\\");\\n-             var dates = findData(stdout, \\\"Date:\\\");\\n-@@ -53,7 +53,7 @@ fs.exists('.git', function (exists) {\\n-             console.log(comments);\\n-             console.log(dates);\\n- \\n--            //fs.writeFileSync(\\\"comments.sousc\\\", stdout);\\n-+            fs.writeFileSync(\\\"comments.sousc\\\", stdout);\\n- \\n-             if (error !== null) {\\n-                 console.log('stderr: ' + stderr);\\n+[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]\\n\\\\ No newline at end of file\\ndiff --git a/test.js b/test.js\\nnew file mode 100644\\nindex 0000000..5ca759c\\n--- /dev/null\\n+++ b/test.js\\n@@ -0,0 +1,21 @@\\n+/**\\n+ * Created by Nick on 18.05.2015.\\n+ */\\n+var async = require('async')\\n+    , tasksIndex = [\\n+        function (callback) {\\n+            // Вымышленный метод который вернет 231\\n+            var viewsNumber = models.stat.viewsNumber();\\n+            callback(null, viewsNumber);\\n+        }\\n+        , function (callback) {\\n+            // Вымышленный метод который вернет 24\\n+            var growFactor = models.stat.growFactor();\\n+            callback(null, growFactor);\\n+        }\\n+    ];\\n+\\n+async.series(tasksIndex, function (err, results) {\\n+    // Результат будет массивом\\n+    console.log(results); // [231, 24]\\n+});\\n\\\\ No newline at end of file\\n\"}\n\\ No newline at end of file\n"},{"commit":"b69c8e0a5203119884ebb2050c894eceb657f4f6","author":"Nick Stepanenko <massaalonso@yandex.ru>","date":"Tue May 19 01:44:20 2015 +0800","comment":"Removed insignificant program code.","content":"diff --git a/main.js b/main.js\nindex ca7473f..eaf537f 100644\n--- a/main.js\n+++ b/main.js\n@@ -4,55 +4,8 @@\n \n var fs = require('fs');\n var cp = require('child_process');\n-var data = [];\n \n var async = require('async');\n-    /*tasks = [\n-        function (callback) {\n-            cp.exec('git log', function(error, stdout, stderr) {\n-                var listOfCommits = [];\n-                var authors = findData(stdout, \"Author:\");\n-                var dates = findData(stdout, \"Date:\");\n-                var comments = findComments(stdout);\n-                var commitNumbers = findCommitNumbers(stdout);\n-\n-                for(i=0; i<authors.length; i++) {\n-                    var commit = {\n-                        \"commit\": commitNumbers[i],\n-                        \"author\": authors[i],\n-                        \"date\": dates[i],\n-                        \"comment\": comments[i],\n-                        \"content\": 'Original'\n-                    };\n-\n-                    listOfCommits[listOfCommits.length] = commit;\n-                }\n-\n-                data = listOfCommits.reverse();\n-\n-                callback(null, data);\n-\n-                if (error !== null) {\n-                    console.log('stderr: ' + stderr);\n-                    console.log('exec error: ' + error);\n-                }\n-            });\n-        }\n-    ],\n-    secondTasks = [\n-        function some_function(callback) {\n-            cp.exec('git diff', function(error, stdout, stderr) {\n-                var currentContent = stdout;\n-\n-                if (error !== null) {\n-                    console.log('stderr: ' + stderr);\n-                    console.log('exec error: ' + error);\n-                }\n-\n-                callback(null, currentContent);\n-            });\n-        }\n-    ];*/\n \n function findData(text, keyword) {\n     var data = [];\n@@ -91,43 +44,8 @@ function findCommitNumbers(text) {\n     return commits;\n }\n \n-/*function pullCommitContent(first, second) {\n-\n-    cp.exec('git diff' + ' ' + first + ' ' + second, function(error, stdout, stderr) {\n-        var currentContent = stdout;\n-\n-        if (error !== null) {\n-            console.log('stderr: ' + stderr);\n-            console.log('exec error: ' + error);\n-        }\n-\n-        return currentContent;\n-    });\n-}*/\n-\n-var commitsInfo = [];\n-\n fs.exists('.git', function (exists) {\n     if(exists) {\n-        /*async.series(tasks, function(err, result) {\n-            fs.writeFileSync(\"patches.sousp\", JSON.stringify(result));\n-\n-            var data = result[0];\n-\n-            /*function some_function(arg1, arg2, callback) {\n-                cp.exec('git diff' + ' ' + arg1 + ' ' + arg2, function(error, stdout, stderr) {\n-                    var currentContent = 54321;//stdout;\n-\n-                    if (error !== null) {\n-                        console.log('stderr: ' + stderr);\n-                        console.log('exec error: ' + error);\n-                    }\n-\n-                    callback(null, currentContent);\n-                });\n-            }\n-        });*/\n-\n         async.waterfall([\n             function getCommitsInfo(callback) {\n                 cp.exec('git log', function(error, stdout, stderr) {\n@@ -173,4 +91,4 @@ fs.exists('.git', function (exists) {\n             }\n         });\n     }\n-});\n\\ No newline at end of file\n+});\ndiff --git a/patches.sousp b/patches.sousp\nindex 300c6a9..11aa280 100644\n--- a/patches.sousp\n+++ b/patches.sousp\n@@ -1 +1 @@\n-{\"commit\":\"1e947f613e976945de85ae35ed923aa470f0be72\",\"author\":\"Nick Stepanenko <massaalonso@yandex.ru>\",\"date\":\"Tue May 19 00:12:12 2015 +0800\",\"comment\":\"Latest updates\",\"content\":\"diff --git a/comments.sousc b/comments.sousc\\nindex 150b0f6..cb3a850 100644\\n--- a/comments.sousc\\n+++ b/comments.sousc\\n@@ -1,3 +1,27 @@\\n+commit 4420cabefc1f470af341af11ed595df67e25c51f\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\n+Date:   Sun May 17 17:05:35 2015 +0800\\n+\\n+    Paste old program code\\n+\\n+commit 9ef3d25fd4c3afdbcc3107a0abf6d7a2e29cb4dd\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\n+Date:   Sun May 17 17:04:52 2015 +0800\\n+\\n+    Adding new file\\n+\\n+commit 64814d140d2fab6ae153cac485008119f29bf230\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\n+Date:   Sun May 17 17:03:58 2015 +0800\\n+\\n+    From clear list\\n+\\n+commit c9d318fea74ea288d544ecf72f00b12c130cf2ef\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\n+Date:   Sun May 17 16:59:40 2015 +0800\\n+\\n+    Create system files\\n+\\n commit e3c853a4282dfe8f000685dc1d39bd55a4a946c4\\n Author: Nick Stepanenko <massaalonso@yandex.ru>\\n Date:   Sun May 17 16:54:58 2015 +0800\\ndiff --git a/main.js b/main.js\\nindex e34dc18..86f30c2 100644\\n--- a/main.js\\n+++ b/main.js\\n@@ -3,6 +3,56 @@\\n  */\\n \\n var fs = require('fs');\\n+var cp = require('child_process');\\n+var data = [];\\n+\\n+var async = require('async');\\n+    /*tasks = [\\n+        function (callback) {\\n+            cp.exec('git log', function(error, stdout, stderr) {\\n+                var listOfCommits = [];\\n+                var authors = findData(stdout, \\\"Author:\\\");\\n+                var dates = findData(stdout, \\\"Date:\\\");\\n+                var comments = findComments(stdout);\\n+                var commitNumbers = findCommitNumbers(stdout);\\n+\\n+                for(i=0; i<authors.length; i++) {\\n+                    var commit = {\\n+                        \\\"commit\\\": commitNumbers[i],\\n+                        \\\"author\\\": authors[i],\\n+                        \\\"date\\\": dates[i],\\n+                        \\\"comment\\\": comments[i],\\n+                        \\\"content\\\": 'Original'\\n+                    };\\n+\\n+                    listOfCommits[listOfCommits.length] = commit;\\n+                }\\n+\\n+                data = listOfCommits.reverse();\\n+\\n+                callback(null, data);\\n+\\n+                if (error !== null) {\\n+                    console.log('stderr: ' + stderr);\\n+                    console.log('exec error: ' + error);\\n+                }\\n+            });\\n+        }\\n+    ],\\n+    secondTasks = [\\n+        function some_function(callback) {\\n+            cp.exec('git diff', function(error, stdout, stderr) {\\n+                var currentContent = stdout;\\n+\\n+                if (error !== null) {\\n+                    console.log('stderr: ' + stderr);\\n+                    console.log('exec error: ' + error);\\n+                }\\n+\\n+                callback(null, currentContent);\\n+            });\\n+        }\\n+    ];*/\\n \\n function findData(text, keyword) {\\n     var data = [];\\n@@ -28,38 +78,106 @@ function findComments(text) {\\n     return comments;\\n }\\n \\n+function findCommitNumbers(text) {\\n+    var commits = [];\\n+    var splittext = text.split('\\\\n');\\n+\\n+    for(i=0; i<splittext.length; i++) {\\n+        if(splittext[i].slice(0, 6) == \\\"commit\\\") {\\n+            commits[commits.length] = splittext[i].slice(6).trim();\\n+        }\\n+    }\\n+\\n+    return commits;\\n+}\\n+\\n+/*function pullCommitContent(first, second) {\\n+\\n+    cp.exec('git diff' + ' ' + first + ' ' + second, function(error, stdout, stderr) {\\n+        var currentContent = stdout;\\n+\\n+        if (error !== null) {\\n+            console.log('stderr: ' + stderr);\\n+            console.log('exec error: ' + error);\\n+        }\\n+\\n+        return currentContent;\\n+    });\\n+}*/\\n+\\n+var commitsInfo = [];\\n+\\n fs.exists('.git', function (exists) {\\n     if(exists) {\\n-        var cp = require('child_process');\\n+        /*async.series(tasks, function(err, result) {\\n+            fs.writeFileSync(\\\"patches.sousp\\\", JSON.stringify(result));\\n+\\n+            var data = result[0];\\n \\n-        cp.exec('git diff', function(error, stdout, stderr) {\\n-            console.log(stdout);\\n+            /*function some_function(arg1, arg2, callback) {\\n+                cp.exec('git diff' + ' ' + arg1 + ' ' + arg2, function(error, stdout, stderr) {\\n+                    var currentContent = 54321;//stdout;\\n \\n-            fs.writeFileSync(\\\"patches.sousp\\\", stdout);\\n+                    if (error !== null) {\\n+                        console.log('stderr: ' + stderr);\\n+                        console.log('exec error: ' + error);\\n+                    }\\n \\n-            if (error !== null) {\\n-                console.log('stderr: ' + stderr);\\n-                console.log('exec error: ' + error);\\n+                    callback(null, currentContent);\\n+                });\\n             }\\n-        });\\n+        });*/\\n+\\n+        async.waterfall([\\n+            function getCommitsInfo(callback) {\\n+                cp.exec('git log', function(error, stdout, stderr) {\\n+                    var listOfCommits = [];\\n+                    var authors = findData(stdout, \\\"Author:\\\");\\n+                    var dates = findData(stdout, \\\"Date:\\\");\\n+                    var comments = findComments(stdout);\\n+                    var commitNumbers = findCommitNumbers(stdout);\\n \\n-        cp.exec('git log', function(error, stdout, stderr) {\\n-            console.log(stdout);\\n+                    for(i=0; i<authors.length; i++) {\\n+                        var commit = {\\n+                            \\\"commit\\\": commitNumbers[i],\\n+                            \\\"author\\\": authors[i],\\n+                            \\\"date\\\": dates[i],\\n+                            \\\"comment\\\": comments[i],\\n+                            \\\"content\\\": 'Original'\\n+                        };\\n+                        listOfCommits[listOfCommits.length] = commit;\\n+                    }\\n \\n-            var authors = findData(stdout, \\\"Author:\\\");\\n-            var dates = findData(stdout, \\\"Date:\\\");\\n-            var comments = findComments(stdout);\\n-            console.log(authors);\\n-            console.log(comments);\\n-            console.log(dates);\\n+                    callback(null, listOfCommits.reverse());\\n \\n-            fs.writeFileSync(\\\"comments.sousc\\\", stdout);\\n+                    if (error !== null) {\\n+                        console.log('stderr: ' + stderr);\\n+                        console.log('exec error: ' + error);\\n+                    }\\n+                });\\n+            },\\n+            function getCommitsContent(commits, callback) {\\n+                console.log(commits);\\n+                var commitsData = commits;\\n \\n-            if (error !== null) {\\n-                console.log('stderr: ' + stderr);\\n-                console.log('exec error: ' + error);\\n+                for(i=1; i<commitsData.length; i++) {\\n+                    cp.exec('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit, function(error, stdout, stderr) {\\n+                        commitsData[i].content = stdout;\\n+\\n+                        if (error !== null) {\\n+                            console.log('stderr: ' + stderr);\\n+                            console.log('exec error: ' + error);\\n+                        }\\n+                    });\\n+                }\\n+\\n+                callback(null, commitsData);\\n             }\\n+        ], function (err, result) {\\n+            fs.writeFileSync(\\\"patches.sousp\\\", result);\\n         });\\n+\\n+        //commitsInfo = JSON.parse(fs.readFileSync(\\\"patches.sousp\\\"));\\n+        //console.log(commitsInfo);\\n     }\\n-    else console.log(\\\"Error.\\\");\\n });\\n\\\\ No newline at end of file\\ndiff --git a/node_modules/async/.travis.yml b/node_modules/async/.travis.yml\\nnew file mode 100644\\nindex 0000000..6e5919d\\n--- /dev/null\\n+++ b/node_modules/async/.travis.yml\\n@@ -0,0 +1,3 @@\\n+language: node_js\\n+node_js:\\n+  - \\\"0.10\\\"\\ndiff --git a/node_modules/async/LICENSE b/node_modules/async/LICENSE\\nnew file mode 100644\\nindex 0000000..8f29698\\n--- /dev/null\\n+++ b/node_modules/async/LICENSE\\n@@ -0,0 +1,19 @@\\n+Copyright (c) 2010-2014 Caolan McMahon\\n+\\n+Permission is hereby granted, free of charge, to any person obtaining a copy\\n+of this software and associated documentation files (the \\\"Software\\\"), to deal\\n+in the Software without restriction, including without limitation the rights\\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n+copies of the Software, and to permit persons to whom the Software is\\n+furnished to do so, subject to the following conditions:\\n+\\n+The above copyright notice and this permission notice shall be included in\\n+all copies or substantial portions of the Software.\\n+\\n+THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n+THE SOFTWARE.\\ndiff --git a/node_modules/async/README.md b/node_modules/async/README.md\\nnew file mode 100644\\nindex 0000000..0bea531\\n--- /dev/null\\n+++ b/node_modules/async/README.md\\n@@ -0,0 +1,1646 @@\\n+# Async.js\\n+\\n+[![Build Status via Travis CI](https://travis-ci.org/caolan/async.svg?branch=master)](https://travis-ci.org/caolan/async)\\n+\\n+\\n+Async is a utility module which provides straight-forward, powerful functions\\n+for working with asynchronous JavaScript. Although originally designed for\\n+use with [Node.js](http://nodejs.org), it can also be used directly in the\\n+browser. Also supports [component](https://github.com/component/component).\\n+\\n+Async provides around 20 functions that include the usual 'functional'\\n+suspects (`map`, `reduce`, `filter`, `each`…) as well as some common patterns\\n+for asynchronous control flow (`parallel`, `series`, `waterfall`…). All these\\n+functions assume you follow the Node.js convention of providing a single\\n+callback as the last argument of your `async` function.\\n+\\n+\\n+## Quick Examples\\n+\\n+```javascript\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\n+    // results is now an array of stats for each file\\n+});\\n+\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\n+    // results now equals an array of the existing files\\n+});\\n+\\n+async.parallel([\\n+    function(){ ... },\\n+    function(){ ... }\\n+], callback);\\n+\\n+async.series([\\n+    function(){ ... },\\n+    function(){ ... }\\n+]);\\n+```\\n+\\n+There are many more functions available so take a look at the docs below for a\\n+full list. This module aims to be comprehensive, so if you feel anything is\\n+missing please create a GitHub issue for it.\\n+\\n+## Common Pitfalls\\n+\\n+### Binding a context to an iterator\\n+\\n+This section is really about `bind`, not about `async`. If you are wondering how to\\n+make `async` execute your iterators in a given context, or are confused as to why\\n+a method of another library isn't working as an iterator, study this example:\\n+\\n+```js\\n+// Here is a simple object with an (unnecessarily roundabout) squaring method\\n+var AsyncSquaringLibrary = {\\n+  squareExponent: 2,\\n+  square: function(number, callback){ \\n+    var result = Math.pow(number, this.squareExponent);\\n+    setTimeout(function(){\\n+      callback(null, result);\\n+    }, 200);\\n+  }\\n+};\\n+\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square, function(err, result){\\n+  // result is [NaN, NaN, NaN]\\n+  // This fails because the `this.squareExponent` expression in the square\\n+  // function is not evaluated in the context of AsyncSquaringLibrary, and is\\n+  // therefore undefined.\\n+});\\n+\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), function(err, result){\\n+  // result is [1, 4, 9]\\n+  // With the help of bind we can attach a context to the iterator before\\n+  // passing it to async. Now the square function will be executed in its \\n+  // 'home' AsyncSquaringLibrary context and the value of `this.squareExponent`\\n+  // will be as expected.\\n+});\\n+```\\n+\\n+## Download\\n+\\n+The source is available for download from\\n+[GitHub](http://github.com/caolan/async).\\n+Alternatively, you can install using Node Package Manager (`npm`):\\n+\\n+    npm install async\\n+\\n+__Development:__ [async.js](https://github.com/caolan/async/raw/master/lib/async.js) - 29.6kb Uncompressed\\n+\\n+## In the Browser\\n+\\n+So far it's been tested in IE6, IE7, IE8, FF3.6 and Chrome 5. \\n+\\n+Usage:\\n+\\n+```html\\n+<script type=\\\"text/javascript\\\" src=\\\"async.js\\\"></script>\\n+<script type=\\\"text/javascript\\\">\\n+\\n+    async.map(data, asyncProcess, function(err, results){\\n+        alert(results);\\n+    });\\n+\\n+</script>\\n+```\\n+\\n+## Documentation\\n+\\n+### Collections\\n+\\n+* [`each`](#each)\\n+* [`eachSeries`](#eachSeries)\\n+* [`eachLimit`](#eachLimit)\\n+* [`map`](#map)\\n+* [`mapSeries`](#mapSeries)\\n+* [`mapLimit`](#mapLimit)\\n+* [`filter`](#filter)\\n+* [`filterSeries`](#filterSeries)\\n+* [`reject`](#reject)\\n+* [`rejectSeries`](#rejectSeries)\\n+* [`reduce`](#reduce)\\n+* [`reduceRight`](#reduceRight)\\n+* [`detect`](#detect)\\n+* [`detectSeries`](#detectSeries)\\n+* [`sortBy`](#sortBy)\\n+* [`some`](#some)\\n+* [`every`](#every)\\n+* [`concat`](#concat)\\n+* [`concatSeries`](#concatSeries)\\n+\\n+### Control Flow\\n+\\n+* [`series`](#seriestasks-callback)\\n+* [`parallel`](#parallel)\\n+* [`parallelLimit`](#parallellimittasks-limit-callback)\\n+* [`whilst`](#whilst)\\n+* [`doWhilst`](#doWhilst)\\n+* [`until`](#until)\\n+* [`doUntil`](#doUntil)\\n+* [`forever`](#forever)\\n+* [`waterfall`](#waterfall)\\n+* [`compose`](#compose)\\n+* [`seq`](#seq)\\n+* [`applyEach`](#applyEach)\\n+* [`applyEachSeries`](#applyEachSeries)\\n+* [`queue`](#queue)\\n+* [`priorityQueue`](#priorityQueue)\\n+* [`cargo`](#cargo)\\n+* [`auto`](#auto)\\n+* [`retry`](#retry)\\n+* [`iterator`](#iterator)\\n+* [`apply`](#apply)\\n+* [`nextTick`](#nextTick)\\n+* [`times`](#times)\\n+* [`timesSeries`](#timesSeries)\\n+\\n+### Utils\\n+\\n+* [`memoize`](#memoize)\\n+* [`unmemoize`](#unmemoize)\\n+* [`log`](#log)\\n+* [`dir`](#dir)\\n+* [`noConflict`](#noConflict)\\n+\\n+\\n+## Collections\\n+\\n+<a name=\\\"forEach\\\" />\\n+<a name=\\\"each\\\" />\\n+### each(arr, iterator, callback)\\n+\\n+Applies the function `iterator` to each item in `arr`, in parallel.\\n+The `iterator` is called with an item from the list, and a callback for when it\\n+has finished. If the `iterator` passes an error to its `callback`, the main\\n+`callback` (for the `each` function) is immediately called with the error.\\n+\\n+Note, that since this function applies `iterator` to each item in parallel,\\n+there is no guarantee that the iterator functions will complete in order.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err)` which must be called once it has \\n+  completed. If no error has occured, the `callback` should be run without \\n+  arguments or with an explicit `null` argument.\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\n+  have finished, or an error occurs.\\n+\\n+__Examples__\\n+\\n+\\n+```js\\n+// assuming openFiles is an array of file names and saveFile is a function\\n+// to save the modified contents of that file:\\n+\\n+async.each(openFiles, saveFile, function(err){\\n+    // if any of the saves produced an error, err would equal that error\\n+});\\n+```\\n+\\n+```js\\n+// assuming openFiles is an array of file names \\n+\\n+async.each(openFiles, function( file, callback) {\\n+  \\n+  // Perform operation on file here.\\n+  console.log('Processing file ' + file);\\n+  \\n+  if( file.length > 32 ) {\\n+    console.log('This file name is too long');\\n+    callback('File name too long');\\n+  } else {\\n+    // Do work to process file here\\n+    console.log('File processed');\\n+    callback();\\n+  }\\n+}, function(err){\\n+    // if any of the file processing produced an error, err would equal that error\\n+    if( err ) {\\n+      // One of the iterations produced an error.\\n+      // All processing will now stop.\\n+      console.log('A file failed to process');\\n+    } else {\\n+      console.log('All files have been processed successfully');\\n+    }\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"forEachSeries\\\" />\\n+<a name=\\\"eachSeries\\\" />\\n+### eachSeries(arr, iterator, callback)\\n+\\n+The same as [`each`](#each), only `iterator` is applied to each item in `arr` in\\n+series. The next `iterator` is only called once the current one has completed. \\n+This means the `iterator` functions will complete in order.\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"forEachLimit\\\" />\\n+<a name=\\\"eachLimit\\\" />\\n+### eachLimit(arr, limit, iterator, callback)\\n+\\n+The same as [`each`](#each), only no more than `limit` `iterator`s will be simultaneously \\n+running at any time.\\n+\\n+Note that the items in `arr` are not processed in batches, so there is no guarantee that \\n+the first `limit` `iterator` functions will complete before any others are started.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err)` which must be called once it has \\n+  completed. If no error has occured, the callback should be run without \\n+  arguments or with an explicit `null` argument.\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\n+  have finished, or an error occurs.\\n+\\n+__Example__\\n+\\n+```js\\n+// Assume documents is an array of JSON objects and requestApi is a\\n+// function that interacts with a rate-limited REST api.\\n+\\n+async.eachLimit(documents, 20, requestApi, function(err){\\n+    // if any of the saves produced an error, err would equal that error\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"map\\\" />\\n+### map(arr, iterator, callback)\\n+\\n+Produces a new array of values by mapping each value in `arr` through\\n+the `iterator` function. The `iterator` is called with an item from `arr` and a\\n+callback for when it has finished processing. Each of these callback takes 2 arguments: \\n+an `error`, and the transformed item from `arr`. If `iterator` passes an error to this \\n+callback, the main `callback` (for the `map` function) is immediately called with the error.\\n+\\n+Note, that since this function applies the `iterator` to each item in parallel,\\n+there is no guarantee that the `iterator` functions will complete in order. \\n+However, the results array will be in the same order as the original `arr`.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\n+  it has completed with an error (which can be `null`) and a transformed item.\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\n+  functions have finished, or an error occurs. Results is an array of the\\n+  transformed items from the `arr`.\\n+\\n+__Example__\\n+\\n+```js\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\n+    // results is now an array of stats for each file\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"mapSeries\\\" />\\n+### mapSeries(arr, iterator, callback)\\n+\\n+The same as [`map`](#map), only the `iterator` is applied to each item in `arr` in\\n+series. The next `iterator` is only called once the current one has completed. \\n+The results array will be in the same order as the original.\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"mapLimit\\\" />\\n+### mapLimit(arr, limit, iterator, callback)\\n+\\n+The same as [`map`](#map), only no more than `limit` `iterator`s will be simultaneously \\n+running at any time.\\n+\\n+Note that the items are not processed in batches, so there is no guarantee that \\n+the first `limit` `iterator` functions will complete before any others are started.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\n+  it has completed with an error (which can be `null`) and a transformed item.\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\n+  calls have finished, or an error occurs. The result is an array of the\\n+  transformed items from the original `arr`.\\n+\\n+__Example__\\n+\\n+```js\\n+async.mapLimit(['file1','file2','file3'], 1, fs.stat, function(err, results){\\n+    // results is now an array of stats for each file\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"select\\\" />\\n+<a name=\\\"filter\\\" />\\n+### filter(arr, iterator, callback)\\n+\\n+__Alias:__ `select`\\n+\\n+Returns a new array of all the values in `arr` which pass an async truth test.\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\n+way node libraries work with truth tests like `fs.exists`. This operation is\\n+performed in parallel, but the results array will be in the same order as the\\n+original.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\n+  The `iterator` is passed a `callback(truthValue)`, which must be called with a \\n+  boolean argument once it has completed.\\n+* `callback(results)` - A callback which is called after all the `iterator`\\n+  functions have finished.\\n+\\n+__Example__\\n+\\n+```js\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\n+    // results now equals an array of the existing files\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"selectSeries\\\" />\\n+<a name=\\\"filterSeries\\\" />\\n+### filterSeries(arr, iterator, callback)\\n+\\n+__Alias:__ `selectSeries`\\n+\\n+The same as [`filter`](#filter) only the `iterator` is applied to each item in `arr` in\\n+series. The next `iterator` is only called once the current one has completed. \\n+The results array will be in the same order as the original.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"reject\\\" />\\n+### reject(arr, iterator, callback)\\n+\\n+The opposite of [`filter`](#filter). Removes values that pass an `async` truth test.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"rejectSeries\\\" />\\n+### rejectSeries(arr, iterator, callback)\\n+\\n+The same as [`reject`](#reject), only the `iterator` is applied to each item in `arr`\\n+in series.\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"reduce\\\" />\\n+### reduce(arr, memo, iterator, callback)\\n+\\n+__Aliases:__ `inject`, `foldl`\\n+\\n+Reduces `arr` into a single value using an async `iterator` to return\\n+each successive step. `memo` is the initial state of the reduction. \\n+This function only operates in series. \\n+\\n+For performance reasons, it may make sense to split a call to this function into \\n+a parallel map, and then use the normal `Array.prototype.reduce` on the results. \\n+This function is for situations where each step in the reduction needs to be async; \\n+if you can get the data before reducing it, then it's probably a good idea to do so.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `memo` - The initial state of the reduction.\\n+* `iterator(memo, item, callback)` - A function applied to each item in the\\n+  array to produce the next step in the reduction. The `iterator` is passed a\\n+  `callback(err, reduction)` which accepts an optional error as its first \\n+  argument, and the state of the reduction as the second. If an error is \\n+  passed to the callback, the reduction is stopped and the main `callback` is \\n+  immediately called with the error.\\n+* `callback(err, result)` - A callback which is called after all the `iterator`\\n+  functions have finished. Result is the reduced value.\\n+\\n+__Example__\\n+\\n+```js\\n+async.reduce([1,2,3], 0, function(memo, item, callback){\\n+    // pointless async:\\n+    process.nextTick(function(){\\n+        callback(null, memo + item)\\n+    });\\n+}, function(err, result){\\n+    // result is now equal to the last value of memo, which is 6\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"reduceRight\\\" />\\n+### reduceRight(arr, memo, iterator, callback)\\n+\\n+__Alias:__ `foldr`\\n+\\n+Same as [`reduce`](#reduce), only operates on `arr` in reverse order.\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"detect\\\" />\\n+### detect(arr, iterator, callback)\\n+\\n+Returns the first value in `arr` that passes an async truth test. The\\n+`iterator` is applied in parallel, meaning the first iterator to return `true` will\\n+fire the detect `callback` with that result. That means the result might not be\\n+the first item in the original `arr` (in terms of order) that passes the test.\\n+\\n+If order within the original `arr` is important, then look at [`detectSeries`](#detectSeries).\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\n+  The iterator is passed a `callback(truthValue)` which must be called with a \\n+  boolean argument once it has completed.\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\n+  `true`, or after all the `iterator` functions have finished. Result will be\\n+  the first item in the array that passes the truth test (iterator) or the\\n+  value `undefined` if none passed.\\n+\\n+__Example__\\n+\\n+```js\\n+async.detect(['file1','file2','file3'], fs.exists, function(result){\\n+    // result now equals the first file in the list that exists\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"detectSeries\\\" />\\n+### detectSeries(arr, iterator, callback)\\n+\\n+The same as [`detect`](#detect), only the `iterator` is applied to each item in `arr`\\n+in series. This means the result is always the first in the original `arr` (in\\n+terms of array order) that passes the truth test.\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"sortBy\\\" />\\n+### sortBy(arr, iterator, callback)\\n+\\n+Sorts a list by the results of running each `arr` value through an async `iterator`.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err, sortValue)` which must be called once it\\n+  has completed with an error (which can be `null`) and a value to use as the sort\\n+  criteria.\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\n+  functions have finished, or an error occurs. Results is the items from\\n+  the original `arr` sorted by the values returned by the `iterator` calls.\\n+\\n+__Example__\\n+\\n+```js\\n+async.sortBy(['file1','file2','file3'], function(file, callback){\\n+    fs.stat(file, function(err, stats){\\n+        callback(err, stats.mtime);\\n+    });\\n+}, function(err, results){\\n+    // results is now the original array of files sorted by\\n+    // modified date\\n+});\\n+```\\n+\\n+__Sort Order__\\n+\\n+By modifying the callback parameter the sorting order can be influenced:\\n+\\n+```js\\n+//ascending order\\n+async.sortBy([1,9,3,5], function(x, callback){\\n+    callback(err, x);\\n+}, function(err,result){\\n+    //result callback\\n+} );\\n+\\n+//descending order\\n+async.sortBy([1,9,3,5], function(x, callback){\\n+    callback(err, x*-1);    //<- x*-1 instead of x, turns the order around\\n+}, function(err,result){\\n+    //result callback\\n+} );\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"some\\\" />\\n+### some(arr, iterator, callback)\\n+\\n+__Alias:__ `any`\\n+\\n+Returns `true` if at least one element in the `arr` satisfies an async test.\\n+_The callback for each iterator call only accepts a single argument of `true` or\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\n+way node libraries work with truth tests like `fs.exists`. Once any iterator\\n+call returns `true`, the main `callback` is immediately called.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\n+  called with a boolean argument once it has completed.\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\n+  `true`, or after all the iterator functions have finished. Result will be\\n+  either `true` or `false` depending on the values of the async tests.\\n+\\n+__Example__\\n+\\n+```js\\n+async.some(['file1','file2','file3'], fs.exists, function(result){\\n+    // if result is true then at least one of the files exists\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"every\\\" />\\n+### every(arr, iterator, callback)\\n+\\n+__Alias:__ `all`\\n+\\n+Returns `true` if every element in `arr` satisfies an async test.\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\n+way node libraries work with truth tests like `fs.exists`.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\n+  called with a  boolean argument once it has completed.\\n+* `callback(result)` - A callback which is called after all the `iterator`\\n+  functions have finished. Result will be either `true` or `false` depending on\\n+  the values of the async tests.\\n+\\n+__Example__\\n+\\n+```js\\n+async.every(['file1','file2','file3'], fs.exists, function(result){\\n+    // if result is true then every file exists\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"concat\\\" />\\n+### concat(arr, iterator, callback)\\n+\\n+Applies `iterator` to each item in `arr`, concatenating the results. Returns the\\n+concatenated list. The `iterator`s are called in parallel, and the results are\\n+concatenated as they return. There is no guarantee that the results array will\\n+be returned in the original order of `arr` passed to the `iterator` function.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err, results)` which must be called once it \\n+  has completed with an error (which can be `null`) and an array of results.\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\n+  functions have finished, or an error occurs. Results is an array containing\\n+  the concatenated results of the `iterator` function.\\n+\\n+__Example__\\n+\\n+```js\\n+async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files){\\n+    // files is now a list of filenames that exist in the 3 directories\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"concatSeries\\\" />\\n+### concatSeries(arr, iterator, callback)\\n+\\n+Same as [`concat`](#concat), but executes in series instead of parallel.\\n+\\n+\\n+## Control Flow\\n+\\n+<a name=\\\"series\\\" />\\n+### series(tasks, [callback])\\n+\\n+Run the functions in the `tasks` array in series, each one running once the previous\\n+function has completed. If any functions in the series pass an error to its\\n+callback, no more functions are run, and `callback` is immediately called with the value of the error. \\n+Otherwise, `callback` receives an array of results when `tasks` have completed.\\n+\\n+It is also possible to use an object instead of an array. Each property will be\\n+run as a function, and the results will be passed to the final `callback` as an object\\n+instead of an array. This can be a more readable way of handling results from\\n+[`series`](#series).\\n+\\n+**Note** that while many implementations preserve the order of object properties, the\\n+[ECMAScript Language Specifcation](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6) \\n+explicitly states that\\n+\\n+> The mechanics and order of enumerating the properties is not specified.\\n+\\n+So if you rely on the order in which your series of functions are executed, and want\\n+this to work on all platforms, consider using an array. \\n+\\n+__Arguments__\\n+\\n+* `tasks` - An array or object containing functions to run, each function is passed\\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\n+  be `null`) and an optional `result` value.\\n+* `callback(err, results)` - An optional callback to run once all the functions\\n+  have completed. This function gets a results array (or object) containing all \\n+  the result arguments passed to the `task` callbacks.\\n+\\n+__Example__\\n+\\n+```js\\n+async.series([\\n+    function(callback){\\n+        // do some stuff ...\\n+        callback(null, 'one');\\n+    },\\n+    function(callback){\\n+        // do some more stuff ...\\n+        callback(null, 'two');\\n+    }\\n+],\\n+// optional callback\\n+function(err, results){\\n+    // results is now equal to ['one', 'two']\\n+});\\n+\\n+\\n+// an example using an object instead of an array\\n+async.series({\\n+    one: function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 1);\\n+        }, 200);\\n+    },\\n+    two: function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 2);\\n+        }, 100);\\n+    }\\n+},\\n+function(err, results) {\\n+    // results is now equal to: {one: 1, two: 2}\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"parallel\\\" />\\n+### parallel(tasks, [callback])\\n+\\n+Run the `tasks` array of functions in parallel, without waiting until the previous\\n+function has completed. If any of the functions pass an error to its\\n+callback, the main `callback` is immediately called with the value of the error.\\n+Once the `tasks` have completed, the results are passed to the final `callback` as an\\n+array.\\n+\\n+It is also possible to use an object instead of an array. Each property will be\\n+run as a function and the results will be passed to the final `callback` as an object\\n+instead of an array. This can be a more readable way of handling results from\\n+[`parallel`](#parallel).\\n+\\n+\\n+__Arguments__\\n+\\n+* `tasks` - An array or object containing functions to run. Each function is passed \\n+  a `callback(err, result)` which it must call on completion with an error `err` \\n+  (which can be `null`) and an optional `result` value.\\n+* `callback(err, results)` - An optional callback to run once all the functions\\n+  have completed. This function gets a results array (or object) containing all \\n+  the result arguments passed to the task callbacks.\\n+\\n+__Example__\\n+\\n+```js\\n+async.parallel([\\n+    function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 'one');\\n+        }, 200);\\n+    },\\n+    function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 'two');\\n+        }, 100);\\n+    }\\n+],\\n+// optional callback\\n+function(err, results){\\n+    // the results array will equal ['one','two'] even though\\n+    // the second function had a shorter timeout.\\n+});\\n+\\n+\\n+// an example using an object instead of an array\\n+async.parallel({\\n+    one: function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 1);\\n+        }, 200);\\n+    },\\n+    two: function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 2);\\n+        }, 100);\\n+    }\\n+},\\n+function(err, results) {\\n+    // results is now equals to: {one: 1, two: 2}\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"parallelLimit\\\" />\\n+### parallelLimit(tasks, limit, [callback])\\n+\\n+The same as [`parallel`](#parallel), only `tasks` are executed in parallel \\n+with a maximum of `limit` tasks executing at any time.\\n+\\n+Note that the `tasks` are not executed in batches, so there is no guarantee that \\n+the first `limit` tasks will complete before any others are started.\\n+\\n+__Arguments__\\n+\\n+* `tasks` - An array or object containing functions to run, each function is passed \\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\n+  be `null`) and an optional `result` value.\\n+* `limit` - The maximum number of `tasks` to run at any time.\\n+* `callback(err, results)` - An optional callback to run once all the functions\\n+  have completed. This function gets a results array (or object) containing all \\n+  the result arguments passed to the `task` callbacks.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"whilst\\\" />\\n+### whilst(test, fn, callback)\\n+\\n+Repeatedly call `fn`, while `test` returns `true`. Calls `callback` when stopped,\\n+or an error occurs.\\n+\\n+__Arguments__\\n+\\n+* `test()` - synchronous truth test to perform before each execution of `fn`.\\n+* `fn(callback)` - A function which is called each time `test` passes. The function is\\n+  passed a `callback(err)`, which must be called once it has completed with an \\n+  optional `err` argument.\\n+* `callback(err)` - A callback which is called after the test fails and repeated\\n+  execution of `fn` has stopped.\\n+\\n+__Example__\\n+\\n+```js\\n+var count = 0;\\n+\\n+async.whilst(\\n+    function () { return count < 5; },\\n+    function (callback) {\\n+        count++;\\n+        setTimeout(callback, 1000);\\n+    },\\n+    function (err) {\\n+        // 5 seconds have passed\\n+    }\\n+);\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"doWhilst\\\" />\\n+### doWhilst(fn, test, callback)\\n+\\n+The post-check version of [`whilst`](#whilst). To reflect the difference in \\n+the order of operations, the arguments `test` and `fn` are switched. \\n+\\n+`doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"until\\\" />\\n+### until(test, fn, callback)\\n+\\n+Repeatedly call `fn` until `test` returns `true`. Calls `callback` when stopped,\\n+or an error occurs.\\n+\\n+The inverse of [`whilst`](#whilst).\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"doUntil\\\" />\\n+### doUntil(fn, test, callback)\\n+\\n+Like [`doWhilst`](#doWhilst), except the `test` is inverted. Note the argument ordering differs from `until`.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"forever\\\" />\\n+### forever(fn, errback)\\n+\\n+Calls the asynchronous function `fn` with a callback parameter that allows it to\\n+call itself again, in series, indefinitely.\\n+\\n+If an error is passed to the callback then `errback` is called with the\\n+error, and execution stops, otherwise it will never be called.\\n+\\n+```js\\n+async.forever(\\n+    function(next) {\\n+        // next is suitable for passing to things that need a callback(err [, whatever]);\\n+        // it will result in this function being called again.\\n+    },\\n+    function(err) {\\n+        // if next is called with a value in its first parameter, it will appear\\n+        // in here as 'err', and execution will stop.\\n+    }\\n+);\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"waterfall\\\" />\\n+### waterfall(tasks, [callback])\\n+\\n+Runs the `tasks` array of functions in series, each passing their results to the next in\\n+the array. However, if any of the `tasks` pass an error to their own callback, the\\n+next function is not executed, and the main `callback` is immediately called with\\n+the error.\\n+\\n+__Arguments__\\n+\\n+* `tasks` - An array of functions to run, each function is passed a \\n+  `callback(err, result1, result2, ...)` it must call on completion. The first\\n+  argument is an error (which can be `null`) and any further arguments will be \\n+  passed as arguments in order to the next task.\\n+* `callback(err, [results])` - An optional callback to run once all the functions\\n+  have completed. This will be passed the results of the last task's callback.\\n+\\n+\\n+\\n+__Example__\\n+\\n+```js\\n+async.waterfall([\\n+    function(callback){\\n+        callback(null, 'one', 'two');\\n+    },\\n+    function(arg1, arg2, callback){\\n+      // arg1 now equals 'one' and arg2 now equals 'two'\\n+        callback(null, 'three');\\n+    },\\n+    function(arg1, callback){\\n+        // arg1 now equals 'three'\\n+        callback(null, 'done');\\n+    }\\n+], function (err, result) {\\n+   // result now equals 'done'    \\n+});\\n+```\\n+\\n+---------------------------------------\\n+<a name=\\\"compose\\\" />\\n+### compose(fn1, fn2...)\\n+\\n+Creates a function which is a composition of the passed asynchronous\\n+functions. Each function consumes the return value of the function that\\n+follows. Composing functions `f()`, `g()`, and `h()` would produce the result of\\n+`f(g(h()))`, only this version uses callbacks to obtain the return values.\\n+\\n+Each function is executed with the `this` binding of the composed function.\\n+\\n+__Arguments__\\n+\\n+* `functions...` - the asynchronous functions to compose\\n+\\n+\\n+__Example__\\n+\\n+```js\\n+function add1(n, callback) {\\n+    setTimeout(function () {\\n+        callback(null, n + 1);\\n+    }, 10);\\n+}\\n+\\n+function mul3(n, callback) {\\n+    setTimeout(function () {\\n+        callback(null, n * 3);\\n+    }, 10);\\n+}\\n+\\n+var add1mul3 = async.compose(mul3, add1);\\n+\\n+add1mul3(4, function (err, result) {\\n+   // result now equals 15\\n+});\\n+```\\n+\\n+---------------------------------------\\n+<a name=\\\"seq\\\" />\\n+### seq(fn1, fn2...)\\n+\\n+Version of the compose function that is more natural to read.\\n+Each following function consumes the return value of the latter function. \\n+\\n+Each function is executed with the `this` binding of the composed function.\\n+\\n+__Arguments__\\n+\\n+* functions... - the asynchronous functions to compose\\n+\\n+\\n+__Example__\\n+\\n+```js\\n+// Requires lodash (or underscore), express3 and dresende's orm2.\\n+// Part of an app, that fetches cats of the logged user.\\n+// This example uses `seq` function to avoid overnesting and error \\n+// handling clutter.\\n+app.get('/cats', function(request, response) {\\n+  function handleError(err, data, callback) {\\n+    if (err) {\\n+      console.error(err);\\n+      response.json({ status: 'error', message: err.message });\\n+    }\\n+    else {\\n+      callback(data);\\n+    }\\n+  }\\n+  var User = request.models.User;\\n+  async.seq(\\n+    _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\\n+    handleError,\\n+    function(user, fn) {\\n+      user.getCats(fn);      // 'getCats' has signature (callback(err, data))\\n+    },\\n+    handleError,\\n+    function(cats) {\\n+      response.json({ status: 'ok', message: 'Cats found', data: cats });\\n+    }\\n+  )(req.session.user_id);\\n+  }\\n+});\\n+```\\n+\\n+---------------------------------------\\n+<a name=\\\"applyEach\\\" />\\n+### applyEach(fns, args..., callback)\\n+\\n+Applies the provided arguments to each function in the array, calling \\n+`callback` after all functions have completed. If you only provide the first\\n+argument, then it will return a function which lets you pass in the\\n+arguments as if it were a single function call.\\n+\\n+__Arguments__\\n+\\n+* `fns` - the asynchronous functions to all call with the same arguments\\n+* `args...` - any number of separate arguments to pass to the function\\n+* `callback` - the final argument should be the callback, called when all\\n+  functions have completed processing\\n+\\n+\\n+__Example__\\n+\\n+```js\\n+async.applyEach([enableSearch, updateSchema], 'bucket', callback);\\n+\\n+// partial application example:\\n+async.each(\\n+    buckets,\\n+    async.applyEach([enableSearch, updateSchema]),\\n+    callback\\n+);\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"applyEachSeries\\\" />\\n+### applyEachSeries(arr, iterator, callback)\\n+\\n+The same as [`applyEach`](#applyEach) only the functions are applied in series.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"queue\\\" />\\n+### queue(worker, concurrency)\\n+\\n+Creates a `queue` object with the specified `concurrency`. Tasks added to the\\n+`queue` are processed in parallel (up to the `concurrency` limit). If all\\n+`worker`s are in progress, the task is queued until one becomes available. \\n+Once a `worker` completes a `task`, that `task`'s callback is called.\\n+\\n+__Arguments__\\n+\\n+* `worker(task, callback)` - An asynchronous function for processing a queued\\n+  task, which must call its `callback(err)` argument when finished, with an \\n+  optional `error` as an argument.\\n+* `concurrency` - An `integer` for determining how many `worker` functions should be\\n+  run in parallel.\\n+\\n+__Queue objects__\\n+\\n+The `queue` object returned by this function has the following properties and\\n+methods:\\n+\\n+* `length()` - a function returning the number of items waiting to be processed.\\n+* `started` - a function returning whether or not any items have been pushed and processed by the queue\\n+* `running()` - a function returning the number of items currently being processed.\\n+* `idle()` - a function returning false if there are items waiting or being processed, or true if not.\\n+* `concurrency` - an integer for determining how many `worker` functions should be\\n+  run in parallel. This property can be changed after a `queue` is created to\\n+  alter the concurrency on-the-fly.\\n+* `push(task, [callback])` - add a new task to the `queue`. Calls `callback` once \\n+  the `worker` has finished processing the task. Instead of a single task, a `tasks` array\\n+  can be submitted. The respective callback is used for every task in the list.\\n+* `unshift(task, [callback])` - add a new task to the front of the `queue`.\\n+* `saturated` - a callback that is called when the `queue` length hits the `concurrency` limit, \\n+   and further tasks will be queued.\\n+* `empty` - a callback that is called when the last item from the `queue` is given to a `worker`.\\n+* `drain` - a callback that is called when the last item from the `queue` has returned from the `worker`.\\n+* `paused` - a boolean for determining whether the queue is in a paused state\\n+* `pause()` - a function that pauses the processing of tasks until `resume()` is called.\\n+* `resume()` - a function that resumes the processing of queued tasks when the queue is paused.\\n+* `kill()` - a function that empties remaining tasks from the queue forcing it to go idle.\\n+\\n+__Example__\\n+\\n+```js\\n+// create a queue object with concurrency 2\\n+\\n+var q = async.queue(function (task, callback) {\\n+    console.log('hello ' + task.name);\\n+    callback();\\n+}, 2);\\n+\\n+\\n+// assign a callback\\n+q.drain = function() {\\n+    console.log('all items have been processed');\\n+}\\n+\\n+// add some items to the queue\\n+\\n+q.push({name: 'foo'}, function (err) {\\n+    console.log('finished processing foo');\\n+});\\n+q.push({name: 'bar'}, function (err) {\\n+    console.log('finished processing bar');\\n+});\\n+\\n+// add some items to the queue (batch-wise)\\n+\\n+q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function (err) {\\n+    console.log('finished processing bar');\\n+});\\n+\\n+// add some items to the front of the queue\\n+\\n+q.unshift({name: 'bar'}, function (err) {\\n+    console.log('finished processing bar');\\n+});\\n+```\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"priorityQueue\\\" />\\n+### priorityQueue(worker, concurrency)\\n+\\n+The same as [`queue`](#queue) only tasks are assigned a priority and completed in ascending priority order. There are two differences between `queue` and `priorityQueue` objects:\\n+\\n+* `push(task, priority, [callback])` - `priority` should be a number. If an array of\\n+  `tasks` is given, all tasks will be assigned the same priority.\\n+* The `unshift` method was removed.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"cargo\\\" />\\n+### cargo(worker, [payload])\\n+\\n+Creates a `cargo` object with the specified payload. Tasks added to the\\n+cargo will be processed altogether (up to the `payload` limit). If the\\n+`worker` is in progress, the task is queued until it becomes available. Once\\n+the `worker` has completed some tasks, each callback of those tasks is called.\\n+Check out [this animation](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) for how `cargo` and `queue` work.\\n+\\n+While [queue](#queue) passes only one task to one of a group of workers\\n+at a time, cargo passes an array of tasks to a single worker, repeating\\n+when the worker is finished.\\n+\\n+__Arguments__\\n+\\n+* `worker(tasks, callback)` - An asynchronous function for processing an array of\\n+  queued tasks, which must call its `callback(err)` argument when finished, with \\n+  an optional `err` argument.\\n+* `payload` - An optional `integer` for determining how many tasks should be\\n+  processed per round; if omitted, the default is unlimited.\\n+\\n+__Cargo objects__\\n+\\n+The `cargo` object returned by this function has the following properties and\\n+methods:\\n+\\n+* `length()` - A function returning the number of items waiting to be processed.\\n+* `payload` - An `integer` for determining how many tasks should be\\n+  process per round. This property can be changed after a `cargo` is created to\\n+  alter the payload on-the-fly.\\n+* `push(task, [callback])` - Adds `task` to the `queue`. The callback is called\\n+  once the `worker` has finished processing the task. Instead of a single task, an array of `tasks` \\n+  can be submitted. The respective callback is used for every task in the list.\\n+* `saturated` - A callback that is called when the `queue.length()` hits the concurrency and further tasks will be queued.\\n+* `empty` - A callback that is called when the last item from the `queue` is given to a `worker`.\\n+* `drain` - A callback that is called when the last item from the `queue` has returned from the `worker`.\\n+\\n+__Example__\\n+\\n+```js\\n+// create a cargo object with payload 2\\n+\\n+var cargo = async.cargo(function (tasks, callback) {\\n+    for(var i=0; i<tasks.length; i++){\\n+      console.log('hello ' + tasks[i].name);\\n+    }\\n+    callback();\\n+}, 2);\\n+\\n+\\n+// add some items\\n+\\n+cargo.push({name: 'foo'}, function (err) {\\n+    console.log('finished processing foo');\\n+});\\n+cargo.push({name: 'bar'}, function (err) {\\n+    console.log('finished processing bar');\\n+});\\n+cargo.push({name: 'baz'}, function (err) {\\n+    console.log('finished processing baz');\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"auto\\\" />\\n+### auto(tasks, [callback])\\n+\\n+Determines the best order for running the functions in `tasks`, based on their \\n+requirements. Each function can optionally depend on other functions being completed \\n+first, and each function is run as soon as its requirements are satisfied. \\n+\\n+If any of the functions pass an error to their callback, it will not \\n+complete (so any other functions depending on it will not run), and the main \\n+`callback` is immediately called with the error. Functions also receive an \\n+object containing the results of functions which have completed so far.\\n+\\n+Note, all functions are called with a `results` object as a second argument, \\n+so it is unsafe to pass functions in the `tasks` object which cannot handle the\\n+extra argument. \\n+\\n+For example, this snippet of code:\\n+\\n+```js\\n+async.auto({\\n+  readData: async.apply(fs.readFile, 'data.txt', 'utf-8')\\n+}, callback);\\n+```\\n+\\n+will have the effect of calling `readFile` with the results object as the last\\n+argument, which will fail:\\n+\\n+```js\\n+fs.readFile('data.txt', 'utf-8', cb, {});\\n+```\\n+\\n+Instead, wrap the call to `readFile` in a function which does not forward the \\n+`results` object:\\n+\\n+```js\\n+async.auto({\\n+  readData: function(cb, results){\\n+    fs.readFile('data.txt', 'utf-8', cb);\\n+  }\\n+}, callback);\\n+```\\n+\\n+__Arguments__\\n+\\n+* `tasks` - An object. Each of its properties is either a function or an array of\\n+  requirements, with the function itself the last item in the array. The object's key\\n+  of a property serves as the name of the task defined by that property,\\n+  i.e. can be used when specifying requirements for other tasks.\\n+  The function receives two arguments: (1) a `callback(err, result)` which must be \\n+  called when finished, passing an `error` (which can be `null`) and the result of \\n+  the function's execution, and (2) a `results` object, containing the results of\\n+  the previously executed functions.\\n+* `callback(err, results)` - An optional callback which is called when all the\\n+  tasks have been completed. It receives the `err` argument if any `tasks` \\n+  pass an error to their callback. Results are always returned; however, if \\n+  an error occurs, no further `tasks` will be performed, and the results\\n+  object will only contain partial results.\\n+\\n+\\n+__Example__\\n+\\n+```js\\n+async.auto({\\n+    get_data: function(callback){\\n+        console.log('in get_data');\\n+        // async code to get some data\\n+        callback(null, 'data', 'converted to array');\\n+    },\\n+    make_folder: function(callback){\\n+        console.log('in make_folder');\\n+        // async code to create a directory to store a file in\\n+        // this is run at the same time as getting the data\\n+        callback(null, 'folder');\\n+    },\\n+    write_file: ['get_data', 'make_folder', function(callback, results){\\n+        console.log('in write_file', JSON.stringify(results));\\n+        // once there is some data and the directory exists,\\n+        // write the data to a file in the directory\\n+        callback(null, 'filename');\\n+    }],\\n+    email_link: ['write_file', function(callback, results){\\n+        console.log('in email_link', JSON.stringify(results));\\n+        // once the file is written let's email a link to it...\\n+        // results.write_file contains the filename returned by write_file.\\n+        callback(null, {'file':results.write_file, 'email':'user@example.com'});\\n+    }]\\n+}, function(err, results) {\\n+    console.log('err = ', err);\\n+    console.log('results = ', results);\\n+});\\n+```\\n+\\n+This is a fairly trivial example, but to do this using the basic parallel and\\n+series functions would look like this:\\n+\\n+```js\\n+async.parallel([\\n+    function(callback){\\n+        console.log('in get_data');\\n+        // async code to get some data\\n+        callback(null, 'data', 'converted to array');\\n+    },\\n+    function(callback){\\n+        console.log('in make_folder');\\n+        // async code to create a directory to store a file in\\n+        // this is run at the same time as getting the data\\n+        callback(null, 'folder');\\n+    }\\n+],\\n+function(err, results){\\n+    async.series([\\n+        function(callback){\\n+            console.log('in write_file', JSON.stringify(results));\\n+            // once there is some data and the directory exists,\\n+            // write the data to a file in the directory\\n+            results.push('filename');\\n+            callback(null);\\n+        },\\n+        function(callback){\\n+            console.log('in email_link', JSON.stringify(results));\\n+            // once the file is written let's email a link to it...\\n+            callback(null, {'file':results.pop(), 'email':'user@example.com'});\\n+        }\\n+    ]);\\n+});\\n+```\\n+\\n+For a complicated series of `async` tasks, using the [`auto`](#auto) function makes adding\\n+new tasks much easier (and the code more readable).\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"retry\\\" />\\n+### retry([times = 5], task, [callback])\\n+\\n+Attempts to get a successful response from `task` no more than `times` times before\\n+returning an error. If the task is successful, the `callback` will be passed the result\\n+of the successfull task. If all attemps fail, the callback will be passed the error and\\n+result (if any) of the final attempt.\\n+\\n+__Arguments__\\n+\\n+* `times` - An integer indicating how many times to attempt the `task` before giving up. Defaults to 5.\\n+* `task(callback, results)` - A function which receives two arguments: (1) a `callback(err, result)`\\n+  which must be called when finished, passing `err` (which can be `null`) and the `result` of \\n+  the function's execution, and (2) a `results` object, containing the results of\\n+  the previously executed functions (if nested inside another control flow).\\n+* `callback(err, results)` - An optional callback which is called when the\\n+  task has succeeded, or after the final failed attempt. It receives the `err` and `result` arguments of the last attempt at completing the `task`.\\n+\\n+The [`retry`](#retry) function can be used as a stand-alone control flow by passing a\\n+callback, as shown below:\\n+\\n+```js\\n+async.retry(3, apiMethod, function(err, result) {\\n+    // do something with the result\\n+});\\n+```\\n+\\n+It can also be embeded within other control flow functions to retry individual methods\\n+that are not as reliable, like this:\\n+\\n+```js\\n+async.auto({\\n+    users: api.getUsers.bind(api),\\n+    payments: async.retry(3, api.getPayments.bind(api))\\n+}, function(err, results) {\\n+  // do something with the results\\n+});\\n+```\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"iterator\\\" />\\n+### iterator(tasks)\\n+\\n+Creates an iterator function which calls the next function in the `tasks` array,\\n+returning a continuation to call the next one after that. It's also possible to\\n+“peek” at the next iterator with `iterator.next()`.\\n+\\n+This function is used internally by the `async` module, but can be useful when\\n+you want to manually control the flow of functions in series.\\n+\\n+__Arguments__\\n+\\n+* `tasks` - An array of functions to run.\\n+\\n+__Example__\\n+\\n+```js\\n+var iterator = async.iterator([\\n+    function(){ sys.p('one'); },\\n+    function(){ sys.p('two'); },\\n+    function(){ sys.p('three'); }\\n+]);\\n+\\n+node> var iterator2 = iterator();\\n+'one'\\n+node> var iterator3 = iterator2();\\n+'two'\\n+node> iterator3();\\n+'three'\\n+node> var nextfn = iterator2.next();\\n+node> nextfn();\\n+'three'\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"apply\\\" />\\n+### apply(function, arguments..)\\n+\\n+Creates a continuation function with some arguments already applied. \\n+\\n+Useful as a shorthand when combined with other control flow functions. Any arguments\\n+passed to the returned function are added to the arguments originally passed\\n+to apply.\\n+\\n+__Arguments__\\n+\\n+* `function` - The function you want to eventually apply all arguments to.\\n+* `arguments...` - Any number of arguments to automatically apply when the\\n+  continuation is called.\\n+\\n+__Example__\\n+\\n+```js\\n+// using apply\\n+\\n+async.parallel([\\n+    async.apply(fs.writeFile, 'testfile1', 'test1'),\\n+    async.apply(fs.writeFile, 'testfile2', 'test2'),\\n+]);\\n+\\n+\\n+// the same process without using apply\\n+\\n+async.parallel([\\n+    function(callback){\\n+        fs.writeFile('testfile1', 'test1', callback);\\n+    },\\n+    function(callback){\\n+        fs.writeFile('testfile2', 'test2', callback);\\n+    }\\n+]);\\n+```\\n+\\n+It's possible to pass any number of additional arguments when calling the\\n+continuation:\\n+\\n+```js\\n+node> var fn = async.apply(sys.puts, 'one');\\n+node> fn('two', 'three');\\n+one\\n+two\\n+three\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"nextTick\\\" />\\n+### nextTick(callback)\\n+\\n+Calls `callback` on a later loop around the event loop. In Node.js this just\\n+calls `process.nextTick`; in the browser it falls back to `setImmediate(callback)`\\n+if available, otherwise `setTimeout(callback, 0)`, which means other higher priority\\n+events may precede the execution of `callback`.\\n+\\n+This is used internally for browser-compatibility purposes.\\n+\\n+__Arguments__\\n+\\n+* `callback` - The function to call on a later loop around the event loop.\\n+\\n+__Example__\\n+\\n+```js\\n+var call_order = [];\\n+async.nextTick(function(){\\n+    call_order.push('two');\\n+    // call_order now equals ['one','two']\\n+});\\n+call_order.push('one')\\n+```\\n+\\n+<a name=\\\"times\\\" />\\n+### times(n, callback)\\n+\\n+Calls the `callback` function `n` times, and accumulates results in the same manner\\n+you would use with [`map`](#map).\\n+\\n+__Arguments__\\n+\\n+* `n` - The number of times to run the function.\\n+* `callback` - The function to call `n` times.\\n+\\n+__Example__\\n+\\n+```js\\n+// Pretend this is some complicated async factory\\n+var createUser = function(id, callback) {\\n+  callback(null, {\\n+    id: 'user' + id\\n+  })\\n+}\\n+// generate 5 users\\n+async.times(5, function(n, next){\\n+    createUser(n, function(err, user) {\\n+      next(err, user)\\n+    })\\n+}, function(err, users) {\\n+  // we should now have 5 users\\n+});\\n+```\\n+\\n+<a name=\\\"timesSeries\\\" />\\n+### timesSeries(n, callback)\\n+\\n+The same as [`times`](#times), only the iterator is applied to each item in `arr` in\\n+series. The next `iterator` is only called once the current one has completed. \\n+The results array will be in the same order as the original.\\n+\\n+\\n+## Utils\\n+\\n+<a name=\\\"memoize\\\" />\\n+### memoize(fn, [hasher])\\n+\\n+Caches the results of an `async` function. When creating a hash to store function\\n+results against, the callback is omitted from the hash and an optional hash\\n+function can be used.\\n+\\n+The cache of results is exposed as the `memo` property of the function returned\\n+by `memoize`.\\n+\\n+__Arguments__\\n+\\n+* `fn` - The function to proxy and cache results from.\\n+* `hasher` - Tn optional function for generating a custom hash for storing\\n+  results. It has all the arguments applied to it apart from the callback, and\\n+  must be synchronous.\\n+\\n+__Example__\\n+\\n+```js\\n+var slow_fn = function (name, callback) {\\n+    // do something\\n+    callback(null, result);\\n+};\\n+var fn = async.memoize(slow_fn);\\n+\\n+// fn can now be used as if it were slow_fn\\n+fn('some name', function () {\\n+    // callback\\n+});\\n+```\\n+\\n+<a name=\\\"unmemoize\\\" />\\n+### unmemoize(fn)\\n+\\n+Undoes a [`memoize`](#memoize)d function, reverting it to the original, unmemoized\\n+form. Handy for testing.\\n+\\n+__Arguments__\\n+\\n+* `fn` - the memoized function\\n+\\n+<a name=\\\"log\\\" />\\n+### log(function, arguments)\\n+\\n+Logs the result of an `async` function to the `console`. Only works in Node.js or\\n+in browsers that support `console.log` and `console.error` (such as FF and Chrome).\\n+If multiple arguments are returned from the async function, `console.log` is\\n+called on each argument in order.\\n+\\n+__Arguments__\\n+\\n+* `function` - The function you want to eventually apply all arguments to.\\n+* `arguments...` - Any number of arguments to apply to the function.\\n+\\n+__Example__\\n+\\n+```js\\n+var hello = function(name, callback){\\n+    setTimeout(function(){\\n+        callback(null, 'hello ' + name);\\n+    }, 1000);\\n+};\\n+```\\n+```js\\n+node> async.log(hello, 'world');\\n+'hello world'\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"dir\\\" />\\n+### dir(function, arguments)\\n+\\n+Logs the result of an `async` function to the `console` using `console.dir` to\\n+display the properties of the resulting object. Only works in Node.js or\\n+in browsers that support `console.dir` and `console.error` (such as FF and Chrome).\\n+If multiple arguments are returned from the async function, `console.dir` is\\n+called on each argument in order.\\n+\\n+__Arguments__\\n+\\n+* `function` - The function you want to eventually apply all arguments to.\\n+* `arguments...` - Any number of arguments to apply to the function.\\n+\\n+__Example__\\n+\\n+```js\\n+var hello = function(name, callback){\\n+    setTimeout(function(){\\n+        callback(null, {hello: name});\\n+    }, 1000);\\n+};\\n+```\\n+```js\\n+node> async.dir(hello, 'world');\\n+{hello: 'world'}\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"noConflict\\\" />\\n+### noConflict()\\n+\\n+Changes the value of `async` back to its original value, returning a reference to the\\n+`async` object.\\ndiff --git a/node_modules/async/component.json b/node_modules/async/component.json\\nnew file mode 100644\\nindex 0000000..bbb0115\\n--- /dev/null\\n+++ b/node_modules/async/component.json\\n@@ -0,0 +1,11 @@\\n+{\\n+  \\\"name\\\": \\\"async\\\",\\n+  \\\"repo\\\": \\\"caolan/async\\\",\\n+  \\\"description\\\": \\\"Higher-order functions and common patterns for asynchronous code\\\",\\n+  \\\"version\\\": \\\"0.1.23\\\",\\n+  \\\"keywords\\\": [],\\n+  \\\"dependencies\\\": {},\\n+  \\\"development\\\": {},\\n+  \\\"main\\\": \\\"lib/async.js\\\",\\n+  \\\"scripts\\\": [ \\\"lib/async.js\\\" ]\\n+}\\ndiff --git a/node_modules/async/lib/async.js b/node_modules/async/lib/async.js\\nnew file mode 100644\\nindex 0000000..01e8afc\\n--- /dev/null\\n+++ b/node_modules/async/lib/async.js\\n@@ -0,0 +1,1123 @@\\n+/*!\\n+ * async\\n+ * https://github.com/caolan/async\\n+ *\\n+ * Copyright 2010-2014 Caolan McMahon\\n+ * Released under the MIT license\\n+ */\\n+/*jshint onevar: false, indent:4 */\\n+/*global setImmediate: false, setTimeout: false, console: false */\\n+(function () {\\n+\\n+    var async = {};\\n+\\n+    // global on the server, window in the browser\\n+    var root, previous_async;\\n+\\n+    root = this;\\n+    if (root != null) {\\n+      previous_async = root.async;\\n+    }\\n+\\n+    async.noConflict = function () {\\n+        root.async = previous_async;\\n+        return async;\\n+    };\\n+\\n+    function only_once(fn) {\\n+        var called = false;\\n+        return function() {\\n+            if (called) throw new Error(\\\"Callback was already called.\\\");\\n+            called = true;\\n+            fn.apply(root, arguments);\\n+        }\\n+    }\\n+\\n+    //// cross-browser compatiblity functions ////\\n+\\n+    var _toString = Object.prototype.toString;\\n+\\n+    var _isArray = Array.isArray || function (obj) {\\n+        return _toString.call(obj) === '[object Array]';\\n+    };\\n+\\n+    var _each = function (arr, iterator) {\\n+        if (arr.forEach) {\\n+            return arr.forEach(iterator);\\n+        }\\n+        for (var i = 0; i < arr.length; i += 1) {\\n+            iterator(arr[i], i, arr);\\n+        }\\n+    };\\n+\\n+    var _map = function (arr, iterator) {\\n+        if (arr.map) {\\n+            return arr.map(iterator);\\n+        }\\n+        var results = [];\\n+        _each(arr, function (x, i, a) {\\n+            results.push(iterator(x, i, a));\\n+        });\\n+        return results;\\n+    };\\n+\\n+    var _reduce = function (arr, iterator, memo) {\\n+        if (arr.reduce) {\\n+            return arr.reduce(iterator, memo);\\n+        }\\n+        _each(arr, function (x, i, a) {\\n+            memo = iterator(memo, x, i, a);\\n+        });\\n+        return memo;\\n+    };\\n+\\n+    var _keys = function (obj) {\\n+        if (Object.keys) {\\n+            return Object.keys(obj);\\n+        }\\n+        var keys = [];\\n+        for (var k in obj) {\\n+            if (obj.hasOwnProperty(k)) {\\n+                keys.push(k);\\n+            }\\n+        }\\n+        return keys;\\n+    };\\n+\\n+    //// exported async module functions ////\\n+\\n+    //// nextTick implementation with browser-compatible fallback ////\\n+    if (typeof process === 'undefined' || !(process.nextTick)) {\\n+        if (typeof setImmediate === 'function') {\\n+            async.nextTick = function (fn) {\\n+                // not a direct alias for IE10 compatibility\\n+                setImmediate(fn);\\n+            };\\n+            async.setImmediate = async.nextTick;\\n+        }\\n+        else {\\n+            async.nextTick = function (fn) {\\n+                setTimeout(fn, 0);\\n+            };\\n+            async.setImmediate = async.nextTick;\\n+        }\\n+    }\\n+    else {\\n+        async.nextTick = process.nextTick;\\n+        if (typeof setImmediate !== 'undefined') {\\n+            async.setImmediate = function (fn) {\\n+              // not a direct alias for IE10 compatibility\\n+              setImmediate(fn);\\n+            };\\n+        }\\n+        else {\\n+            async.setImmediate = async.nextTick;\\n+        }\\n+    }\\n+\\n+    async.each = function (arr, iterator, callback) {\\n+        callback = callback || function () {};\\n+        if (!arr.length) {\\n+            return callback();\\n+        }\\n+        var completed = 0;\\n+        _each(arr, function (x) {\\n+            iterator(x, only_once(done) );\\n+        });\\n+        function done(err) {\\n+          if (err) {\\n+              callback(err);\\n+              callback = function () {};\\n+          }\\n+          else {\\n+              completed += 1;\\n+              if (completed >= arr.length) {\\n+                  callback();\\n+              }\\n+          }\\n+        }\\n+    };\\n+    async.forEach = async.each;\\n+\\n+    async.eachSeries = function (arr, iterator, callback) {\\n+        callback = callback || function () {};\\n+        if (!arr.length) {\\n+            return callback();\\n+        }\\n+        var completed = 0;\\n+        var iterate = function () {\\n+            iterator(arr[completed], function (err) {\\n+                if (err) {\\n+                    callback(err);\\n+                    callback = function () {};\\n+                }\\n+                else {\\n+                    completed += 1;\\n+                    if (completed >= arr.length) {\\n+                        callback();\\n+                    }\\n+                    else {\\n+                        iterate();\\n+                    }\\n+                }\\n+            });\\n+        };\\n+        iterate();\\n+    };\\n+    async.forEachSeries = async.eachSeries;\\n+\\n+    async.eachLimit = function (arr, limit, iterator, callback) {\\n+        var fn = _eachLimit(limit);\\n+        fn.apply(null, [arr, iterator, callback]);\\n+    };\\n+    async.forEachLimit = async.eachLimit;\\n+\\n+    var _eachLimit = function (limit) {\\n+\\n+        return function (arr, iterator, callback) {\\n+            callback = callback || function () {};\\n+            if (!arr.length || limit <= 0) {\\n+                return callback();\\n+            }\\n+            var completed = 0;\\n+            var started = 0;\\n+            var running = 0;\\n+\\n+            (function replenish () {\\n+                if (completed >= arr.length) {\\n+                    return callback();\\n+                }\\n+\\n+                while (running < limit && started < arr.length) {\\n+                    started += 1;\\n+                    running += 1;\\n+                    iterator(arr[started - 1], function (err) {\\n+                        if (err) {\\n+                            callback(err);\\n+                            callback = function () {};\\n+                        }\\n+                        else {\\n+                            completed += 1;\\n+                            running -= 1;\\n+                            if (completed >= arr.length) {\\n+                                callback();\\n+                            }\\n+                            else {\\n+                                replenish();\\n+                            }\\n+                        }\\n+                    });\\n+                }\\n+            })();\\n+        };\\n+    };\\n+\\n+\\n+    var doParallel = function (fn) {\\n+        return function () {\\n+            var args = Array.prototype.slice.call(arguments);\\n+            return fn.apply(null, [async.each].concat(args));\\n+        };\\n+    };\\n+    var doParallelLimit = function(limit, fn) {\\n+        return function () {\\n+            var args = Array.prototype.slice.call(arguments);\\n+            return fn.apply(null, [_eachLimit(limit)].concat(args));\\n+        };\\n+    };\\n+    var doSeries = function (fn) {\\n+        return function () {\\n+            var args = Array.prototype.slice.call(arguments);\\n+            return fn.apply(null, [async.eachSeries].concat(args));\\n+        };\\n+    };\\n+\\n+\\n+    var _asyncMap = function (eachfn, arr, iterator, callback) {\\n+        arr = _map(arr, function (x, i) {\\n+            return {index: i, value: x};\\n+        });\\n+        if (!callback) {\\n+            eachfn(arr, function (x, callback) {\\n+                iterator(x.value, function (err) {\\n+                    callback(err);\\n+                });\\n+            });\\n+        } else {\\n+            var results = [];\\n+            eachfn(arr, function (x, callback) {\\n+                iterator(x.value, function (err, v) {\\n+                    results[x.index] = v;\\n+                    callback(err);\\n+                });\\n+            }, function (err) {\\n+                callback(err, results);\\n+            });\\n+        }\\n+    };\\n+    async.map = doParallel(_asyncMap);\\n+    async.mapSeries = doSeries(_asyncMap);\\n+    async.mapLimit = function (arr, limit, iterator, callback) {\\n+        return _mapLimit(limit)(arr, iterator, callback);\\n+    };\\n+\\n+    var _mapLimit = function(limit) {\\n+        return doParallelLimit(limit, _asyncMap);\\n+    };\\n+\\n+    // reduce only has a series version, as doing reduce in parallel won't\\n+    // work in many situations.\\n+    async.reduce = function (arr, memo, iterator, callback) {\\n+        async.eachSeries(arr, function (x, callback) {\\n+            iterator(memo, x, function (err, v) {\\n+                memo = v;\\n+                callback(err);\\n+            });\\n+        }, function (err) {\\n+            callback(err, memo);\\n+        });\\n+    };\\n+    // inject alias\\n+    async.inject = async.reduce;\\n+    // foldl alias\\n+    async.foldl = async.reduce;\\n+\\n+    async.reduceRight = function (arr, memo, iterator, callback) {\\n+        var reversed = _map(arr, function (x) {\\n+            return x;\\n+        }).reverse();\\n+        async.reduce(reversed, memo, iterator, callback);\\n+    };\\n+    // foldr alias\\n+    async.foldr = async.reduceRight;\\n+\\n+    var _filter = function (eachfn, arr, iterator, callback) {\\n+        var results = [];\\n+        arr = _map(arr, function (x, i) {\\n+            return {index: i, value: x};\\n+        });\\n+        eachfn(arr, function (x, callback) {\\n+            iterator(x.value, function (v) {\\n+                if (v) {\\n+                    results.push(x);\\n+                }\\n+                callback();\\n+            });\\n+        }, function (err) {\\n+            callback(_map(results.sort(function (a, b) {\\n+                return a.index - b.index;\\n+            }), function (x) {\\n+                return x.value;\\n+            }));\\n+        });\\n+    };\\n+    async.filter = doParallel(_filter);\\n+    async.filterSeries = doSeries(_filter);\\n+    // select alias\\n+    async.select = async.filter;\\n+    async.selectSeries = async.filterSeries;\\n+\\n+    var _reject = function (eachfn, arr, iterator, callback) {\\n+        var results = [];\\n+        arr = _map(arr, function (x, i) {\\n+            return {index: i, value: x};\\n+        });\\n+        eachfn(arr, function (x, callback) {\\n+            iterator(x.value, function (v) {\\n+                if (!v) {\\n+                    results.push(x);\\n+                }\\n+                callback();\\n+            });\\n+        }, function (err) {\\n+            callback(_map(results.sort(function (a, b) {\\n+                return a.index - b.index;\\n+            }), function (x) {\\n+                return x.value;\\n+            }));\\n+        });\\n+    };\\n+    async.reject = doParallel(_reject);\\n+    async.rejectSeries = doSeries(_reject);\\n+\\n+    var _detect = function (eachfn, arr, iterator, main_callback) {\\n+        eachfn(arr, function (x, callback) {\\n+            iterator(x, function (result) {\\n+                if (result) {\\n+                    main_callback(x);\\n+                    main_callback = function () {};\\n+                }\\n+                else {\\n+                    callback();\\n+                }\\n+            });\\n+        }, function (err) {\\n+            main_callback();\\n+        });\\n+    };\\n+    async.detect = doParallel(_detect);\\n+    async.detectSeries = doSeries(_detect);\\n+\\n+    async.some = function (arr, iterator, main_callback) {\\n+        async.each(arr, function (x, callback) {\\n+            iterator(x, function (v) {\\n+                if (v) {\\n+                    main_callback(true);\\n+                    main_callback = function () {};\\n+                }\\n+                callback();\\n+            });\\n+        }, function (err) {\\n+            main_callback(false);\\n+        });\\n+    };\\n+    // any alias\\n+    async.any = async.some;\\n+\\n+    async.every = function (arr, iterator, main_callback) {\\n+        async.each(arr, function (x, callback) {\\n+            iterator(x, function (v) {\\n+                if (!v) {\\n+                    main_callback(false);\\n+                    main_callback = function () {};\\n+                }\\n+                callback();\\n+            });\\n+        }, function (err) {\\n+            main_callback(true);\\n+        });\\n+    };\\n+    // all alias\\n+    async.all = async.every;\\n+\\n+    async.sortBy = function (arr, iterator, callback) {\\n+        async.map(arr, function (x, callback) {\\n+            iterator(x, function (err, criteria) {\\n+                if (err) {\\n+                    callback(err);\\n+                }\\n+                else {\\n+                    callback(null, {value: x, criteria: criteria});\\n+                }\\n+            });\\n+        }, function (err, results) {\\n+            if (err) {\\n+                return callback(err);\\n+            }\\n+            else {\\n+                var fn = function (left, right) {\\n+                    var a = left.criteria, b = right.criteria;\\n+                    return a < b ? -1 : a > b ? 1 : 0;\\n+                };\\n+                callback(null, _map(results.sort(fn), function (x) {\\n+                    return x.value;\\n+                }));\\n+            }\\n+        });\\n+    };\\n+\\n+    async.auto = function (tasks, callback) {\\n+        callback = callback || function () {};\\n+        var keys = _keys(tasks);\\n+        var remainingTasks = keys.length\\n+        if (!remainingTasks) {\\n+            return callback();\\n+        }\\n+\\n+        var results = {};\\n+\\n+        var listeners = [];\\n+        var addListener = function (fn) {\\n+            listeners.unshift(fn);\\n+        };\\n+        var removeListener = function (fn) {\\n+            for (var i = 0; i < listeners.length; i += 1) {\\n+                if (listeners[i] === fn) {\\n+                    listeners.splice(i, 1);\\n+                    return;\\n+                }\\n+            }\\n+        };\\n+        var taskComplete = function () {\\n+            remainingTasks--\\n+            _each(listeners.slice(0), function (fn) {\\n+                fn();\\n+            });\\n+        };\\n+\\n+        addListener(function () {\\n+            if (!remainingTasks) {\\n+                var theCallback = callback;\\n+                // prevent final callback from calling itself if it errors\\n+                callback = function () {};\\n+\\n+                theCallback(null, results);\\n+            }\\n+        });\\n+\\n+        _each(keys, function (k) {\\n+            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\\n+            var taskCallback = function (err) {\\n+                var args = Array.prototype.slice.call(arguments, 1);\\n+                if (args.length <= 1) {\\n+                    args = args[0];\\n+                }\\n+                if (err) {\\n+                    var safeResults = {};\\n+                    _each(_keys(results), function(rkey) {\\n+                        safeResults[rkey] = results[rkey];\\n+                    });\\n+                    safeResults[k] = args;\\n+                    callback(err, safeResults);\\n+                    // stop subsequent errors hitting callback multiple times\\n+                    callback = function () {};\\n+                }\\n+                else {\\n+                    results[k] = args;\\n+                    async.setImmediate(taskComplete);\\n+                }\\n+            };\\n+            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\\n+            var ready = function () {\\n+                return _reduce(requires, function (a, x) {\\n+                    return (a && results.hasOwnProperty(x));\\n+                }, true) && !results.hasOwnProperty(k);\\n+            };\\n+            if (ready()) {\\n+                task[task.length - 1](taskCallback, results);\\n+            }\\n+            else {\\n+                var listener = function () {\\n+                    if (ready()) {\\n+                        removeListener(listener);\\n+                        task[task.length - 1](taskCallback, results);\\n+                    }\\n+                };\\n+                addListener(listener);\\n+            }\\n+        });\\n+    };\\n+\\n+    async.retry = function(times, task, callback) {\\n+        var DEFAULT_TIMES = 5;\\n+        var attempts = [];\\n+        // Use defaults if times not passed\\n+        if (typeof times === 'function') {\\n+            callback = task;\\n+            task = times;\\n+            times = DEFAULT_TIMES;\\n+        }\\n+        // Make sure times is a number\\n+        times = parseInt(times, 10) || DEFAULT_TIMES;\\n+        var wrappedTask = function(wrappedCallback, wrappedResults) {\\n+            var retryAttempt = function(task, finalAttempt) {\\n+                return function(seriesCallback) {\\n+                    task(function(err, result){\\n+                        seriesCallback(!err || finalAttempt, {err: err, result: result});\\n+                    }, wrappedResults);\\n+                };\\n+            };\\n+            while (times) {\\n+                attempts.push(retryAttempt(task, !(times-=1)));\\n+            }\\n+            async.series(attempts, function(done, data){\\n+                data = data[data.length - 1];\\n+                (wrappedCallback || callback)(data.err, data.result);\\n+            });\\n+        }\\n+        // If a callback is passed, run this as a controll flow\\n+        return callback ? wrappedTask() : wrappedTask\\n+    };\\n+\\n+    async.waterfall = function (tasks, callback) {\\n+        callback = callback || function () {};\\n+        if (!_isArray(tasks)) {\\n+          var err = new Error('First argument to waterfall must be an array of functions');\\n+          return callback(err);\\n+        }\\n+        if (!tasks.length) {\\n+            return callback();\\n+        }\\n+        var wrapIterator = function (iterator) {\\n+            return function (err) {\\n+                if (err) {\\n+                    callback.apply(null, arguments);\\n+                    callback = function () {};\\n+                }\\n+                else {\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\n+                    var next = iterator.next();\\n+                    if (next) {\\n+                        args.push(wrapIterator(next));\\n+                    }\\n+                    else {\\n+                        args.push(callback);\\n+                    }\\n+                    async.setImmediate(function () {\\n+                        iterator.apply(null, args);\\n+                    });\\n+                }\\n+            };\\n+        };\\n+        wrapIterator(async.iterator(tasks))();\\n+    };\\n+\\n+    var _parallel = function(eachfn, tasks, callback) {\\n+        callback = callback || function () {};\\n+        if (_isArray(tasks)) {\\n+            eachfn.map(tasks, function (fn, callback) {\\n+                if (fn) {\\n+                    fn(function (err) {\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\n+                        if (args.length <= 1) {\\n+                            args = args[0];\\n+                        }\\n+                        callback.call(null, err, args);\\n+                    });\\n+                }\\n+            }, callback);\\n+        }\\n+        else {\\n+            var results = {};\\n+            eachfn.each(_keys(tasks), function (k, callback) {\\n+                tasks[k](function (err) {\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\n+                    if (args.length <= 1) {\\n+                        args = args[0];\\n+                    }\\n+                    results[k] = args;\\n+                    callback(err);\\n+                });\\n+            }, function (err) {\\n+                callback(err, results);\\n+            });\\n+        }\\n+    };\\n+\\n+    async.parallel = function (tasks, callback) {\\n+        _parallel({ map: async.map, each: async.each }, tasks, callback);\\n+    };\\n+\\n+    async.parallelLimit = function(tasks, limit, callback) {\\n+        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\\n+    };\\n+\\n+    async.series = function (tasks, callback) {\\n+        callback = callback || function () {};\\n+        if (_isArray(tasks)) {\\n+            async.mapSeries(tasks, function (fn, callback) {\\n+                if (fn) {\\n+                    fn(function (err) {\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\n+                        if (args.length <= 1) {\\n+                            args = args[0];\\n+                        }\\n+                        callback.call(null, err, args);\\n+                    });\\n+                }\\n+            }, callback);\\n+        }\\n+        else {\\n+            var results = {};\\n+            async.eachSeries(_keys(tasks), function (k, callback) {\\n+                tasks[k](function (err) {\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\n+                    if (args.length <= 1) {\\n+                        args = args[0];\\n+                    }\\n+                    results[k] = args;\\n+                    callback(err);\\n+                });\\n+            }, function (err) {\\n+                callback(err, results);\\n+            });\\n+        }\\n+    };\\n+\\n+    async.iterator = function (tasks) {\\n+        var makeCallback = function (index) {\\n+            var fn = function () {\\n+                if (tasks.length) {\\n+                    tasks[index].apply(null, arguments);\\n+                }\\n+                return fn.next();\\n+            };\\n+            fn.next = function () {\\n+                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\\n+            };\\n+            return fn;\\n+        };\\n+        return makeCallback(0);\\n+    };\\n+\\n+    async.apply = function (fn) {\\n+        var args = Array.prototype.slice.call(arguments, 1);\\n+        return function () {\\n+            return fn.apply(\\n+                null, args.concat(Array.prototype.slice.call(arguments))\\n+            );\\n+        };\\n+    };\\n+\\n+    var _concat = function (eachfn, arr, fn, callback) {\\n+        var r = [];\\n+        eachfn(arr, function (x, cb) {\\n+            fn(x, function (err, y) {\\n+                r = r.concat(y || []);\\n+                cb(err);\\n+            });\\n+        }, function (err) {\\n+            callback(err, r);\\n+        });\\n+    };\\n+    async.concat = doParallel(_concat);\\n+    async.concatSeries = doSeries(_concat);\\n+\\n+    async.whilst = function (test, iterator, callback) {\\n+        if (test()) {\\n+            iterator(function (err) {\\n+                if (err) {\\n+                    return callback(err);\\n+                }\\n+                async.whilst(test, iterator, callback);\\n+            });\\n+        }\\n+        else {\\n+            callback();\\n+        }\\n+    };\\n+\\n+    async.doWhilst = function (iterator, test, callback) {\\n+        iterator(function (err) {\\n+            if (err) {\\n+                return callback(err);\\n+            }\\n+            var args = Array.prototype.slice.call(arguments, 1);\\n+            if (test.apply(null, args)) {\\n+                async.doWhilst(iterator, test, callback);\\n+            }\\n+            else {\\n+                callback();\\n+            }\\n+        });\\n+    };\\n+\\n+    async.until = function (test, iterator, callback) {\\n+        if (!test()) {\\n+            iterator(function (err) {\\n+                if (err) {\\n+                    return callback(err);\\n+                }\\n+                async.until(test, iterator, callback);\\n+            });\\n+        }\\n+        else {\\n+            callback();\\n+        }\\n+    };\\n+\\n+    async.doUntil = function (iterator, test, callback) {\\n+        iterator(function (err) {\\n+            if (err) {\\n+                return callback(err);\\n+            }\\n+            var args = Array.prototype.slice.call(arguments, 1);\\n+            if (!test.apply(null, args)) {\\n+                async.doUntil(iterator, test, callback);\\n+            }\\n+            else {\\n+                callback();\\n+            }\\n+        });\\n+    };\\n+\\n+    async.queue = function (worker, concurrency) {\\n+        if (concurrency === undefined) {\\n+            concurrency = 1;\\n+        }\\n+        function _insert(q, data, pos, callback) {\\n+          if (!q.started){\\n+            q.started = true;\\n+          }\\n+          if (!_isArray(data)) {\\n+              data = [data];\\n+          }\\n+          if(data.length == 0) {\\n+             // call drain immediately if there are no tasks\\n+             return async.setImmediate(function() {\\n+                 if (q.drain) {\\n+                     q.drain();\\n+                 }\\n+             });\\n+          }\\n+          _each(data, function(task) {\\n+              var item = {\\n+                  data: task,\\n+                  callback: typeof callback === 'function' ? callback : null\\n+              };\\n+\\n+              if (pos) {\\n+                q.tasks.unshift(item);\\n+              } else {\\n+                q.tasks.push(item);\\n+              }\\n+\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\n+                  q.saturated();\\n+              }\\n+              async.setImmediate(q.process);\\n+          });\\n+        }\\n+\\n+        var workers = 0;\\n+        var q = {\\n+            tasks: [],\\n+            concurrency: concurrency,\\n+            saturated: null,\\n+            empty: null,\\n+            drain: null,\\n+            started: false,\\n+            paused: false,\\n+            push: function (data, callback) {\\n+              _insert(q, data, false, callback);\\n+            },\\n+            kill: function () {\\n+              q.drain = null;\\n+              q.tasks = [];\\n+            },\\n+            unshift: function (data, callback) {\\n+              _insert(q, data, true, callback);\\n+            },\\n+            process: function () {\\n+                if (!q.paused && workers < q.concurrency && q.tasks.length) {\\n+                    var task = q.tasks.shift();\\n+                    if (q.empty && q.tasks.length === 0) {\\n+                        q.empty();\\n+                    }\\n+                    workers += 1;\\n+                    var next = function () {\\n+                        workers -= 1;\\n+                        if (task.callback) {\\n+                            task.callback.apply(task, arguments);\\n+                        }\\n+                        if (q.drain && q.tasks.length + workers === 0) {\\n+                            q.drain();\\n+                        }\\n+                        q.process();\\n+                    };\\n+                    var cb = only_once(next);\\n+                    worker(task.data, cb);\\n+                }\\n+            },\\n+            length: function () {\\n+                return q.tasks.length;\\n+            },\\n+            running: function () {\\n+                return workers;\\n+            },\\n+            idle: function() {\\n+                return q.tasks.length + workers === 0;\\n+            },\\n+            pause: function () {\\n+                if (q.paused === true) { return; }\\n+                q.paused = true;\\n+                q.process();\\n+            },\\n+            resume: function () {\\n+                if (q.paused === false) { return; }\\n+                q.paused = false;\\n+                q.process();\\n+            }\\n+        };\\n+        return q;\\n+    };\\n+    \\n+    async.priorityQueue = function (worker, concurrency) {\\n+        \\n+        function _compareTasks(a, b){\\n+          return a.priority - b.priority;\\n+        };\\n+        \\n+        function _binarySearch(sequence, item, compare) {\\n+          var beg = -1,\\n+              end = sequence.length - 1;\\n+          while (beg < end) {\\n+            var mid = beg + ((end - beg + 1) >>> 1);\\n+            if (compare(item, sequence[mid]) >= 0) {\\n+              beg = mid;\\n+            } else {\\n+              end = mid - 1;\\n+            }\\n+          }\\n+          return beg;\\n+        }\\n+        \\n+        function _insert(q, data, priority, callback) {\\n+          if (!q.started){\\n+            q.started = true;\\n+          }\\n+          if (!_isArray(data)) {\\n+              data = [data];\\n+          }\\n+          if(data.length == 0) {\\n+             // call drain immediately if there are no tasks\\n+             return async.setImmediate(function() {\\n+                 if (q.drain) {\\n+                     q.drain();\\n+                 }\\n+             });\\n+          }\\n+          _each(data, function(task) {\\n+              var item = {\\n+                  data: task,\\n+                  priority: priority,\\n+                  callback: typeof callback === 'function' ? callback : null\\n+              };\\n+              \\n+              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\\n+\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\n+                  q.saturated();\\n+              }\\n+              async.setImmediate(q.process);\\n+          });\\n+        }\\n+        \\n+        // Start with a normal queue\\n+        var q = async.queue(worker, concurrency);\\n+        \\n+        // Override push to accept second parameter representing priority\\n+        q.push = function (data, priority, callback) {\\n+          _insert(q, data, priority, callback);\\n+        };\\n+        \\n+        // Remove unshift function\\n+        delete q.unshift;\\n+\\n+        return q;\\n+    };\\n+\\n+    async.cargo = function (worker, payload) {\\n+        var working     = false,\\n+            tasks       = [];\\n+\\n+        var cargo = {\\n+            tasks: tasks,\\n+            payload: payload,\\n+            saturated: null,\\n+            empty: null,\\n+            drain: null,\\n+            drained: true,\\n+            push: function (data, callback) {\\n+                if (!_isArray(data)) {\\n+                    data = [data];\\n+                }\\n+                _each(data, function(task) {\\n+                    tasks.push({\\n+                        data: task,\\n+                        callback: typeof callback === 'function' ? callback : null\\n+                    });\\n+                    cargo.drained = false;\\n+                    if (cargo.saturated && tasks.length === payload) {\\n+                        cargo.saturated();\\n+                    }\\n+                });\\n+                async.setImmediate(cargo.process);\\n+            },\\n+            process: function process() {\\n+                if (working) return;\\n+                if (tasks.length === 0) {\\n+                    if(cargo.drain && !cargo.drained) cargo.drain();\\n+                    cargo.drained = true;\\n+                    return;\\n+                }\\n+\\n+                var ts = typeof payload === 'number'\\n+                            ? tasks.splice(0, payload)\\n+                            : tasks.splice(0, tasks.length);\\n+\\n+                var ds = _map(ts, function (task) {\\n+                    return task.data;\\n+                });\\n+\\n+                if(cargo.empty) cargo.empty();\\n+                working = true;\\n+                worker(ds, function () {\\n+                    working = false;\\n+\\n+                    var args = arguments;\\n+                    _each(ts, function (data) {\\n+                        if (data.callback) {\\n+                            data.callback.apply(null, args);\\n+                        }\\n+                    });\\n+\\n+                    process();\\n+                });\\n+            },\\n+            length: function () {\\n+                return tasks.length;\\n+            },\\n+            running: function () {\\n+                return working;\\n+            }\\n+        };\\n+        return cargo;\\n+    };\\n+\\n+    var _console_fn = function (name) {\\n+        return function (fn) {\\n+            var args = Array.prototype.slice.call(arguments, 1);\\n+            fn.apply(null, args.concat([function (err) {\\n+                var args = Array.prototype.slice.call(arguments, 1);\\n+                if (typeof console !== 'undefined') {\\n+                    if (err) {\\n+                        if (console.error) {\\n+                            console.error(err);\\n+                        }\\n+                    }\\n+                    else if (console[name]) {\\n+                        _each(args, function (x) {\\n+                            console[name](x);\\n+                        });\\n+                    }\\n+                }\\n+            }]));\\n+        };\\n+    };\\n+    async.log = _console_fn('log');\\n+    async.dir = _console_fn('dir');\\n+    /*async.info = _console_fn('info');\\n+    async.warn = _console_fn('warn');\\n+    async.error = _console_fn('error');*/\\n+\\n+    async.memoize = function (fn, hasher) {\\n+        var memo = {};\\n+        var queues = {};\\n+        hasher = hasher || function (x) {\\n+            return x;\\n+        };\\n+        var memoized = function () {\\n+            var args = Array.prototype.slice.call(arguments);\\n+            var callback = args.pop();\\n+            var key = hasher.apply(null, args);\\n+            if (key in memo) {\\n+                async.nextTick(function () {\\n+                    callback.apply(null, memo[key]);\\n+                });\\n+            }\\n+            else if (key in queues) {\\n+                queues[key].push(callback);\\n+            }\\n+            else {\\n+                queues[key] = [callback];\\n+                fn.apply(null, args.concat([function () {\\n+                    memo[key] = arguments;\\n+                    var q = queues[key];\\n+                    delete queues[key];\\n+                    for (var i = 0, l = q.length; i < l; i++) {\\n+                      q[i].apply(null, arguments);\\n+                    }\\n+                }]));\\n+            }\\n+        };\\n+        memoized.memo = memo;\\n+        memoized.unmemoized = fn;\\n+        return memoized;\\n+    };\\n+\\n+    async.unmemoize = function (fn) {\\n+      return function () {\\n+        return (fn.unmemoized || fn).apply(null, arguments);\\n+      };\\n+    };\\n+\\n+    async.times = function (count, iterator, callback) {\\n+        var counter = [];\\n+        for (var i = 0; i < count; i++) {\\n+            counter.push(i);\\n+        }\\n+        return async.map(counter, iterator, callback);\\n+    };\\n+\\n+    async.timesSeries = function (count, iterator, callback) {\\n+        var counter = [];\\n+        for (var i = 0; i < count; i++) {\\n+            counter.push(i);\\n+        }\\n+        return async.mapSeries(counter, iterator, callback);\\n+    };\\n+\\n+    async.seq = function (/* functions... */) {\\n+        var fns = arguments;\\n+        return function () {\\n+            var that = this;\\n+            var args = Array.prototype.slice.call(arguments);\\n+            var callback = args.pop();\\n+            async.reduce(fns, args, function (newargs, fn, cb) {\\n+                fn.apply(that, newargs.concat([function () {\\n+                    var err = arguments[0];\\n+                    var nextargs = Array.prototype.slice.call(arguments, 1);\\n+                    cb(err, nextargs);\\n+                }]))\\n+            },\\n+            function (err, results) {\\n+                callback.apply(that, [err].concat(results));\\n+            });\\n+        };\\n+    };\\n+\\n+    async.compose = function (/* functions... */) {\\n+      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\\n+    };\\n+\\n+    var _applyEach = function (eachfn, fns /*args...*/) {\\n+        var go = function () {\\n+            var that = this;\\n+            var args = Array.prototype.slice.call(arguments);\\n+            var callback = args.pop();\\n+            return eachfn(fns, function (fn, cb) {\\n+                fn.apply(that, args.concat([cb]));\\n+            },\\n+            callback);\\n+        };\\n+        if (arguments.length > 2) {\\n+            var args = Array.prototype.slice.call(arguments, 2);\\n+            return go.apply(this, args);\\n+        }\\n+        else {\\n+            return go;\\n+        }\\n+    };\\n+    async.applyEach = doParallel(_applyEach);\\n+    async.applyEachSeries = doSeries(_applyEach);\\n+\\n+    async.forever = function (fn, callback) {\\n+        function next(err) {\\n+            if (err) {\\n+                if (callback) {\\n+                    return callback(err);\\n+                }\\n+                throw err;\\n+            }\\n+            fn(next);\\n+        }\\n+        next();\\n+    };\\n+\\n+    // Node.js\\n+    if (typeof module !== 'undefined' && module.exports) {\\n+        module.exports = async;\\n+    }\\n+    // AMD / RequireJS\\n+    else if (typeof define !== 'undefined' && define.amd) {\\n+        define([], function () {\\n+            return async;\\n+        });\\n+    }\\n+    // included directly via <script> tag\\n+    else {\\n+        root.async = async;\\n+    }\\n+\\n+}());\\ndiff --git a/node_modules/async/package.json b/node_modules/async/package.json\\nnew file mode 100644\\nindex 0000000..31a5200\\n--- /dev/null\\n+++ b/node_modules/async/package.json\\n@@ -0,0 +1,59 @@\\n+{\\n+  \\\"name\\\": \\\"async\\\",\\n+  \\\"description\\\": \\\"Higher-order functions and common patterns for asynchronous code\\\",\\n+  \\\"main\\\": \\\"./lib/async\\\",\\n+  \\\"author\\\": {\\n+    \\\"name\\\": \\\"Caolan McMahon\\\"\\n+  },\\n+  \\\"version\\\": \\\"0.9.0\\\",\\n+  \\\"repository\\\": {\\n+    \\\"type\\\": \\\"git\\\",\\n+    \\\"url\\\": \\\"https://github.com/caolan/async.git\\\"\\n+  },\\n+  \\\"bugs\\\": {\\n+    \\\"url\\\": \\\"https://github.com/caolan/async/issues\\\"\\n+  },\\n+  \\\"licenses\\\": [\\n+    {\\n+      \\\"type\\\": \\\"MIT\\\",\\n+      \\\"url\\\": \\\"https://github.com/caolan/async/raw/master/LICENSE\\\"\\n+    }\\n+  ],\\n+  \\\"devDependencies\\\": {\\n+    \\\"nodeunit\\\": \\\">0.0.0\\\",\\n+    \\\"uglify-js\\\": \\\"1.2.x\\\",\\n+    \\\"nodelint\\\": \\\">0.0.0\\\"\\n+  },\\n+  \\\"jam\\\": {\\n+    \\\"main\\\": \\\"lib/async.js\\\",\\n+    \\\"include\\\": [\\n+      \\\"lib/async.js\\\",\\n+      \\\"README.md\\\",\\n+      \\\"LICENSE\\\"\\n+    ]\\n+  },\\n+  \\\"scripts\\\": {\\n+    \\\"test\\\": \\\"nodeunit test/test-async.js\\\"\\n+  },\\n+  \\\"homepage\\\": \\\"https://github.com/caolan/async\\\",\\n+  \\\"_id\\\": \\\"async@0.9.0\\\",\\n+  \\\"dist\\\": {\\n+    \\\"shasum\\\": \\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\",\\n+    \\\"tarball\\\": \\\"http://registry.npmjs.org/async/-/async-0.9.0.tgz\\\"\\n+  },\\n+  \\\"_from\\\": \\\"async@*\\\",\\n+  \\\"_npmVersion\\\": \\\"1.4.3\\\",\\n+  \\\"_npmUser\\\": {\\n+    \\\"name\\\": \\\"caolan\\\",\\n+    \\\"email\\\": \\\"caolan.mcmahon@gmail.com\\\"\\n+  },\\n+  \\\"maintainers\\\": [\\n+    {\\n+      \\\"name\\\": \\\"caolan\\\",\\n+      \\\"email\\\": \\\"caolan@caolanmcmahon.com\\\"\\n+    }\\n+  ],\\n+  \\\"directories\\\": {},\\n+  \\\"_shasum\\\": \\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\",\\n+  \\\"_resolved\\\": \\\"https://registry.npmjs.org/async/-/async-0.9.0.tgz\\\"\\n+}\\ndiff --git a/package.json b/package.json\\nindex 5f21627..6033d43 100644\\n--- a/package.json\\n+++ b/package.json\\n@@ -4,7 +4,8 @@\\n   \\\"description\\\": \\\"Sous project\\\",\\n   \\\"main\\\": \\\"main.js\\\",\\n   \\\"dependencies\\\": {\\n-},\\n+    \\\"async\\\": \\\"*\\\"\\n+  },\\n   \\\"devDependencies\\\": {},\\n   \\\"scripts\\\": {\\n     \\\"test\\\": \\\"echo \\\\\\\"Error: no test specified\\\\\\\" && exit 1\\\"\\ndiff --git a/patches.sousp b/patches.sousp\\nindex 16405a3..d71e511 100644\\n--- a/patches.sousp\\n+++ b/patches.sousp\\n@@ -1,31 +1 @@\\n-diff --git a/main.js b/main.js\\n-index f81b54e..744cdd5 100644\\n---- a/main.js\\n-+++ b/main.js\\n-@@ -35,7 +35,7 @@ fs.exists('.git', function (exists) {\\n-         cp.exec('git diff', function(error, stdout, stderr) {\\n-             console.log(stdout);\\n- \\n--            //fs.writeFileSync(\\\"patches.sousp\\\", stdout);\\n-+            fs.writeFileSync(\\\"patches.sousp\\\", stdout);\\n- \\n-             if (error !== null) {\\n-                 console.log('stderr: ' + stderr);\\n-@@ -44,7 +44,7 @@ fs.exists('.git', function (exists) {\\n-         });\\n- \\n-         cp.exec('git log', function(error, stdout, stderr) {\\n--            //console.log(stdout);\\n-+            console.log(stdout);\\n- \\n-             var authors = findData(stdout, \\\"Author:\\\");\\n-             var dates = findData(stdout, \\\"Date:\\\");\\n-@@ -53,7 +53,7 @@ fs.exists('.git', function (exists) {\\n-             console.log(comments);\\n-             console.log(dates);\\n- \\n--            //fs.writeFileSync(\\\"comments.sousc\\\", stdout);\\n-+            fs.writeFileSync(\\\"comments.sousc\\\", stdout);\\n- \\n-             if (error !== null) {\\n-                 console.log('stderr: ' + stderr);\\n+[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]\\n\\\\ No newline at end of file\\ndiff --git a/test.js b/test.js\\nnew file mode 100644\\nindex 0000000..5ca759c\\n--- /dev/null\\n+++ b/test.js\\n@@ -0,0 +1,21 @@\\n+/**\\n+ * Created by Nick on 18.05.2015.\\n+ */\\n+var async = require('async')\\n+    , tasksIndex = [\\n+        function (callback) {\\n+            // Вымышленный метод который вернет 231\\n+            var viewsNumber = models.stat.viewsNumber();\\n+            callback(null, viewsNumber);\\n+        }\\n+        , function (callback) {\\n+            // Вымышленный метод который вернет 24\\n+            var growFactor = models.stat.growFactor();\\n+            callback(null, growFactor);\\n+        }\\n+    ];\\n+\\n+async.series(tasksIndex, function (err, results) {\\n+    // Результат будет массивом\\n+    console.log(results); // [231, 24]\\n+});\\n\\\\ No newline at end of file\\n\"}\n\\ No newline at end of file\n+{\"commit\":\"dbe72b9889081e5856c1e2d72723e8ab2dc898bd\",\"author\":\"Nick Stepanenko <massaalonso@yandex.ru>\",\"date\":\"Tue May 19 01:41:21 2015 +0800\",\"comment\":\"Content will be added now.\",\"content\":\"diff --git a/main.js b/main.js\\nindex 86f30c2..ca7473f 100644\\n--- a/main.js\\n+++ b/main.js\\n@@ -148,7 +148,9 @@ fs.exists('.git', function (exists) {\\n                         listOfCommits[listOfCommits.length] = commit;\\n                     }\\n \\n-                    callback(null, listOfCommits.reverse());\\n+                    var commitsData = listOfCommits.reverse();\\n+\\n+                    callback(null, commitsData);\\n \\n                     if (error !== null) {\\n                         console.log('stderr: ' + stderr);\\n@@ -157,27 +159,18 @@ fs.exists('.git', function (exists) {\\n                 });\\n             },\\n             function getCommitsContent(commits, callback) {\\n-                console.log(commits);\\n                 var commitsData = commits;\\n \\n                 for(i=1; i<commitsData.length; i++) {\\n-                    cp.exec('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit, function(error, stdout, stderr) {\\n-                        commitsData[i].content = stdout;\\n-\\n-                        if (error !== null) {\\n-                            console.log('stderr: ' + stderr);\\n-                            console.log('exec error: ' + error);\\n-                        }\\n-                    });\\n+                    commitsData[i].content = cp.execSync('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit).toString('utf8');\\n                 }\\n \\n                 callback(null, commitsData);\\n             }\\n         ], function (err, result) {\\n-            fs.writeFileSync(\\\"patches.sousp\\\", result);\\n+            for(i=0; i<result.length; i++) {\\n+                fs.writeFileSync(\\\"patches.sousp\\\", JSON.stringify(result[i]));\\n+            }\\n         });\\n-\\n-        //commitsInfo = JSON.parse(fs.readFileSync(\\\"patches.sousp\\\"));\\n-        //console.log(commitsInfo);\\n     }\\n });\\n\\\\ No newline at end of file\\ndiff --git a/patches.sousp b/patches.sousp\\nindex d71e511..300c6a9 100644\\n--- a/patches.sousp\\n+++ b/patches.sousp\\n@@ -1 +1 @@\\n-[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]\\n\\\\ No newline at end of file\\n+{\\\"commit\\\":\\\"1e947f613e976945de85ae35ed923aa470f0be72\\\",\\\"author\\\":\\\"Nick Stepanenko <massaalonso@yandex.ru>\\\",\\\"date\\\":\\\"Tue May 19 00:12:12 2015 +0800\\\",\\\"comment\\\":\\\"Latest updates\\\",\\\"content\\\":\\\"diff --git a/comments.sousc b/comments.sousc\\\\nindex 150b0f6..cb3a850 100644\\\\n--- a/comments.sousc\\\\n+++ b/comments.sousc\\\\n@@ -1,3 +1,27 @@\\\\n+commit 4420cabefc1f470af341af11ed595df67e25c51f\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 17:05:35 2015 +0800\\\\n+\\\\n+    Paste old program code\\\\n+\\\\n+commit 9ef3d25fd4c3afdbcc3107a0abf6d7a2e29cb4dd\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 17:04:52 2015 +0800\\\\n+\\\\n+    Adding new file\\\\n+\\\\n+commit 64814d140d2fab6ae153cac485008119f29bf230\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 17:03:58 2015 +0800\\\\n+\\\\n+    From clear list\\\\n+\\\\n+commit c9d318fea74ea288d544ecf72f00b12c130cf2ef\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 16:59:40 2015 +0800\\\\n+\\\\n+    Create system files\\\\n+\\\\n commit e3c853a4282dfe8f000685dc1d39bd55a4a946c4\\\\n Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n Date:   Sun May 17 16:54:58 2015 +0800\\\\ndiff --git a/main.js b/main.js\\\\nindex e34dc18..86f30c2 100644\\\\n--- a/main.js\\\\n+++ b/main.js\\\\n@@ -3,6 +3,56 @@\\\\n  */\\\\n \\\\n var fs = require('fs');\\\\n+var cp = require('child_process');\\\\n+var data = [];\\\\n+\\\\n+var async = require('async');\\\\n+    /*tasks = [\\\\n+        function (callback) {\\\\n+            cp.exec('git log', function(error, stdout, stderr) {\\\\n+                var listOfCommits = [];\\\\n+                var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n+                var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n+                var comments = findComments(stdout);\\\\n+                var commitNumbers = findCommitNumbers(stdout);\\\\n+\\\\n+                for(i=0; i<authors.length; i++) {\\\\n+                    var commit = {\\\\n+                        \\\\\\\"commit\\\\\\\": commitNumbers[i],\\\\n+                        \\\\\\\"author\\\\\\\": authors[i],\\\\n+                        \\\\\\\"date\\\\\\\": dates[i],\\\\n+                        \\\\\\\"comment\\\\\\\": comments[i],\\\\n+                        \\\\\\\"content\\\\\\\": 'Original'\\\\n+                    };\\\\n+\\\\n+                    listOfCommits[listOfCommits.length] = commit;\\\\n+                }\\\\n+\\\\n+                data = listOfCommits.reverse();\\\\n+\\\\n+                callback(null, data);\\\\n+\\\\n+                if (error !== null) {\\\\n+                    console.log('stderr: ' + stderr);\\\\n+                    console.log('exec error: ' + error);\\\\n+                }\\\\n+            });\\\\n+        }\\\\n+    ],\\\\n+    secondTasks = [\\\\n+        function some_function(callback) {\\\\n+            cp.exec('git diff', function(error, stdout, stderr) {\\\\n+                var currentContent = stdout;\\\\n+\\\\n+                if (error !== null) {\\\\n+                    console.log('stderr: ' + stderr);\\\\n+                    console.log('exec error: ' + error);\\\\n+                }\\\\n+\\\\n+                callback(null, currentContent);\\\\n+            });\\\\n+        }\\\\n+    ];*/\\\\n \\\\n function findData(text, keyword) {\\\\n     var data = [];\\\\n@@ -28,38 +78,106 @@ function findComments(text) {\\\\n     return comments;\\\\n }\\\\n \\\\n+function findCommitNumbers(text) {\\\\n+    var commits = [];\\\\n+    var splittext = text.split('\\\\\\\\n');\\\\n+\\\\n+    for(i=0; i<splittext.length; i++) {\\\\n+        if(splittext[i].slice(0, 6) == \\\\\\\"commit\\\\\\\") {\\\\n+            commits[commits.length] = splittext[i].slice(6).trim();\\\\n+        }\\\\n+    }\\\\n+\\\\n+    return commits;\\\\n+}\\\\n+\\\\n+/*function pullCommitContent(first, second) {\\\\n+\\\\n+    cp.exec('git diff' + ' ' + first + ' ' + second, function(error, stdout, stderr) {\\\\n+        var currentContent = stdout;\\\\n+\\\\n+        if (error !== null) {\\\\n+            console.log('stderr: ' + stderr);\\\\n+            console.log('exec error: ' + error);\\\\n+        }\\\\n+\\\\n+        return currentContent;\\\\n+    });\\\\n+}*/\\\\n+\\\\n+var commitsInfo = [];\\\\n+\\\\n fs.exists('.git', function (exists) {\\\\n     if(exists) {\\\\n-        var cp = require('child_process');\\\\n+        /*async.series(tasks, function(err, result) {\\\\n+            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", JSON.stringify(result));\\\\n+\\\\n+            var data = result[0];\\\\n \\\\n-        cp.exec('git diff', function(error, stdout, stderr) {\\\\n-            console.log(stdout);\\\\n+            /*function some_function(arg1, arg2, callback) {\\\\n+                cp.exec('git diff' + ' ' + arg1 + ' ' + arg2, function(error, stdout, stderr) {\\\\n+                    var currentContent = 54321;//stdout;\\\\n \\\\n-            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", stdout);\\\\n+                    if (error !== null) {\\\\n+                        console.log('stderr: ' + stderr);\\\\n+                        console.log('exec error: ' + error);\\\\n+                    }\\\\n \\\\n-            if (error !== null) {\\\\n-                console.log('stderr: ' + stderr);\\\\n-                console.log('exec error: ' + error);\\\\n+                    callback(null, currentContent);\\\\n+                });\\\\n             }\\\\n-        });\\\\n+        });*/\\\\n+\\\\n+        async.waterfall([\\\\n+            function getCommitsInfo(callback) {\\\\n+                cp.exec('git log', function(error, stdout, stderr) {\\\\n+                    var listOfCommits = [];\\\\n+                    var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n+                    var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n+                    var comments = findComments(stdout);\\\\n+                    var commitNumbers = findCommitNumbers(stdout);\\\\n \\\\n-        cp.exec('git log', function(error, stdout, stderr) {\\\\n-            console.log(stdout);\\\\n+                    for(i=0; i<authors.length; i++) {\\\\n+                        var commit = {\\\\n+                            \\\\\\\"commit\\\\\\\": commitNumbers[i],\\\\n+                            \\\\\\\"author\\\\\\\": authors[i],\\\\n+                            \\\\\\\"date\\\\\\\": dates[i],\\\\n+                            \\\\\\\"comment\\\\\\\": comments[i],\\\\n+                            \\\\\\\"content\\\\\\\": 'Original'\\\\n+                        };\\\\n+                        listOfCommits[listOfCommits.length] = commit;\\\\n+                    }\\\\n \\\\n-            var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n-            var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n-            var comments = findComments(stdout);\\\\n-            console.log(authors);\\\\n-            console.log(comments);\\\\n-            console.log(dates);\\\\n+                    callback(null, listOfCommits.reverse());\\\\n \\\\n-            fs.writeFileSync(\\\\\\\"comments.sousc\\\\\\\", stdout);\\\\n+                    if (error !== null) {\\\\n+                        console.log('stderr: ' + stderr);\\\\n+                        console.log('exec error: ' + error);\\\\n+                    }\\\\n+                });\\\\n+            },\\\\n+            function getCommitsContent(commits, callback) {\\\\n+                console.log(commits);\\\\n+                var commitsData = commits;\\\\n \\\\n-            if (error !== null) {\\\\n-                console.log('stderr: ' + stderr);\\\\n-                console.log('exec error: ' + error);\\\\n+                for(i=1; i<commitsData.length; i++) {\\\\n+                    cp.exec('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit, function(error, stdout, stderr) {\\\\n+                        commitsData[i].content = stdout;\\\\n+\\\\n+                        if (error !== null) {\\\\n+                            console.log('stderr: ' + stderr);\\\\n+                            console.log('exec error: ' + error);\\\\n+                        }\\\\n+                    });\\\\n+                }\\\\n+\\\\n+                callback(null, commitsData);\\\\n             }\\\\n+        ], function (err, result) {\\\\n+            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", result);\\\\n         });\\\\n+\\\\n+        //commitsInfo = JSON.parse(fs.readFileSync(\\\\\\\"patches.sousp\\\\\\\"));\\\\n+        //console.log(commitsInfo);\\\\n     }\\\\n-    else console.log(\\\\\\\"Error.\\\\\\\");\\\\n });\\\\n\\\\\\\\ No newline at end of file\\\\ndiff --git a/node_modules/async/.travis.yml b/node_modules/async/.travis.yml\\\\nnew file mode 100644\\\\nindex 0000000..6e5919d\\\\n--- /dev/null\\\\n+++ b/node_modules/async/.travis.yml\\\\n@@ -0,0 +1,3 @@\\\\n+language: node_js\\\\n+node_js:\\\\n+  - \\\\\\\"0.10\\\\\\\"\\\\ndiff --git a/node_modules/async/LICENSE b/node_modules/async/LICENSE\\\\nnew file mode 100644\\\\nindex 0000000..8f29698\\\\n--- /dev/null\\\\n+++ b/node_modules/async/LICENSE\\\\n@@ -0,0 +1,19 @@\\\\n+Copyright (c) 2010-2014 Caolan McMahon\\\\n+\\\\n+Permission is hereby granted, free of charge, to any person obtaining a copy\\\\n+of this software and associated documentation files (the \\\\\\\"Software\\\\\\\"), to deal\\\\n+in the Software without restriction, including without limitation the rights\\\\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\\\n+copies of the Software, and to permit persons to whom the Software is\\\\n+furnished to do so, subject to the following conditions:\\\\n+\\\\n+The above copyright notice and this permission notice shall be included in\\\\n+all copies or substantial portions of the Software.\\\\n+\\\\n+THE SOFTWARE IS PROVIDED \\\\\\\"AS IS\\\\\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\\\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\\\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\\\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\\\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\\\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\\\n+THE SOFTWARE.\\\\ndiff --git a/node_modules/async/README.md b/node_modules/async/README.md\\\\nnew file mode 100644\\\\nindex 0000000..0bea531\\\\n--- /dev/null\\\\n+++ b/node_modules/async/README.md\\\\n@@ -0,0 +1,1646 @@\\\\n+# Async.js\\\\n+\\\\n+[![Build Status via Travis CI](https://travis-ci.org/caolan/async.svg?branch=master)](https://travis-ci.org/caolan/async)\\\\n+\\\\n+\\\\n+Async is a utility module which provides straight-forward, powerful functions\\\\n+for working with asynchronous JavaScript. Although originally designed for\\\\n+use with [Node.js](http://nodejs.org), it can also be used directly in the\\\\n+browser. Also supports [component](https://github.com/component/component).\\\\n+\\\\n+Async provides around 20 functions that include the usual 'functional'\\\\n+suspects (`map`, `reduce`, `filter`, `each`…) as well as some common patterns\\\\n+for asynchronous control flow (`parallel`, `series`, `waterfall`…). All these\\\\n+functions assume you follow the Node.js convention of providing a single\\\\n+callback as the last argument of your `async` function.\\\\n+\\\\n+\\\\n+## Quick Examples\\\\n+\\\\n+```javascript\\\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\\\n+    // results is now an array of stats for each file\\\\n+});\\\\n+\\\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\\\n+    // results now equals an array of the existing files\\\\n+});\\\\n+\\\\n+async.parallel([\\\\n+    function(){ ... },\\\\n+    function(){ ... }\\\\n+], callback);\\\\n+\\\\n+async.series([\\\\n+    function(){ ... },\\\\n+    function(){ ... }\\\\n+]);\\\\n+```\\\\n+\\\\n+There are many more functions available so take a look at the docs below for a\\\\n+full list. This module aims to be comprehensive, so if you feel anything is\\\\n+missing please create a GitHub issue for it.\\\\n+\\\\n+## Common Pitfalls\\\\n+\\\\n+### Binding a context to an iterator\\\\n+\\\\n+This section is really about `bind`, not about `async`. If you are wondering how to\\\\n+make `async` execute your iterators in a given context, or are confused as to why\\\\n+a method of another library isn't working as an iterator, study this example:\\\\n+\\\\n+```js\\\\n+// Here is a simple object with an (unnecessarily roundabout) squaring method\\\\n+var AsyncSquaringLibrary = {\\\\n+  squareExponent: 2,\\\\n+  square: function(number, callback){ \\\\n+    var result = Math.pow(number, this.squareExponent);\\\\n+    setTimeout(function(){\\\\n+      callback(null, result);\\\\n+    }, 200);\\\\n+  }\\\\n+};\\\\n+\\\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square, function(err, result){\\\\n+  // result is [NaN, NaN, NaN]\\\\n+  // This fails because the `this.squareExponent` expression in the square\\\\n+  // function is not evaluated in the context of AsyncSquaringLibrary, and is\\\\n+  // therefore undefined.\\\\n+});\\\\n+\\\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), function(err, result){\\\\n+  // result is [1, 4, 9]\\\\n+  // With the help of bind we can attach a context to the iterator before\\\\n+  // passing it to async. Now the square function will be executed in its \\\\n+  // 'home' AsyncSquaringLibrary context and the value of `this.squareExponent`\\\\n+  // will be as expected.\\\\n+});\\\\n+```\\\\n+\\\\n+## Download\\\\n+\\\\n+The source is available for download from\\\\n+[GitHub](http://github.com/caolan/async).\\\\n+Alternatively, you can install using Node Package Manager (`npm`):\\\\n+\\\\n+    npm install async\\\\n+\\\\n+__Development:__ [async.js](https://github.com/caolan/async/raw/master/lib/async.js) - 29.6kb Uncompressed\\\\n+\\\\n+## In the Browser\\\\n+\\\\n+So far it's been tested in IE6, IE7, IE8, FF3.6 and Chrome 5. \\\\n+\\\\n+Usage:\\\\n+\\\\n+```html\\\\n+<script type=\\\\\\\"text/javascript\\\\\\\" src=\\\\\\\"async.js\\\\\\\"></script>\\\\n+<script type=\\\\\\\"text/javascript\\\\\\\">\\\\n+\\\\n+    async.map(data, asyncProcess, function(err, results){\\\\n+        alert(results);\\\\n+    });\\\\n+\\\\n+</script>\\\\n+```\\\\n+\\\\n+## Documentation\\\\n+\\\\n+### Collections\\\\n+\\\\n+* [`each`](#each)\\\\n+* [`eachSeries`](#eachSeries)\\\\n+* [`eachLimit`](#eachLimit)\\\\n+* [`map`](#map)\\\\n+* [`mapSeries`](#mapSeries)\\\\n+* [`mapLimit`](#mapLimit)\\\\n+* [`filter`](#filter)\\\\n+* [`filterSeries`](#filterSeries)\\\\n+* [`reject`](#reject)\\\\n+* [`rejectSeries`](#rejectSeries)\\\\n+* [`reduce`](#reduce)\\\\n+* [`reduceRight`](#reduceRight)\\\\n+* [`detect`](#detect)\\\\n+* [`detectSeries`](#detectSeries)\\\\n+* [`sortBy`](#sortBy)\\\\n+* [`some`](#some)\\\\n+* [`every`](#every)\\\\n+* [`concat`](#concat)\\\\n+* [`concatSeries`](#concatSeries)\\\\n+\\\\n+### Control Flow\\\\n+\\\\n+* [`series`](#seriestasks-callback)\\\\n+* [`parallel`](#parallel)\\\\n+* [`parallelLimit`](#parallellimittasks-limit-callback)\\\\n+* [`whilst`](#whilst)\\\\n+* [`doWhilst`](#doWhilst)\\\\n+* [`until`](#until)\\\\n+* [`doUntil`](#doUntil)\\\\n+* [`forever`](#forever)\\\\n+* [`waterfall`](#waterfall)\\\\n+* [`compose`](#compose)\\\\n+* [`seq`](#seq)\\\\n+* [`applyEach`](#applyEach)\\\\n+* [`applyEachSeries`](#applyEachSeries)\\\\n+* [`queue`](#queue)\\\\n+* [`priorityQueue`](#priorityQueue)\\\\n+* [`cargo`](#cargo)\\\\n+* [`auto`](#auto)\\\\n+* [`retry`](#retry)\\\\n+* [`iterator`](#iterator)\\\\n+* [`apply`](#apply)\\\\n+* [`nextTick`](#nextTick)\\\\n+* [`times`](#times)\\\\n+* [`timesSeries`](#timesSeries)\\\\n+\\\\n+### Utils\\\\n+\\\\n+* [`memoize`](#memoize)\\\\n+* [`unmemoize`](#unmemoize)\\\\n+* [`log`](#log)\\\\n+* [`dir`](#dir)\\\\n+* [`noConflict`](#noConflict)\\\\n+\\\\n+\\\\n+## Collections\\\\n+\\\\n+<a name=\\\\\\\"forEach\\\\\\\" />\\\\n+<a name=\\\\\\\"each\\\\\\\" />\\\\n+### each(arr, iterator, callback)\\\\n+\\\\n+Applies the function `iterator` to each item in `arr`, in parallel.\\\\n+The `iterator` is called with an item from the list, and a callback for when it\\\\n+has finished. If the `iterator` passes an error to its `callback`, the main\\\\n+`callback` (for the `each` function) is immediately called with the error.\\\\n+\\\\n+Note, that since this function applies `iterator` to each item in parallel,\\\\n+there is no guarantee that the iterator functions will complete in order.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err)` which must be called once it has \\\\n+  completed. If no error has occured, the `callback` should be run without \\\\n+  arguments or with an explicit `null` argument.\\\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\\\n+  have finished, or an error occurs.\\\\n+\\\\n+__Examples__\\\\n+\\\\n+\\\\n+```js\\\\n+// assuming openFiles is an array of file names and saveFile is a function\\\\n+// to save the modified contents of that file:\\\\n+\\\\n+async.each(openFiles, saveFile, function(err){\\\\n+    // if any of the saves produced an error, err would equal that error\\\\n+});\\\\n+```\\\\n+\\\\n+```js\\\\n+// assuming openFiles is an array of file names \\\\n+\\\\n+async.each(openFiles, function( file, callback) {\\\\n+  \\\\n+  // Perform operation on file here.\\\\n+  console.log('Processing file ' + file);\\\\n+  \\\\n+  if( file.length > 32 ) {\\\\n+    console.log('This file name is too long');\\\\n+    callback('File name too long');\\\\n+  } else {\\\\n+    // Do work to process file here\\\\n+    console.log('File processed');\\\\n+    callback();\\\\n+  }\\\\n+}, function(err){\\\\n+    // if any of the file processing produced an error, err would equal that error\\\\n+    if( err ) {\\\\n+      // One of the iterations produced an error.\\\\n+      // All processing will now stop.\\\\n+      console.log('A file failed to process');\\\\n+    } else {\\\\n+      console.log('All files have been processed successfully');\\\\n+    }\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"forEachSeries\\\\\\\" />\\\\n+<a name=\\\\\\\"eachSeries\\\\\\\" />\\\\n+### eachSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`each`](#each), only `iterator` is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+This means the `iterator` functions will complete in order.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"forEachLimit\\\\\\\" />\\\\n+<a name=\\\\\\\"eachLimit\\\\\\\" />\\\\n+### eachLimit(arr, limit, iterator, callback)\\\\n+\\\\n+The same as [`each`](#each), only no more than `limit` `iterator`s will be simultaneously \\\\n+running at any time.\\\\n+\\\\n+Note that the items in `arr` are not processed in batches, so there is no guarantee that \\\\n+the first `limit` `iterator` functions will complete before any others are started.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err)` which must be called once it has \\\\n+  completed. If no error has occured, the callback should be run without \\\\n+  arguments or with an explicit `null` argument.\\\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\\\n+  have finished, or an error occurs.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// Assume documents is an array of JSON objects and requestApi is a\\\\n+// function that interacts with a rate-limited REST api.\\\\n+\\\\n+async.eachLimit(documents, 20, requestApi, function(err){\\\\n+    // if any of the saves produced an error, err would equal that error\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"map\\\\\\\" />\\\\n+### map(arr, iterator, callback)\\\\n+\\\\n+Produces a new array of values by mapping each value in `arr` through\\\\n+the `iterator` function. The `iterator` is called with an item from `arr` and a\\\\n+callback for when it has finished processing. Each of these callback takes 2 arguments: \\\\n+an `error`, and the transformed item from `arr`. If `iterator` passes an error to this \\\\n+callback, the main `callback` (for the `map` function) is immediately called with the error.\\\\n+\\\\n+Note, that since this function applies the `iterator` to each item in parallel,\\\\n+there is no guarantee that the `iterator` functions will complete in order. \\\\n+However, the results array will be in the same order as the original `arr`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\\\n+  it has completed with an error (which can be `null`) and a transformed item.\\\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\\\n+  functions have finished, or an error occurs. Results is an array of the\\\\n+  transformed items from the `arr`.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\\\n+    // results is now an array of stats for each file\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"mapSeries\\\\\\\" />\\\\n+### mapSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`map`](#map), only the `iterator` is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+The results array will be in the same order as the original.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"mapLimit\\\\\\\" />\\\\n+### mapLimit(arr, limit, iterator, callback)\\\\n+\\\\n+The same as [`map`](#map), only no more than `limit` `iterator`s will be simultaneously \\\\n+running at any time.\\\\n+\\\\n+Note that the items are not processed in batches, so there is no guarantee that \\\\n+the first `limit` `iterator` functions will complete before any others are started.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\\\n+  it has completed with an error (which can be `null`) and a transformed item.\\\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\\\n+  calls have finished, or an error occurs. The result is an array of the\\\\n+  transformed items from the original `arr`.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.mapLimit(['file1','file2','file3'], 1, fs.stat, function(err, results){\\\\n+    // results is now an array of stats for each file\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"select\\\\\\\" />\\\\n+<a name=\\\\\\\"filter\\\\\\\" />\\\\n+### filter(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `select`\\\\n+\\\\n+Returns a new array of all the values in `arr` which pass an async truth test.\\\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\n+way node libraries work with truth tests like `fs.exists`. This operation is\\\\n+performed in parallel, but the results array will be in the same order as the\\\\n+original.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\\\n+  The `iterator` is passed a `callback(truthValue)`, which must be called with a \\\\n+  boolean argument once it has completed.\\\\n+* `callback(results)` - A callback which is called after all the `iterator`\\\\n+  functions have finished.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\\\n+    // results now equals an array of the existing files\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"selectSeries\\\\\\\" />\\\\n+<a name=\\\\\\\"filterSeries\\\\\\\" />\\\\n+### filterSeries(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `selectSeries`\\\\n+\\\\n+The same as [`filter`](#filter) only the `iterator` is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+The results array will be in the same order as the original.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"reject\\\\\\\" />\\\\n+### reject(arr, iterator, callback)\\\\n+\\\\n+The opposite of [`filter`](#filter). Removes values that pass an `async` truth test.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"rejectSeries\\\\\\\" />\\\\n+### rejectSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`reject`](#reject), only the `iterator` is applied to each item in `arr`\\\\n+in series.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"reduce\\\\\\\" />\\\\n+### reduce(arr, memo, iterator, callback)\\\\n+\\\\n+__Aliases:__ `inject`, `foldl`\\\\n+\\\\n+Reduces `arr` into a single value using an async `iterator` to return\\\\n+each successive step. `memo` is the initial state of the reduction. \\\\n+This function only operates in series. \\\\n+\\\\n+For performance reasons, it may make sense to split a call to this function into \\\\n+a parallel map, and then use the normal `Array.prototype.reduce` on the results. \\\\n+This function is for situations where each step in the reduction needs to be async; \\\\n+if you can get the data before reducing it, then it's probably a good idea to do so.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `memo` - The initial state of the reduction.\\\\n+* `iterator(memo, item, callback)` - A function applied to each item in the\\\\n+  array to produce the next step in the reduction. The `iterator` is passed a\\\\n+  `callback(err, reduction)` which accepts an optional error as its first \\\\n+  argument, and the state of the reduction as the second. If an error is \\\\n+  passed to the callback, the reduction is stopped and the main `callback` is \\\\n+  immediately called with the error.\\\\n+* `callback(err, result)` - A callback which is called after all the `iterator`\\\\n+  functions have finished. Result is the reduced value.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.reduce([1,2,3], 0, function(memo, item, callback){\\\\n+    // pointless async:\\\\n+    process.nextTick(function(){\\\\n+        callback(null, memo + item)\\\\n+    });\\\\n+}, function(err, result){\\\\n+    // result is now equal to the last value of memo, which is 6\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"reduceRight\\\\\\\" />\\\\n+### reduceRight(arr, memo, iterator, callback)\\\\n+\\\\n+__Alias:__ `foldr`\\\\n+\\\\n+Same as [`reduce`](#reduce), only operates on `arr` in reverse order.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"detect\\\\\\\" />\\\\n+### detect(arr, iterator, callback)\\\\n+\\\\n+Returns the first value in `arr` that passes an async truth test. The\\\\n+`iterator` is applied in parallel, meaning the first iterator to return `true` will\\\\n+fire the detect `callback` with that result. That means the result might not be\\\\n+the first item in the original `arr` (in terms of order) that passes the test.\\\\n+\\\\n+If order within the original `arr` is important, then look at [`detectSeries`](#detectSeries).\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(truthValue)` which must be called with a \\\\n+  boolean argument once it has completed.\\\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\\\n+  `true`, or after all the `iterator` functions have finished. Result will be\\\\n+  the first item in the array that passes the truth test (iterator) or the\\\\n+  value `undefined` if none passed.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.detect(['file1','file2','file3'], fs.exists, function(result){\\\\n+    // result now equals the first file in the list that exists\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"detectSeries\\\\\\\" />\\\\n+### detectSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`detect`](#detect), only the `iterator` is applied to each item in `arr`\\\\n+in series. This means the result is always the first in the original `arr` (in\\\\n+terms of array order) that passes the truth test.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"sortBy\\\\\\\" />\\\\n+### sortBy(arr, iterator, callback)\\\\n+\\\\n+Sorts a list by the results of running each `arr` value through an async `iterator`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, sortValue)` which must be called once it\\\\n+  has completed with an error (which can be `null`) and a value to use as the sort\\\\n+  criteria.\\\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\\\n+  functions have finished, or an error occurs. Results is the items from\\\\n+  the original `arr` sorted by the values returned by the `iterator` calls.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.sortBy(['file1','file2','file3'], function(file, callback){\\\\n+    fs.stat(file, function(err, stats){\\\\n+        callback(err, stats.mtime);\\\\n+    });\\\\n+}, function(err, results){\\\\n+    // results is now the original array of files sorted by\\\\n+    // modified date\\\\n+});\\\\n+```\\\\n+\\\\n+__Sort Order__\\\\n+\\\\n+By modifying the callback parameter the sorting order can be influenced:\\\\n+\\\\n+```js\\\\n+//ascending order\\\\n+async.sortBy([1,9,3,5], function(x, callback){\\\\n+    callback(err, x);\\\\n+}, function(err,result){\\\\n+    //result callback\\\\n+} );\\\\n+\\\\n+//descending order\\\\n+async.sortBy([1,9,3,5], function(x, callback){\\\\n+    callback(err, x*-1);    //<- x*-1 instead of x, turns the order around\\\\n+}, function(err,result){\\\\n+    //result callback\\\\n+} );\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"some\\\\\\\" />\\\\n+### some(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `any`\\\\n+\\\\n+Returns `true` if at least one element in the `arr` satisfies an async test.\\\\n+_The callback for each iterator call only accepts a single argument of `true` or\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\n+way node libraries work with truth tests like `fs.exists`. Once any iterator\\\\n+call returns `true`, the main `callback` is immediately called.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\\\n+  called with a boolean argument once it has completed.\\\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\\\n+  `true`, or after all the iterator functions have finished. Result will be\\\\n+  either `true` or `false` depending on the values of the async tests.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.some(['file1','file2','file3'], fs.exists, function(result){\\\\n+    // if result is true then at least one of the files exists\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"every\\\\\\\" />\\\\n+### every(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `all`\\\\n+\\\\n+Returns `true` if every element in `arr` satisfies an async test.\\\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\n+way node libraries work with truth tests like `fs.exists`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\\\n+  called with a  boolean argument once it has completed.\\\\n+* `callback(result)` - A callback which is called after all the `iterator`\\\\n+  functions have finished. Result will be either `true` or `false` depending on\\\\n+  the values of the async tests.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.every(['file1','file2','file3'], fs.exists, function(result){\\\\n+    // if result is true then every file exists\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"concat\\\\\\\" />\\\\n+### concat(arr, iterator, callback)\\\\n+\\\\n+Applies `iterator` to each item in `arr`, concatenating the results. Returns the\\\\n+concatenated list. The `iterator`s are called in parallel, and the results are\\\\n+concatenated as they return. There is no guarantee that the results array will\\\\n+be returned in the original order of `arr` passed to the `iterator` function.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, results)` which must be called once it \\\\n+  has completed with an error (which can be `null`) and an array of results.\\\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\\\n+  functions have finished, or an error occurs. Results is an array containing\\\\n+  the concatenated results of the `iterator` function.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files){\\\\n+    // files is now a list of filenames that exist in the 3 directories\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"concatSeries\\\\\\\" />\\\\n+### concatSeries(arr, iterator, callback)\\\\n+\\\\n+Same as [`concat`](#concat), but executes in series instead of parallel.\\\\n+\\\\n+\\\\n+## Control Flow\\\\n+\\\\n+<a name=\\\\\\\"series\\\\\\\" />\\\\n+### series(tasks, [callback])\\\\n+\\\\n+Run the functions in the `tasks` array in series, each one running once the previous\\\\n+function has completed. If any functions in the series pass an error to its\\\\n+callback, no more functions are run, and `callback` is immediately called with the value of the error. \\\\n+Otherwise, `callback` receives an array of results when `tasks` have completed.\\\\n+\\\\n+It is also possible to use an object instead of an array. Each property will be\\\\n+run as a function, and the results will be passed to the final `callback` as an object\\\\n+instead of an array. This can be a more readable way of handling results from\\\\n+[`series`](#series).\\\\n+\\\\n+**Note** that while many implementations preserve the order of object properties, the\\\\n+[ECMAScript Language Specifcation](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6) \\\\n+explicitly states that\\\\n+\\\\n+> The mechanics and order of enumerating the properties is not specified.\\\\n+\\\\n+So if you rely on the order in which your series of functions are executed, and want\\\\n+this to work on all platforms, consider using an array. \\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array or object containing functions to run, each function is passed\\\\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\\\n+  be `null`) and an optional `result` value.\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\n+  have completed. This function gets a results array (or object) containing all \\\\n+  the result arguments passed to the `task` callbacks.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.series([\\\\n+    function(callback){\\\\n+        // do some stuff ...\\\\n+        callback(null, 'one');\\\\n+    },\\\\n+    function(callback){\\\\n+        // do some more stuff ...\\\\n+        callback(null, 'two');\\\\n+    }\\\\n+],\\\\n+// optional callback\\\\n+function(err, results){\\\\n+    // results is now equal to ['one', 'two']\\\\n+});\\\\n+\\\\n+\\\\n+// an example using an object instead of an array\\\\n+async.series({\\\\n+    one: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 1);\\\\n+        }, 200);\\\\n+    },\\\\n+    two: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 2);\\\\n+        }, 100);\\\\n+    }\\\\n+},\\\\n+function(err, results) {\\\\n+    // results is now equal to: {one: 1, two: 2}\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"parallel\\\\\\\" />\\\\n+### parallel(tasks, [callback])\\\\n+\\\\n+Run the `tasks` array of functions in parallel, without waiting until the previous\\\\n+function has completed. If any of the functions pass an error to its\\\\n+callback, the main `callback` is immediately called with the value of the error.\\\\n+Once the `tasks` have completed, the results are passed to the final `callback` as an\\\\n+array.\\\\n+\\\\n+It is also possible to use an object instead of an array. Each property will be\\\\n+run as a function and the results will be passed to the final `callback` as an object\\\\n+instead of an array. This can be a more readable way of handling results from\\\\n+[`parallel`](#parallel).\\\\n+\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array or object containing functions to run. Each function is passed \\\\n+  a `callback(err, result)` which it must call on completion with an error `err` \\\\n+  (which can be `null`) and an optional `result` value.\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\n+  have completed. This function gets a results array (or object) containing all \\\\n+  the result arguments passed to the task callbacks.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.parallel([\\\\n+    function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 'one');\\\\n+        }, 200);\\\\n+    },\\\\n+    function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 'two');\\\\n+        }, 100);\\\\n+    }\\\\n+],\\\\n+// optional callback\\\\n+function(err, results){\\\\n+    // the results array will equal ['one','two'] even though\\\\n+    // the second function had a shorter timeout.\\\\n+});\\\\n+\\\\n+\\\\n+// an example using an object instead of an array\\\\n+async.parallel({\\\\n+    one: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 1);\\\\n+        }, 200);\\\\n+    },\\\\n+    two: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 2);\\\\n+        }, 100);\\\\n+    }\\\\n+},\\\\n+function(err, results) {\\\\n+    // results is now equals to: {one: 1, two: 2}\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"parallelLimit\\\\\\\" />\\\\n+### parallelLimit(tasks, limit, [callback])\\\\n+\\\\n+The same as [`parallel`](#parallel), only `tasks` are executed in parallel \\\\n+with a maximum of `limit` tasks executing at any time.\\\\n+\\\\n+Note that the `tasks` are not executed in batches, so there is no guarantee that \\\\n+the first `limit` tasks will complete before any others are started.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array or object containing functions to run, each function is passed \\\\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\\\n+  be `null`) and an optional `result` value.\\\\n+* `limit` - The maximum number of `tasks` to run at any time.\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\n+  have completed. This function gets a results array (or object) containing all \\\\n+  the result arguments passed to the `task` callbacks.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"whilst\\\\\\\" />\\\\n+### whilst(test, fn, callback)\\\\n+\\\\n+Repeatedly call `fn`, while `test` returns `true`. Calls `callback` when stopped,\\\\n+or an error occurs.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `test()` - synchronous truth test to perform before each execution of `fn`.\\\\n+* `fn(callback)` - A function which is called each time `test` passes. The function is\\\\n+  passed a `callback(err)`, which must be called once it has completed with an \\\\n+  optional `err` argument.\\\\n+* `callback(err)` - A callback which is called after the test fails and repeated\\\\n+  execution of `fn` has stopped.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var count = 0;\\\\n+\\\\n+async.whilst(\\\\n+    function () { return count < 5; },\\\\n+    function (callback) {\\\\n+        count++;\\\\n+        setTimeout(callback, 1000);\\\\n+    },\\\\n+    function (err) {\\\\n+        // 5 seconds have passed\\\\n+    }\\\\n+);\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"doWhilst\\\\\\\" />\\\\n+### doWhilst(fn, test, callback)\\\\n+\\\\n+The post-check version of [`whilst`](#whilst). To reflect the difference in \\\\n+the order of operations, the arguments `test` and `fn` are switched. \\\\n+\\\\n+`doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"until\\\\\\\" />\\\\n+### until(test, fn, callback)\\\\n+\\\\n+Repeatedly call `fn` until `test` returns `true`. Calls `callback` when stopped,\\\\n+or an error occurs.\\\\n+\\\\n+The inverse of [`whilst`](#whilst).\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"doUntil\\\\\\\" />\\\\n+### doUntil(fn, test, callback)\\\\n+\\\\n+Like [`doWhilst`](#doWhilst), except the `test` is inverted. Note the argument ordering differs from `until`.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"forever\\\\\\\" />\\\\n+### forever(fn, errback)\\\\n+\\\\n+Calls the asynchronous function `fn` with a callback parameter that allows it to\\\\n+call itself again, in series, indefinitely.\\\\n+\\\\n+If an error is passed to the callback then `errback` is called with the\\\\n+error, and execution stops, otherwise it will never be called.\\\\n+\\\\n+```js\\\\n+async.forever(\\\\n+    function(next) {\\\\n+        // next is suitable for passing to things that need a callback(err [, whatever]);\\\\n+        // it will result in this function being called again.\\\\n+    },\\\\n+    function(err) {\\\\n+        // if next is called with a value in its first parameter, it will appear\\\\n+        // in here as 'err', and execution will stop.\\\\n+    }\\\\n+);\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"waterfall\\\\\\\" />\\\\n+### waterfall(tasks, [callback])\\\\n+\\\\n+Runs the `tasks` array of functions in series, each passing their results to the next in\\\\n+the array. However, if any of the `tasks` pass an error to their own callback, the\\\\n+next function is not executed, and the main `callback` is immediately called with\\\\n+the error.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array of functions to run, each function is passed a \\\\n+  `callback(err, result1, result2, ...)` it must call on completion. The first\\\\n+  argument is an error (which can be `null`) and any further arguments will be \\\\n+  passed as arguments in order to the next task.\\\\n+* `callback(err, [results])` - An optional callback to run once all the functions\\\\n+  have completed. This will be passed the results of the last task's callback.\\\\n+\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.waterfall([\\\\n+    function(callback){\\\\n+        callback(null, 'one', 'two');\\\\n+    },\\\\n+    function(arg1, arg2, callback){\\\\n+      // arg1 now equals 'one' and arg2 now equals 'two'\\\\n+        callback(null, 'three');\\\\n+    },\\\\n+    function(arg1, callback){\\\\n+        // arg1 now equals 'three'\\\\n+        callback(null, 'done');\\\\n+    }\\\\n+], function (err, result) {\\\\n+   // result now equals 'done'    \\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+<a name=\\\\\\\"compose\\\\\\\" />\\\\n+### compose(fn1, fn2...)\\\\n+\\\\n+Creates a function which is a composition of the passed asynchronous\\\\n+functions. Each function consumes the return value of the function that\\\\n+follows. Composing functions `f()`, `g()`, and `h()` would produce the result of\\\\n+`f(g(h()))`, only this version uses callbacks to obtain the return values.\\\\n+\\\\n+Each function is executed with the `this` binding of the composed function.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `functions...` - the asynchronous functions to compose\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+function add1(n, callback) {\\\\n+    setTimeout(function () {\\\\n+        callback(null, n + 1);\\\\n+    }, 10);\\\\n+}\\\\n+\\\\n+function mul3(n, callback) {\\\\n+    setTimeout(function () {\\\\n+        callback(null, n * 3);\\\\n+    }, 10);\\\\n+}\\\\n+\\\\n+var add1mul3 = async.compose(mul3, add1);\\\\n+\\\\n+add1mul3(4, function (err, result) {\\\\n+   // result now equals 15\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+<a name=\\\\\\\"seq\\\\\\\" />\\\\n+### seq(fn1, fn2...)\\\\n+\\\\n+Version of the compose function that is more natural to read.\\\\n+Each following function consumes the return value of the latter function. \\\\n+\\\\n+Each function is executed with the `this` binding of the composed function.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* functions... - the asynchronous functions to compose\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// Requires lodash (or underscore), express3 and dresende's orm2.\\\\n+// Part of an app, that fetches cats of the logged user.\\\\n+// This example uses `seq` function to avoid overnesting and error \\\\n+// handling clutter.\\\\n+app.get('/cats', function(request, response) {\\\\n+  function handleError(err, data, callback) {\\\\n+    if (err) {\\\\n+      console.error(err);\\\\n+      response.json({ status: 'error', message: err.message });\\\\n+    }\\\\n+    else {\\\\n+      callback(data);\\\\n+    }\\\\n+  }\\\\n+  var User = request.models.User;\\\\n+  async.seq(\\\\n+    _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\\\\n+    handleError,\\\\n+    function(user, fn) {\\\\n+      user.getCats(fn);      // 'getCats' has signature (callback(err, data))\\\\n+    },\\\\n+    handleError,\\\\n+    function(cats) {\\\\n+      response.json({ status: 'ok', message: 'Cats found', data: cats });\\\\n+    }\\\\n+  )(req.session.user_id);\\\\n+  }\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+<a name=\\\\\\\"applyEach\\\\\\\" />\\\\n+### applyEach(fns, args..., callback)\\\\n+\\\\n+Applies the provided arguments to each function in the array, calling \\\\n+`callback` after all functions have completed. If you only provide the first\\\\n+argument, then it will return a function which lets you pass in the\\\\n+arguments as if it were a single function call.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `fns` - the asynchronous functions to all call with the same arguments\\\\n+* `args...` - any number of separate arguments to pass to the function\\\\n+* `callback` - the final argument should be the callback, called when all\\\\n+  functions have completed processing\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.applyEach([enableSearch, updateSchema], 'bucket', callback);\\\\n+\\\\n+// partial application example:\\\\n+async.each(\\\\n+    buckets,\\\\n+    async.applyEach([enableSearch, updateSchema]),\\\\n+    callback\\\\n+);\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"applyEachSeries\\\\\\\" />\\\\n+### applyEachSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`applyEach`](#applyEach) only the functions are applied in series.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"queue\\\\\\\" />\\\\n+### queue(worker, concurrency)\\\\n+\\\\n+Creates a `queue` object with the specified `concurrency`. Tasks added to the\\\\n+`queue` are processed in parallel (up to the `concurrency` limit). If all\\\\n+`worker`s are in progress, the task is queued until one becomes available. \\\\n+Once a `worker` completes a `task`, that `task`'s callback is called.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `worker(task, callback)` - An asynchronous function for processing a queued\\\\n+  task, which must call its `callback(err)` argument when finished, with an \\\\n+  optional `error` as an argument.\\\\n+* `concurrency` - An `integer` for determining how many `worker` functions should be\\\\n+  run in parallel.\\\\n+\\\\n+__Queue objects__\\\\n+\\\\n+The `queue` object returned by this function has the following properties and\\\\n+methods:\\\\n+\\\\n+* `length()` - a function returning the number of items waiting to be processed.\\\\n+* `started` - a function returning whether or not any items have been pushed and processed by the queue\\\\n+* `running()` - a function returning the number of items currently being processed.\\\\n+* `idle()` - a function returning false if there are items waiting or being processed, or true if not.\\\\n+* `concurrency` - an integer for determining how many `worker` functions should be\\\\n+  run in parallel. This property can be changed after a `queue` is created to\\\\n+  alter the concurrency on-the-fly.\\\\n+* `push(task, [callback])` - add a new task to the `queue`. Calls `callback` once \\\\n+  the `worker` has finished processing the task. Instead of a single task, a `tasks` array\\\\n+  can be submitted. The respective callback is used for every task in the list.\\\\n+* `unshift(task, [callback])` - add a new task to the front of the `queue`.\\\\n+* `saturated` - a callback that is called when the `queue` length hits the `concurrency` limit, \\\\n+   and further tasks will be queued.\\\\n+* `empty` - a callback that is called when the last item from the `queue` is given to a `worker`.\\\\n+* `drain` - a callback that is called when the last item from the `queue` has returned from the `worker`.\\\\n+* `paused` - a boolean for determining whether the queue is in a paused state\\\\n+* `pause()` - a function that pauses the processing of tasks until `resume()` is called.\\\\n+* `resume()` - a function that resumes the processing of queued tasks when the queue is paused.\\\\n+* `kill()` - a function that empties remaining tasks from the queue forcing it to go idle.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// create a queue object with concurrency 2\\\\n+\\\\n+var q = async.queue(function (task, callback) {\\\\n+    console.log('hello ' + task.name);\\\\n+    callback();\\\\n+}, 2);\\\\n+\\\\n+\\\\n+// assign a callback\\\\n+q.drain = function() {\\\\n+    console.log('all items have been processed');\\\\n+}\\\\n+\\\\n+// add some items to the queue\\\\n+\\\\n+q.push({name: 'foo'}, function (err) {\\\\n+    console.log('finished processing foo');\\\\n+});\\\\n+q.push({name: 'bar'}, function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+\\\\n+// add some items to the queue (batch-wise)\\\\n+\\\\n+q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+\\\\n+// add some items to the front of the queue\\\\n+\\\\n+q.unshift({name: 'bar'}, function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+```\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"priorityQueue\\\\\\\" />\\\\n+### priorityQueue(worker, concurrency)\\\\n+\\\\n+The same as [`queue`](#queue) only tasks are assigned a priority and completed in ascending priority order. There are two differences between `queue` and `priorityQueue` objects:\\\\n+\\\\n+* `push(task, priority, [callback])` - `priority` should be a number. If an array of\\\\n+  `tasks` is given, all tasks will be assigned the same priority.\\\\n+* The `unshift` method was removed.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"cargo\\\\\\\" />\\\\n+### cargo(worker, [payload])\\\\n+\\\\n+Creates a `cargo` object with the specified payload. Tasks added to the\\\\n+cargo will be processed altogether (up to the `payload` limit). If the\\\\n+`worker` is in progress, the task is queued until it becomes available. Once\\\\n+the `worker` has completed some tasks, each callback of those tasks is called.\\\\n+Check out [this animation](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) for how `cargo` and `queue` work.\\\\n+\\\\n+While [queue](#queue) passes only one task to one of a group of workers\\\\n+at a time, cargo passes an array of tasks to a single worker, repeating\\\\n+when the worker is finished.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `worker(tasks, callback)` - An asynchronous function for processing an array of\\\\n+  queued tasks, which must call its `callback(err)` argument when finished, with \\\\n+  an optional `err` argument.\\\\n+* `payload` - An optional `integer` for determining how many tasks should be\\\\n+  processed per round; if omitted, the default is unlimited.\\\\n+\\\\n+__Cargo objects__\\\\n+\\\\n+The `cargo` object returned by this function has the following properties and\\\\n+methods:\\\\n+\\\\n+* `length()` - A function returning the number of items waiting to be processed.\\\\n+* `payload` - An `integer` for determining how many tasks should be\\\\n+  process per round. This property can be changed after a `cargo` is created to\\\\n+  alter the payload on-the-fly.\\\\n+* `push(task, [callback])` - Adds `task` to the `queue`. The callback is called\\\\n+  once the `worker` has finished processing the task. Instead of a single task, an array of `tasks` \\\\n+  can be submitted. The respective callback is used for every task in the list.\\\\n+* `saturated` - A callback that is called when the `queue.length()` hits the concurrency and further tasks will be queued.\\\\n+* `empty` - A callback that is called when the last item from the `queue` is given to a `worker`.\\\\n+* `drain` - A callback that is called when the last item from the `queue` has returned from the `worker`.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// create a cargo object with payload 2\\\\n+\\\\n+var cargo = async.cargo(function (tasks, callback) {\\\\n+    for(var i=0; i<tasks.length; i++){\\\\n+      console.log('hello ' + tasks[i].name);\\\\n+    }\\\\n+    callback();\\\\n+}, 2);\\\\n+\\\\n+\\\\n+// add some items\\\\n+\\\\n+cargo.push({name: 'foo'}, function (err) {\\\\n+    console.log('finished processing foo');\\\\n+});\\\\n+cargo.push({name: 'bar'}, function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+cargo.push({name: 'baz'}, function (err) {\\\\n+    console.log('finished processing baz');\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"auto\\\\\\\" />\\\\n+### auto(tasks, [callback])\\\\n+\\\\n+Determines the best order for running the functions in `tasks`, based on their \\\\n+requirements. Each function can optionally depend on other functions being completed \\\\n+first, and each function is run as soon as its requirements are satisfied. \\\\n+\\\\n+If any of the functions pass an error to their callback, it will not \\\\n+complete (so any other functions depending on it will not run), and the main \\\\n+`callback` is immediately called with the error. Functions also receive an \\\\n+object containing the results of functions which have completed so far.\\\\n+\\\\n+Note, all functions are called with a `results` object as a second argument, \\\\n+so it is unsafe to pass functions in the `tasks` object which cannot handle the\\\\n+extra argument. \\\\n+\\\\n+For example, this snippet of code:\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+  readData: async.apply(fs.readFile, 'data.txt', 'utf-8')\\\\n+}, callback);\\\\n+```\\\\n+\\\\n+will have the effect of calling `readFile` with the results object as the last\\\\n+argument, which will fail:\\\\n+\\\\n+```js\\\\n+fs.readFile('data.txt', 'utf-8', cb, {});\\\\n+```\\\\n+\\\\n+Instead, wrap the call to `readFile` in a function which does not forward the \\\\n+`results` object:\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+  readData: function(cb, results){\\\\n+    fs.readFile('data.txt', 'utf-8', cb);\\\\n+  }\\\\n+}, callback);\\\\n+```\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An object. Each of its properties is either a function or an array of\\\\n+  requirements, with the function itself the last item in the array. The object's key\\\\n+  of a property serves as the name of the task defined by that property,\\\\n+  i.e. can be used when specifying requirements for other tasks.\\\\n+  The function receives two arguments: (1) a `callback(err, result)` which must be \\\\n+  called when finished, passing an `error` (which can be `null`) and the result of \\\\n+  the function's execution, and (2) a `results` object, containing the results of\\\\n+  the previously executed functions.\\\\n+* `callback(err, results)` - An optional callback which is called when all the\\\\n+  tasks have been completed. It receives the `err` argument if any `tasks` \\\\n+  pass an error to their callback. Results are always returned; however, if \\\\n+  an error occurs, no further `tasks` will be performed, and the results\\\\n+  object will only contain partial results.\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+    get_data: function(callback){\\\\n+        console.log('in get_data');\\\\n+        // async code to get some data\\\\n+        callback(null, 'data', 'converted to array');\\\\n+    },\\\\n+    make_folder: function(callback){\\\\n+        console.log('in make_folder');\\\\n+        // async code to create a directory to store a file in\\\\n+        // this is run at the same time as getting the data\\\\n+        callback(null, 'folder');\\\\n+    },\\\\n+    write_file: ['get_data', 'make_folder', function(callback, results){\\\\n+        console.log('in write_file', JSON.stringify(results));\\\\n+        // once there is some data and the directory exists,\\\\n+        // write the data to a file in the directory\\\\n+        callback(null, 'filename');\\\\n+    }],\\\\n+    email_link: ['write_file', function(callback, results){\\\\n+        console.log('in email_link', JSON.stringify(results));\\\\n+        // once the file is written let's email a link to it...\\\\n+        // results.write_file contains the filename returned by write_file.\\\\n+        callback(null, {'file':results.write_file, 'email':'user@example.com'});\\\\n+    }]\\\\n+}, function(err, results) {\\\\n+    console.log('err = ', err);\\\\n+    console.log('results = ', results);\\\\n+});\\\\n+```\\\\n+\\\\n+This is a fairly trivial example, but to do this using the basic parallel and\\\\n+series functions would look like this:\\\\n+\\\\n+```js\\\\n+async.parallel([\\\\n+    function(callback){\\\\n+        console.log('in get_data');\\\\n+        // async code to get some data\\\\n+        callback(null, 'data', 'converted to array');\\\\n+    },\\\\n+    function(callback){\\\\n+        console.log('in make_folder');\\\\n+        // async code to create a directory to store a file in\\\\n+        // this is run at the same time as getting the data\\\\n+        callback(null, 'folder');\\\\n+    }\\\\n+],\\\\n+function(err, results){\\\\n+    async.series([\\\\n+        function(callback){\\\\n+            console.log('in write_file', JSON.stringify(results));\\\\n+            // once there is some data and the directory exists,\\\\n+            // write the data to a file in the directory\\\\n+            results.push('filename');\\\\n+            callback(null);\\\\n+        },\\\\n+        function(callback){\\\\n+            console.log('in email_link', JSON.stringify(results));\\\\n+            // once the file is written let's email a link to it...\\\\n+            callback(null, {'file':results.pop(), 'email':'user@example.com'});\\\\n+        }\\\\n+    ]);\\\\n+});\\\\n+```\\\\n+\\\\n+For a complicated series of `async` tasks, using the [`auto`](#auto) function makes adding\\\\n+new tasks much easier (and the code more readable).\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"retry\\\\\\\" />\\\\n+### retry([times = 5], task, [callback])\\\\n+\\\\n+Attempts to get a successful response from `task` no more than `times` times before\\\\n+returning an error. If the task is successful, the `callback` will be passed the result\\\\n+of the successfull task. If all attemps fail, the callback will be passed the error and\\\\n+result (if any) of the final attempt.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `times` - An integer indicating how many times to attempt the `task` before giving up. Defaults to 5.\\\\n+* `task(callback, results)` - A function which receives two arguments: (1) a `callback(err, result)`\\\\n+  which must be called when finished, passing `err` (which can be `null`) and the `result` of \\\\n+  the function's execution, and (2) a `results` object, containing the results of\\\\n+  the previously executed functions (if nested inside another control flow).\\\\n+* `callback(err, results)` - An optional callback which is called when the\\\\n+  task has succeeded, or after the final failed attempt. It receives the `err` and `result` arguments of the last attempt at completing the `task`.\\\\n+\\\\n+The [`retry`](#retry) function can be used as a stand-alone control flow by passing a\\\\n+callback, as shown below:\\\\n+\\\\n+```js\\\\n+async.retry(3, apiMethod, function(err, result) {\\\\n+    // do something with the result\\\\n+});\\\\n+```\\\\n+\\\\n+It can also be embeded within other control flow functions to retry individual methods\\\\n+that are not as reliable, like this:\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+    users: api.getUsers.bind(api),\\\\n+    payments: async.retry(3, api.getPayments.bind(api))\\\\n+}, function(err, results) {\\\\n+  // do something with the results\\\\n+});\\\\n+```\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"iterator\\\\\\\" />\\\\n+### iterator(tasks)\\\\n+\\\\n+Creates an iterator function which calls the next function in the `tasks` array,\\\\n+returning a continuation to call the next one after that. It's also possible to\\\\n+“peek” at the next iterator with `iterator.next()`.\\\\n+\\\\n+This function is used internally by the `async` module, but can be useful when\\\\n+you want to manually control the flow of functions in series.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array of functions to run.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var iterator = async.iterator([\\\\n+    function(){ sys.p('one'); },\\\\n+    function(){ sys.p('two'); },\\\\n+    function(){ sys.p('three'); }\\\\n+]);\\\\n+\\\\n+node> var iterator2 = iterator();\\\\n+'one'\\\\n+node> var iterator3 = iterator2();\\\\n+'two'\\\\n+node> iterator3();\\\\n+'three'\\\\n+node> var nextfn = iterator2.next();\\\\n+node> nextfn();\\\\n+'three'\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"apply\\\\\\\" />\\\\n+### apply(function, arguments..)\\\\n+\\\\n+Creates a continuation function with some arguments already applied. \\\\n+\\\\n+Useful as a shorthand when combined with other control flow functions. Any arguments\\\\n+passed to the returned function are added to the arguments originally passed\\\\n+to apply.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\n+* `arguments...` - Any number of arguments to automatically apply when the\\\\n+  continuation is called.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// using apply\\\\n+\\\\n+async.parallel([\\\\n+    async.apply(fs.writeFile, 'testfile1', 'test1'),\\\\n+    async.apply(fs.writeFile, 'testfile2', 'test2'),\\\\n+]);\\\\n+\\\\n+\\\\n+// the same process without using apply\\\\n+\\\\n+async.parallel([\\\\n+    function(callback){\\\\n+        fs.writeFile('testfile1', 'test1', callback);\\\\n+    },\\\\n+    function(callback){\\\\n+        fs.writeFile('testfile2', 'test2', callback);\\\\n+    }\\\\n+]);\\\\n+```\\\\n+\\\\n+It's possible to pass any number of additional arguments when calling the\\\\n+continuation:\\\\n+\\\\n+```js\\\\n+node> var fn = async.apply(sys.puts, 'one');\\\\n+node> fn('two', 'three');\\\\n+one\\\\n+two\\\\n+three\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"nextTick\\\\\\\" />\\\\n+### nextTick(callback)\\\\n+\\\\n+Calls `callback` on a later loop around the event loop. In Node.js this just\\\\n+calls `process.nextTick`; in the browser it falls back to `setImmediate(callback)`\\\\n+if available, otherwise `setTimeout(callback, 0)`, which means other higher priority\\\\n+events may precede the execution of `callback`.\\\\n+\\\\n+This is used internally for browser-compatibility purposes.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `callback` - The function to call on a later loop around the event loop.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var call_order = [];\\\\n+async.nextTick(function(){\\\\n+    call_order.push('two');\\\\n+    // call_order now equals ['one','two']\\\\n+});\\\\n+call_order.push('one')\\\\n+```\\\\n+\\\\n+<a name=\\\\\\\"times\\\\\\\" />\\\\n+### times(n, callback)\\\\n+\\\\n+Calls the `callback` function `n` times, and accumulates results in the same manner\\\\n+you would use with [`map`](#map).\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `n` - The number of times to run the function.\\\\n+* `callback` - The function to call `n` times.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// Pretend this is some complicated async factory\\\\n+var createUser = function(id, callback) {\\\\n+  callback(null, {\\\\n+    id: 'user' + id\\\\n+  })\\\\n+}\\\\n+// generate 5 users\\\\n+async.times(5, function(n, next){\\\\n+    createUser(n, function(err, user) {\\\\n+      next(err, user)\\\\n+    })\\\\n+}, function(err, users) {\\\\n+  // we should now have 5 users\\\\n+});\\\\n+```\\\\n+\\\\n+<a name=\\\\\\\"timesSeries\\\\\\\" />\\\\n+### timesSeries(n, callback)\\\\n+\\\\n+The same as [`times`](#times), only the iterator is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+The results array will be in the same order as the original.\\\\n+\\\\n+\\\\n+## Utils\\\\n+\\\\n+<a name=\\\\\\\"memoize\\\\\\\" />\\\\n+### memoize(fn, [hasher])\\\\n+\\\\n+Caches the results of an `async` function. When creating a hash to store function\\\\n+results against, the callback is omitted from the hash and an optional hash\\\\n+function can be used.\\\\n+\\\\n+The cache of results is exposed as the `memo` property of the function returned\\\\n+by `memoize`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `fn` - The function to proxy and cache results from.\\\\n+* `hasher` - Tn optional function for generating a custom hash for storing\\\\n+  results. It has all the arguments applied to it apart from the callback, and\\\\n+  must be synchronous.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var slow_fn = function (name, callback) {\\\\n+    // do something\\\\n+    callback(null, result);\\\\n+};\\\\n+var fn = async.memoize(slow_fn);\\\\n+\\\\n+// fn can now be used as if it were slow_fn\\\\n+fn('some name', function () {\\\\n+    // callback\\\\n+});\\\\n+```\\\\n+\\\\n+<a name=\\\\\\\"unmemoize\\\\\\\" />\\\\n+### unmemoize(fn)\\\\n+\\\\n+Undoes a [`memoize`](#memoize)d function, reverting it to the original, unmemoized\\\\n+form. Handy for testing.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `fn` - the memoized function\\\\n+\\\\n+<a name=\\\\\\\"log\\\\\\\" />\\\\n+### log(function, arguments)\\\\n+\\\\n+Logs the result of an `async` function to the `console`. Only works in Node.js or\\\\n+in browsers that support `console.log` and `console.error` (such as FF and Chrome).\\\\n+If multiple arguments are returned from the async function, `console.log` is\\\\n+called on each argument in order.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\n+* `arguments...` - Any number of arguments to apply to the function.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var hello = function(name, callback){\\\\n+    setTimeout(function(){\\\\n+        callback(null, 'hello ' + name);\\\\n+    }, 1000);\\\\n+};\\\\n+```\\\\n+```js\\\\n+node> async.log(hello, 'world');\\\\n+'hello world'\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"dir\\\\\\\" />\\\\n+### dir(function, arguments)\\\\n+\\\\n+Logs the result of an `async` function to the `console` using `console.dir` to\\\\n+display the properties of the resulting object. Only works in Node.js or\\\\n+in browsers that support `console.dir` and `console.error` (such as FF and Chrome).\\\\n+If multiple arguments are returned from the async function, `console.dir` is\\\\n+called on each argument in order.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\n+* `arguments...` - Any number of arguments to apply to the function.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var hello = function(name, callback){\\\\n+    setTimeout(function(){\\\\n+        callback(null, {hello: name});\\\\n+    }, 1000);\\\\n+};\\\\n+```\\\\n+```js\\\\n+node> async.dir(hello, 'world');\\\\n+{hello: 'world'}\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"noConflict\\\\\\\" />\\\\n+### noConflict()\\\\n+\\\\n+Changes the value of `async` back to its original value, returning a reference to the\\\\n+`async` object.\\\\ndiff --git a/node_modules/async/component.json b/node_modules/async/component.json\\\\nnew file mode 100644\\\\nindex 0000000..bbb0115\\\\n--- /dev/null\\\\n+++ b/node_modules/async/component.json\\\\n@@ -0,0 +1,11 @@\\\\n+{\\\\n+  \\\\\\\"name\\\\\\\": \\\\\\\"async\\\\\\\",\\\\n+  \\\\\\\"repo\\\\\\\": \\\\\\\"caolan/async\\\\\\\",\\\\n+  \\\\\\\"description\\\\\\\": \\\\\\\"Higher-order functions and common patterns for asynchronous code\\\\\\\",\\\\n+  \\\\\\\"version\\\\\\\": \\\\\\\"0.1.23\\\\\\\",\\\\n+  \\\\\\\"keywords\\\\\\\": [],\\\\n+  \\\\\\\"dependencies\\\\\\\": {},\\\\n+  \\\\\\\"development\\\\\\\": {},\\\\n+  \\\\\\\"main\\\\\\\": \\\\\\\"lib/async.js\\\\\\\",\\\\n+  \\\\\\\"scripts\\\\\\\": [ \\\\\\\"lib/async.js\\\\\\\" ]\\\\n+}\\\\ndiff --git a/node_modules/async/lib/async.js b/node_modules/async/lib/async.js\\\\nnew file mode 100644\\\\nindex 0000000..01e8afc\\\\n--- /dev/null\\\\n+++ b/node_modules/async/lib/async.js\\\\n@@ -0,0 +1,1123 @@\\\\n+/*!\\\\n+ * async\\\\n+ * https://github.com/caolan/async\\\\n+ *\\\\n+ * Copyright 2010-2014 Caolan McMahon\\\\n+ * Released under the MIT license\\\\n+ */\\\\n+/*jshint onevar: false, indent:4 */\\\\n+/*global setImmediate: false, setTimeout: false, console: false */\\\\n+(function () {\\\\n+\\\\n+    var async = {};\\\\n+\\\\n+    // global on the server, window in the browser\\\\n+    var root, previous_async;\\\\n+\\\\n+    root = this;\\\\n+    if (root != null) {\\\\n+      previous_async = root.async;\\\\n+    }\\\\n+\\\\n+    async.noConflict = function () {\\\\n+        root.async = previous_async;\\\\n+        return async;\\\\n+    };\\\\n+\\\\n+    function only_once(fn) {\\\\n+        var called = false;\\\\n+        return function() {\\\\n+            if (called) throw new Error(\\\\\\\"Callback was already called.\\\\\\\");\\\\n+            called = true;\\\\n+            fn.apply(root, arguments);\\\\n+        }\\\\n+    }\\\\n+\\\\n+    //// cross-browser compatiblity functions ////\\\\n+\\\\n+    var _toString = Object.prototype.toString;\\\\n+\\\\n+    var _isArray = Array.isArray || function (obj) {\\\\n+        return _toString.call(obj) === '[object Array]';\\\\n+    };\\\\n+\\\\n+    var _each = function (arr, iterator) {\\\\n+        if (arr.forEach) {\\\\n+            return arr.forEach(iterator);\\\\n+        }\\\\n+        for (var i = 0; i < arr.length; i += 1) {\\\\n+            iterator(arr[i], i, arr);\\\\n+        }\\\\n+    };\\\\n+\\\\n+    var _map = function (arr, iterator) {\\\\n+        if (arr.map) {\\\\n+            return arr.map(iterator);\\\\n+        }\\\\n+        var results = [];\\\\n+        _each(arr, function (x, i, a) {\\\\n+            results.push(iterator(x, i, a));\\\\n+        });\\\\n+        return results;\\\\n+    };\\\\n+\\\\n+    var _reduce = function (arr, iterator, memo) {\\\\n+        if (arr.reduce) {\\\\n+            return arr.reduce(iterator, memo);\\\\n+        }\\\\n+        _each(arr, function (x, i, a) {\\\\n+            memo = iterator(memo, x, i, a);\\\\n+        });\\\\n+        return memo;\\\\n+    };\\\\n+\\\\n+    var _keys = function (obj) {\\\\n+        if (Object.keys) {\\\\n+            return Object.keys(obj);\\\\n+        }\\\\n+        var keys = [];\\\\n+        for (var k in obj) {\\\\n+            if (obj.hasOwnProperty(k)) {\\\\n+                keys.push(k);\\\\n+            }\\\\n+        }\\\\n+        return keys;\\\\n+    };\\\\n+\\\\n+    //// exported async module functions ////\\\\n+\\\\n+    //// nextTick implementation with browser-compatible fallback ////\\\\n+    if (typeof process === 'undefined' || !(process.nextTick)) {\\\\n+        if (typeof setImmediate === 'function') {\\\\n+            async.nextTick = function (fn) {\\\\n+                // not a direct alias for IE10 compatibility\\\\n+                setImmediate(fn);\\\\n+            };\\\\n+            async.setImmediate = async.nextTick;\\\\n+        }\\\\n+        else {\\\\n+            async.nextTick = function (fn) {\\\\n+                setTimeout(fn, 0);\\\\n+            };\\\\n+            async.setImmediate = async.nextTick;\\\\n+        }\\\\n+    }\\\\n+    else {\\\\n+        async.nextTick = process.nextTick;\\\\n+        if (typeof setImmediate !== 'undefined') {\\\\n+            async.setImmediate = function (fn) {\\\\n+              // not a direct alias for IE10 compatibility\\\\n+              setImmediate(fn);\\\\n+            };\\\\n+        }\\\\n+        else {\\\\n+            async.setImmediate = async.nextTick;\\\\n+        }\\\\n+    }\\\\n+\\\\n+    async.each = function (arr, iterator, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (!arr.length) {\\\\n+            return callback();\\\\n+        }\\\\n+        var completed = 0;\\\\n+        _each(arr, function (x) {\\\\n+            iterator(x, only_once(done) );\\\\n+        });\\\\n+        function done(err) {\\\\n+          if (err) {\\\\n+              callback(err);\\\\n+              callback = function () {};\\\\n+          }\\\\n+          else {\\\\n+              completed += 1;\\\\n+              if (completed >= arr.length) {\\\\n+                  callback();\\\\n+              }\\\\n+          }\\\\n+        }\\\\n+    };\\\\n+    async.forEach = async.each;\\\\n+\\\\n+    async.eachSeries = function (arr, iterator, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (!arr.length) {\\\\n+            return callback();\\\\n+        }\\\\n+        var completed = 0;\\\\n+        var iterate = function () {\\\\n+            iterator(arr[completed], function (err) {\\\\n+                if (err) {\\\\n+                    callback(err);\\\\n+                    callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    completed += 1;\\\\n+                    if (completed >= arr.length) {\\\\n+                        callback();\\\\n+                    }\\\\n+                    else {\\\\n+                        iterate();\\\\n+                    }\\\\n+                }\\\\n+            });\\\\n+        };\\\\n+        iterate();\\\\n+    };\\\\n+    async.forEachSeries = async.eachSeries;\\\\n+\\\\n+    async.eachLimit = function (arr, limit, iterator, callback) {\\\\n+        var fn = _eachLimit(limit);\\\\n+        fn.apply(null, [arr, iterator, callback]);\\\\n+    };\\\\n+    async.forEachLimit = async.eachLimit;\\\\n+\\\\n+    var _eachLimit = function (limit) {\\\\n+\\\\n+        return function (arr, iterator, callback) {\\\\n+            callback = callback || function () {};\\\\n+            if (!arr.length || limit <= 0) {\\\\n+                return callback();\\\\n+            }\\\\n+            var completed = 0;\\\\n+            var started = 0;\\\\n+            var running = 0;\\\\n+\\\\n+            (function replenish () {\\\\n+                if (completed >= arr.length) {\\\\n+                    return callback();\\\\n+                }\\\\n+\\\\n+                while (running < limit && started < arr.length) {\\\\n+                    started += 1;\\\\n+                    running += 1;\\\\n+                    iterator(arr[started - 1], function (err) {\\\\n+                        if (err) {\\\\n+                            callback(err);\\\\n+                            callback = function () {};\\\\n+                        }\\\\n+                        else {\\\\n+                            completed += 1;\\\\n+                            running -= 1;\\\\n+                            if (completed >= arr.length) {\\\\n+                                callback();\\\\n+                            }\\\\n+                            else {\\\\n+                                replenish();\\\\n+                            }\\\\n+                        }\\\\n+                    });\\\\n+                }\\\\n+            })();\\\\n+        };\\\\n+    };\\\\n+\\\\n+\\\\n+    var doParallel = function (fn) {\\\\n+        return function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            return fn.apply(null, [async.each].concat(args));\\\\n+        };\\\\n+    };\\\\n+    var doParallelLimit = function(limit, fn) {\\\\n+        return function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            return fn.apply(null, [_eachLimit(limit)].concat(args));\\\\n+        };\\\\n+    };\\\\n+    var doSeries = function (fn) {\\\\n+        return function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            return fn.apply(null, [async.eachSeries].concat(args));\\\\n+        };\\\\n+    };\\\\n+\\\\n+\\\\n+    var _asyncMap = function (eachfn, arr, iterator, callback) {\\\\n+        arr = _map(arr, function (x, i) {\\\\n+            return {index: i, value: x};\\\\n+        });\\\\n+        if (!callback) {\\\\n+            eachfn(arr, function (x, callback) {\\\\n+                iterator(x.value, function (err) {\\\\n+                    callback(err);\\\\n+                });\\\\n+            });\\\\n+        } else {\\\\n+            var results = [];\\\\n+            eachfn(arr, function (x, callback) {\\\\n+                iterator(x.value, function (err, v) {\\\\n+                    results[x.index] = v;\\\\n+                    callback(err);\\\\n+                });\\\\n+            }, function (err) {\\\\n+                callback(err, results);\\\\n+            });\\\\n+        }\\\\n+    };\\\\n+    async.map = doParallel(_asyncMap);\\\\n+    async.mapSeries = doSeries(_asyncMap);\\\\n+    async.mapLimit = function (arr, limit, iterator, callback) {\\\\n+        return _mapLimit(limit)(arr, iterator, callback);\\\\n+    };\\\\n+\\\\n+    var _mapLimit = function(limit) {\\\\n+        return doParallelLimit(limit, _asyncMap);\\\\n+    };\\\\n+\\\\n+    // reduce only has a series version, as doing reduce in parallel won't\\\\n+    // work in many situations.\\\\n+    async.reduce = function (arr, memo, iterator, callback) {\\\\n+        async.eachSeries(arr, function (x, callback) {\\\\n+            iterator(memo, x, function (err, v) {\\\\n+                memo = v;\\\\n+                callback(err);\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(err, memo);\\\\n+        });\\\\n+    };\\\\n+    // inject alias\\\\n+    async.inject = async.reduce;\\\\n+    // foldl alias\\\\n+    async.foldl = async.reduce;\\\\n+\\\\n+    async.reduceRight = function (arr, memo, iterator, callback) {\\\\n+        var reversed = _map(arr, function (x) {\\\\n+            return x;\\\\n+        }).reverse();\\\\n+        async.reduce(reversed, memo, iterator, callback);\\\\n+    };\\\\n+    // foldr alias\\\\n+    async.foldr = async.reduceRight;\\\\n+\\\\n+    var _filter = function (eachfn, arr, iterator, callback) {\\\\n+        var results = [];\\\\n+        arr = _map(arr, function (x, i) {\\\\n+            return {index: i, value: x};\\\\n+        });\\\\n+        eachfn(arr, function (x, callback) {\\\\n+            iterator(x.value, function (v) {\\\\n+                if (v) {\\\\n+                    results.push(x);\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(_map(results.sort(function (a, b) {\\\\n+                return a.index - b.index;\\\\n+            }), function (x) {\\\\n+                return x.value;\\\\n+            }));\\\\n+        });\\\\n+    };\\\\n+    async.filter = doParallel(_filter);\\\\n+    async.filterSeries = doSeries(_filter);\\\\n+    // select alias\\\\n+    async.select = async.filter;\\\\n+    async.selectSeries = async.filterSeries;\\\\n+\\\\n+    var _reject = function (eachfn, arr, iterator, callback) {\\\\n+        var results = [];\\\\n+        arr = _map(arr, function (x, i) {\\\\n+            return {index: i, value: x};\\\\n+        });\\\\n+        eachfn(arr, function (x, callback) {\\\\n+            iterator(x.value, function (v) {\\\\n+                if (!v) {\\\\n+                    results.push(x);\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(_map(results.sort(function (a, b) {\\\\n+                return a.index - b.index;\\\\n+            }), function (x) {\\\\n+                return x.value;\\\\n+            }));\\\\n+        });\\\\n+    };\\\\n+    async.reject = doParallel(_reject);\\\\n+    async.rejectSeries = doSeries(_reject);\\\\n+\\\\n+    var _detect = function (eachfn, arr, iterator, main_callback) {\\\\n+        eachfn(arr, function (x, callback) {\\\\n+            iterator(x, function (result) {\\\\n+                if (result) {\\\\n+                    main_callback(x);\\\\n+                    main_callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    callback();\\\\n+                }\\\\n+            });\\\\n+        }, function (err) {\\\\n+            main_callback();\\\\n+        });\\\\n+    };\\\\n+    async.detect = doParallel(_detect);\\\\n+    async.detectSeries = doSeries(_detect);\\\\n+\\\\n+    async.some = function (arr, iterator, main_callback) {\\\\n+        async.each(arr, function (x, callback) {\\\\n+            iterator(x, function (v) {\\\\n+                if (v) {\\\\n+                    main_callback(true);\\\\n+                    main_callback = function () {};\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            main_callback(false);\\\\n+        });\\\\n+    };\\\\n+    // any alias\\\\n+    async.any = async.some;\\\\n+\\\\n+    async.every = function (arr, iterator, main_callback) {\\\\n+        async.each(arr, function (x, callback) {\\\\n+            iterator(x, function (v) {\\\\n+                if (!v) {\\\\n+                    main_callback(false);\\\\n+                    main_callback = function () {};\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            main_callback(true);\\\\n+        });\\\\n+    };\\\\n+    // all alias\\\\n+    async.all = async.every;\\\\n+\\\\n+    async.sortBy = function (arr, iterator, callback) {\\\\n+        async.map(arr, function (x, callback) {\\\\n+            iterator(x, function (err, criteria) {\\\\n+                if (err) {\\\\n+                    callback(err);\\\\n+                }\\\\n+                else {\\\\n+                    callback(null, {value: x, criteria: criteria});\\\\n+                }\\\\n+            });\\\\n+        }, function (err, results) {\\\\n+            if (err) {\\\\n+                return callback(err);\\\\n+            }\\\\n+            else {\\\\n+                var fn = function (left, right) {\\\\n+                    var a = left.criteria, b = right.criteria;\\\\n+                    return a < b ? -1 : a > b ? 1 : 0;\\\\n+                };\\\\n+                callback(null, _map(results.sort(fn), function (x) {\\\\n+                    return x.value;\\\\n+                }));\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.auto = function (tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        var keys = _keys(tasks);\\\\n+        var remainingTasks = keys.length\\\\n+        if (!remainingTasks) {\\\\n+            return callback();\\\\n+        }\\\\n+\\\\n+        var results = {};\\\\n+\\\\n+        var listeners = [];\\\\n+        var addListener = function (fn) {\\\\n+            listeners.unshift(fn);\\\\n+        };\\\\n+        var removeListener = function (fn) {\\\\n+            for (var i = 0; i < listeners.length; i += 1) {\\\\n+                if (listeners[i] === fn) {\\\\n+                    listeners.splice(i, 1);\\\\n+                    return;\\\\n+                }\\\\n+            }\\\\n+        };\\\\n+        var taskComplete = function () {\\\\n+            remainingTasks--\\\\n+            _each(listeners.slice(0), function (fn) {\\\\n+                fn();\\\\n+            });\\\\n+        };\\\\n+\\\\n+        addListener(function () {\\\\n+            if (!remainingTasks) {\\\\n+                var theCallback = callback;\\\\n+                // prevent final callback from calling itself if it errors\\\\n+                callback = function () {};\\\\n+\\\\n+                theCallback(null, results);\\\\n+            }\\\\n+        });\\\\n+\\\\n+        _each(keys, function (k) {\\\\n+            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\\\\n+            var taskCallback = function (err) {\\\\n+                var args = Array.prototype.slice.call(arguments, 1);\\\\n+                if (args.length <= 1) {\\\\n+                    args = args[0];\\\\n+                }\\\\n+                if (err) {\\\\n+                    var safeResults = {};\\\\n+                    _each(_keys(results), function(rkey) {\\\\n+                        safeResults[rkey] = results[rkey];\\\\n+                    });\\\\n+                    safeResults[k] = args;\\\\n+                    callback(err, safeResults);\\\\n+                    // stop subsequent errors hitting callback multiple times\\\\n+                    callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    results[k] = args;\\\\n+                    async.setImmediate(taskComplete);\\\\n+                }\\\\n+            };\\\\n+            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\\\\n+            var ready = function () {\\\\n+                return _reduce(requires, function (a, x) {\\\\n+                    return (a && results.hasOwnProperty(x));\\\\n+                }, true) && !results.hasOwnProperty(k);\\\\n+            };\\\\n+            if (ready()) {\\\\n+                task[task.length - 1](taskCallback, results);\\\\n+            }\\\\n+            else {\\\\n+                var listener = function () {\\\\n+                    if (ready()) {\\\\n+                        removeListener(listener);\\\\n+                        task[task.length - 1](taskCallback, results);\\\\n+                    }\\\\n+                };\\\\n+                addListener(listener);\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.retry = function(times, task, callback) {\\\\n+        var DEFAULT_TIMES = 5;\\\\n+        var attempts = [];\\\\n+        // Use defaults if times not passed\\\\n+        if (typeof times === 'function') {\\\\n+            callback = task;\\\\n+            task = times;\\\\n+            times = DEFAULT_TIMES;\\\\n+        }\\\\n+        // Make sure times is a number\\\\n+        times = parseInt(times, 10) || DEFAULT_TIMES;\\\\n+        var wrappedTask = function(wrappedCallback, wrappedResults) {\\\\n+            var retryAttempt = function(task, finalAttempt) {\\\\n+                return function(seriesCallback) {\\\\n+                    task(function(err, result){\\\\n+                        seriesCallback(!err || finalAttempt, {err: err, result: result});\\\\n+                    }, wrappedResults);\\\\n+                };\\\\n+            };\\\\n+            while (times) {\\\\n+                attempts.push(retryAttempt(task, !(times-=1)));\\\\n+            }\\\\n+            async.series(attempts, function(done, data){\\\\n+                data = data[data.length - 1];\\\\n+                (wrappedCallback || callback)(data.err, data.result);\\\\n+            });\\\\n+        }\\\\n+        // If a callback is passed, run this as a controll flow\\\\n+        return callback ? wrappedTask() : wrappedTask\\\\n+    };\\\\n+\\\\n+    async.waterfall = function (tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (!_isArray(tasks)) {\\\\n+          var err = new Error('First argument to waterfall must be an array of functions');\\\\n+          return callback(err);\\\\n+        }\\\\n+        if (!tasks.length) {\\\\n+            return callback();\\\\n+        }\\\\n+        var wrapIterator = function (iterator) {\\\\n+            return function (err) {\\\\n+                if (err) {\\\\n+                    callback.apply(null, arguments);\\\\n+                    callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\n+                    var next = iterator.next();\\\\n+                    if (next) {\\\\n+                        args.push(wrapIterator(next));\\\\n+                    }\\\\n+                    else {\\\\n+                        args.push(callback);\\\\n+                    }\\\\n+                    async.setImmediate(function () {\\\\n+                        iterator.apply(null, args);\\\\n+                    });\\\\n+                }\\\\n+            };\\\\n+        };\\\\n+        wrapIterator(async.iterator(tasks))();\\\\n+    };\\\\n+\\\\n+    var _parallel = function(eachfn, tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (_isArray(tasks)) {\\\\n+            eachfn.map(tasks, function (fn, callback) {\\\\n+                if (fn) {\\\\n+                    fn(function (err) {\\\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\\\n+                        if (args.length <= 1) {\\\\n+                            args = args[0];\\\\n+                        }\\\\n+                        callback.call(null, err, args);\\\\n+                    });\\\\n+                }\\\\n+            }, callback);\\\\n+        }\\\\n+        else {\\\\n+            var results = {};\\\\n+            eachfn.each(_keys(tasks), function (k, callback) {\\\\n+                tasks[k](function (err) {\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\n+                    if (args.length <= 1) {\\\\n+                        args = args[0];\\\\n+                    }\\\\n+                    results[k] = args;\\\\n+                    callback(err);\\\\n+                });\\\\n+            }, function (err) {\\\\n+                callback(err, results);\\\\n+            });\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.parallel = function (tasks, callback) {\\\\n+        _parallel({ map: async.map, each: async.each }, tasks, callback);\\\\n+    };\\\\n+\\\\n+    async.parallelLimit = function(tasks, limit, callback) {\\\\n+        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\\\\n+    };\\\\n+\\\\n+    async.series = function (tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (_isArray(tasks)) {\\\\n+            async.mapSeries(tasks, function (fn, callback) {\\\\n+                if (fn) {\\\\n+                    fn(function (err) {\\\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\\\n+                        if (args.length <= 1) {\\\\n+                            args = args[0];\\\\n+                        }\\\\n+                        callback.call(null, err, args);\\\\n+                    });\\\\n+                }\\\\n+            }, callback);\\\\n+        }\\\\n+        else {\\\\n+            var results = {};\\\\n+            async.eachSeries(_keys(tasks), function (k, callback) {\\\\n+                tasks[k](function (err) {\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\n+                    if (args.length <= 1) {\\\\n+                        args = args[0];\\\\n+                    }\\\\n+                    results[k] = args;\\\\n+                    callback(err);\\\\n+                });\\\\n+            }, function (err) {\\\\n+                callback(err, results);\\\\n+            });\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.iterator = function (tasks) {\\\\n+        var makeCallback = function (index) {\\\\n+            var fn = function () {\\\\n+                if (tasks.length) {\\\\n+                    tasks[index].apply(null, arguments);\\\\n+                }\\\\n+                return fn.next();\\\\n+            };\\\\n+            fn.next = function () {\\\\n+                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\\\\n+            };\\\\n+            return fn;\\\\n+        };\\\\n+        return makeCallback(0);\\\\n+    };\\\\n+\\\\n+    async.apply = function (fn) {\\\\n+        var args = Array.prototype.slice.call(arguments, 1);\\\\n+        return function () {\\\\n+            return fn.apply(\\\\n+                null, args.concat(Array.prototype.slice.call(arguments))\\\\n+            );\\\\n+        };\\\\n+    };\\\\n+\\\\n+    var _concat = function (eachfn, arr, fn, callback) {\\\\n+        var r = [];\\\\n+        eachfn(arr, function (x, cb) {\\\\n+            fn(x, function (err, y) {\\\\n+                r = r.concat(y || []);\\\\n+                cb(err);\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(err, r);\\\\n+        });\\\\n+    };\\\\n+    async.concat = doParallel(_concat);\\\\n+    async.concatSeries = doSeries(_concat);\\\\n+\\\\n+    async.whilst = function (test, iterator, callback) {\\\\n+        if (test()) {\\\\n+            iterator(function (err) {\\\\n+                if (err) {\\\\n+                    return callback(err);\\\\n+                }\\\\n+                async.whilst(test, iterator, callback);\\\\n+            });\\\\n+        }\\\\n+        else {\\\\n+            callback();\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.doWhilst = function (iterator, test, callback) {\\\\n+        iterator(function (err) {\\\\n+            if (err) {\\\\n+                return callback(err);\\\\n+            }\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\n+            if (test.apply(null, args)) {\\\\n+                async.doWhilst(iterator, test, callback);\\\\n+            }\\\\n+            else {\\\\n+                callback();\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.until = function (test, iterator, callback) {\\\\n+        if (!test()) {\\\\n+            iterator(function (err) {\\\\n+                if (err) {\\\\n+                    return callback(err);\\\\n+                }\\\\n+                async.until(test, iterator, callback);\\\\n+            });\\\\n+        }\\\\n+        else {\\\\n+            callback();\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.doUntil = function (iterator, test, callback) {\\\\n+        iterator(function (err) {\\\\n+            if (err) {\\\\n+                return callback(err);\\\\n+            }\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\n+            if (!test.apply(null, args)) {\\\\n+                async.doUntil(iterator, test, callback);\\\\n+            }\\\\n+            else {\\\\n+                callback();\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.queue = function (worker, concurrency) {\\\\n+        if (concurrency === undefined) {\\\\n+            concurrency = 1;\\\\n+        }\\\\n+        function _insert(q, data, pos, callback) {\\\\n+          if (!q.started){\\\\n+            q.started = true;\\\\n+          }\\\\n+          if (!_isArray(data)) {\\\\n+              data = [data];\\\\n+          }\\\\n+          if(data.length == 0) {\\\\n+             // call drain immediately if there are no tasks\\\\n+             return async.setImmediate(function() {\\\\n+                 if (q.drain) {\\\\n+                     q.drain();\\\\n+                 }\\\\n+             });\\\\n+          }\\\\n+          _each(data, function(task) {\\\\n+              var item = {\\\\n+                  data: task,\\\\n+                  callback: typeof callback === 'function' ? callback : null\\\\n+              };\\\\n+\\\\n+              if (pos) {\\\\n+                q.tasks.unshift(item);\\\\n+              } else {\\\\n+                q.tasks.push(item);\\\\n+              }\\\\n+\\\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\\\n+                  q.saturated();\\\\n+              }\\\\n+              async.setImmediate(q.process);\\\\n+          });\\\\n+        }\\\\n+\\\\n+        var workers = 0;\\\\n+        var q = {\\\\n+            tasks: [],\\\\n+            concurrency: concurrency,\\\\n+            saturated: null,\\\\n+            empty: null,\\\\n+            drain: null,\\\\n+            started: false,\\\\n+            paused: false,\\\\n+            push: function (data, callback) {\\\\n+              _insert(q, data, false, callback);\\\\n+            },\\\\n+            kill: function () {\\\\n+              q.drain = null;\\\\n+              q.tasks = [];\\\\n+            },\\\\n+            unshift: function (data, callback) {\\\\n+              _insert(q, data, true, callback);\\\\n+            },\\\\n+            process: function () {\\\\n+                if (!q.paused && workers < q.concurrency && q.tasks.length) {\\\\n+                    var task = q.tasks.shift();\\\\n+                    if (q.empty && q.tasks.length === 0) {\\\\n+                        q.empty();\\\\n+                    }\\\\n+                    workers += 1;\\\\n+                    var next = function () {\\\\n+                        workers -= 1;\\\\n+                        if (task.callback) {\\\\n+                            task.callback.apply(task, arguments);\\\\n+                        }\\\\n+                        if (q.drain && q.tasks.length + workers === 0) {\\\\n+                            q.drain();\\\\n+                        }\\\\n+                        q.process();\\\\n+                    };\\\\n+                    var cb = only_once(next);\\\\n+                    worker(task.data, cb);\\\\n+                }\\\\n+            },\\\\n+            length: function () {\\\\n+                return q.tasks.length;\\\\n+            },\\\\n+            running: function () {\\\\n+                return workers;\\\\n+            },\\\\n+            idle: function() {\\\\n+                return q.tasks.length + workers === 0;\\\\n+            },\\\\n+            pause: function () {\\\\n+                if (q.paused === true) { return; }\\\\n+                q.paused = true;\\\\n+                q.process();\\\\n+            },\\\\n+            resume: function () {\\\\n+                if (q.paused === false) { return; }\\\\n+                q.paused = false;\\\\n+                q.process();\\\\n+            }\\\\n+        };\\\\n+        return q;\\\\n+    };\\\\n+    \\\\n+    async.priorityQueue = function (worker, concurrency) {\\\\n+        \\\\n+        function _compareTasks(a, b){\\\\n+          return a.priority - b.priority;\\\\n+        };\\\\n+        \\\\n+        function _binarySearch(sequence, item, compare) {\\\\n+          var beg = -1,\\\\n+              end = sequence.length - 1;\\\\n+          while (beg < end) {\\\\n+            var mid = beg + ((end - beg + 1) >>> 1);\\\\n+            if (compare(item, sequence[mid]) >= 0) {\\\\n+              beg = mid;\\\\n+            } else {\\\\n+              end = mid - 1;\\\\n+            }\\\\n+          }\\\\n+          return beg;\\\\n+        }\\\\n+        \\\\n+        function _insert(q, data, priority, callback) {\\\\n+          if (!q.started){\\\\n+            q.started = true;\\\\n+          }\\\\n+          if (!_isArray(data)) {\\\\n+              data = [data];\\\\n+          }\\\\n+          if(data.length == 0) {\\\\n+             // call drain immediately if there are no tasks\\\\n+             return async.setImmediate(function() {\\\\n+                 if (q.drain) {\\\\n+                     q.drain();\\\\n+                 }\\\\n+             });\\\\n+          }\\\\n+          _each(data, function(task) {\\\\n+              var item = {\\\\n+                  data: task,\\\\n+                  priority: priority,\\\\n+                  callback: typeof callback === 'function' ? callback : null\\\\n+              };\\\\n+              \\\\n+              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\\\\n+\\\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\\\n+                  q.saturated();\\\\n+              }\\\\n+              async.setImmediate(q.process);\\\\n+          });\\\\n+        }\\\\n+        \\\\n+        // Start with a normal queue\\\\n+        var q = async.queue(worker, concurrency);\\\\n+        \\\\n+        // Override push to accept second parameter representing priority\\\\n+        q.push = function (data, priority, callback) {\\\\n+          _insert(q, data, priority, callback);\\\\n+        };\\\\n+        \\\\n+        // Remove unshift function\\\\n+        delete q.unshift;\\\\n+\\\\n+        return q;\\\\n+    };\\\\n+\\\\n+    async.cargo = function (worker, payload) {\\\\n+        var working     = false,\\\\n+            tasks       = [];\\\\n+\\\\n+        var cargo = {\\\\n+            tasks: tasks,\\\\n+            payload: payload,\\\\n+            saturated: null,\\\\n+            empty: null,\\\\n+            drain: null,\\\\n+            drained: true,\\\\n+            push: function (data, callback) {\\\\n+                if (!_isArray(data)) {\\\\n+                    data = [data];\\\\n+                }\\\\n+                _each(data, function(task) {\\\\n+                    tasks.push({\\\\n+                        data: task,\\\\n+                        callback: typeof callback === 'function' ? callback : null\\\\n+                    });\\\\n+                    cargo.drained = false;\\\\n+                    if (cargo.saturated && tasks.length === payload) {\\\\n+                        cargo.saturated();\\\\n+                    }\\\\n+                });\\\\n+                async.setImmediate(cargo.process);\\\\n+            },\\\\n+            process: function process() {\\\\n+                if (working) return;\\\\n+                if (tasks.length === 0) {\\\\n+                    if(cargo.drain && !cargo.drained) cargo.drain();\\\\n+                    cargo.drained = true;\\\\n+                    return;\\\\n+                }\\\\n+\\\\n+                var ts = typeof payload === 'number'\\\\n+                            ? tasks.splice(0, payload)\\\\n+                            : tasks.splice(0, tasks.length);\\\\n+\\\\n+                var ds = _map(ts, function (task) {\\\\n+                    return task.data;\\\\n+                });\\\\n+\\\\n+                if(cargo.empty) cargo.empty();\\\\n+                working = true;\\\\n+                worker(ds, function () {\\\\n+                    working = false;\\\\n+\\\\n+                    var args = arguments;\\\\n+                    _each(ts, function (data) {\\\\n+                        if (data.callback) {\\\\n+                            data.callback.apply(null, args);\\\\n+                        }\\\\n+                    });\\\\n+\\\\n+                    process();\\\\n+                });\\\\n+            },\\\\n+            length: function () {\\\\n+                return tasks.length;\\\\n+            },\\\\n+            running: function () {\\\\n+                return working;\\\\n+            }\\\\n+        };\\\\n+        return cargo;\\\\n+    };\\\\n+\\\\n+    var _console_fn = function (name) {\\\\n+        return function (fn) {\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\n+            fn.apply(null, args.concat([function (err) {\\\\n+                var args = Array.prototype.slice.call(arguments, 1);\\\\n+                if (typeof console !== 'undefined') {\\\\n+                    if (err) {\\\\n+                        if (console.error) {\\\\n+                            console.error(err);\\\\n+                        }\\\\n+                    }\\\\n+                    else if (console[name]) {\\\\n+                        _each(args, function (x) {\\\\n+                            console[name](x);\\\\n+                        });\\\\n+                    }\\\\n+                }\\\\n+            }]));\\\\n+        };\\\\n+    };\\\\n+    async.log = _console_fn('log');\\\\n+    async.dir = _console_fn('dir');\\\\n+    /*async.info = _console_fn('info');\\\\n+    async.warn = _console_fn('warn');\\\\n+    async.error = _console_fn('error');*/\\\\n+\\\\n+    async.memoize = function (fn, hasher) {\\\\n+        var memo = {};\\\\n+        var queues = {};\\\\n+        hasher = hasher || function (x) {\\\\n+            return x;\\\\n+        };\\\\n+        var memoized = function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            var callback = args.pop();\\\\n+            var key = hasher.apply(null, args);\\\\n+            if (key in memo) {\\\\n+                async.nextTick(function () {\\\\n+                    callback.apply(null, memo[key]);\\\\n+                });\\\\n+            }\\\\n+            else if (key in queues) {\\\\n+                queues[key].push(callback);\\\\n+            }\\\\n+            else {\\\\n+                queues[key] = [callback];\\\\n+                fn.apply(null, args.concat([function () {\\\\n+                    memo[key] = arguments;\\\\n+                    var q = queues[key];\\\\n+                    delete queues[key];\\\\n+                    for (var i = 0, l = q.length; i < l; i++) {\\\\n+                      q[i].apply(null, arguments);\\\\n+                    }\\\\n+                }]));\\\\n+            }\\\\n+        };\\\\n+        memoized.memo = memo;\\\\n+        memoized.unmemoized = fn;\\\\n+        return memoized;\\\\n+    };\\\\n+\\\\n+    async.unmemoize = function (fn) {\\\\n+      return function () {\\\\n+        return (fn.unmemoized || fn).apply(null, arguments);\\\\n+      };\\\\n+    };\\\\n+\\\\n+    async.times = function (count, iterator, callback) {\\\\n+        var counter = [];\\\\n+        for (var i = 0; i < count; i++) {\\\\n+            counter.push(i);\\\\n+        }\\\\n+        return async.map(counter, iterator, callback);\\\\n+    };\\\\n+\\\\n+    async.timesSeries = function (count, iterator, callback) {\\\\n+        var counter = [];\\\\n+        for (var i = 0; i < count; i++) {\\\\n+            counter.push(i);\\\\n+        }\\\\n+        return async.mapSeries(counter, iterator, callback);\\\\n+    };\\\\n+\\\\n+    async.seq = function (/* functions... */) {\\\\n+        var fns = arguments;\\\\n+        return function () {\\\\n+            var that = this;\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            var callback = args.pop();\\\\n+            async.reduce(fns, args, function (newargs, fn, cb) {\\\\n+                fn.apply(that, newargs.concat([function () {\\\\n+                    var err = arguments[0];\\\\n+                    var nextargs = Array.prototype.slice.call(arguments, 1);\\\\n+                    cb(err, nextargs);\\\\n+                }]))\\\\n+            },\\\\n+            function (err, results) {\\\\n+                callback.apply(that, [err].concat(results));\\\\n+            });\\\\n+        };\\\\n+    };\\\\n+\\\\n+    async.compose = function (/* functions... */) {\\\\n+      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\\\\n+    };\\\\n+\\\\n+    var _applyEach = function (eachfn, fns /*args...*/) {\\\\n+        var go = function () {\\\\n+            var that = this;\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            var callback = args.pop();\\\\n+            return eachfn(fns, function (fn, cb) {\\\\n+                fn.apply(that, args.concat([cb]));\\\\n+            },\\\\n+            callback);\\\\n+        };\\\\n+        if (arguments.length > 2) {\\\\n+            var args = Array.prototype.slice.call(arguments, 2);\\\\n+            return go.apply(this, args);\\\\n+        }\\\\n+        else {\\\\n+            return go;\\\\n+        }\\\\n+    };\\\\n+    async.applyEach = doParallel(_applyEach);\\\\n+    async.applyEachSeries = doSeries(_applyEach);\\\\n+\\\\n+    async.forever = function (fn, callback) {\\\\n+        function next(err) {\\\\n+            if (err) {\\\\n+                if (callback) {\\\\n+                    return callback(err);\\\\n+                }\\\\n+                throw err;\\\\n+            }\\\\n+            fn(next);\\\\n+        }\\\\n+        next();\\\\n+    };\\\\n+\\\\n+    // Node.js\\\\n+    if (typeof module !== 'undefined' && module.exports) {\\\\n+        module.exports = async;\\\\n+    }\\\\n+    // AMD / RequireJS\\\\n+    else if (typeof define !== 'undefined' && define.amd) {\\\\n+        define([], function () {\\\\n+            return async;\\\\n+        });\\\\n+    }\\\\n+    // included directly via <script> tag\\\\n+    else {\\\\n+        root.async = async;\\\\n+    }\\\\n+\\\\n+}());\\\\ndiff --git a/node_modules/async/package.json b/node_modules/async/package.json\\\\nnew file mode 100644\\\\nindex 0000000..31a5200\\\\n--- /dev/null\\\\n+++ b/node_modules/async/package.json\\\\n@@ -0,0 +1,59 @@\\\\n+{\\\\n+  \\\\\\\"name\\\\\\\": \\\\\\\"async\\\\\\\",\\\\n+  \\\\\\\"description\\\\\\\": \\\\\\\"Higher-order functions and common patterns for asynchronous code\\\\\\\",\\\\n+  \\\\\\\"main\\\\\\\": \\\\\\\"./lib/async\\\\\\\",\\\\n+  \\\\\\\"author\\\\\\\": {\\\\n+    \\\\\\\"name\\\\\\\": \\\\\\\"Caolan McMahon\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"version\\\\\\\": \\\\\\\"0.9.0\\\\\\\",\\\\n+  \\\\\\\"repository\\\\\\\": {\\\\n+    \\\\\\\"type\\\\\\\": \\\\\\\"git\\\\\\\",\\\\n+    \\\\\\\"url\\\\\\\": \\\\\\\"https://github.com/caolan/async.git\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"bugs\\\\\\\": {\\\\n+    \\\\\\\"url\\\\\\\": \\\\\\\"https://github.com/caolan/async/issues\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"licenses\\\\\\\": [\\\\n+    {\\\\n+      \\\\\\\"type\\\\\\\": \\\\\\\"MIT\\\\\\\",\\\\n+      \\\\\\\"url\\\\\\\": \\\\\\\"https://github.com/caolan/async/raw/master/LICENSE\\\\\\\"\\\\n+    }\\\\n+  ],\\\\n+  \\\\\\\"devDependencies\\\\\\\": {\\\\n+    \\\\\\\"nodeunit\\\\\\\": \\\\\\\">0.0.0\\\\\\\",\\\\n+    \\\\\\\"uglify-js\\\\\\\": \\\\\\\"1.2.x\\\\\\\",\\\\n+    \\\\\\\"nodelint\\\\\\\": \\\\\\\">0.0.0\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"jam\\\\\\\": {\\\\n+    \\\\\\\"main\\\\\\\": \\\\\\\"lib/async.js\\\\\\\",\\\\n+    \\\\\\\"include\\\\\\\": [\\\\n+      \\\\\\\"lib/async.js\\\\\\\",\\\\n+      \\\\\\\"README.md\\\\\\\",\\\\n+      \\\\\\\"LICENSE\\\\\\\"\\\\n+    ]\\\\n+  },\\\\n+  \\\\\\\"scripts\\\\\\\": {\\\\n+    \\\\\\\"test\\\\\\\": \\\\\\\"nodeunit test/test-async.js\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"homepage\\\\\\\": \\\\\\\"https://github.com/caolan/async\\\\\\\",\\\\n+  \\\\\\\"_id\\\\\\\": \\\\\\\"async@0.9.0\\\\\\\",\\\\n+  \\\\\\\"dist\\\\\\\": {\\\\n+    \\\\\\\"shasum\\\\\\\": \\\\\\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\\\\\",\\\\n+    \\\\\\\"tarball\\\\\\\": \\\\\\\"http://registry.npmjs.org/async/-/async-0.9.0.tgz\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"_from\\\\\\\": \\\\\\\"async@*\\\\\\\",\\\\n+  \\\\\\\"_npmVersion\\\\\\\": \\\\\\\"1.4.3\\\\\\\",\\\\n+  \\\\\\\"_npmUser\\\\\\\": {\\\\n+    \\\\\\\"name\\\\\\\": \\\\\\\"caolan\\\\\\\",\\\\n+    \\\\\\\"email\\\\\\\": \\\\\\\"caolan.mcmahon@gmail.com\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"maintainers\\\\\\\": [\\\\n+    {\\\\n+      \\\\\\\"name\\\\\\\": \\\\\\\"caolan\\\\\\\",\\\\n+      \\\\\\\"email\\\\\\\": \\\\\\\"caolan@caolanmcmahon.com\\\\\\\"\\\\n+    }\\\\n+  ],\\\\n+  \\\\\\\"directories\\\\\\\": {},\\\\n+  \\\\\\\"_shasum\\\\\\\": \\\\\\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\\\\\",\\\\n+  \\\\\\\"_resolved\\\\\\\": \\\\\\\"https://registry.npmjs.org/async/-/async-0.9.0.tgz\\\\\\\"\\\\n+}\\\\ndiff --git a/package.json b/package.json\\\\nindex 5f21627..6033d43 100644\\\\n--- a/package.json\\\\n+++ b/package.json\\\\n@@ -4,7 +4,8 @@\\\\n   \\\\\\\"description\\\\\\\": \\\\\\\"Sous project\\\\\\\",\\\\n   \\\\\\\"main\\\\\\\": \\\\\\\"main.js\\\\\\\",\\\\n   \\\\\\\"dependencies\\\\\\\": {\\\\n-},\\\\n+    \\\\\\\"async\\\\\\\": \\\\\\\"*\\\\\\\"\\\\n+  },\\\\n   \\\\\\\"devDependencies\\\\\\\": {},\\\\n   \\\\\\\"scripts\\\\\\\": {\\\\n     \\\\\\\"test\\\\\\\": \\\\\\\"echo \\\\\\\\\\\\\\\"Error: no test specified\\\\\\\\\\\\\\\" && exit 1\\\\\\\"\\\\ndiff --git a/patches.sousp b/patches.sousp\\\\nindex 16405a3..d71e511 100644\\\\n--- a/patches.sousp\\\\n+++ b/patches.sousp\\\\n@@ -1,31 +1 @@\\\\n-diff --git a/main.js b/main.js\\\\n-index f81b54e..744cdd5 100644\\\\n---- a/main.js\\\\n-+++ b/main.js\\\\n-@@ -35,7 +35,7 @@ fs.exists('.git', function (exists) {\\\\n-         cp.exec('git diff', function(error, stdout, stderr) {\\\\n-             console.log(stdout);\\\\n- \\\\n--            //fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", stdout);\\\\n-+            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", stdout);\\\\n- \\\\n-             if (error !== null) {\\\\n-                 console.log('stderr: ' + stderr);\\\\n-@@ -44,7 +44,7 @@ fs.exists('.git', function (exists) {\\\\n-         });\\\\n- \\\\n-         cp.exec('git log', function(error, stdout, stderr) {\\\\n--            //console.log(stdout);\\\\n-+            console.log(stdout);\\\\n- \\\\n-             var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n-             var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n-@@ -53,7 +53,7 @@ fs.exists('.git', function (exists) {\\\\n-             console.log(comments);\\\\n-             console.log(dates);\\\\n- \\\\n--            //fs.writeFileSync(\\\\\\\"comments.sousc\\\\\\\", stdout);\\\\n-+            fs.writeFileSync(\\\\\\\"comments.sousc\\\\\\\", stdout);\\\\n- \\\\n-             if (error !== null) {\\\\n-                 console.log('stderr: ' + stderr);\\\\n+[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]\\\\n\\\\\\\\ No newline at end of file\\\\ndiff --git a/test.js b/test.js\\\\nnew file mode 100644\\\\nindex 0000000..5ca759c\\\\n--- /dev/null\\\\n+++ b/test.js\\\\n@@ -0,0 +1,21 @@\\\\n+/**\\\\n+ * Created by Nick on 18.05.2015.\\\\n+ */\\\\n+var async = require('async')\\\\n+    , tasksIndex = [\\\\n+        function (callback) {\\\\n+            // Вымышленный метод который вернет 231\\\\n+            var viewsNumber = models.stat.viewsNumber();\\\\n+            callback(null, viewsNumber);\\\\n+        }\\\\n+        , function (callback) {\\\\n+            // Вымышленный метод который вернет 24\\\\n+            var growFactor = models.stat.growFactor();\\\\n+            callback(null, growFactor);\\\\n+        }\\\\n+    ];\\\\n+\\\\n+async.series(tasksIndex, function (err, results) {\\\\n+    // Результат будет массивом\\\\n+    console.log(results); // [231, 24]\\\\n+});\\\\n\\\\\\\\ No newline at end of file\\\\n\\\"}\\n\\\\ No newline at end of file\\ndiff --git a/patches.txt b/patches.txt\\nnew file mode 100644\\nindex 0000000..300c6a9\\n--- /dev/null\\n+++ b/patches.txt\\n@@ -0,0 +1 @@\\n+{\\\"commit\\\":\\\"1e947f613e976945de85ae35ed923aa470f0be72\\\",\\\"author\\\":\\\"Nick Stepanenko <massaalonso@yandex.ru>\\\",\\\"date\\\":\\\"Tue May 19 00:12:12 2015 +0800\\\",\\\"comment\\\":\\\"Latest updates\\\",\\\"content\\\":\\\"diff --git a/comments.sousc b/comments.sousc\\\\nindex 150b0f6..cb3a850 100644\\\\n--- a/comments.sousc\\\\n+++ b/comments.sousc\\\\n@@ -1,3 +1,27 @@\\\\n+commit 4420cabefc1f470af341af11ed595df67e25c51f\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 17:05:35 2015 +0800\\\\n+\\\\n+    Paste old program code\\\\n+\\\\n+commit 9ef3d25fd4c3afdbcc3107a0abf6d7a2e29cb4dd\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 17:04:52 2015 +0800\\\\n+\\\\n+    Adding new file\\\\n+\\\\n+commit 64814d140d2fab6ae153cac485008119f29bf230\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 17:03:58 2015 +0800\\\\n+\\\\n+    From clear list\\\\n+\\\\n+commit c9d318fea74ea288d544ecf72f00b12c130cf2ef\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 16:59:40 2015 +0800\\\\n+\\\\n+    Create system files\\\\n+\\\\n commit e3c853a4282dfe8f000685dc1d39bd55a4a946c4\\\\n Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n Date:   Sun May 17 16:54:58 2015 +0800\\\\ndiff --git a/main.js b/main.js\\\\nindex e34dc18..86f30c2 100644\\\\n--- a/main.js\\\\n+++ b/main.js\\\\n@@ -3,6 +3,56 @@\\\\n  */\\\\n \\\\n var fs = require('fs');\\\\n+var cp = require('child_process');\\\\n+var data = [];\\\\n+\\\\n+var async = require('async');\\\\n+    /*tasks = [\\\\n+        function (callback) {\\\\n+            cp.exec('git log', function(error, stdout, stderr) {\\\\n+                var listOfCommits = [];\\\\n+                var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n+                var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n+                var comments = findComments(stdout);\\\\n+                var commitNumbers = findCommitNumbers(stdout);\\\\n+\\\\n+                for(i=0; i<authors.length; i++) {\\\\n+                    var commit = {\\\\n+                        \\\\\\\"commit\\\\\\\": commitNumbers[i],\\\\n+                        \\\\\\\"author\\\\\\\": authors[i],\\\\n+                        \\\\\\\"date\\\\\\\": dates[i],\\\\n+                        \\\\\\\"comment\\\\\\\": comments[i],\\\\n+                        \\\\\\\"content\\\\\\\": 'Original'\\\\n+                    };\\\\n+\\\\n+                    listOfCommits[listOfCommits.length] = commit;\\\\n+                }\\\\n+\\\\n+                data = listOfCommits.reverse();\\\\n+\\\\n+                callback(null, data);\\\\n+\\\\n+                if (error !== null) {\\\\n+                    console.log('stderr: ' + stderr);\\\\n+                    console.log('exec error: ' + error);\\\\n+                }\\\\n+            });\\\\n+        }\\\\n+    ],\\\\n+    secondTasks = [\\\\n+        function some_function(callback) {\\\\n+            cp.exec('git diff', function(error, stdout, stderr) {\\\\n+                var currentContent = stdout;\\\\n+\\\\n+                if (error !== null) {\\\\n+                    console.log('stderr: ' + stderr);\\\\n+                    console.log('exec error: ' + error);\\\\n+                }\\\\n+\\\\n+                callback(null, currentContent);\\\\n+            });\\\\n+        }\\\\n+    ];*/\\\\n \\\\n function findData(text, keyword) {\\\\n     var data = [];\\\\n@@ -28,38 +78,106 @@ function findComments(text) {\\\\n     return comments;\\\\n }\\\\n \\\\n+function findCommitNumbers(text) {\\\\n+    var commits = [];\\\\n+    var splittext = text.split('\\\\\\\\n');\\\\n+\\\\n+    for(i=0; i<splittext.length; i++) {\\\\n+        if(splittext[i].slice(0, 6) == \\\\\\\"commit\\\\\\\") {\\\\n+            commits[commits.length] = splittext[i].slice(6).trim();\\\\n+        }\\\\n+    }\\\\n+\\\\n+    return commits;\\\\n+}\\\\n+\\\\n+/*function pullCommitContent(first, second) {\\\\n+\\\\n+    cp.exec('git diff' + ' ' + first + ' ' + second, function(error, stdout, stderr) {\\\\n+        var currentContent = stdout;\\\\n+\\\\n+        if (error !== null) {\\\\n+            console.log('stderr: ' + stderr);\\\\n+            console.log('exec error: ' + error);\\\\n+        }\\\\n+\\\\n+        return currentContent;\\\\n+    });\\\\n+}*/\\\\n+\\\\n+var commitsInfo = [];\\\\n+\\\\n fs.exists('.git', function (exists) {\\\\n     if(exists) {\\\\n-        var cp = require('child_process');\\\\n+        /*async.series(tasks, function(err, result) {\\\\n+            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", JSON.stringify(result));\\\\n+\\\\n+            var data = result[0];\\\\n \\\\n-        cp.exec('git diff', function(error, stdout, stderr) {\\\\n-            console.log(stdout);\\\\n+            /*function some_function(arg1, arg2, callback) {\\\\n+                cp.exec('git diff' + ' ' + arg1 + ' ' + arg2, function(error, stdout, stderr) {\\\\n+                    var currentContent = 54321;//stdout;\\\\n \\\\n-            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", stdout);\\\\n+                    if (error !== null) {\\\\n+                        console.log('stderr: ' + stderr);\\\\n+                        console.log('exec error: ' + error);\\\\n+                    }\\\\n \\\\n-            if (error !== null) {\\\\n-                console.log('stderr: ' + stderr);\\\\n-                console.log('exec error: ' + error);\\\\n+                    callback(null, currentContent);\\\\n+                });\\\\n             }\\\\n-        });\\\\n+        });*/\\\\n+\\\\n+        async.waterfall([\\\\n+            function getCommitsInfo(callback) {\\\\n+                cp.exec('git log', function(error, stdout, stderr) {\\\\n+                    var listOfCommits = [];\\\\n+                    var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n+                    var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n+                    var comments = findComments(stdout);\\\\n+                    var commitNumbers = findCommitNumbers(stdout);\\\\n \\\\n-        cp.exec('git log', function(error, stdout, stderr) {\\\\n-            console.log(stdout);\\\\n+                    for(i=0; i<authors.length; i++) {\\\\n+                        var commit = {\\\\n+                            \\\\\\\"commit\\\\\\\": commitNumbers[i],\\\\n+                            \\\\\\\"author\\\\\\\": authors[i],\\\\n+                            \\\\\\\"date\\\\\\\": dates[i],\\\\n+                            \\\\\\\"comment\\\\\\\": comments[i],\\\\n+                            \\\\\\\"content\\\\\\\": 'Original'\\\\n+                        };\\\\n+                        listOfCommits[listOfCommits.length] = commit;\\\\n+                    }\\\\n \\\\n-            var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n-            var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n-            var comments = findComments(stdout);\\\\n-            console.log(authors);\\\\n-            console.log(comments);\\\\n-            console.log(dates);\\\\n+                    callback(null, listOfCommits.reverse());\\\\n \\\\n-            fs.writeFileSync(\\\\\\\"comments.sousc\\\\\\\", stdout);\\\\n+                    if (error !== null) {\\\\n+                        console.log('stderr: ' + stderr);\\\\n+                        console.log('exec error: ' + error);\\\\n+                    }\\\\n+                });\\\\n+            },\\\\n+            function getCommitsContent(commits, callback) {\\\\n+                console.log(commits);\\\\n+                var commitsData = commits;\\\\n \\\\n-            if (error !== null) {\\\\n-                console.log('stderr: ' + stderr);\\\\n-                console.log('exec error: ' + error);\\\\n+                for(i=1; i<commitsData.length; i++) {\\\\n+                    cp.exec('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit, function(error, stdout, stderr) {\\\\n+                        commitsData[i].content = stdout;\\\\n+\\\\n+                        if (error !== null) {\\\\n+                            console.log('stderr: ' + stderr);\\\\n+                            console.log('exec error: ' + error);\\\\n+                        }\\\\n+                    });\\\\n+                }\\\\n+\\\\n+                callback(null, commitsData);\\\\n             }\\\\n+        ], function (err, result) {\\\\n+            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", result);\\\\n         });\\\\n+\\\\n+        //commitsInfo = JSON.parse(fs.readFileSync(\\\\\\\"patches.sousp\\\\\\\"));\\\\n+        //console.log(commitsInfo);\\\\n     }\\\\n-    else console.log(\\\\\\\"Error.\\\\\\\");\\\\n });\\\\n\\\\\\\\ No newline at end of file\\\\ndiff --git a/node_modules/async/.travis.yml b/node_modules/async/.travis.yml\\\\nnew file mode 100644\\\\nindex 0000000..6e5919d\\\\n--- /dev/null\\\\n+++ b/node_modules/async/.travis.yml\\\\n@@ -0,0 +1,3 @@\\\\n+language: node_js\\\\n+node_js:\\\\n+  - \\\\\\\"0.10\\\\\\\"\\\\ndiff --git a/node_modules/async/LICENSE b/node_modules/async/LICENSE\\\\nnew file mode 100644\\\\nindex 0000000..8f29698\\\\n--- /dev/null\\\\n+++ b/node_modules/async/LICENSE\\\\n@@ -0,0 +1,19 @@\\\\n+Copyright (c) 2010-2014 Caolan McMahon\\\\n+\\\\n+Permission is hereby granted, free of charge, to any person obtaining a copy\\\\n+of this software and associated documentation files (the \\\\\\\"Software\\\\\\\"), to deal\\\\n+in the Software without restriction, including without limitation the rights\\\\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\\\n+copies of the Software, and to permit persons to whom the Software is\\\\n+furnished to do so, subject to the following conditions:\\\\n+\\\\n+The above copyright notice and this permission notice shall be included in\\\\n+all copies or substantial portions of the Software.\\\\n+\\\\n+THE SOFTWARE IS PROVIDED \\\\\\\"AS IS\\\\\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\\\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\\\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\\\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\\\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\\\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\\\n+THE SOFTWARE.\\\\ndiff --git a/node_modules/async/README.md b/node_modules/async/README.md\\\\nnew file mode 100644\\\\nindex 0000000..0bea531\\\\n--- /dev/null\\\\n+++ b/node_modules/async/README.md\\\\n@@ -0,0 +1,1646 @@\\\\n+# Async.js\\\\n+\\\\n+[![Build Status via Travis CI](https://travis-ci.org/caolan/async.svg?branch=master)](https://travis-ci.org/caolan/async)\\\\n+\\\\n+\\\\n+Async is a utility module which provides straight-forward, powerful functions\\\\n+for working with asynchronous JavaScript. Although originally designed for\\\\n+use with [Node.js](http://nodejs.org), it can also be used directly in the\\\\n+browser. Also supports [component](https://github.com/component/component).\\\\n+\\\\n+Async provides around 20 functions that include the usual 'functional'\\\\n+suspects (`map`, `reduce`, `filter`, `each`…) as well as some common patterns\\\\n+for asynchronous control flow (`parallel`, `series`, `waterfall`…). All these\\\\n+functions assume you follow the Node.js convention of providing a single\\\\n+callback as the last argument of your `async` function.\\\\n+\\\\n+\\\\n+## Quick Examples\\\\n+\\\\n+```javascript\\\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\\\n+    // results is now an array of stats for each file\\\\n+});\\\\n+\\\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\\\n+    // results now equals an array of the existing files\\\\n+});\\\\n+\\\\n+async.parallel([\\\\n+    function(){ ... },\\\\n+    function(){ ... }\\\\n+], callback);\\\\n+\\\\n+async.series([\\\\n+    function(){ ... },\\\\n+    function(){ ... }\\\\n+]);\\\\n+```\\\\n+\\\\n+There are many more functions available so take a look at the docs below for a\\\\n+full list. This module aims to be comprehensive, so if you feel anything is\\\\n+missing please create a GitHub issue for it.\\\\n+\\\\n+## Common Pitfalls\\\\n+\\\\n+### Binding a context to an iterator\\\\n+\\\\n+This section is really about `bind`, not about `async`. If you are wondering how to\\\\n+make `async` execute your iterators in a given context, or are confused as to why\\\\n+a method of another library isn't working as an iterator, study this example:\\\\n+\\\\n+```js\\\\n+// Here is a simple object with an (unnecessarily roundabout) squaring method\\\\n+var AsyncSquaringLibrary = {\\\\n+  squareExponent: 2,\\\\n+  square: function(number, callback){ \\\\n+    var result = Math.pow(number, this.squareExponent);\\\\n+    setTimeout(function(){\\\\n+      callback(null, result);\\\\n+    }, 200);\\\\n+  }\\\\n+};\\\\n+\\\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square, function(err, result){\\\\n+  // result is [NaN, NaN, NaN]\\\\n+  // This fails because the `this.squareExponent` expression in the square\\\\n+  // function is not evaluated in the context of AsyncSquaringLibrary, and is\\\\n+  // therefore undefined.\\\\n+});\\\\n+\\\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), function(err, result){\\\\n+  // result is [1, 4, 9]\\\\n+  // With the help of bind we can attach a context to the iterator before\\\\n+  // passing it to async. Now the square function will be executed in its \\\\n+  // 'home' AsyncSquaringLibrary context and the value of `this.squareExponent`\\\\n+  // will be as expected.\\\\n+});\\\\n+```\\\\n+\\\\n+## Download\\\\n+\\\\n+The source is available for download from\\\\n+[GitHub](http://github.com/caolan/async).\\\\n+Alternatively, you can install using Node Package Manager (`npm`):\\\\n+\\\\n+    npm install async\\\\n+\\\\n+__Development:__ [async.js](https://github.com/caolan/async/raw/master/lib/async.js) - 29.6kb Uncompressed\\\\n+\\\\n+## In the Browser\\\\n+\\\\n+So far it's been tested in IE6, IE7, IE8, FF3.6 and Chrome 5. \\\\n+\\\\n+Usage:\\\\n+\\\\n+```html\\\\n+<script type=\\\\\\\"text/javascript\\\\\\\" src=\\\\\\\"async.js\\\\\\\"></script>\\\\n+<script type=\\\\\\\"text/javascript\\\\\\\">\\\\n+\\\\n+    async.map(data, asyncProcess, function(err, results){\\\\n+        alert(results);\\\\n+    });\\\\n+\\\\n+</script>\\\\n+```\\\\n+\\\\n+## Documentation\\\\n+\\\\n+### Collections\\\\n+\\\\n+* [`each`](#each)\\\\n+* [`eachSeries`](#eachSeries)\\\\n+* [`eachLimit`](#eachLimit)\\\\n+* [`map`](#map)\\\\n+* [`mapSeries`](#mapSeries)\\\\n+* [`mapLimit`](#mapLimit)\\\\n+* [`filter`](#filter)\\\\n+* [`filterSeries`](#filterSeries)\\\\n+* [`reject`](#reject)\\\\n+* [`rejectSeries`](#rejectSeries)\\\\n+* [`reduce`](#reduce)\\\\n+* [`reduceRight`](#reduceRight)\\\\n+* [`detect`](#detect)\\\\n+* [`detectSeries`](#detectSeries)\\\\n+* [`sortBy`](#sortBy)\\\\n+* [`some`](#some)\\\\n+* [`every`](#every)\\\\n+* [`concat`](#concat)\\\\n+* [`concatSeries`](#concatSeries)\\\\n+\\\\n+### Control Flow\\\\n+\\\\n+* [`series`](#seriestasks-callback)\\\\n+* [`parallel`](#parallel)\\\\n+* [`parallelLimit`](#parallellimittasks-limit-callback)\\\\n+* [`whilst`](#whilst)\\\\n+* [`doWhilst`](#doWhilst)\\\\n+* [`until`](#until)\\\\n+* [`doUntil`](#doUntil)\\\\n+* [`forever`](#forever)\\\\n+* [`waterfall`](#waterfall)\\\\n+* [`compose`](#compose)\\\\n+* [`seq`](#seq)\\\\n+* [`applyEach`](#applyEach)\\\\n+* [`applyEachSeries`](#applyEachSeries)\\\\n+* [`queue`](#queue)\\\\n+* [`priorityQueue`](#priorityQueue)\\\\n+* [`cargo`](#cargo)\\\\n+* [`auto`](#auto)\\\\n+* [`retry`](#retry)\\\\n+* [`iterator`](#iterator)\\\\n+* [`apply`](#apply)\\\\n+* [`nextTick`](#nextTick)\\\\n+* [`times`](#times)\\\\n+* [`timesSeries`](#timesSeries)\\\\n+\\\\n+### Utils\\\\n+\\\\n+* [`memoize`](#memoize)\\\\n+* [`unmemoize`](#unmemoize)\\\\n+* [`log`](#log)\\\\n+* [`dir`](#dir)\\\\n+* [`noConflict`](#noConflict)\\\\n+\\\\n+\\\\n+## Collections\\\\n+\\\\n+<a name=\\\\\\\"forEach\\\\\\\" />\\\\n+<a name=\\\\\\\"each\\\\\\\" />\\\\n+### each(arr, iterator, callback)\\\\n+\\\\n+Applies the function `iterator` to each item in `arr`, in parallel.\\\\n+The `iterator` is called with an item from the list, and a callback for when it\\\\n+has finished. If the `iterator` passes an error to its `callback`, the main\\\\n+`callback` (for the `each` function) is immediately called with the error.\\\\n+\\\\n+Note, that since this function applies `iterator` to each item in parallel,\\\\n+there is no guarantee that the iterator functions will complete in order.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err)` which must be called once it has \\\\n+  completed. If no error has occured, the `callback` should be run without \\\\n+  arguments or with an explicit `null` argument.\\\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\\\n+  have finished, or an error occurs.\\\\n+\\\\n+__Examples__\\\\n+\\\\n+\\\\n+```js\\\\n+// assuming openFiles is an array of file names and saveFile is a function\\\\n+// to save the modified contents of that file:\\\\n+\\\\n+async.each(openFiles, saveFile, function(err){\\\\n+    // if any of the saves produced an error, err would equal that error\\\\n+});\\\\n+```\\\\n+\\\\n+```js\\\\n+// assuming openFiles is an array of file names \\\\n+\\\\n+async.each(openFiles, function( file, callback) {\\\\n+  \\\\n+  // Perform operation on file here.\\\\n+  console.log('Processing file ' + file);\\\\n+  \\\\n+  if( file.length > 32 ) {\\\\n+    console.log('This file name is too long');\\\\n+    callback('File name too long');\\\\n+  } else {\\\\n+    // Do work to process file here\\\\n+    console.log('File processed');\\\\n+    callback();\\\\n+  }\\\\n+}, function(err){\\\\n+    // if any of the file processing produced an error, err would equal that error\\\\n+    if( err ) {\\\\n+      // One of the iterations produced an error.\\\\n+      // All processing will now stop.\\\\n+      console.log('A file failed to process');\\\\n+    } else {\\\\n+      console.log('All files have been processed successfully');\\\\n+    }\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"forEachSeries\\\\\\\" />\\\\n+<a name=\\\\\\\"eachSeries\\\\\\\" />\\\\n+### eachSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`each`](#each), only `iterator` is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+This means the `iterator` functions will complete in order.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"forEachLimit\\\\\\\" />\\\\n+<a name=\\\\\\\"eachLimit\\\\\\\" />\\\\n+### eachLimit(arr, limit, iterator, callback)\\\\n+\\\\n+The same as [`each`](#each), only no more than `limit` `iterator`s will be simultaneously \\\\n+running at any time.\\\\n+\\\\n+Note that the items in `arr` are not processed in batches, so there is no guarantee that \\\\n+the first `limit` `iterator` functions will complete before any others are started.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err)` which must be called once it has \\\\n+  completed. If no error has occured, the callback should be run without \\\\n+  arguments or with an explicit `null` argument.\\\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\\\n+  have finished, or an error occurs.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// Assume documents is an array of JSON objects and requestApi is a\\\\n+// function that interacts with a rate-limited REST api.\\\\n+\\\\n+async.eachLimit(documents, 20, requestApi, function(err){\\\\n+    // if any of the saves produced an error, err would equal that error\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"map\\\\\\\" />\\\\n+### map(arr, iterator, callback)\\\\n+\\\\n+Produces a new array of values by mapping each value in `arr` through\\\\n+the `iterator` function. The `iterator` is called with an item from `arr` and a\\\\n+callback for when it has finished processing. Each of these callback takes 2 arguments: \\\\n+an `error`, and the transformed item from `arr`. If `iterator` passes an error to this \\\\n+callback, the main `callback` (for the `map` function) is immediately called with the error.\\\\n+\\\\n+Note, that since this function applies the `iterator` to each item in parallel,\\\\n+there is no guarantee that the `iterator` functions will complete in order. \\\\n+However, the results array will be in the same order as the original `arr`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\\\n+  it has completed with an error (which can be `null`) and a transformed item.\\\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\\\n+  functions have finished, or an error occurs. Results is an array of the\\\\n+  transformed items from the `arr`.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\\\n+    // results is now an array of stats for each file\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"mapSeries\\\\\\\" />\\\\n+### mapSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`map`](#map), only the `iterator` is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+The results array will be in the same order as the original.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"mapLimit\\\\\\\" />\\\\n+### mapLimit(arr, limit, iterator, callback)\\\\n+\\\\n+The same as [`map`](#map), only no more than `limit` `iterator`s will be simultaneously \\\\n+running at any time.\\\\n+\\\\n+Note that the items are not processed in batches, so there is no guarantee that \\\\n+the first `limit` `iterator` functions will complete before any others are started.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\\\n+  it has completed with an error (which can be `null`) and a transformed item.\\\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\\\n+  calls have finished, or an error occurs. The result is an array of the\\\\n+  transformed items from the original `arr`.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.mapLimit(['file1','file2','file3'], 1, fs.stat, function(err, results){\\\\n+    // results is now an array of stats for each file\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"select\\\\\\\" />\\\\n+<a name=\\\\\\\"filter\\\\\\\" />\\\\n+### filter(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `select`\\\\n+\\\\n+Returns a new array of all the values in `arr` which pass an async truth test.\\\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\n+way node libraries work with truth tests like `fs.exists`. This operation is\\\\n+performed in parallel, but the results array will be in the same order as the\\\\n+original.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\\\n+  The `iterator` is passed a `callback(truthValue)`, which must be called with a \\\\n+  boolean argument once it has completed.\\\\n+* `callback(results)` - A callback which is called after all the `iterator`\\\\n+  functions have finished.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\\\n+    // results now equals an array of the existing files\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"selectSeries\\\\\\\" />\\\\n+<a name=\\\\\\\"filterSeries\\\\\\\" />\\\\n+### filterSeries(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `selectSeries`\\\\n+\\\\n+The same as [`filter`](#filter) only the `iterator` is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+The results array will be in the same order as the original.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"reject\\\\\\\" />\\\\n+### reject(arr, iterator, callback)\\\\n+\\\\n+The opposite of [`filter`](#filter). Removes values that pass an `async` truth test.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"rejectSeries\\\\\\\" />\\\\n+### rejectSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`reject`](#reject), only the `iterator` is applied to each item in `arr`\\\\n+in series.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"reduce\\\\\\\" />\\\\n+### reduce(arr, memo, iterator, callback)\\\\n+\\\\n+__Aliases:__ `inject`, `foldl`\\\\n+\\\\n+Reduces `arr` into a single value using an async `iterator` to return\\\\n+each successive step. `memo` is the initial state of the reduction. \\\\n+This function only operates in series. \\\\n+\\\\n+For performance reasons, it may make sense to split a call to this function into \\\\n+a parallel map, and then use the normal `Array.prototype.reduce` on the results. \\\\n+This function is for situations where each step in the reduction needs to be async; \\\\n+if you can get the data before reducing it, then it's probably a good idea to do so.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `memo` - The initial state of the reduction.\\\\n+* `iterator(memo, item, callback)` - A function applied to each item in the\\\\n+  array to produce the next step in the reduction. The `iterator` is passed a\\\\n+  `callback(err, reduction)` which accepts an optional error as its first \\\\n+  argument, and the state of the reduction as the second. If an error is \\\\n+  passed to the callback, the reduction is stopped and the main `callback` is \\\\n+  immediately called with the error.\\\\n+* `callback(err, result)` - A callback which is called after all the `iterator`\\\\n+  functions have finished. Result is the reduced value.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.reduce([1,2,3], 0, function(memo, item, callback){\\\\n+    // pointless async:\\\\n+    process.nextTick(function(){\\\\n+        callback(null, memo + item)\\\\n+    });\\\\n+}, function(err, result){\\\\n+    // result is now equal to the last value of memo, which is 6\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"reduceRight\\\\\\\" />\\\\n+### reduceRight(arr, memo, iterator, callback)\\\\n+\\\\n+__Alias:__ `foldr`\\\\n+\\\\n+Same as [`reduce`](#reduce), only operates on `arr` in reverse order.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"detect\\\\\\\" />\\\\n+### detect(arr, iterator, callback)\\\\n+\\\\n+Returns the first value in `arr` that passes an async truth test. The\\\\n+`iterator` is applied in parallel, meaning the first iterator to return `true` will\\\\n+fire the detect `callback` with that result. That means the result might not be\\\\n+the first item in the original `arr` (in terms of order) that passes the test.\\\\n+\\\\n+If order within the original `arr` is important, then look at [`detectSeries`](#detectSeries).\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(truthValue)` which must be called with a \\\\n+  boolean argument once it has completed.\\\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\\\n+  `true`, or after all the `iterator` functions have finished. Result will be\\\\n+  the first item in the array that passes the truth test (iterator) or the\\\\n+  value `undefined` if none passed.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.detect(['file1','file2','file3'], fs.exists, function(result){\\\\n+    // result now equals the first file in the list that exists\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"detectSeries\\\\\\\" />\\\\n+### detectSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`detect`](#detect), only the `iterator` is applied to each item in `arr`\\\\n+in series. This means the result is always the first in the original `arr` (in\\\\n+terms of array order) that passes the truth test.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"sortBy\\\\\\\" />\\\\n+### sortBy(arr, iterator, callback)\\\\n+\\\\n+Sorts a list by the results of running each `arr` value through an async `iterator`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, sortValue)` which must be called once it\\\\n+  has completed with an error (which can be `null`) and a value to use as the sort\\\\n+  criteria.\\\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\\\n+  functions have finished, or an error occurs. Results is the items from\\\\n+  the original `arr` sorted by the values returned by the `iterator` calls.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.sortBy(['file1','file2','file3'], function(file, callback){\\\\n+    fs.stat(file, function(err, stats){\\\\n+        callback(err, stats.mtime);\\\\n+    });\\\\n+}, function(err, results){\\\\n+    // results is now the original array of files sorted by\\\\n+    // modified date\\\\n+});\\\\n+```\\\\n+\\\\n+__Sort Order__\\\\n+\\\\n+By modifying the callback parameter the sorting order can be influenced:\\\\n+\\\\n+```js\\\\n+//ascending order\\\\n+async.sortBy([1,9,3,5], function(x, callback){\\\\n+    callback(err, x);\\\\n+}, function(err,result){\\\\n+    //result callback\\\\n+} );\\\\n+\\\\n+//descending order\\\\n+async.sortBy([1,9,3,5], function(x, callback){\\\\n+    callback(err, x*-1);    //<- x*-1 instead of x, turns the order around\\\\n+}, function(err,result){\\\\n+    //result callback\\\\n+} );\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"some\\\\\\\" />\\\\n+### some(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `any`\\\\n+\\\\n+Returns `true` if at least one element in the `arr` satisfies an async test.\\\\n+_The callback for each iterator call only accepts a single argument of `true` or\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\n+way node libraries work with truth tests like `fs.exists`. Once any iterator\\\\n+call returns `true`, the main `callback` is immediately called.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\\\n+  called with a boolean argument once it has completed.\\\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\\\n+  `true`, or after all the iterator functions have finished. Result will be\\\\n+  either `true` or `false` depending on the values of the async tests.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.some(['file1','file2','file3'], fs.exists, function(result){\\\\n+    // if result is true then at least one of the files exists\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"every\\\\\\\" />\\\\n+### every(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `all`\\\\n+\\\\n+Returns `true` if every element in `arr` satisfies an async test.\\\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\n+way node libraries work with truth tests like `fs.exists`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\\\n+  called with a  boolean argument once it has completed.\\\\n+* `callback(result)` - A callback which is called after all the `iterator`\\\\n+  functions have finished. Result will be either `true` or `false` depending on\\\\n+  the values of the async tests.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.every(['file1','file2','file3'], fs.exists, function(result){\\\\n+    // if result is true then every file exists\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"concat\\\\\\\" />\\\\n+### concat(arr, iterator, callback)\\\\n+\\\\n+Applies `iterator` to each item in `arr`, concatenating the results. Returns the\\\\n+concatenated list. The `iterator`s are called in parallel, and the results are\\\\n+concatenated as they return. There is no guarantee that the results array will\\\\n+be returned in the original order of `arr` passed to the `iterator` function.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, results)` which must be called once it \\\\n+  has completed with an error (which can be `null`) and an array of results.\\\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\\\n+  functions have finished, or an error occurs. Results is an array containing\\\\n+  the concatenated results of the `iterator` function.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files){\\\\n+    // files is now a list of filenames that exist in the 3 directories\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"concatSeries\\\\\\\" />\\\\n+### concatSeries(arr, iterator, callback)\\\\n+\\\\n+Same as [`concat`](#concat), but executes in series instead of parallel.\\\\n+\\\\n+\\\\n+## Control Flow\\\\n+\\\\n+<a name=\\\\\\\"series\\\\\\\" />\\\\n+### series(tasks, [callback])\\\\n+\\\\n+Run the functions in the `tasks` array in series, each one running once the previous\\\\n+function has completed. If any functions in the series pass an error to its\\\\n+callback, no more functions are run, and `callback` is immediately called with the value of the error. \\\\n+Otherwise, `callback` receives an array of results when `tasks` have completed.\\\\n+\\\\n+It is also possible to use an object instead of an array. Each property will be\\\\n+run as a function, and the results will be passed to the final `callback` as an object\\\\n+instead of an array. This can be a more readable way of handling results from\\\\n+[`series`](#series).\\\\n+\\\\n+**Note** that while many implementations preserve the order of object properties, the\\\\n+[ECMAScript Language Specifcation](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6) \\\\n+explicitly states that\\\\n+\\\\n+> The mechanics and order of enumerating the properties is not specified.\\\\n+\\\\n+So if you rely on the order in which your series of functions are executed, and want\\\\n+this to work on all platforms, consider using an array. \\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array or object containing functions to run, each function is passed\\\\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\\\n+  be `null`) and an optional `result` value.\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\n+  have completed. This function gets a results array (or object) containing all \\\\n+  the result arguments passed to the `task` callbacks.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.series([\\\\n+    function(callback){\\\\n+        // do some stuff ...\\\\n+        callback(null, 'one');\\\\n+    },\\\\n+    function(callback){\\\\n+        // do some more stuff ...\\\\n+        callback(null, 'two');\\\\n+    }\\\\n+],\\\\n+// optional callback\\\\n+function(err, results){\\\\n+    // results is now equal to ['one', 'two']\\\\n+});\\\\n+\\\\n+\\\\n+// an example using an object instead of an array\\\\n+async.series({\\\\n+    one: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 1);\\\\n+        }, 200);\\\\n+    },\\\\n+    two: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 2);\\\\n+        }, 100);\\\\n+    }\\\\n+},\\\\n+function(err, results) {\\\\n+    // results is now equal to: {one: 1, two: 2}\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"parallel\\\\\\\" />\\\\n+### parallel(tasks, [callback])\\\\n+\\\\n+Run the `tasks` array of functions in parallel, without waiting until the previous\\\\n+function has completed. If any of the functions pass an error to its\\\\n+callback, the main `callback` is immediately called with the value of the error.\\\\n+Once the `tasks` have completed, the results are passed to the final `callback` as an\\\\n+array.\\\\n+\\\\n+It is also possible to use an object instead of an array. Each property will be\\\\n+run as a function and the results will be passed to the final `callback` as an object\\\\n+instead of an array. This can be a more readable way of handling results from\\\\n+[`parallel`](#parallel).\\\\n+\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array or object containing functions to run. Each function is passed \\\\n+  a `callback(err, result)` which it must call on completion with an error `err` \\\\n+  (which can be `null`) and an optional `result` value.\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\n+  have completed. This function gets a results array (or object) containing all \\\\n+  the result arguments passed to the task callbacks.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.parallel([\\\\n+    function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 'one');\\\\n+        }, 200);\\\\n+    },\\\\n+    function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 'two');\\\\n+        }, 100);\\\\n+    }\\\\n+],\\\\n+// optional callback\\\\n+function(err, results){\\\\n+    // the results array will equal ['one','two'] even though\\\\n+    // the second function had a shorter timeout.\\\\n+});\\\\n+\\\\n+\\\\n+// an example using an object instead of an array\\\\n+async.parallel({\\\\n+    one: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 1);\\\\n+        }, 200);\\\\n+    },\\\\n+    two: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 2);\\\\n+        }, 100);\\\\n+    }\\\\n+},\\\\n+function(err, results) {\\\\n+    // results is now equals to: {one: 1, two: 2}\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"parallelLimit\\\\\\\" />\\\\n+### parallelLimit(tasks, limit, [callback])\\\\n+\\\\n+The same as [`parallel`](#parallel), only `tasks` are executed in parallel \\\\n+with a maximum of `limit` tasks executing at any time.\\\\n+\\\\n+Note that the `tasks` are not executed in batches, so there is no guarantee that \\\\n+the first `limit` tasks will complete before any others are started.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array or object containing functions to run, each function is passed \\\\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\\\n+  be `null`) and an optional `result` value.\\\\n+* `limit` - The maximum number of `tasks` to run at any time.\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\n+  have completed. This function gets a results array (or object) containing all \\\\n+  the result arguments passed to the `task` callbacks.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"whilst\\\\\\\" />\\\\n+### whilst(test, fn, callback)\\\\n+\\\\n+Repeatedly call `fn`, while `test` returns `true`. Calls `callback` when stopped,\\\\n+or an error occurs.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `test()` - synchronous truth test to perform before each execution of `fn`.\\\\n+* `fn(callback)` - A function which is called each time `test` passes. The function is\\\\n+  passed a `callback(err)`, which must be called once it has completed with an \\\\n+  optional `err` argument.\\\\n+* `callback(err)` - A callback which is called after the test fails and repeated\\\\n+  execution of `fn` has stopped.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var count = 0;\\\\n+\\\\n+async.whilst(\\\\n+    function () { return count < 5; },\\\\n+    function (callback) {\\\\n+        count++;\\\\n+        setTimeout(callback, 1000);\\\\n+    },\\\\n+    function (err) {\\\\n+        // 5 seconds have passed\\\\n+    }\\\\n+);\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"doWhilst\\\\\\\" />\\\\n+### doWhilst(fn, test, callback)\\\\n+\\\\n+The post-check version of [`whilst`](#whilst). To reflect the difference in \\\\n+the order of operations, the arguments `test` and `fn` are switched. \\\\n+\\\\n+`doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"until\\\\\\\" />\\\\n+### until(test, fn, callback)\\\\n+\\\\n+Repeatedly call `fn` until `test` returns `true`. Calls `callback` when stopped,\\\\n+or an error occurs.\\\\n+\\\\n+The inverse of [`whilst`](#whilst).\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"doUntil\\\\\\\" />\\\\n+### doUntil(fn, test, callback)\\\\n+\\\\n+Like [`doWhilst`](#doWhilst), except the `test` is inverted. Note the argument ordering differs from `until`.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"forever\\\\\\\" />\\\\n+### forever(fn, errback)\\\\n+\\\\n+Calls the asynchronous function `fn` with a callback parameter that allows it to\\\\n+call itself again, in series, indefinitely.\\\\n+\\\\n+If an error is passed to the callback then `errback` is called with the\\\\n+error, and execution stops, otherwise it will never be called.\\\\n+\\\\n+```js\\\\n+async.forever(\\\\n+    function(next) {\\\\n+        // next is suitable for passing to things that need a callback(err [, whatever]);\\\\n+        // it will result in this function being called again.\\\\n+    },\\\\n+    function(err) {\\\\n+        // if next is called with a value in its first parameter, it will appear\\\\n+        // in here as 'err', and execution will stop.\\\\n+    }\\\\n+);\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"waterfall\\\\\\\" />\\\\n+### waterfall(tasks, [callback])\\\\n+\\\\n+Runs the `tasks` array of functions in series, each passing their results to the next in\\\\n+the array. However, if any of the `tasks` pass an error to their own callback, the\\\\n+next function is not executed, and the main `callback` is immediately called with\\\\n+the error.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array of functions to run, each function is passed a \\\\n+  `callback(err, result1, result2, ...)` it must call on completion. The first\\\\n+  argument is an error (which can be `null`) and any further arguments will be \\\\n+  passed as arguments in order to the next task.\\\\n+* `callback(err, [results])` - An optional callback to run once all the functions\\\\n+  have completed. This will be passed the results of the last task's callback.\\\\n+\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.waterfall([\\\\n+    function(callback){\\\\n+        callback(null, 'one', 'two');\\\\n+    },\\\\n+    function(arg1, arg2, callback){\\\\n+      // arg1 now equals 'one' and arg2 now equals 'two'\\\\n+        callback(null, 'three');\\\\n+    },\\\\n+    function(arg1, callback){\\\\n+        // arg1 now equals 'three'\\\\n+        callback(null, 'done');\\\\n+    }\\\\n+], function (err, result) {\\\\n+   // result now equals 'done'    \\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+<a name=\\\\\\\"compose\\\\\\\" />\\\\n+### compose(fn1, fn2...)\\\\n+\\\\n+Creates a function which is a composition of the passed asynchronous\\\\n+functions. Each function consumes the return value of the function that\\\\n+follows. Composing functions `f()`, `g()`, and `h()` would produce the result of\\\\n+`f(g(h()))`, only this version uses callbacks to obtain the return values.\\\\n+\\\\n+Each function is executed with the `this` binding of the composed function.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `functions...` - the asynchronous functions to compose\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+function add1(n, callback) {\\\\n+    setTimeout(function () {\\\\n+        callback(null, n + 1);\\\\n+    }, 10);\\\\n+}\\\\n+\\\\n+function mul3(n, callback) {\\\\n+    setTimeout(function () {\\\\n+        callback(null, n * 3);\\\\n+    }, 10);\\\\n+}\\\\n+\\\\n+var add1mul3 = async.compose(mul3, add1);\\\\n+\\\\n+add1mul3(4, function (err, result) {\\\\n+   // result now equals 15\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+<a name=\\\\\\\"seq\\\\\\\" />\\\\n+### seq(fn1, fn2...)\\\\n+\\\\n+Version of the compose function that is more natural to read.\\\\n+Each following function consumes the return value of the latter function. \\\\n+\\\\n+Each function is executed with the `this` binding of the composed function.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* functions... - the asynchronous functions to compose\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// Requires lodash (or underscore), express3 and dresende's orm2.\\\\n+// Part of an app, that fetches cats of the logged user.\\\\n+// This example uses `seq` function to avoid overnesting and error \\\\n+// handling clutter.\\\\n+app.get('/cats', function(request, response) {\\\\n+  function handleError(err, data, callback) {\\\\n+    if (err) {\\\\n+      console.error(err);\\\\n+      response.json({ status: 'error', message: err.message });\\\\n+    }\\\\n+    else {\\\\n+      callback(data);\\\\n+    }\\\\n+  }\\\\n+  var User = request.models.User;\\\\n+  async.seq(\\\\n+    _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\\\\n+    handleError,\\\\n+    function(user, fn) {\\\\n+      user.getCats(fn);      // 'getCats' has signature (callback(err, data))\\\\n+    },\\\\n+    handleError,\\\\n+    function(cats) {\\\\n+      response.json({ status: 'ok', message: 'Cats found', data: cats });\\\\n+    }\\\\n+  )(req.session.user_id);\\\\n+  }\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+<a name=\\\\\\\"applyEach\\\\\\\" />\\\\n+### applyEach(fns, args..., callback)\\\\n+\\\\n+Applies the provided arguments to each function in the array, calling \\\\n+`callback` after all functions have completed. If you only provide the first\\\\n+argument, then it will return a function which lets you pass in the\\\\n+arguments as if it were a single function call.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `fns` - the asynchronous functions to all call with the same arguments\\\\n+* `args...` - any number of separate arguments to pass to the function\\\\n+* `callback` - the final argument should be the callback, called when all\\\\n+  functions have completed processing\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.applyEach([enableSearch, updateSchema], 'bucket', callback);\\\\n+\\\\n+// partial application example:\\\\n+async.each(\\\\n+    buckets,\\\\n+    async.applyEach([enableSearch, updateSchema]),\\\\n+    callback\\\\n+);\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"applyEachSeries\\\\\\\" />\\\\n+### applyEachSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`applyEach`](#applyEach) only the functions are applied in series.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"queue\\\\\\\" />\\\\n+### queue(worker, concurrency)\\\\n+\\\\n+Creates a `queue` object with the specified `concurrency`. Tasks added to the\\\\n+`queue` are processed in parallel (up to the `concurrency` limit). If all\\\\n+`worker`s are in progress, the task is queued until one becomes available. \\\\n+Once a `worker` completes a `task`, that `task`'s callback is called.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `worker(task, callback)` - An asynchronous function for processing a queued\\\\n+  task, which must call its `callback(err)` argument when finished, with an \\\\n+  optional `error` as an argument.\\\\n+* `concurrency` - An `integer` for determining how many `worker` functions should be\\\\n+  run in parallel.\\\\n+\\\\n+__Queue objects__\\\\n+\\\\n+The `queue` object returned by this function has the following properties and\\\\n+methods:\\\\n+\\\\n+* `length()` - a function returning the number of items waiting to be processed.\\\\n+* `started` - a function returning whether or not any items have been pushed and processed by the queue\\\\n+* `running()` - a function returning the number of items currently being processed.\\\\n+* `idle()` - a function returning false if there are items waiting or being processed, or true if not.\\\\n+* `concurrency` - an integer for determining how many `worker` functions should be\\\\n+  run in parallel. This property can be changed after a `queue` is created to\\\\n+  alter the concurrency on-the-fly.\\\\n+* `push(task, [callback])` - add a new task to the `queue`. Calls `callback` once \\\\n+  the `worker` has finished processing the task. Instead of a single task, a `tasks` array\\\\n+  can be submitted. The respective callback is used for every task in the list.\\\\n+* `unshift(task, [callback])` - add a new task to the front of the `queue`.\\\\n+* `saturated` - a callback that is called when the `queue` length hits the `concurrency` limit, \\\\n+   and further tasks will be queued.\\\\n+* `empty` - a callback that is called when the last item from the `queue` is given to a `worker`.\\\\n+* `drain` - a callback that is called when the last item from the `queue` has returned from the `worker`.\\\\n+* `paused` - a boolean for determining whether the queue is in a paused state\\\\n+* `pause()` - a function that pauses the processing of tasks until `resume()` is called.\\\\n+* `resume()` - a function that resumes the processing of queued tasks when the queue is paused.\\\\n+* `kill()` - a function that empties remaining tasks from the queue forcing it to go idle.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// create a queue object with concurrency 2\\\\n+\\\\n+var q = async.queue(function (task, callback) {\\\\n+    console.log('hello ' + task.name);\\\\n+    callback();\\\\n+}, 2);\\\\n+\\\\n+\\\\n+// assign a callback\\\\n+q.drain = function() {\\\\n+    console.log('all items have been processed');\\\\n+}\\\\n+\\\\n+// add some items to the queue\\\\n+\\\\n+q.push({name: 'foo'}, function (err) {\\\\n+    console.log('finished processing foo');\\\\n+});\\\\n+q.push({name: 'bar'}, function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+\\\\n+// add some items to the queue (batch-wise)\\\\n+\\\\n+q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+\\\\n+// add some items to the front of the queue\\\\n+\\\\n+q.unshift({name: 'bar'}, function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+```\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"priorityQueue\\\\\\\" />\\\\n+### priorityQueue(worker, concurrency)\\\\n+\\\\n+The same as [`queue`](#queue) only tasks are assigned a priority and completed in ascending priority order. There are two differences between `queue` and `priorityQueue` objects:\\\\n+\\\\n+* `push(task, priority, [callback])` - `priority` should be a number. If an array of\\\\n+  `tasks` is given, all tasks will be assigned the same priority.\\\\n+* The `unshift` method was removed.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"cargo\\\\\\\" />\\\\n+### cargo(worker, [payload])\\\\n+\\\\n+Creates a `cargo` object with the specified payload. Tasks added to the\\\\n+cargo will be processed altogether (up to the `payload` limit). If the\\\\n+`worker` is in progress, the task is queued until it becomes available. Once\\\\n+the `worker` has completed some tasks, each callback of those tasks is called.\\\\n+Check out [this animation](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) for how `cargo` and `queue` work.\\\\n+\\\\n+While [queue](#queue) passes only one task to one of a group of workers\\\\n+at a time, cargo passes an array of tasks to a single worker, repeating\\\\n+when the worker is finished.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `worker(tasks, callback)` - An asynchronous function for processing an array of\\\\n+  queued tasks, which must call its `callback(err)` argument when finished, with \\\\n+  an optional `err` argument.\\\\n+* `payload` - An optional `integer` for determining how many tasks should be\\\\n+  processed per round; if omitted, the default is unlimited.\\\\n+\\\\n+__Cargo objects__\\\\n+\\\\n+The `cargo` object returned by this function has the following properties and\\\\n+methods:\\\\n+\\\\n+* `length()` - A function returning the number of items waiting to be processed.\\\\n+* `payload` - An `integer` for determining how many tasks should be\\\\n+  process per round. This property can be changed after a `cargo` is created to\\\\n+  alter the payload on-the-fly.\\\\n+* `push(task, [callback])` - Adds `task` to the `queue`. The callback is called\\\\n+  once the `worker` has finished processing the task. Instead of a single task, an array of `tasks` \\\\n+  can be submitted. The respective callback is used for every task in the list.\\\\n+* `saturated` - A callback that is called when the `queue.length()` hits the concurrency and further tasks will be queued.\\\\n+* `empty` - A callback that is called when the last item from the `queue` is given to a `worker`.\\\\n+* `drain` - A callback that is called when the last item from the `queue` has returned from the `worker`.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// create a cargo object with payload 2\\\\n+\\\\n+var cargo = async.cargo(function (tasks, callback) {\\\\n+    for(var i=0; i<tasks.length; i++){\\\\n+      console.log('hello ' + tasks[i].name);\\\\n+    }\\\\n+    callback();\\\\n+}, 2);\\\\n+\\\\n+\\\\n+// add some items\\\\n+\\\\n+cargo.push({name: 'foo'}, function (err) {\\\\n+    console.log('finished processing foo');\\\\n+});\\\\n+cargo.push({name: 'bar'}, function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+cargo.push({name: 'baz'}, function (err) {\\\\n+    console.log('finished processing baz');\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"auto\\\\\\\" />\\\\n+### auto(tasks, [callback])\\\\n+\\\\n+Determines the best order for running the functions in `tasks`, based on their \\\\n+requirements. Each function can optionally depend on other functions being completed \\\\n+first, and each function is run as soon as its requirements are satisfied. \\\\n+\\\\n+If any of the functions pass an error to their callback, it will not \\\\n+complete (so any other functions depending on it will not run), and the main \\\\n+`callback` is immediately called with the error. Functions also receive an \\\\n+object containing the results of functions which have completed so far.\\\\n+\\\\n+Note, all functions are called with a `results` object as a second argument, \\\\n+so it is unsafe to pass functions in the `tasks` object which cannot handle the\\\\n+extra argument. \\\\n+\\\\n+For example, this snippet of code:\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+  readData: async.apply(fs.readFile, 'data.txt', 'utf-8')\\\\n+}, callback);\\\\n+```\\\\n+\\\\n+will have the effect of calling `readFile` with the results object as the last\\\\n+argument, which will fail:\\\\n+\\\\n+```js\\\\n+fs.readFile('data.txt', 'utf-8', cb, {});\\\\n+```\\\\n+\\\\n+Instead, wrap the call to `readFile` in a function which does not forward the \\\\n+`results` object:\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+  readData: function(cb, results){\\\\n+    fs.readFile('data.txt', 'utf-8', cb);\\\\n+  }\\\\n+}, callback);\\\\n+```\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An object. Each of its properties is either a function or an array of\\\\n+  requirements, with the function itself the last item in the array. The object's key\\\\n+  of a property serves as the name of the task defined by that property,\\\\n+  i.e. can be used when specifying requirements for other tasks.\\\\n+  The function receives two arguments: (1) a `callback(err, result)` which must be \\\\n+  called when finished, passing an `error` (which can be `null`) and the result of \\\\n+  the function's execution, and (2) a `results` object, containing the results of\\\\n+  the previously executed functions.\\\\n+* `callback(err, results)` - An optional callback which is called when all the\\\\n+  tasks have been completed. It receives the `err` argument if any `tasks` \\\\n+  pass an error to their callback. Results are always returned; however, if \\\\n+  an error occurs, no further `tasks` will be performed, and the results\\\\n+  object will only contain partial results.\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+    get_data: function(callback){\\\\n+        console.log('in get_data');\\\\n+        // async code to get some data\\\\n+        callback(null, 'data', 'converted to array');\\\\n+    },\\\\n+    make_folder: function(callback){\\\\n+        console.log('in make_folder');\\\\n+        // async code to create a directory to store a file in\\\\n+        // this is run at the same time as getting the data\\\\n+        callback(null, 'folder');\\\\n+    },\\\\n+    write_file: ['get_data', 'make_folder', function(callback, results){\\\\n+        console.log('in write_file', JSON.stringify(results));\\\\n+        // once there is some data and the directory exists,\\\\n+        // write the data to a file in the directory\\\\n+        callback(null, 'filename');\\\\n+    }],\\\\n+    email_link: ['write_file', function(callback, results){\\\\n+        console.log('in email_link', JSON.stringify(results));\\\\n+        // once the file is written let's email a link to it...\\\\n+        // results.write_file contains the filename returned by write_file.\\\\n+        callback(null, {'file':results.write_file, 'email':'user@example.com'});\\\\n+    }]\\\\n+}, function(err, results) {\\\\n+    console.log('err = ', err);\\\\n+    console.log('results = ', results);\\\\n+});\\\\n+```\\\\n+\\\\n+This is a fairly trivial example, but to do this using the basic parallel and\\\\n+series functions would look like this:\\\\n+\\\\n+```js\\\\n+async.parallel([\\\\n+    function(callback){\\\\n+        console.log('in get_data');\\\\n+        // async code to get some data\\\\n+        callback(null, 'data', 'converted to array');\\\\n+    },\\\\n+    function(callback){\\\\n+        console.log('in make_folder');\\\\n+        // async code to create a directory to store a file in\\\\n+        // this is run at the same time as getting the data\\\\n+        callback(null, 'folder');\\\\n+    }\\\\n+],\\\\n+function(err, results){\\\\n+    async.series([\\\\n+        function(callback){\\\\n+            console.log('in write_file', JSON.stringify(results));\\\\n+            // once there is some data and the directory exists,\\\\n+            // write the data to a file in the directory\\\\n+            results.push('filename');\\\\n+            callback(null);\\\\n+        },\\\\n+        function(callback){\\\\n+            console.log('in email_link', JSON.stringify(results));\\\\n+            // once the file is written let's email a link to it...\\\\n+            callback(null, {'file':results.pop(), 'email':'user@example.com'});\\\\n+        }\\\\n+    ]);\\\\n+});\\\\n+```\\\\n+\\\\n+For a complicated series of `async` tasks, using the [`auto`](#auto) function makes adding\\\\n+new tasks much easier (and the code more readable).\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"retry\\\\\\\" />\\\\n+### retry([times = 5], task, [callback])\\\\n+\\\\n+Attempts to get a successful response from `task` no more than `times` times before\\\\n+returning an error. If the task is successful, the `callback` will be passed the result\\\\n+of the successfull task. If all attemps fail, the callback will be passed the error and\\\\n+result (if any) of the final attempt.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `times` - An integer indicating how many times to attempt the `task` before giving up. Defaults to 5.\\\\n+* `task(callback, results)` - A function which receives two arguments: (1) a `callback(err, result)`\\\\n+  which must be called when finished, passing `err` (which can be `null`) and the `result` of \\\\n+  the function's execution, and (2) a `results` object, containing the results of\\\\n+  the previously executed functions (if nested inside another control flow).\\\\n+* `callback(err, results)` - An optional callback which is called when the\\\\n+  task has succeeded, or after the final failed attempt. It receives the `err` and `result` arguments of the last attempt at completing the `task`.\\\\n+\\\\n+The [`retry`](#retry) function can be used as a stand-alone control flow by passing a\\\\n+callback, as shown below:\\\\n+\\\\n+```js\\\\n+async.retry(3, apiMethod, function(err, result) {\\\\n+    // do something with the result\\\\n+});\\\\n+```\\\\n+\\\\n+It can also be embeded within other control flow functions to retry individual methods\\\\n+that are not as reliable, like this:\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+    users: api.getUsers.bind(api),\\\\n+    payments: async.retry(3, api.getPayments.bind(api))\\\\n+}, function(err, results) {\\\\n+  // do something with the results\\\\n+});\\\\n+```\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"iterator\\\\\\\" />\\\\n+### iterator(tasks)\\\\n+\\\\n+Creates an iterator function which calls the next function in the `tasks` array,\\\\n+returning a continuation to call the next one after that. It's also possible to\\\\n+“peek” at the next iterator with `iterator.next()`.\\\\n+\\\\n+This function is used internally by the `async` module, but can be useful when\\\\n+you want to manually control the flow of functions in series.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array of functions to run.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var iterator = async.iterator([\\\\n+    function(){ sys.p('one'); },\\\\n+    function(){ sys.p('two'); },\\\\n+    function(){ sys.p('three'); }\\\\n+]);\\\\n+\\\\n+node> var iterator2 = iterator();\\\\n+'one'\\\\n+node> var iterator3 = iterator2();\\\\n+'two'\\\\n+node> iterator3();\\\\n+'three'\\\\n+node> var nextfn = iterator2.next();\\\\n+node> nextfn();\\\\n+'three'\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"apply\\\\\\\" />\\\\n+### apply(function, arguments..)\\\\n+\\\\n+Creates a continuation function with some arguments already applied. \\\\n+\\\\n+Useful as a shorthand when combined with other control flow functions. Any arguments\\\\n+passed to the returned function are added to the arguments originally passed\\\\n+to apply.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\n+* `arguments...` - Any number of arguments to automatically apply when the\\\\n+  continuation is called.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// using apply\\\\n+\\\\n+async.parallel([\\\\n+    async.apply(fs.writeFile, 'testfile1', 'test1'),\\\\n+    async.apply(fs.writeFile, 'testfile2', 'test2'),\\\\n+]);\\\\n+\\\\n+\\\\n+// the same process without using apply\\\\n+\\\\n+async.parallel([\\\\n+    function(callback){\\\\n+        fs.writeFile('testfile1', 'test1', callback);\\\\n+    },\\\\n+    function(callback){\\\\n+        fs.writeFile('testfile2', 'test2', callback);\\\\n+    }\\\\n+]);\\\\n+```\\\\n+\\\\n+It's possible to pass any number of additional arguments when calling the\\\\n+continuation:\\\\n+\\\\n+```js\\\\n+node> var fn = async.apply(sys.puts, 'one');\\\\n+node> fn('two', 'three');\\\\n+one\\\\n+two\\\\n+three\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"nextTick\\\\\\\" />\\\\n+### nextTick(callback)\\\\n+\\\\n+Calls `callback` on a later loop around the event loop. In Node.js this just\\\\n+calls `process.nextTick`; in the browser it falls back to `setImmediate(callback)`\\\\n+if available, otherwise `setTimeout(callback, 0)`, which means other higher priority\\\\n+events may precede the execution of `callback`.\\\\n+\\\\n+This is used internally for browser-compatibility purposes.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `callback` - The function to call on a later loop around the event loop.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var call_order = [];\\\\n+async.nextTick(function(){\\\\n+    call_order.push('two');\\\\n+    // call_order now equals ['one','two']\\\\n+});\\\\n+call_order.push('one')\\\\n+```\\\\n+\\\\n+<a name=\\\\\\\"times\\\\\\\" />\\\\n+### times(n, callback)\\\\n+\\\\n+Calls the `callback` function `n` times, and accumulates results in the same manner\\\\n+you would use with [`map`](#map).\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `n` - The number of times to run the function.\\\\n+* `callback` - The function to call `n` times.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// Pretend this is some complicated async factory\\\\n+var createUser = function(id, callback) {\\\\n+  callback(null, {\\\\n+    id: 'user' + id\\\\n+  })\\\\n+}\\\\n+// generate 5 users\\\\n+async.times(5, function(n, next){\\\\n+    createUser(n, function(err, user) {\\\\n+      next(err, user)\\\\n+    })\\\\n+}, function(err, users) {\\\\n+  // we should now have 5 users\\\\n+});\\\\n+```\\\\n+\\\\n+<a name=\\\\\\\"timesSeries\\\\\\\" />\\\\n+### timesSeries(n, callback)\\\\n+\\\\n+The same as [`times`](#times), only the iterator is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+The results array will be in the same order as the original.\\\\n+\\\\n+\\\\n+## Utils\\\\n+\\\\n+<a name=\\\\\\\"memoize\\\\\\\" />\\\\n+### memoize(fn, [hasher])\\\\n+\\\\n+Caches the results of an `async` function. When creating a hash to store function\\\\n+results against, the callback is omitted from the hash and an optional hash\\\\n+function can be used.\\\\n+\\\\n+The cache of results is exposed as the `memo` property of the function returned\\\\n+by `memoize`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `fn` - The function to proxy and cache results from.\\\\n+* `hasher` - Tn optional function for generating a custom hash for storing\\\\n+  results. It has all the arguments applied to it apart from the callback, and\\\\n+  must be synchronous.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var slow_fn = function (name, callback) {\\\\n+    // do something\\\\n+    callback(null, result);\\\\n+};\\\\n+var fn = async.memoize(slow_fn);\\\\n+\\\\n+// fn can now be used as if it were slow_fn\\\\n+fn('some name', function () {\\\\n+    // callback\\\\n+});\\\\n+```\\\\n+\\\\n+<a name=\\\\\\\"unmemoize\\\\\\\" />\\\\n+### unmemoize(fn)\\\\n+\\\\n+Undoes a [`memoize`](#memoize)d function, reverting it to the original, unmemoized\\\\n+form. Handy for testing.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `fn` - the memoized function\\\\n+\\\\n+<a name=\\\\\\\"log\\\\\\\" />\\\\n+### log(function, arguments)\\\\n+\\\\n+Logs the result of an `async` function to the `console`. Only works in Node.js or\\\\n+in browsers that support `console.log` and `console.error` (such as FF and Chrome).\\\\n+If multiple arguments are returned from the async function, `console.log` is\\\\n+called on each argument in order.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\n+* `arguments...` - Any number of arguments to apply to the function.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var hello = function(name, callback){\\\\n+    setTimeout(function(){\\\\n+        callback(null, 'hello ' + name);\\\\n+    }, 1000);\\\\n+};\\\\n+```\\\\n+```js\\\\n+node> async.log(hello, 'world');\\\\n+'hello world'\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"dir\\\\\\\" />\\\\n+### dir(function, arguments)\\\\n+\\\\n+Logs the result of an `async` function to the `console` using `console.dir` to\\\\n+display the properties of the resulting object. Only works in Node.js or\\\\n+in browsers that support `console.dir` and `console.error` (such as FF and Chrome).\\\\n+If multiple arguments are returned from the async function, `console.dir` is\\\\n+called on each argument in order.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\n+* `arguments...` - Any number of arguments to apply to the function.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var hello = function(name, callback){\\\\n+    setTimeout(function(){\\\\n+        callback(null, {hello: name});\\\\n+    }, 1000);\\\\n+};\\\\n+```\\\\n+```js\\\\n+node> async.dir(hello, 'world');\\\\n+{hello: 'world'}\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"noConflict\\\\\\\" />\\\\n+### noConflict()\\\\n+\\\\n+Changes the value of `async` back to its original value, returning a reference to the\\\\n+`async` object.\\\\ndiff --git a/node_modules/async/component.json b/node_modules/async/component.json\\\\nnew file mode 100644\\\\nindex 0000000..bbb0115\\\\n--- /dev/null\\\\n+++ b/node_modules/async/component.json\\\\n@@ -0,0 +1,11 @@\\\\n+{\\\\n+  \\\\\\\"name\\\\\\\": \\\\\\\"async\\\\\\\",\\\\n+  \\\\\\\"repo\\\\\\\": \\\\\\\"caolan/async\\\\\\\",\\\\n+  \\\\\\\"description\\\\\\\": \\\\\\\"Higher-order functions and common patterns for asynchronous code\\\\\\\",\\\\n+  \\\\\\\"version\\\\\\\": \\\\\\\"0.1.23\\\\\\\",\\\\n+  \\\\\\\"keywords\\\\\\\": [],\\\\n+  \\\\\\\"dependencies\\\\\\\": {},\\\\n+  \\\\\\\"development\\\\\\\": {},\\\\n+  \\\\\\\"main\\\\\\\": \\\\\\\"lib/async.js\\\\\\\",\\\\n+  \\\\\\\"scripts\\\\\\\": [ \\\\\\\"lib/async.js\\\\\\\" ]\\\\n+}\\\\ndiff --git a/node_modules/async/lib/async.js b/node_modules/async/lib/async.js\\\\nnew file mode 100644\\\\nindex 0000000..01e8afc\\\\n--- /dev/null\\\\n+++ b/node_modules/async/lib/async.js\\\\n@@ -0,0 +1,1123 @@\\\\n+/*!\\\\n+ * async\\\\n+ * https://github.com/caolan/async\\\\n+ *\\\\n+ * Copyright 2010-2014 Caolan McMahon\\\\n+ * Released under the MIT license\\\\n+ */\\\\n+/*jshint onevar: false, indent:4 */\\\\n+/*global setImmediate: false, setTimeout: false, console: false */\\\\n+(function () {\\\\n+\\\\n+    var async = {};\\\\n+\\\\n+    // global on the server, window in the browser\\\\n+    var root, previous_async;\\\\n+\\\\n+    root = this;\\\\n+    if (root != null) {\\\\n+      previous_async = root.async;\\\\n+    }\\\\n+\\\\n+    async.noConflict = function () {\\\\n+        root.async = previous_async;\\\\n+        return async;\\\\n+    };\\\\n+\\\\n+    function only_once(fn) {\\\\n+        var called = false;\\\\n+        return function() {\\\\n+            if (called) throw new Error(\\\\\\\"Callback was already called.\\\\\\\");\\\\n+            called = true;\\\\n+            fn.apply(root, arguments);\\\\n+        }\\\\n+    }\\\\n+\\\\n+    //// cross-browser compatiblity functions ////\\\\n+\\\\n+    var _toString = Object.prototype.toString;\\\\n+\\\\n+    var _isArray = Array.isArray || function (obj) {\\\\n+        return _toString.call(obj) === '[object Array]';\\\\n+    };\\\\n+\\\\n+    var _each = function (arr, iterator) {\\\\n+        if (arr.forEach) {\\\\n+            return arr.forEach(iterator);\\\\n+        }\\\\n+        for (var i = 0; i < arr.length; i += 1) {\\\\n+            iterator(arr[i], i, arr);\\\\n+        }\\\\n+    };\\\\n+\\\\n+    var _map = function (arr, iterator) {\\\\n+        if (arr.map) {\\\\n+            return arr.map(iterator);\\\\n+        }\\\\n+        var results = [];\\\\n+        _each(arr, function (x, i, a) {\\\\n+            results.push(iterator(x, i, a));\\\\n+        });\\\\n+        return results;\\\\n+    };\\\\n+\\\\n+    var _reduce = function (arr, iterator, memo) {\\\\n+        if (arr.reduce) {\\\\n+            return arr.reduce(iterator, memo);\\\\n+        }\\\\n+        _each(arr, function (x, i, a) {\\\\n+            memo = iterator(memo, x, i, a);\\\\n+        });\\\\n+        return memo;\\\\n+    };\\\\n+\\\\n+    var _keys = function (obj) {\\\\n+        if (Object.keys) {\\\\n+            return Object.keys(obj);\\\\n+        }\\\\n+        var keys = [];\\\\n+        for (var k in obj) {\\\\n+            if (obj.hasOwnProperty(k)) {\\\\n+                keys.push(k);\\\\n+            }\\\\n+        }\\\\n+        return keys;\\\\n+    };\\\\n+\\\\n+    //// exported async module functions ////\\\\n+\\\\n+    //// nextTick implementation with browser-compatible fallback ////\\\\n+    if (typeof process === 'undefined' || !(process.nextTick)) {\\\\n+        if (typeof setImmediate === 'function') {\\\\n+            async.nextTick = function (fn) {\\\\n+                // not a direct alias for IE10 compatibility\\\\n+                setImmediate(fn);\\\\n+            };\\\\n+            async.setImmediate = async.nextTick;\\\\n+        }\\\\n+        else {\\\\n+            async.nextTick = function (fn) {\\\\n+                setTimeout(fn, 0);\\\\n+            };\\\\n+            async.setImmediate = async.nextTick;\\\\n+        }\\\\n+    }\\\\n+    else {\\\\n+        async.nextTick = process.nextTick;\\\\n+        if (typeof setImmediate !== 'undefined') {\\\\n+            async.setImmediate = function (fn) {\\\\n+              // not a direct alias for IE10 compatibility\\\\n+              setImmediate(fn);\\\\n+            };\\\\n+        }\\\\n+        else {\\\\n+            async.setImmediate = async.nextTick;\\\\n+        }\\\\n+    }\\\\n+\\\\n+    async.each = function (arr, iterator, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (!arr.length) {\\\\n+            return callback();\\\\n+        }\\\\n+        var completed = 0;\\\\n+        _each(arr, function (x) {\\\\n+            iterator(x, only_once(done) );\\\\n+        });\\\\n+        function done(err) {\\\\n+          if (err) {\\\\n+              callback(err);\\\\n+              callback = function () {};\\\\n+          }\\\\n+          else {\\\\n+              completed += 1;\\\\n+              if (completed >= arr.length) {\\\\n+                  callback();\\\\n+              }\\\\n+          }\\\\n+        }\\\\n+    };\\\\n+    async.forEach = async.each;\\\\n+\\\\n+    async.eachSeries = function (arr, iterator, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (!arr.length) {\\\\n+            return callback();\\\\n+        }\\\\n+        var completed = 0;\\\\n+        var iterate = function () {\\\\n+            iterator(arr[completed], function (err) {\\\\n+                if (err) {\\\\n+                    callback(err);\\\\n+                    callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    completed += 1;\\\\n+                    if (completed >= arr.length) {\\\\n+                        callback();\\\\n+                    }\\\\n+                    else {\\\\n+                        iterate();\\\\n+                    }\\\\n+                }\\\\n+            });\\\\n+        };\\\\n+        iterate();\\\\n+    };\\\\n+    async.forEachSeries = async.eachSeries;\\\\n+\\\\n+    async.eachLimit = function (arr, limit, iterator, callback) {\\\\n+        var fn = _eachLimit(limit);\\\\n+        fn.apply(null, [arr, iterator, callback]);\\\\n+    };\\\\n+    async.forEachLimit = async.eachLimit;\\\\n+\\\\n+    var _eachLimit = function (limit) {\\\\n+\\\\n+        return function (arr, iterator, callback) {\\\\n+            callback = callback || function () {};\\\\n+            if (!arr.length || limit <= 0) {\\\\n+                return callback();\\\\n+            }\\\\n+            var completed = 0;\\\\n+            var started = 0;\\\\n+            var running = 0;\\\\n+\\\\n+            (function replenish () {\\\\n+                if (completed >= arr.length) {\\\\n+                    return callback();\\\\n+                }\\\\n+\\\\n+                while (running < limit && started < arr.length) {\\\\n+                    started += 1;\\\\n+                    running += 1;\\\\n+                    iterator(arr[started - 1], function (err) {\\\\n+                        if (err) {\\\\n+                            callback(err);\\\\n+                            callback = function () {};\\\\n+                        }\\\\n+                        else {\\\\n+                            completed += 1;\\\\n+                            running -= 1;\\\\n+                            if (completed >= arr.length) {\\\\n+                                callback();\\\\n+                            }\\\\n+                            else {\\\\n+                                replenish();\\\\n+                            }\\\\n+                        }\\\\n+                    });\\\\n+                }\\\\n+            })();\\\\n+        };\\\\n+    };\\\\n+\\\\n+\\\\n+    var doParallel = function (fn) {\\\\n+        return function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            return fn.apply(null, [async.each].concat(args));\\\\n+        };\\\\n+    };\\\\n+    var doParallelLimit = function(limit, fn) {\\\\n+        return function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            return fn.apply(null, [_eachLimit(limit)].concat(args));\\\\n+        };\\\\n+    };\\\\n+    var doSeries = function (fn) {\\\\n+        return function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            return fn.apply(null, [async.eachSeries].concat(args));\\\\n+        };\\\\n+    };\\\\n+\\\\n+\\\\n+    var _asyncMap = function (eachfn, arr, iterator, callback) {\\\\n+        arr = _map(arr, function (x, i) {\\\\n+            return {index: i, value: x};\\\\n+        });\\\\n+        if (!callback) {\\\\n+            eachfn(arr, function (x, callback) {\\\\n+                iterator(x.value, function (err) {\\\\n+                    callback(err);\\\\n+                });\\\\n+            });\\\\n+        } else {\\\\n+            var results = [];\\\\n+            eachfn(arr, function (x, callback) {\\\\n+                iterator(x.value, function (err, v) {\\\\n+                    results[x.index] = v;\\\\n+                    callback(err);\\\\n+                });\\\\n+            }, function (err) {\\\\n+                callback(err, results);\\\\n+            });\\\\n+        }\\\\n+    };\\\\n+    async.map = doParallel(_asyncMap);\\\\n+    async.mapSeries = doSeries(_asyncMap);\\\\n+    async.mapLimit = function (arr, limit, iterator, callback) {\\\\n+        return _mapLimit(limit)(arr, iterator, callback);\\\\n+    };\\\\n+\\\\n+    var _mapLimit = function(limit) {\\\\n+        return doParallelLimit(limit, _asyncMap);\\\\n+    };\\\\n+\\\\n+    // reduce only has a series version, as doing reduce in parallel won't\\\\n+    // work in many situations.\\\\n+    async.reduce = function (arr, memo, iterator, callback) {\\\\n+        async.eachSeries(arr, function (x, callback) {\\\\n+            iterator(memo, x, function (err, v) {\\\\n+                memo = v;\\\\n+                callback(err);\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(err, memo);\\\\n+        });\\\\n+    };\\\\n+    // inject alias\\\\n+    async.inject = async.reduce;\\\\n+    // foldl alias\\\\n+    async.foldl = async.reduce;\\\\n+\\\\n+    async.reduceRight = function (arr, memo, iterator, callback) {\\\\n+        var reversed = _map(arr, function (x) {\\\\n+            return x;\\\\n+        }).reverse();\\\\n+        async.reduce(reversed, memo, iterator, callback);\\\\n+    };\\\\n+    // foldr alias\\\\n+    async.foldr = async.reduceRight;\\\\n+\\\\n+    var _filter = function (eachfn, arr, iterator, callback) {\\\\n+        var results = [];\\\\n+        arr = _map(arr, function (x, i) {\\\\n+            return {index: i, value: x};\\\\n+        });\\\\n+        eachfn(arr, function (x, callback) {\\\\n+            iterator(x.value, function (v) {\\\\n+                if (v) {\\\\n+                    results.push(x);\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(_map(results.sort(function (a, b) {\\\\n+                return a.index - b.index;\\\\n+            }), function (x) {\\\\n+                return x.value;\\\\n+            }));\\\\n+        });\\\\n+    };\\\\n+    async.filter = doParallel(_filter);\\\\n+    async.filterSeries = doSeries(_filter);\\\\n+    // select alias\\\\n+    async.select = async.filter;\\\\n+    async.selectSeries = async.filterSeries;\\\\n+\\\\n+    var _reject = function (eachfn, arr, iterator, callback) {\\\\n+        var results = [];\\\\n+        arr = _map(arr, function (x, i) {\\\\n+            return {index: i, value: x};\\\\n+        });\\\\n+        eachfn(arr, function (x, callback) {\\\\n+            iterator(x.value, function (v) {\\\\n+                if (!v) {\\\\n+                    results.push(x);\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(_map(results.sort(function (a, b) {\\\\n+                return a.index - b.index;\\\\n+            }), function (x) {\\\\n+                return x.value;\\\\n+            }));\\\\n+        });\\\\n+    };\\\\n+    async.reject = doParallel(_reject);\\\\n+    async.rejectSeries = doSeries(_reject);\\\\n+\\\\n+    var _detect = function (eachfn, arr, iterator, main_callback) {\\\\n+        eachfn(arr, function (x, callback) {\\\\n+            iterator(x, function (result) {\\\\n+                if (result) {\\\\n+                    main_callback(x);\\\\n+                    main_callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    callback();\\\\n+                }\\\\n+            });\\\\n+        }, function (err) {\\\\n+            main_callback();\\\\n+        });\\\\n+    };\\\\n+    async.detect = doParallel(_detect);\\\\n+    async.detectSeries = doSeries(_detect);\\\\n+\\\\n+    async.some = function (arr, iterator, main_callback) {\\\\n+        async.each(arr, function (x, callback) {\\\\n+            iterator(x, function (v) {\\\\n+                if (v) {\\\\n+                    main_callback(true);\\\\n+                    main_callback = function () {};\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            main_callback(false);\\\\n+        });\\\\n+    };\\\\n+    // any alias\\\\n+    async.any = async.some;\\\\n+\\\\n+    async.every = function (arr, iterator, main_callback) {\\\\n+        async.each(arr, function (x, callback) {\\\\n+            iterator(x, function (v) {\\\\n+                if (!v) {\\\\n+                    main_callback(false);\\\\n+                    main_callback = function () {};\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            main_callback(true);\\\\n+        });\\\\n+    };\\\\n+    // all alias\\\\n+    async.all = async.every;\\\\n+\\\\n+    async.sortBy = function (arr, iterator, callback) {\\\\n+        async.map(arr, function (x, callback) {\\\\n+            iterator(x, function (err, criteria) {\\\\n+                if (err) {\\\\n+                    callback(err);\\\\n+                }\\\\n+                else {\\\\n+                    callback(null, {value: x, criteria: criteria});\\\\n+                }\\\\n+            });\\\\n+        }, function (err, results) {\\\\n+            if (err) {\\\\n+                return callback(err);\\\\n+            }\\\\n+            else {\\\\n+                var fn = function (left, right) {\\\\n+                    var a = left.criteria, b = right.criteria;\\\\n+                    return a < b ? -1 : a > b ? 1 : 0;\\\\n+                };\\\\n+                callback(null, _map(results.sort(fn), function (x) {\\\\n+                    return x.value;\\\\n+                }));\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.auto = function (tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        var keys = _keys(tasks);\\\\n+        var remainingTasks = keys.length\\\\n+        if (!remainingTasks) {\\\\n+            return callback();\\\\n+        }\\\\n+\\\\n+        var results = {};\\\\n+\\\\n+        var listeners = [];\\\\n+        var addListener = function (fn) {\\\\n+            listeners.unshift(fn);\\\\n+        };\\\\n+        var removeListener = function (fn) {\\\\n+            for (var i = 0; i < listeners.length; i += 1) {\\\\n+                if (listeners[i] === fn) {\\\\n+                    listeners.splice(i, 1);\\\\n+                    return;\\\\n+                }\\\\n+            }\\\\n+        };\\\\n+        var taskComplete = function () {\\\\n+            remainingTasks--\\\\n+            _each(listeners.slice(0), function (fn) {\\\\n+                fn();\\\\n+            });\\\\n+        };\\\\n+\\\\n+        addListener(function () {\\\\n+            if (!remainingTasks) {\\\\n+                var theCallback = callback;\\\\n+                // prevent final callback from calling itself if it errors\\\\n+                callback = function () {};\\\\n+\\\\n+                theCallback(null, results);\\\\n+            }\\\\n+        });\\\\n+\\\\n+        _each(keys, function (k) {\\\\n+            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\\\\n+            var taskCallback = function (err) {\\\\n+                var args = Array.prototype.slice.call(arguments, 1);\\\\n+                if (args.length <= 1) {\\\\n+                    args = args[0];\\\\n+                }\\\\n+                if (err) {\\\\n+                    var safeResults = {};\\\\n+                    _each(_keys(results), function(rkey) {\\\\n+                        safeResults[rkey] = results[rkey];\\\\n+                    });\\\\n+                    safeResults[k] = args;\\\\n+                    callback(err, safeResults);\\\\n+                    // stop subsequent errors hitting callback multiple times\\\\n+                    callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    results[k] = args;\\\\n+                    async.setImmediate(taskComplete);\\\\n+                }\\\\n+            };\\\\n+            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\\\\n+            var ready = function () {\\\\n+                return _reduce(requires, function (a, x) {\\\\n+                    return (a && results.hasOwnProperty(x));\\\\n+                }, true) && !results.hasOwnProperty(k);\\\\n+            };\\\\n+            if (ready()) {\\\\n+                task[task.length - 1](taskCallback, results);\\\\n+            }\\\\n+            else {\\\\n+                var listener = function () {\\\\n+                    if (ready()) {\\\\n+                        removeListener(listener);\\\\n+                        task[task.length - 1](taskCallback, results);\\\\n+                    }\\\\n+                };\\\\n+                addListener(listener);\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.retry = function(times, task, callback) {\\\\n+        var DEFAULT_TIMES = 5;\\\\n+        var attempts = [];\\\\n+        // Use defaults if times not passed\\\\n+        if (typeof times === 'function') {\\\\n+            callback = task;\\\\n+            task = times;\\\\n+            times = DEFAULT_TIMES;\\\\n+        }\\\\n+        // Make sure times is a number\\\\n+        times = parseInt(times, 10) || DEFAULT_TIMES;\\\\n+        var wrappedTask = function(wrappedCallback, wrappedResults) {\\\\n+            var retryAttempt = function(task, finalAttempt) {\\\\n+                return function(seriesCallback) {\\\\n+                    task(function(err, result){\\\\n+                        seriesCallback(!err || finalAttempt, {err: err, result: result});\\\\n+                    }, wrappedResults);\\\\n+                };\\\\n+            };\\\\n+            while (times) {\\\\n+                attempts.push(retryAttempt(task, !(times-=1)));\\\\n+            }\\\\n+            async.series(attempts, function(done, data){\\\\n+                data = data[data.length - 1];\\\\n+                (wrappedCallback || callback)(data.err, data.result);\\\\n+            });\\\\n+        }\\\\n+        // If a callback is passed, run this as a controll flow\\\\n+        return callback ? wrappedTask() : wrappedTask\\\\n+    };\\\\n+\\\\n+    async.waterfall = function (tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (!_isArray(tasks)) {\\\\n+          var err = new Error('First argument to waterfall must be an array of functions');\\\\n+          return callback(err);\\\\n+        }\\\\n+        if (!tasks.length) {\\\\n+            return callback();\\\\n+        }\\\\n+        var wrapIterator = function (iterator) {\\\\n+            return function (err) {\\\\n+                if (err) {\\\\n+                    callback.apply(null, arguments);\\\\n+                    callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\n+                    var next = iterator.next();\\\\n+                    if (next) {\\\\n+                        args.push(wrapIterator(next));\\\\n+                    }\\\\n+                    else {\\\\n+                        args.push(callback);\\\\n+                    }\\\\n+                    async.setImmediate(function () {\\\\n+                        iterator.apply(null, args);\\\\n+                    });\\\\n+                }\\\\n+            };\\\\n+        };\\\\n+        wrapIterator(async.iterator(tasks))();\\\\n+    };\\\\n+\\\\n+    var _parallel = function(eachfn, tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (_isArray(tasks)) {\\\\n+            eachfn.map(tasks, function (fn, callback) {\\\\n+                if (fn) {\\\\n+                    fn(function (err) {\\\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\\\n+                        if (args.length <= 1) {\\\\n+                            args = args[0];\\\\n+                        }\\\\n+                        callback.call(null, err, args);\\\\n+                    });\\\\n+                }\\\\n+            }, callback);\\\\n+        }\\\\n+        else {\\\\n+            var results = {};\\\\n+            eachfn.each(_keys(tasks), function (k, callback) {\\\\n+                tasks[k](function (err) {\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\n+                    if (args.length <= 1) {\\\\n+                        args = args[0];\\\\n+                    }\\\\n+                    results[k] = args;\\\\n+                    callback(err);\\\\n+                });\\\\n+            }, function (err) {\\\\n+                callback(err, results);\\\\n+            });\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.parallel = function (tasks, callback) {\\\\n+        _parallel({ map: async.map, each: async.each }, tasks, callback);\\\\n+    };\\\\n+\\\\n+    async.parallelLimit = function(tasks, limit, callback) {\\\\n+        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\\\\n+    };\\\\n+\\\\n+    async.series = function (tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (_isArray(tasks)) {\\\\n+            async.mapSeries(tasks, function (fn, callback) {\\\\n+                if (fn) {\\\\n+                    fn(function (err) {\\\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\\\n+                        if (args.length <= 1) {\\\\n+                            args = args[0];\\\\n+                        }\\\\n+                        callback.call(null, err, args);\\\\n+                    });\\\\n+                }\\\\n+            }, callback);\\\\n+        }\\\\n+        else {\\\\n+            var results = {};\\\\n+            async.eachSeries(_keys(tasks), function (k, callback) {\\\\n+                tasks[k](function (err) {\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\n+                    if (args.length <= 1) {\\\\n+                        args = args[0];\\\\n+                    }\\\\n+                    results[k] = args;\\\\n+                    callback(err);\\\\n+                });\\\\n+            }, function (err) {\\\\n+                callback(err, results);\\\\n+            });\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.iterator = function (tasks) {\\\\n+        var makeCallback = function (index) {\\\\n+            var fn = function () {\\\\n+                if (tasks.length) {\\\\n+                    tasks[index].apply(null, arguments);\\\\n+                }\\\\n+                return fn.next();\\\\n+            };\\\\n+            fn.next = function () {\\\\n+                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\\\\n+            };\\\\n+            return fn;\\\\n+        };\\\\n+        return makeCallback(0);\\\\n+    };\\\\n+\\\\n+    async.apply = function (fn) {\\\\n+        var args = Array.prototype.slice.call(arguments, 1);\\\\n+        return function () {\\\\n+            return fn.apply(\\\\n+                null, args.concat(Array.prototype.slice.call(arguments))\\\\n+            );\\\\n+        };\\\\n+    };\\\\n+\\\\n+    var _concat = function (eachfn, arr, fn, callback) {\\\\n+        var r = [];\\\\n+        eachfn(arr, function (x, cb) {\\\\n+            fn(x, function (err, y) {\\\\n+                r = r.concat(y || []);\\\\n+                cb(err);\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(err, r);\\\\n+        });\\\\n+    };\\\\n+    async.concat = doParallel(_concat);\\\\n+    async.concatSeries = doSeries(_concat);\\\\n+\\\\n+    async.whilst = function (test, iterator, callback) {\\\\n+        if (test()) {\\\\n+            iterator(function (err) {\\\\n+                if (err) {\\\\n+                    return callback(err);\\\\n+                }\\\\n+                async.whilst(test, iterator, callback);\\\\n+            });\\\\n+        }\\\\n+        else {\\\\n+            callback();\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.doWhilst = function (iterator, test, callback) {\\\\n+        iterator(function (err) {\\\\n+            if (err) {\\\\n+                return callback(err);\\\\n+            }\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\n+            if (test.apply(null, args)) {\\\\n+                async.doWhilst(iterator, test, callback);\\\\n+            }\\\\n+            else {\\\\n+                callback();\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.until = function (test, iterator, callback) {\\\\n+        if (!test()) {\\\\n+            iterator(function (err) {\\\\n+                if (err) {\\\\n+                    return callback(err);\\\\n+                }\\\\n+                async.until(test, iterator, callback);\\\\n+            });\\\\n+        }\\\\n+        else {\\\\n+            callback();\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.doUntil = function (iterator, test, callback) {\\\\n+        iterator(function (err) {\\\\n+            if (err) {\\\\n+                return callback(err);\\\\n+            }\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\n+            if (!test.apply(null, args)) {\\\\n+                async.doUntil(iterator, test, callback);\\\\n+            }\\\\n+            else {\\\\n+                callback();\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.queue = function (worker, concurrency) {\\\\n+        if (concurrency === undefined) {\\\\n+            concurrency = 1;\\\\n+        }\\\\n+        function _insert(q, data, pos, callback) {\\\\n+          if (!q.started){\\\\n+            q.started = true;\\\\n+          }\\\\n+          if (!_isArray(data)) {\\\\n+              data = [data];\\\\n+          }\\\\n+          if(data.length == 0) {\\\\n+             // call drain immediately if there are no tasks\\\\n+             return async.setImmediate(function() {\\\\n+                 if (q.drain) {\\\\n+                     q.drain();\\\\n+                 }\\\\n+             });\\\\n+          }\\\\n+          _each(data, function(task) {\\\\n+              var item = {\\\\n+                  data: task,\\\\n+                  callback: typeof callback === 'function' ? callback : null\\\\n+              };\\\\n+\\\\n+              if (pos) {\\\\n+                q.tasks.unshift(item);\\\\n+              } else {\\\\n+                q.tasks.push(item);\\\\n+              }\\\\n+\\\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\\\n+                  q.saturated();\\\\n+              }\\\\n+              async.setImmediate(q.process);\\\\n+          });\\\\n+        }\\\\n+\\\\n+        var workers = 0;\\\\n+        var q = {\\\\n+            tasks: [],\\\\n+            concurrency: concurrency,\\\\n+            saturated: null,\\\\n+            empty: null,\\\\n+            drain: null,\\\\n+            started: false,\\\\n+            paused: false,\\\\n+            push: function (data, callback) {\\\\n+              _insert(q, data, false, callback);\\\\n+            },\\\\n+            kill: function () {\\\\n+              q.drain = null;\\\\n+              q.tasks = [];\\\\n+            },\\\\n+            unshift: function (data, callback) {\\\\n+              _insert(q, data, true, callback);\\\\n+            },\\\\n+            process: function () {\\\\n+                if (!q.paused && workers < q.concurrency && q.tasks.length) {\\\\n+                    var task = q.tasks.shift();\\\\n+                    if (q.empty && q.tasks.length === 0) {\\\\n+                        q.empty();\\\\n+                    }\\\\n+                    workers += 1;\\\\n+                    var next = function () {\\\\n+                        workers -= 1;\\\\n+                        if (task.callback) {\\\\n+                            task.callback.apply(task, arguments);\\\\n+                        }\\\\n+                        if (q.drain && q.tasks.length + workers === 0) {\\\\n+                            q.drain();\\\\n+                        }\\\\n+                        q.process();\\\\n+                    };\\\\n+                    var cb = only_once(next);\\\\n+                    worker(task.data, cb);\\\\n+                }\\\\n+            },\\\\n+            length: function () {\\\\n+                return q.tasks.length;\\\\n+            },\\\\n+            running: function () {\\\\n+                return workers;\\\\n+            },\\\\n+            idle: function() {\\\\n+                return q.tasks.length + workers === 0;\\\\n+            },\\\\n+            pause: function () {\\\\n+                if (q.paused === true) { return; }\\\\n+                q.paused = true;\\\\n+                q.process();\\\\n+            },\\\\n+            resume: function () {\\\\n+                if (q.paused === false) { return; }\\\\n+                q.paused = false;\\\\n+                q.process();\\\\n+            }\\\\n+        };\\\\n+        return q;\\\\n+    };\\\\n+    \\\\n+    async.priorityQueue = function (worker, concurrency) {\\\\n+        \\\\n+        function _compareTasks(a, b){\\\\n+          return a.priority - b.priority;\\\\n+        };\\\\n+        \\\\n+        function _binarySearch(sequence, item, compare) {\\\\n+          var beg = -1,\\\\n+              end = sequence.length - 1;\\\\n+          while (beg < end) {\\\\n+            var mid = beg + ((end - beg + 1) >>> 1);\\\\n+            if (compare(item, sequence[mid]) >= 0) {\\\\n+              beg = mid;\\\\n+            } else {\\\\n+              end = mid - 1;\\\\n+            }\\\\n+          }\\\\n+          return beg;\\\\n+        }\\\\n+        \\\\n+        function _insert(q, data, priority, callback) {\\\\n+          if (!q.started){\\\\n+            q.started = true;\\\\n+          }\\\\n+          if (!_isArray(data)) {\\\\n+              data = [data];\\\\n+          }\\\\n+          if(data.length == 0) {\\\\n+             // call drain immediately if there are no tasks\\\\n+             return async.setImmediate(function() {\\\\n+                 if (q.drain) {\\\\n+                     q.drain();\\\\n+                 }\\\\n+             });\\\\n+          }\\\\n+          _each(data, function(task) {\\\\n+              var item = {\\\\n+                  data: task,\\\\n+                  priority: priority,\\\\n+                  callback: typeof callback === 'function' ? callback : null\\\\n+              };\\\\n+              \\\\n+              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\\\\n+\\\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\\\n+                  q.saturated();\\\\n+              }\\\\n+              async.setImmediate(q.process);\\\\n+          });\\\\n+        }\\\\n+        \\\\n+        // Start with a normal queue\\\\n+        var q = async.queue(worker, concurrency);\\\\n+        \\\\n+        // Override push to accept second parameter representing priority\\\\n+        q.push = function (data, priority, callback) {\\\\n+          _insert(q, data, priority, callback);\\\\n+        };\\\\n+        \\\\n+        // Remove unshift function\\\\n+        delete q.unshift;\\\\n+\\\\n+        return q;\\\\n+    };\\\\n+\\\\n+    async.cargo = function (worker, payload) {\\\\n+        var working     = false,\\\\n+            tasks       = [];\\\\n+\\\\n+        var cargo = {\\\\n+            tasks: tasks,\\\\n+            payload: payload,\\\\n+            saturated: null,\\\\n+            empty: null,\\\\n+            drain: null,\\\\n+            drained: true,\\\\n+            push: function (data, callback) {\\\\n+                if (!_isArray(data)) {\\\\n+                    data = [data];\\\\n+                }\\\\n+                _each(data, function(task) {\\\\n+                    tasks.push({\\\\n+                        data: task,\\\\n+                        callback: typeof callback === 'function' ? callback : null\\\\n+                    });\\\\n+                    cargo.drained = false;\\\\n+                    if (cargo.saturated && tasks.length === payload) {\\\\n+                        cargo.saturated();\\\\n+                    }\\\\n+                });\\\\n+                async.setImmediate(cargo.process);\\\\n+            },\\\\n+            process: function process() {\\\\n+                if (working) return;\\\\n+                if (tasks.length === 0) {\\\\n+                    if(cargo.drain && !cargo.drained) cargo.drain();\\\\n+                    cargo.drained = true;\\\\n+                    return;\\\\n+                }\\\\n+\\\\n+                var ts = typeof payload === 'number'\\\\n+                            ? tasks.splice(0, payload)\\\\n+                            : tasks.splice(0, tasks.length);\\\\n+\\\\n+                var ds = _map(ts, function (task) {\\\\n+                    return task.data;\\\\n+                });\\\\n+\\\\n+                if(cargo.empty) cargo.empty();\\\\n+                working = true;\\\\n+                worker(ds, function () {\\\\n+                    working = false;\\\\n+\\\\n+                    var args = arguments;\\\\n+                    _each(ts, function (data) {\\\\n+                        if (data.callback) {\\\\n+                            data.callback.apply(null, args);\\\\n+                        }\\\\n+                    });\\\\n+\\\\n+                    process();\\\\n+                });\\\\n+            },\\\\n+            length: function () {\\\\n+                return tasks.length;\\\\n+            },\\\\n+            running: function () {\\\\n+                return working;\\\\n+            }\\\\n+        };\\\\n+        return cargo;\\\\n+    };\\\\n+\\\\n+    var _console_fn = function (name) {\\\\n+        return function (fn) {\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\n+            fn.apply(null, args.concat([function (err) {\\\\n+                var args = Array.prototype.slice.call(arguments, 1);\\\\n+                if (typeof console !== 'undefined') {\\\\n+                    if (err) {\\\\n+                        if (console.error) {\\\\n+                            console.error(err);\\\\n+                        }\\\\n+                    }\\\\n+                    else if (console[name]) {\\\\n+                        _each(args, function (x) {\\\\n+                            console[name](x);\\\\n+                        });\\\\n+                    }\\\\n+                }\\\\n+            }]));\\\\n+        };\\\\n+    };\\\\n+    async.log = _console_fn('log');\\\\n+    async.dir = _console_fn('dir');\\\\n+    /*async.info = _console_fn('info');\\\\n+    async.warn = _console_fn('warn');\\\\n+    async.error = _console_fn('error');*/\\\\n+\\\\n+    async.memoize = function (fn, hasher) {\\\\n+        var memo = {};\\\\n+        var queues = {};\\\\n+        hasher = hasher || function (x) {\\\\n+            return x;\\\\n+        };\\\\n+        var memoized = function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            var callback = args.pop();\\\\n+            var key = hasher.apply(null, args);\\\\n+            if (key in memo) {\\\\n+                async.nextTick(function () {\\\\n+                    callback.apply(null, memo[key]);\\\\n+                });\\\\n+            }\\\\n+            else if (key in queues) {\\\\n+                queues[key].push(callback);\\\\n+            }\\\\n+            else {\\\\n+                queues[key] = [callback];\\\\n+                fn.apply(null, args.concat([function () {\\\\n+                    memo[key] = arguments;\\\\n+                    var q = queues[key];\\\\n+                    delete queues[key];\\\\n+                    for (var i = 0, l = q.length; i < l; i++) {\\\\n+                      q[i].apply(null, arguments);\\\\n+                    }\\\\n+                }]));\\\\n+            }\\\\n+        };\\\\n+        memoized.memo = memo;\\\\n+        memoized.unmemoized = fn;\\\\n+        return memoized;\\\\n+    };\\\\n+\\\\n+    async.unmemoize = function (fn) {\\\\n+      return function () {\\\\n+        return (fn.unmemoized || fn).apply(null, arguments);\\\\n+      };\\\\n+    };\\\\n+\\\\n+    async.times = function (count, iterator, callback) {\\\\n+        var counter = [];\\\\n+        for (var i = 0; i < count; i++) {\\\\n+            counter.push(i);\\\\n+        }\\\\n+        return async.map(counter, iterator, callback);\\\\n+    };\\\\n+\\\\n+    async.timesSeries = function (count, iterator, callback) {\\\\n+        var counter = [];\\\\n+        for (var i = 0; i < count; i++) {\\\\n+            counter.push(i);\\\\n+        }\\\\n+        return async.mapSeries(counter, iterator, callback);\\\\n+    };\\\\n+\\\\n+    async.seq = function (/* functions... */) {\\\\n+        var fns = arguments;\\\\n+        return function () {\\\\n+            var that = this;\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            var callback = args.pop();\\\\n+            async.reduce(fns, args, function (newargs, fn, cb) {\\\\n+                fn.apply(that, newargs.concat([function () {\\\\n+                    var err = arguments[0];\\\\n+                    var nextargs = Array.prototype.slice.call(arguments, 1);\\\\n+                    cb(err, nextargs);\\\\n+                }]))\\\\n+            },\\\\n+            function (err, results) {\\\\n+                callback.apply(that, [err].concat(results));\\\\n+            });\\\\n+        };\\\\n+    };\\\\n+\\\\n+    async.compose = function (/* functions... */) {\\\\n+      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\\\\n+    };\\\\n+\\\\n+    var _applyEach = function (eachfn, fns /*args...*/) {\\\\n+        var go = function () {\\\\n+            var that = this;\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            var callback = args.pop();\\\\n+            return eachfn(fns, function (fn, cb) {\\\\n+                fn.apply(that, args.concat([cb]));\\\\n+            },\\\\n+            callback);\\\\n+        };\\\\n+        if (arguments.length > 2) {\\\\n+            var args = Array.prototype.slice.call(arguments, 2);\\\\n+            return go.apply(this, args);\\\\n+        }\\\\n+        else {\\\\n+            return go;\\\\n+        }\\\\n+    };\\\\n+    async.applyEach = doParallel(_applyEach);\\\\n+    async.applyEachSeries = doSeries(_applyEach);\\\\n+\\\\n+    async.forever = function (fn, callback) {\\\\n+        function next(err) {\\\\n+            if (err) {\\\\n+                if (callback) {\\\\n+                    return callback(err);\\\\n+                }\\\\n+                throw err;\\\\n+            }\\\\n+            fn(next);\\\\n+        }\\\\n+        next();\\\\n+    };\\\\n+\\\\n+    // Node.js\\\\n+    if (typeof module !== 'undefined' && module.exports) {\\\\n+        module.exports = async;\\\\n+    }\\\\n+    // AMD / RequireJS\\\\n+    else if (typeof define !== 'undefined' && define.amd) {\\\\n+        define([], function () {\\\\n+            return async;\\\\n+        });\\\\n+    }\\\\n+    // included directly via <script> tag\\\\n+    else {\\\\n+        root.async = async;\\\\n+    }\\\\n+\\\\n+}());\\\\ndiff --git a/node_modules/async/package.json b/node_modules/async/package.json\\\\nnew file mode 100644\\\\nindex 0000000..31a5200\\\\n--- /dev/null\\\\n+++ b/node_modules/async/package.json\\\\n@@ -0,0 +1,59 @@\\\\n+{\\\\n+  \\\\\\\"name\\\\\\\": \\\\\\\"async\\\\\\\",\\\\n+  \\\\\\\"description\\\\\\\": \\\\\\\"Higher-order functions and common patterns for asynchronous code\\\\\\\",\\\\n+  \\\\\\\"main\\\\\\\": \\\\\\\"./lib/async\\\\\\\",\\\\n+  \\\\\\\"author\\\\\\\": {\\\\n+    \\\\\\\"name\\\\\\\": \\\\\\\"Caolan McMahon\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"version\\\\\\\": \\\\\\\"0.9.0\\\\\\\",\\\\n+  \\\\\\\"repository\\\\\\\": {\\\\n+    \\\\\\\"type\\\\\\\": \\\\\\\"git\\\\\\\",\\\\n+    \\\\\\\"url\\\\\\\": \\\\\\\"https://github.com/caolan/async.git\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"bugs\\\\\\\": {\\\\n+    \\\\\\\"url\\\\\\\": \\\\\\\"https://github.com/caolan/async/issues\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"licenses\\\\\\\": [\\\\n+    {\\\\n+      \\\\\\\"type\\\\\\\": \\\\\\\"MIT\\\\\\\",\\\\n+      \\\\\\\"url\\\\\\\": \\\\\\\"https://github.com/caolan/async/raw/master/LICENSE\\\\\\\"\\\\n+    }\\\\n+  ],\\\\n+  \\\\\\\"devDependencies\\\\\\\": {\\\\n+    \\\\\\\"nodeunit\\\\\\\": \\\\\\\">0.0.0\\\\\\\",\\\\n+    \\\\\\\"uglify-js\\\\\\\": \\\\\\\"1.2.x\\\\\\\",\\\\n+    \\\\\\\"nodelint\\\\\\\": \\\\\\\">0.0.0\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"jam\\\\\\\": {\\\\n+    \\\\\\\"main\\\\\\\": \\\\\\\"lib/async.js\\\\\\\",\\\\n+    \\\\\\\"include\\\\\\\": [\\\\n+      \\\\\\\"lib/async.js\\\\\\\",\\\\n+      \\\\\\\"README.md\\\\\\\",\\\\n+      \\\\\\\"LICENSE\\\\\\\"\\\\n+    ]\\\\n+  },\\\\n+  \\\\\\\"scripts\\\\\\\": {\\\\n+    \\\\\\\"test\\\\\\\": \\\\\\\"nodeunit test/test-async.js\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"homepage\\\\\\\": \\\\\\\"https://github.com/caolan/async\\\\\\\",\\\\n+  \\\\\\\"_id\\\\\\\": \\\\\\\"async@0.9.0\\\\\\\",\\\\n+  \\\\\\\"dist\\\\\\\": {\\\\n+    \\\\\\\"shasum\\\\\\\": \\\\\\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\\\\\",\\\\n+    \\\\\\\"tarball\\\\\\\": \\\\\\\"http://registry.npmjs.org/async/-/async-0.9.0.tgz\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"_from\\\\\\\": \\\\\\\"async@*\\\\\\\",\\\\n+  \\\\\\\"_npmVersion\\\\\\\": \\\\\\\"1.4.3\\\\\\\",\\\\n+  \\\\\\\"_npmUser\\\\\\\": {\\\\n+    \\\\\\\"name\\\\\\\": \\\\\\\"caolan\\\\\\\",\\\\n+    \\\\\\\"email\\\\\\\": \\\\\\\"caolan.mcmahon@gmail.com\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"maintainers\\\\\\\": [\\\\n+    {\\\\n+      \\\\\\\"name\\\\\\\": \\\\\\\"caolan\\\\\\\",\\\\n+      \\\\\\\"email\\\\\\\": \\\\\\\"caolan@caolanmcmahon.com\\\\\\\"\\\\n+    }\\\\n+  ],\\\\n+  \\\\\\\"directories\\\\\\\": {},\\\\n+  \\\\\\\"_shasum\\\\\\\": \\\\\\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\\\\\",\\\\n+  \\\\\\\"_resolved\\\\\\\": \\\\\\\"https://registry.npmjs.org/async/-/async-0.9.0.tgz\\\\\\\"\\\\n+}\\\\ndiff --git a/package.json b/package.json\\\\nindex 5f21627..6033d43 100644\\\\n--- a/package.json\\\\n+++ b/package.json\\\\n@@ -4,7 +4,8 @@\\\\n   \\\\\\\"description\\\\\\\": \\\\\\\"Sous project\\\\\\\",\\\\n   \\\\\\\"main\\\\\\\": \\\\\\\"main.js\\\\\\\",\\\\n   \\\\\\\"dependencies\\\\\\\": {\\\\n-},\\\\n+    \\\\\\\"async\\\\\\\": \\\\\\\"*\\\\\\\"\\\\n+  },\\\\n   \\\\\\\"devDependencies\\\\\\\": {},\\\\n   \\\\\\\"scripts\\\\\\\": {\\\\n     \\\\\\\"test\\\\\\\": \\\\\\\"echo \\\\\\\\\\\\\\\"Error: no test specified\\\\\\\\\\\\\\\" && exit 1\\\\\\\"\\\\ndiff --git a/patches.sousp b/patches.sousp\\\\nindex 16405a3..d71e511 100644\\\\n--- a/patches.sousp\\\\n+++ b/patches.sousp\\\\n@@ -1,31 +1 @@\\\\n-diff --git a/main.js b/main.js\\\\n-index f81b54e..744cdd5 100644\\\\n---- a/main.js\\\\n-+++ b/main.js\\\\n-@@ -35,7 +35,7 @@ fs.exists('.git', function (exists) {\\\\n-         cp.exec('git diff', function(error, stdout, stderr) {\\\\n-             console.log(stdout);\\\\n- \\\\n--            //fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", stdout);\\\\n-+            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", stdout);\\\\n- \\\\n-             if (error !== null) {\\\\n-                 console.log('stderr: ' + stderr);\\\\n-@@ -44,7 +44,7 @@ fs.exists('.git', function (exists) {\\\\n-         });\\\\n- \\\\n-         cp.exec('git log', function(error, stdout, stderr) {\\\\n--            //console.log(stdout);\\\\n-+            console.log(stdout);\\\\n- \\\\n-             var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n-             var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n-@@ -53,7 +53,7 @@ fs.exists('.git', function (exists) {\\\\n-             console.log(comments);\\\\n-             console.log(dates);\\\\n- \\\\n--            //fs.writeFileSync(\\\\\\\"comments.sousc\\\\\\\", stdout);\\\\n-+            fs.writeFileSync(\\\\\\\"comments.sousc\\\\\\\", stdout);\\\\n- \\\\n-             if (error !== null) {\\\\n-                 console.log('stderr: ' + stderr);\\\\n+[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]\\\\n\\\\\\\\ No newline at end of file\\\\ndiff --git a/test.js b/test.js\\\\nnew file mode 100644\\\\nindex 0000000..5ca759c\\\\n--- /dev/null\\\\n+++ b/test.js\\\\n@@ -0,0 +1,21 @@\\\\n+/**\\\\n+ * Created by Nick on 18.05.2015.\\\\n+ */\\\\n+var async = require('async')\\\\n+    , tasksIndex = [\\\\n+        function (callback) {\\\\n+            // Вымышленный метод который вернет 231\\\\n+            var viewsNumber = models.stat.viewsNumber();\\\\n+            callback(null, viewsNumber);\\\\n+        }\\\\n+        , function (callback) {\\\\n+            // Вымышленный метод который вернет 24\\\\n+            var growFactor = models.stat.growFactor();\\\\n+            callback(null, growFactor);\\\\n+        }\\\\n+    ];\\\\n+\\\\n+async.series(tasksIndex, function (err, results) {\\\\n+    // Результат будет массивом\\\\n+    console.log(results); // [231, 24]\\\\n+});\\\\n\\\\\\\\ No newline at end of file\\\\n\\\"}\\n\\\\ No newline at end of file\\n\"}\n\\ No newline at end of file\n"},{"commit":"56fce414fd6d0a1ae19657db7fdf95d5636ea5dc","author":"NickStepanenko <massaalonso@yandex.ru>","date":"Sun May 24 00:41:35 2015 +0800","comment":"NexState function added.","content":"diff --git a/.gitignore b/.gitignore\nindex 723ef36..42ccb02 100644\n--- a/.gitignore\n+++ b/.gitignore\n@@ -1 +1,7 @@\n-.idea\n\\ No newline at end of file\n+.idea\n+node_modules\n+patches.sousp\n+comments.sousc\n+package.json\n+README.md\n+test.js\n\\ No newline at end of file\ndiff --git a/comments.sousc b/comments.sousc\ndeleted file mode 100644\nindex cb3a850..0000000\n--- a/comments.sousc\n+++ /dev/null\n@@ -1,47 +0,0 @@\n-commit 4420cabefc1f470af341af11ed595df67e25c51f\n-Author: Nick Stepanenko <massaalonso@yandex.ru>\n-Date:   Sun May 17 17:05:35 2015 +0800\n-\n-    Paste old program code\n-\n-commit 9ef3d25fd4c3afdbcc3107a0abf6d7a2e29cb4dd\n-Author: Nick Stepanenko <massaalonso@yandex.ru>\n-Date:   Sun May 17 17:04:52 2015 +0800\n-\n-    Adding new file\n-\n-commit 64814d140d2fab6ae153cac485008119f29bf230\n-Author: Nick Stepanenko <massaalonso@yandex.ru>\n-Date:   Sun May 17 17:03:58 2015 +0800\n-\n-    From clear list\n-\n-commit c9d318fea74ea288d544ecf72f00b12c130cf2ef\n-Author: Nick Stepanenko <massaalonso@yandex.ru>\n-Date:   Sun May 17 16:59:40 2015 +0800\n-\n-    Create system files\n-\n-commit e3c853a4282dfe8f000685dc1d39bd55a4a946c4\n-Author: Nick Stepanenko <massaalonso@yandex.ru>\n-Date:   Sun May 17 16:54:58 2015 +0800\n-\n-    Recovered main.js\n-\n-commit be4929d2307043334b29b872760f31b1f2387a10\n-Author: Nick Stepanenko <massaalonso@yandex.ru>\n-Date:   Sun May 17 16:54:24 2015 +0800\n-\n-    Clean main.js\n-\n-commit bd0049f4d0639be5d3ff5f666c2568c7008cdaef\n-Author: Nick Stepanenko <massaalonso@yandex.ru>\n-Date:   Sun May 17 16:46:31 2015 +0800\n-\n-    New commit\n-\n-commit 8e1ca32cec51a8884adff9ff63ad53f459ce5d8c\n-Author: Nick <massaalonso@yandex.ru>\n-Date:   Sun May 17 16:40:02 2015 +0800\n-\n-    Initial commit\ndiff --git a/main.js b/main.js\nindex eaf537f..27d3215 100644\n--- a/main.js\n+++ b/main.js\n@@ -7,6 +7,57 @@ var cp = require('child_process');\n \n var async = require('async');\n \n+function readyStringToJSON(stringData) {\n+    var obj = {};\n+    var data = stringData.split(',\"');\n+\n+    obj.commit = data[0].slice(data[0].indexOf(':')+2, data[0].length-1);\n+    obj.author = data[1].slice(data[1].indexOf(':')+2, data[1].length-1);\n+    obj.date = data[2].slice(data[2].indexOf(':')+2, data[2].length-1);\n+    obj.comment = data[3].slice(data[3].indexOf(':')+2, data[3].length-1);\n+    obj.content = data[4].slice(data[4].indexOf(':')+2, data[4].length-1);\n+\n+    return obj;\n+}\n+\n+function nextState(commitNum, direction) {\n+    var data = fs.readFileSync('patches.sousp').toString().split('},{\"');\n+    var newState = {};\n+\n+    for(i=0; i<data.length; i++) {\n+        if(i==0) {\n+            data[i] = data[i].slice(1);\n+        } else if(i!=data.length-1) {\n+            data[i] = '\"' + data[i];\n+        } else if(i==data.length-1) {\n+            data[i] = '\"' + data[i].slice(0, data[i].length-2);\n+        }\n+        data[i] = readyStringToJSON(data[i]);\n+    }\n+\n+    console.log(data);\n+\n+    for(i=0; i<data.length; i++) {\n+        if(data[i].commit == commitNum) {\n+            if(direction == \"Next\") {\n+                newState.commit = data[i+1].commit;\n+                newState.author = data[i+1].author;\n+                newState.date = data[i+1].date;\n+                newState.comment = data[i+1].comment;\n+                newState.content = data[i+1].content;\n+            } else if(direction == \"Back\") {\n+                newState.commit = data[i-1].commit;\n+                newState.author = data[i-1].author;\n+                newState.date = data[i-1].date;\n+                newState.comment = data[i-1].comment;\n+                newState.content = data[i-1].content;\n+            }\n+        }\n+    }\n+\n+    return(newState);\n+}\n+\n function findData(text, keyword) {\n     var data = [];\n     var splittext = text.split('\\n');\n@@ -86,9 +137,15 @@ fs.exists('.git', function (exists) {\n                 callback(null, commitsData);\n             }\n         ], function (err, result) {\n+            var data = [];\n+\n             for(i=0; i<result.length; i++) {\n-                fs.writeFileSync(\"patches.sousp\", JSON.stringify(result[i]));\n+                data[i] = JSON.stringify(result[i]);\n             }\n+\n+            fs.writeFileSync(\"patches.sousp\", data);\n+\n+            console.log(nextState(\"1e947f613e976945de85ae35ed923aa470f0be72\"));\n         });\n     }\n });\ndiff --git a/patches.sousp b/patches.sousp\nindex 11aa280..ce0b4a4 100644\n--- a/patches.sousp\n+++ b/patches.sousp\n@@ -1 +1 @@\n-{\"commit\":\"dbe72b9889081e5856c1e2d72723e8ab2dc898bd\",\"author\":\"Nick Stepanenko <massaalonso@yandex.ru>\",\"date\":\"Tue May 19 01:41:21 2015 +0800\",\"comment\":\"Content will be added now.\",\"content\":\"diff --git a/main.js b/main.js\\nindex 86f30c2..ca7473f 100644\\n--- a/main.js\\n+++ b/main.js\\n@@ -148,7 +148,9 @@ fs.exists('.git', function (exists) {\\n                         listOfCommits[listOfCommits.length] = commit;\\n                     }\\n \\n-                    callback(null, listOfCommits.reverse());\\n+                    var commitsData = listOfCommits.reverse();\\n+\\n+                    callback(null, commitsData);\\n \\n                     if (error !== null) {\\n                         console.log('stderr: ' + stderr);\\n@@ -157,27 +159,18 @@ fs.exists('.git', function (exists) {\\n                 });\\n             },\\n             function getCommitsContent(commits, callback) {\\n-                console.log(commits);\\n                 var commitsData = commits;\\n \\n                 for(i=1; i<commitsData.length; i++) {\\n-                    cp.exec('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit, function(error, stdout, stderr) {\\n-                        commitsData[i].content = stdout;\\n-\\n-                        if (error !== null) {\\n-                            console.log('stderr: ' + stderr);\\n-                            console.log('exec error: ' + error);\\n-                        }\\n-                    });\\n+                    commitsData[i].content = cp.execSync('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit).toString('utf8');\\n                 }\\n \\n                 callback(null, commitsData);\\n             }\\n         ], function (err, result) {\\n-            fs.writeFileSync(\\\"patches.sousp\\\", result);\\n+            for(i=0; i<result.length; i++) {\\n+                fs.writeFileSync(\\\"patches.sousp\\\", JSON.stringify(result[i]));\\n+            }\\n         });\\n-\\n-        //commitsInfo = JSON.parse(fs.readFileSync(\\\"patches.sousp\\\"));\\n-        //console.log(commitsInfo);\\n     }\\n });\\n\\\\ No newline at end of file\\ndiff --git a/patches.sousp b/patches.sousp\\nindex d71e511..300c6a9 100644\\n--- a/patches.sousp\\n+++ b/patches.sousp\\n@@ -1 +1 @@\\n-[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]\\n\\\\ No newline at end of file\\n+{\\\"commit\\\":\\\"1e947f613e976945de85ae35ed923aa470f0be72\\\",\\\"author\\\":\\\"Nick Stepanenko <massaalonso@yandex.ru>\\\",\\\"date\\\":\\\"Tue May 19 00:12:12 2015 +0800\\\",\\\"comment\\\":\\\"Latest updates\\\",\\\"content\\\":\\\"diff --git a/comments.sousc b/comments.sousc\\\\nindex 150b0f6..cb3a850 100644\\\\n--- a/comments.sousc\\\\n+++ b/comments.sousc\\\\n@@ -1,3 +1,27 @@\\\\n+commit 4420cabefc1f470af341af11ed595df67e25c51f\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 17:05:35 2015 +0800\\\\n+\\\\n+    Paste old program code\\\\n+\\\\n+commit 9ef3d25fd4c3afdbcc3107a0abf6d7a2e29cb4dd\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 17:04:52 2015 +0800\\\\n+\\\\n+    Adding new file\\\\n+\\\\n+commit 64814d140d2fab6ae153cac485008119f29bf230\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 17:03:58 2015 +0800\\\\n+\\\\n+    From clear list\\\\n+\\\\n+commit c9d318fea74ea288d544ecf72f00b12c130cf2ef\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 16:59:40 2015 +0800\\\\n+\\\\n+    Create system files\\\\n+\\\\n commit e3c853a4282dfe8f000685dc1d39bd55a4a946c4\\\\n Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n Date:   Sun May 17 16:54:58 2015 +0800\\\\ndiff --git a/main.js b/main.js\\\\nindex e34dc18..86f30c2 100644\\\\n--- a/main.js\\\\n+++ b/main.js\\\\n@@ -3,6 +3,56 @@\\\\n  */\\\\n \\\\n var fs = require('fs');\\\\n+var cp = require('child_process');\\\\n+var data = [];\\\\n+\\\\n+var async = require('async');\\\\n+    /*tasks = [\\\\n+        function (callback) {\\\\n+            cp.exec('git log', function(error, stdout, stderr) {\\\\n+                var listOfCommits = [];\\\\n+                var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n+                var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n+                var comments = findComments(stdout);\\\\n+                var commitNumbers = findCommitNumbers(stdout);\\\\n+\\\\n+                for(i=0; i<authors.length; i++) {\\\\n+                    var commit = {\\\\n+                        \\\\\\\"commit\\\\\\\": commitNumbers[i],\\\\n+                        \\\\\\\"author\\\\\\\": authors[i],\\\\n+                        \\\\\\\"date\\\\\\\": dates[i],\\\\n+                        \\\\\\\"comment\\\\\\\": comments[i],\\\\n+                        \\\\\\\"content\\\\\\\": 'Original'\\\\n+                    };\\\\n+\\\\n+                    listOfCommits[listOfCommits.length] = commit;\\\\n+                }\\\\n+\\\\n+                data = listOfCommits.reverse();\\\\n+\\\\n+                callback(null, data);\\\\n+\\\\n+                if (error !== null) {\\\\n+                    console.log('stderr: ' + stderr);\\\\n+                    console.log('exec error: ' + error);\\\\n+                }\\\\n+            });\\\\n+        }\\\\n+    ],\\\\n+    secondTasks = [\\\\n+        function some_function(callback) {\\\\n+            cp.exec('git diff', function(error, stdout, stderr) {\\\\n+                var currentContent = stdout;\\\\n+\\\\n+                if (error !== null) {\\\\n+                    console.log('stderr: ' + stderr);\\\\n+                    console.log('exec error: ' + error);\\\\n+                }\\\\n+\\\\n+                callback(null, currentContent);\\\\n+            });\\\\n+        }\\\\n+    ];*/\\\\n \\\\n function findData(text, keyword) {\\\\n     var data = [];\\\\n@@ -28,38 +78,106 @@ function findComments(text) {\\\\n     return comments;\\\\n }\\\\n \\\\n+function findCommitNumbers(text) {\\\\n+    var commits = [];\\\\n+    var splittext = text.split('\\\\\\\\n');\\\\n+\\\\n+    for(i=0; i<splittext.length; i++) {\\\\n+        if(splittext[i].slice(0, 6) == \\\\\\\"commit\\\\\\\") {\\\\n+            commits[commits.length] = splittext[i].slice(6).trim();\\\\n+        }\\\\n+    }\\\\n+\\\\n+    return commits;\\\\n+}\\\\n+\\\\n+/*function pullCommitContent(first, second) {\\\\n+\\\\n+    cp.exec('git diff' + ' ' + first + ' ' + second, function(error, stdout, stderr) {\\\\n+        var currentContent = stdout;\\\\n+\\\\n+        if (error !== null) {\\\\n+            console.log('stderr: ' + stderr);\\\\n+            console.log('exec error: ' + error);\\\\n+        }\\\\n+\\\\n+        return currentContent;\\\\n+    });\\\\n+}*/\\\\n+\\\\n+var commitsInfo = [];\\\\n+\\\\n fs.exists('.git', function (exists) {\\\\n     if(exists) {\\\\n-        var cp = require('child_process');\\\\n+        /*async.series(tasks, function(err, result) {\\\\n+            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", JSON.stringify(result));\\\\n+\\\\n+            var data = result[0];\\\\n \\\\n-        cp.exec('git diff', function(error, stdout, stderr) {\\\\n-            console.log(stdout);\\\\n+            /*function some_function(arg1, arg2, callback) {\\\\n+                cp.exec('git diff' + ' ' + arg1 + ' ' + arg2, function(error, stdout, stderr) {\\\\n+                    var currentContent = 54321;//stdout;\\\\n \\\\n-            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", stdout);\\\\n+                    if (error !== null) {\\\\n+                        console.log('stderr: ' + stderr);\\\\n+                        console.log('exec error: ' + error);\\\\n+                    }\\\\n \\\\n-            if (error !== null) {\\\\n-                console.log('stderr: ' + stderr);\\\\n-                console.log('exec error: ' + error);\\\\n+                    callback(null, currentContent);\\\\n+                });\\\\n             }\\\\n-        });\\\\n+        });*/\\\\n+\\\\n+        async.waterfall([\\\\n+            function getCommitsInfo(callback) {\\\\n+                cp.exec('git log', function(error, stdout, stderr) {\\\\n+                    var listOfCommits = [];\\\\n+                    var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n+                    var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n+                    var comments = findComments(stdout);\\\\n+                    var commitNumbers = findCommitNumbers(stdout);\\\\n \\\\n-        cp.exec('git log', function(error, stdout, stderr) {\\\\n-            console.log(stdout);\\\\n+                    for(i=0; i<authors.length; i++) {\\\\n+                        var commit = {\\\\n+                            \\\\\\\"commit\\\\\\\": commitNumbers[i],\\\\n+                            \\\\\\\"author\\\\\\\": authors[i],\\\\n+                            \\\\\\\"date\\\\\\\": dates[i],\\\\n+                            \\\\\\\"comment\\\\\\\": comments[i],\\\\n+                            \\\\\\\"content\\\\\\\": 'Original'\\\\n+                        };\\\\n+                        listOfCommits[listOfCommits.length] = commit;\\\\n+                    }\\\\n \\\\n-            var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n-            var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n-            var comments = findComments(stdout);\\\\n-            console.log(authors);\\\\n-            console.log(comments);\\\\n-            console.log(dates);\\\\n+                    callback(null, listOfCommits.reverse());\\\\n \\\\n-            fs.writeFileSync(\\\\\\\"comments.sousc\\\\\\\", stdout);\\\\n+                    if (error !== null) {\\\\n+                        console.log('stderr: ' + stderr);\\\\n+                        console.log('exec error: ' + error);\\\\n+                    }\\\\n+                });\\\\n+            },\\\\n+            function getCommitsContent(commits, callback) {\\\\n+                console.log(commits);\\\\n+                var commitsData = commits;\\\\n \\\\n-            if (error !== null) {\\\\n-                console.log('stderr: ' + stderr);\\\\n-                console.log('exec error: ' + error);\\\\n+                for(i=1; i<commitsData.length; i++) {\\\\n+                    cp.exec('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit, function(error, stdout, stderr) {\\\\n+                        commitsData[i].content = stdout;\\\\n+\\\\n+                        if (error !== null) {\\\\n+                            console.log('stderr: ' + stderr);\\\\n+                            console.log('exec error: ' + error);\\\\n+                        }\\\\n+                    });\\\\n+                }\\\\n+\\\\n+                callback(null, commitsData);\\\\n             }\\\\n+        ], function (err, result) {\\\\n+            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", result);\\\\n         });\\\\n+\\\\n+        //commitsInfo = JSON.parse(fs.readFileSync(\\\\\\\"patches.sousp\\\\\\\"));\\\\n+        //console.log(commitsInfo);\\\\n     }\\\\n-    else console.log(\\\\\\\"Error.\\\\\\\");\\\\n });\\\\n\\\\\\\\ No newline at end of file\\\\ndiff --git a/node_modules/async/.travis.yml b/node_modules/async/.travis.yml\\\\nnew file mode 100644\\\\nindex 0000000..6e5919d\\\\n--- /dev/null\\\\n+++ b/node_modules/async/.travis.yml\\\\n@@ -0,0 +1,3 @@\\\\n+language: node_js\\\\n+node_js:\\\\n+  - \\\\\\\"0.10\\\\\\\"\\\\ndiff --git a/node_modules/async/LICENSE b/node_modules/async/LICENSE\\\\nnew file mode 100644\\\\nindex 0000000..8f29698\\\\n--- /dev/null\\\\n+++ b/node_modules/async/LICENSE\\\\n@@ -0,0 +1,19 @@\\\\n+Copyright (c) 2010-2014 Caolan McMahon\\\\n+\\\\n+Permission is hereby granted, free of charge, to any person obtaining a copy\\\\n+of this software and associated documentation files (the \\\\\\\"Software\\\\\\\"), to deal\\\\n+in the Software without restriction, including without limitation the rights\\\\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\\\n+copies of the Software, and to permit persons to whom the Software is\\\\n+furnished to do so, subject to the following conditions:\\\\n+\\\\n+The above copyright notice and this permission notice shall be included in\\\\n+all copies or substantial portions of the Software.\\\\n+\\\\n+THE SOFTWARE IS PROVIDED \\\\\\\"AS IS\\\\\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\\\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\\\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\\\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\\\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\\\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\\\n+THE SOFTWARE.\\\\ndiff --git a/node_modules/async/README.md b/node_modules/async/README.md\\\\nnew file mode 100644\\\\nindex 0000000..0bea531\\\\n--- /dev/null\\\\n+++ b/node_modules/async/README.md\\\\n@@ -0,0 +1,1646 @@\\\\n+# Async.js\\\\n+\\\\n+[![Build Status via Travis CI](https://travis-ci.org/caolan/async.svg?branch=master)](https://travis-ci.org/caolan/async)\\\\n+\\\\n+\\\\n+Async is a utility module which provides straight-forward, powerful functions\\\\n+for working with asynchronous JavaScript. Although originally designed for\\\\n+use with [Node.js](http://nodejs.org), it can also be used directly in the\\\\n+browser. Also supports [component](https://github.com/component/component).\\\\n+\\\\n+Async provides around 20 functions that include the usual 'functional'\\\\n+suspects (`map`, `reduce`, `filter`, `each`…) as well as some common patterns\\\\n+for asynchronous control flow (`parallel`, `series`, `waterfall`…). All these\\\\n+functions assume you follow the Node.js convention of providing a single\\\\n+callback as the last argument of your `async` function.\\\\n+\\\\n+\\\\n+## Quick Examples\\\\n+\\\\n+```javascript\\\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\\\n+    // results is now an array of stats for each file\\\\n+});\\\\n+\\\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\\\n+    // results now equals an array of the existing files\\\\n+});\\\\n+\\\\n+async.parallel([\\\\n+    function(){ ... },\\\\n+    function(){ ... }\\\\n+], callback);\\\\n+\\\\n+async.series([\\\\n+    function(){ ... },\\\\n+    function(){ ... }\\\\n+]);\\\\n+```\\\\n+\\\\n+There are many more functions available so take a look at the docs below for a\\\\n+full list. This module aims to be comprehensive, so if you feel anything is\\\\n+missing please create a GitHub issue for it.\\\\n+\\\\n+## Common Pitfalls\\\\n+\\\\n+### Binding a context to an iterator\\\\n+\\\\n+This section is really about `bind`, not about `async`. If you are wondering how to\\\\n+make `async` execute your iterators in a given context, or are confused as to why\\\\n+a method of another library isn't working as an iterator, study this example:\\\\n+\\\\n+```js\\\\n+// Here is a simple object with an (unnecessarily roundabout) squaring method\\\\n+var AsyncSquaringLibrary = {\\\\n+  squareExponent: 2,\\\\n+  square: function(number, callback){ \\\\n+    var result = Math.pow(number, this.squareExponent);\\\\n+    setTimeout(function(){\\\\n+      callback(null, result);\\\\n+    }, 200);\\\\n+  }\\\\n+};\\\\n+\\\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square, function(err, result){\\\\n+  // result is [NaN, NaN, NaN]\\\\n+  // This fails because the `this.squareExponent` expression in the square\\\\n+  // function is not evaluated in the context of AsyncSquaringLibrary, and is\\\\n+  // therefore undefined.\\\\n+});\\\\n+\\\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), function(err, result){\\\\n+  // result is [1, 4, 9]\\\\n+  // With the help of bind we can attach a context to the iterator before\\\\n+  // passing it to async. Now the square function will be executed in its \\\\n+  // 'home' AsyncSquaringLibrary context and the value of `this.squareExponent`\\\\n+  // will be as expected.\\\\n+});\\\\n+```\\\\n+\\\\n+## Download\\\\n+\\\\n+The source is available for download from\\\\n+[GitHub](http://github.com/caolan/async).\\\\n+Alternatively, you can install using Node Package Manager (`npm`):\\\\n+\\\\n+    npm install async\\\\n+\\\\n+__Development:__ [async.js](https://github.com/caolan/async/raw/master/lib/async.js) - 29.6kb Uncompressed\\\\n+\\\\n+## In the Browser\\\\n+\\\\n+So far it's been tested in IE6, IE7, IE8, FF3.6 and Chrome 5. \\\\n+\\\\n+Usage:\\\\n+\\\\n+```html\\\\n+<script type=\\\\\\\"text/javascript\\\\\\\" src=\\\\\\\"async.js\\\\\\\"></script>\\\\n+<script type=\\\\\\\"text/javascript\\\\\\\">\\\\n+\\\\n+    async.map(data, asyncProcess, function(err, results){\\\\n+        alert(results);\\\\n+    });\\\\n+\\\\n+</script>\\\\n+```\\\\n+\\\\n+## Documentation\\\\n+\\\\n+### Collections\\\\n+\\\\n+* [`each`](#each)\\\\n+* [`eachSeries`](#eachSeries)\\\\n+* [`eachLimit`](#eachLimit)\\\\n+* [`map`](#map)\\\\n+* [`mapSeries`](#mapSeries)\\\\n+* [`mapLimit`](#mapLimit)\\\\n+* [`filter`](#filter)\\\\n+* [`filterSeries`](#filterSeries)\\\\n+* [`reject`](#reject)\\\\n+* [`rejectSeries`](#rejectSeries)\\\\n+* [`reduce`](#reduce)\\\\n+* [`reduceRight`](#reduceRight)\\\\n+* [`detect`](#detect)\\\\n+* [`detectSeries`](#detectSeries)\\\\n+* [`sortBy`](#sortBy)\\\\n+* [`some`](#some)\\\\n+* [`every`](#every)\\\\n+* [`concat`](#concat)\\\\n+* [`concatSeries`](#concatSeries)\\\\n+\\\\n+### Control Flow\\\\n+\\\\n+* [`series`](#seriestasks-callback)\\\\n+* [`parallel`](#parallel)\\\\n+* [`parallelLimit`](#parallellimittasks-limit-callback)\\\\n+* [`whilst`](#whilst)\\\\n+* [`doWhilst`](#doWhilst)\\\\n+* [`until`](#until)\\\\n+* [`doUntil`](#doUntil)\\\\n+* [`forever`](#forever)\\\\n+* [`waterfall`](#waterfall)\\\\n+* [`compose`](#compose)\\\\n+* [`seq`](#seq)\\\\n+* [`applyEach`](#applyEach)\\\\n+* [`applyEachSeries`](#applyEachSeries)\\\\n+* [`queue`](#queue)\\\\n+* [`priorityQueue`](#priorityQueue)\\\\n+* [`cargo`](#cargo)\\\\n+* [`auto`](#auto)\\\\n+* [`retry`](#retry)\\\\n+* [`iterator`](#iterator)\\\\n+* [`apply`](#apply)\\\\n+* [`nextTick`](#nextTick)\\\\n+* [`times`](#times)\\\\n+* [`timesSeries`](#timesSeries)\\\\n+\\\\n+### Utils\\\\n+\\\\n+* [`memoize`](#memoize)\\\\n+* [`unmemoize`](#unmemoize)\\\\n+* [`log`](#log)\\\\n+* [`dir`](#dir)\\\\n+* [`noConflict`](#noConflict)\\\\n+\\\\n+\\\\n+## Collections\\\\n+\\\\n+<a name=\\\\\\\"forEach\\\\\\\" />\\\\n+<a name=\\\\\\\"each\\\\\\\" />\\\\n+### each(arr, iterator, callback)\\\\n+\\\\n+Applies the function `iterator` to each item in `arr`, in parallel.\\\\n+The `iterator` is called with an item from the list, and a callback for when it\\\\n+has finished. If the `iterator` passes an error to its `callback`, the main\\\\n+`callback` (for the `each` function) is immediately called with the error.\\\\n+\\\\n+Note, that since this function applies `iterator` to each item in parallel,\\\\n+there is no guarantee that the iterator functions will complete in order.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err)` which must be called once it has \\\\n+  completed. If no error has occured, the `callback` should be run without \\\\n+  arguments or with an explicit `null` argument.\\\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\\\n+  have finished, or an error occurs.\\\\n+\\\\n+__Examples__\\\\n+\\\\n+\\\\n+```js\\\\n+// assuming openFiles is an array of file names and saveFile is a function\\\\n+// to save the modified contents of that file:\\\\n+\\\\n+async.each(openFiles, saveFile, function(err){\\\\n+    // if any of the saves produced an error, err would equal that error\\\\n+});\\\\n+```\\\\n+\\\\n+```js\\\\n+// assuming openFiles is an array of file names \\\\n+\\\\n+async.each(openFiles, function( file, callback) {\\\\n+  \\\\n+  // Perform operation on file here.\\\\n+  console.log('Processing file ' + file);\\\\n+  \\\\n+  if( file.length > 32 ) {\\\\n+    console.log('This file name is too long');\\\\n+    callback('File name too long');\\\\n+  } else {\\\\n+    // Do work to process file here\\\\n+    console.log('File processed');\\\\n+    callback();\\\\n+  }\\\\n+}, function(err){\\\\n+    // if any of the file processing produced an error, err would equal that error\\\\n+    if( err ) {\\\\n+      // One of the iterations produced an error.\\\\n+      // All processing will now stop.\\\\n+      console.log('A file failed to process');\\\\n+    } else {\\\\n+      console.log('All files have been processed successfully');\\\\n+    }\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"forEachSeries\\\\\\\" />\\\\n+<a name=\\\\\\\"eachSeries\\\\\\\" />\\\\n+### eachSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`each`](#each), only `iterator` is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+This means the `iterator` functions will complete in order.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"forEachLimit\\\\\\\" />\\\\n+<a name=\\\\\\\"eachLimit\\\\\\\" />\\\\n+### eachLimit(arr, limit, iterator, callback)\\\\n+\\\\n+The same as [`each`](#each), only no more than `limit` `iterator`s will be simultaneously \\\\n+running at any time.\\\\n+\\\\n+Note that the items in `arr` are not processed in batches, so there is no guarantee that \\\\n+the first `limit` `iterator` functions will complete before any others are started.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err)` which must be called once it has \\\\n+  completed. If no error has occured, the callback should be run without \\\\n+  arguments or with an explicit `null` argument.\\\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\\\n+  have finished, or an error occurs.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// Assume documents is an array of JSON objects and requestApi is a\\\\n+// function that interacts with a rate-limited REST api.\\\\n+\\\\n+async.eachLimit(documents, 20, requestApi, function(err){\\\\n+    // if any of the saves produced an error, err would equal that error\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"map\\\\\\\" />\\\\n+### map(arr, iterator, callback)\\\\n+\\\\n+Produces a new array of values by mapping each value in `arr` through\\\\n+the `iterator` function. The `iterator` is called with an item from `arr` and a\\\\n+callback for when it has finished processing. Each of these callback takes 2 arguments: \\\\n+an `error`, and the transformed item from `arr`. If `iterator` passes an error to this \\\\n+callback, the main `callback` (for the `map` function) is immediately called with the error.\\\\n+\\\\n+Note, that since this function applies the `iterator` to each item in parallel,\\\\n+there is no guarantee that the `iterator` functions will complete in order. \\\\n+However, the results array will be in the same order as the original `arr`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\\\n+  it has completed with an error (which can be `null`) and a transformed item.\\\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\\\n+  functions have finished, or an error occurs. Results is an array of the\\\\n+  transformed items from the `arr`.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\\\n+    // results is now an array of stats for each file\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"mapSeries\\\\\\\" />\\\\n+### mapSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`map`](#map), only the `iterator` is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+The results array will be in the same order as the original.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"mapLimit\\\\\\\" />\\\\n+### mapLimit(arr, limit, iterator, callback)\\\\n+\\\\n+The same as [`map`](#map), only no more than `limit` `iterator`s will be simultaneously \\\\n+running at any time.\\\\n+\\\\n+Note that the items are not processed in batches, so there is no guarantee that \\\\n+the first `limit` `iterator` functions will complete before any others are started.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\\\n+  it has completed with an error (which can be `null`) and a transformed item.\\\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\\\n+  calls have finished, or an error occurs. The result is an array of the\\\\n+  transformed items from the original `arr`.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.mapLimit(['file1','file2','file3'], 1, fs.stat, function(err, results){\\\\n+    // results is now an array of stats for each file\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"select\\\\\\\" />\\\\n+<a name=\\\\\\\"filter\\\\\\\" />\\\\n+### filter(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `select`\\\\n+\\\\n+Returns a new array of all the values in `arr` which pass an async truth test.\\\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\n+way node libraries work with truth tests like `fs.exists`. This operation is\\\\n+performed in parallel, but the results array will be in the same order as the\\\\n+original.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\\\n+  The `iterator` is passed a `callback(truthValue)`, which must be called with a \\\\n+  boolean argument once it has completed.\\\\n+* `callback(results)` - A callback which is called after all the `iterator`\\\\n+  functions have finished.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\\\n+    // results now equals an array of the existing files\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"selectSeries\\\\\\\" />\\\\n+<a name=\\\\\\\"filterSeries\\\\\\\" />\\\\n+### filterSeries(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `selectSeries`\\\\n+\\\\n+The same as [`filter`](#filter) only the `iterator` is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+The results array will be in the same order as the original.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"reject\\\\\\\" />\\\\n+### reject(arr, iterator, callback)\\\\n+\\\\n+The opposite of [`filter`](#filter). Removes values that pass an `async` truth test.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"rejectSeries\\\\\\\" />\\\\n+### rejectSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`reject`](#reject), only the `iterator` is applied to each item in `arr`\\\\n+in series.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"reduce\\\\\\\" />\\\\n+### reduce(arr, memo, iterator, callback)\\\\n+\\\\n+__Aliases:__ `inject`, `foldl`\\\\n+\\\\n+Reduces `arr` into a single value using an async `iterator` to return\\\\n+each successive step. `memo` is the initial state of the reduction. \\\\n+This function only operates in series. \\\\n+\\\\n+For performance reasons, it may make sense to split a call to this function into \\\\n+a parallel map, and then use the normal `Array.prototype.reduce` on the results. \\\\n+This function is for situations where each step in the reduction needs to be async; \\\\n+if you can get the data before reducing it, then it's probably a good idea to do so.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `memo` - The initial state of the reduction.\\\\n+* `iterator(memo, item, callback)` - A function applied to each item in the\\\\n+  array to produce the next step in the reduction. The `iterator` is passed a\\\\n+  `callback(err, reduction)` which accepts an optional error as its first \\\\n+  argument, and the state of the reduction as the second. If an error is \\\\n+  passed to the callback, the reduction is stopped and the main `callback` is \\\\n+  immediately called with the error.\\\\n+* `callback(err, result)` - A callback which is called after all the `iterator`\\\\n+  functions have finished. Result is the reduced value.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.reduce([1,2,3], 0, function(memo, item, callback){\\\\n+    // pointless async:\\\\n+    process.nextTick(function(){\\\\n+        callback(null, memo + item)\\\\n+    });\\\\n+}, function(err, result){\\\\n+    // result is now equal to the last value of memo, which is 6\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"reduceRight\\\\\\\" />\\\\n+### reduceRight(arr, memo, iterator, callback)\\\\n+\\\\n+__Alias:__ `foldr`\\\\n+\\\\n+Same as [`reduce`](#reduce), only operates on `arr` in reverse order.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"detect\\\\\\\" />\\\\n+### detect(arr, iterator, callback)\\\\n+\\\\n+Returns the first value in `arr` that passes an async truth test. The\\\\n+`iterator` is applied in parallel, meaning the first iterator to return `true` will\\\\n+fire the detect `callback` with that result. That means the result might not be\\\\n+the first item in the original `arr` (in terms of order) that passes the test.\\\\n+\\\\n+If order within the original `arr` is important, then look at [`detectSeries`](#detectSeries).\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(truthValue)` which must be called with a \\\\n+  boolean argument once it has completed.\\\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\\\n+  `true`, or after all the `iterator` functions have finished. Result will be\\\\n+  the first item in the array that passes the truth test (iterator) or the\\\\n+  value `undefined` if none passed.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.detect(['file1','file2','file3'], fs.exists, function(result){\\\\n+    // result now equals the first file in the list that exists\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"detectSeries\\\\\\\" />\\\\n+### detectSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`detect`](#detect), only the `iterator` is applied to each item in `arr`\\\\n+in series. This means the result is always the first in the original `arr` (in\\\\n+terms of array order) that passes the truth test.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"sortBy\\\\\\\" />\\\\n+### sortBy(arr, iterator, callback)\\\\n+\\\\n+Sorts a list by the results of running each `arr` value through an async `iterator`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, sortValue)` which must be called once it\\\\n+  has completed with an error (which can be `null`) and a value to use as the sort\\\\n+  criteria.\\\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\\\n+  functions have finished, or an error occurs. Results is the items from\\\\n+  the original `arr` sorted by the values returned by the `iterator` calls.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.sortBy(['file1','file2','file3'], function(file, callback){\\\\n+    fs.stat(file, function(err, stats){\\\\n+        callback(err, stats.mtime);\\\\n+    });\\\\n+}, function(err, results){\\\\n+    // results is now the original array of files sorted by\\\\n+    // modified date\\\\n+});\\\\n+```\\\\n+\\\\n+__Sort Order__\\\\n+\\\\n+By modifying the callback parameter the sorting order can be influenced:\\\\n+\\\\n+```js\\\\n+//ascending order\\\\n+async.sortBy([1,9,3,5], function(x, callback){\\\\n+    callback(err, x);\\\\n+}, function(err,result){\\\\n+    //result callback\\\\n+} );\\\\n+\\\\n+//descending order\\\\n+async.sortBy([1,9,3,5], function(x, callback){\\\\n+    callback(err, x*-1);    //<- x*-1 instead of x, turns the order around\\\\n+}, function(err,result){\\\\n+    //result callback\\\\n+} );\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"some\\\\\\\" />\\\\n+### some(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `any`\\\\n+\\\\n+Returns `true` if at least one element in the `arr` satisfies an async test.\\\\n+_The callback for each iterator call only accepts a single argument of `true` or\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\n+way node libraries work with truth tests like `fs.exists`. Once any iterator\\\\n+call returns `true`, the main `callback` is immediately called.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\\\n+  called with a boolean argument once it has completed.\\\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\\\n+  `true`, or after all the iterator functions have finished. Result will be\\\\n+  either `true` or `false` depending on the values of the async tests.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.some(['file1','file2','file3'], fs.exists, function(result){\\\\n+    // if result is true then at least one of the files exists\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"every\\\\\\\" />\\\\n+### every(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `all`\\\\n+\\\\n+Returns `true` if every element in `arr` satisfies an async test.\\\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\n+way node libraries work with truth tests like `fs.exists`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\\\n+  called with a  boolean argument once it has completed.\\\\n+* `callback(result)` - A callback which is called after all the `iterator`\\\\n+  functions have finished. Result will be either `true` or `false` depending on\\\\n+  the values of the async tests.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.every(['file1','file2','file3'], fs.exists, function(result){\\\\n+    // if result is true then every file exists\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"concat\\\\\\\" />\\\\n+### concat(arr, iterator, callback)\\\\n+\\\\n+Applies `iterator` to each item in `arr`, concatenating the results. Returns the\\\\n+concatenated list. The `iterator`s are called in parallel, and the results are\\\\n+concatenated as they return. There is no guarantee that the results array will\\\\n+be returned in the original order of `arr` passed to the `iterator` function.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, results)` which must be called once it \\\\n+  has completed with an error (which can be `null`) and an array of results.\\\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\\\n+  functions have finished, or an error occurs. Results is an array containing\\\\n+  the concatenated results of the `iterator` function.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files){\\\\n+    // files is now a list of filenames that exist in the 3 directories\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"concatSeries\\\\\\\" />\\\\n+### concatSeries(arr, iterator, callback)\\\\n+\\\\n+Same as [`concat`](#concat), but executes in series instead of parallel.\\\\n+\\\\n+\\\\n+## Control Flow\\\\n+\\\\n+<a name=\\\\\\\"series\\\\\\\" />\\\\n+### series(tasks, [callback])\\\\n+\\\\n+Run the functions in the `tasks` array in series, each one running once the previous\\\\n+function has completed. If any functions in the series pass an error to its\\\\n+callback, no more functions are run, and `callback` is immediately called with the value of the error. \\\\n+Otherwise, `callback` receives an array of results when `tasks` have completed.\\\\n+\\\\n+It is also possible to use an object instead of an array. Each property will be\\\\n+run as a function, and the results will be passed to the final `callback` as an object\\\\n+instead of an array. This can be a more readable way of handling results from\\\\n+[`series`](#series).\\\\n+\\\\n+**Note** that while many implementations preserve the order of object properties, the\\\\n+[ECMAScript Language Specifcation](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6) \\\\n+explicitly states that\\\\n+\\\\n+> The mechanics and order of enumerating the properties is not specified.\\\\n+\\\\n+So if you rely on the order in which your series of functions are executed, and want\\\\n+this to work on all platforms, consider using an array. \\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array or object containing functions to run, each function is passed\\\\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\\\n+  be `null`) and an optional `result` value.\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\n+  have completed. This function gets a results array (or object) containing all \\\\n+  the result arguments passed to the `task` callbacks.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.series([\\\\n+    function(callback){\\\\n+        // do some stuff ...\\\\n+        callback(null, 'one');\\\\n+    },\\\\n+    function(callback){\\\\n+        // do some more stuff ...\\\\n+        callback(null, 'two');\\\\n+    }\\\\n+],\\\\n+// optional callback\\\\n+function(err, results){\\\\n+    // results is now equal to ['one', 'two']\\\\n+});\\\\n+\\\\n+\\\\n+// an example using an object instead of an array\\\\n+async.series({\\\\n+    one: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 1);\\\\n+        }, 200);\\\\n+    },\\\\n+    two: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 2);\\\\n+        }, 100);\\\\n+    }\\\\n+},\\\\n+function(err, results) {\\\\n+    // results is now equal to: {one: 1, two: 2}\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"parallel\\\\\\\" />\\\\n+### parallel(tasks, [callback])\\\\n+\\\\n+Run the `tasks` array of functions in parallel, without waiting until the previous\\\\n+function has completed. If any of the functions pass an error to its\\\\n+callback, the main `callback` is immediately called with the value of the error.\\\\n+Once the `tasks` have completed, the results are passed to the final `callback` as an\\\\n+array.\\\\n+\\\\n+It is also possible to use an object instead of an array. Each property will be\\\\n+run as a function and the results will be passed to the final `callback` as an object\\\\n+instead of an array. This can be a more readable way of handling results from\\\\n+[`parallel`](#parallel).\\\\n+\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array or object containing functions to run. Each function is passed \\\\n+  a `callback(err, result)` which it must call on completion with an error `err` \\\\n+  (which can be `null`) and an optional `result` value.\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\n+  have completed. This function gets a results array (or object) containing all \\\\n+  the result arguments passed to the task callbacks.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.parallel([\\\\n+    function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 'one');\\\\n+        }, 200);\\\\n+    },\\\\n+    function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 'two');\\\\n+        }, 100);\\\\n+    }\\\\n+],\\\\n+// optional callback\\\\n+function(err, results){\\\\n+    // the results array will equal ['one','two'] even though\\\\n+    // the second function had a shorter timeout.\\\\n+});\\\\n+\\\\n+\\\\n+// an example using an object instead of an array\\\\n+async.parallel({\\\\n+    one: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 1);\\\\n+        }, 200);\\\\n+    },\\\\n+    two: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 2);\\\\n+        }, 100);\\\\n+    }\\\\n+},\\\\n+function(err, results) {\\\\n+    // results is now equals to: {one: 1, two: 2}\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"parallelLimit\\\\\\\" />\\\\n+### parallelLimit(tasks, limit, [callback])\\\\n+\\\\n+The same as [`parallel`](#parallel), only `tasks` are executed in parallel \\\\n+with a maximum of `limit` tasks executing at any time.\\\\n+\\\\n+Note that the `tasks` are not executed in batches, so there is no guarantee that \\\\n+the first `limit` tasks will complete before any others are started.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array or object containing functions to run, each function is passed \\\\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\\\n+  be `null`) and an optional `result` value.\\\\n+* `limit` - The maximum number of `tasks` to run at any time.\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\n+  have completed. This function gets a results array (or object) containing all \\\\n+  the result arguments passed to the `task` callbacks.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"whilst\\\\\\\" />\\\\n+### whilst(test, fn, callback)\\\\n+\\\\n+Repeatedly call `fn`, while `test` returns `true`. Calls `callback` when stopped,\\\\n+or an error occurs.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `test()` - synchronous truth test to perform before each execution of `fn`.\\\\n+* `fn(callback)` - A function which is called each time `test` passes. The function is\\\\n+  passed a `callback(err)`, which must be called once it has completed with an \\\\n+  optional `err` argument.\\\\n+* `callback(err)` - A callback which is called after the test fails and repeated\\\\n+  execution of `fn` has stopped.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var count = 0;\\\\n+\\\\n+async.whilst(\\\\n+    function () { return count < 5; },\\\\n+    function (callback) {\\\\n+        count++;\\\\n+        setTimeout(callback, 1000);\\\\n+    },\\\\n+    function (err) {\\\\n+        // 5 seconds have passed\\\\n+    }\\\\n+);\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"doWhilst\\\\\\\" />\\\\n+### doWhilst(fn, test, callback)\\\\n+\\\\n+The post-check version of [`whilst`](#whilst). To reflect the difference in \\\\n+the order of operations, the arguments `test` and `fn` are switched. \\\\n+\\\\n+`doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"until\\\\\\\" />\\\\n+### until(test, fn, callback)\\\\n+\\\\n+Repeatedly call `fn` until `test` returns `true`. Calls `callback` when stopped,\\\\n+or an error occurs.\\\\n+\\\\n+The inverse of [`whilst`](#whilst).\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"doUntil\\\\\\\" />\\\\n+### doUntil(fn, test, callback)\\\\n+\\\\n+Like [`doWhilst`](#doWhilst), except the `test` is inverted. Note the argument ordering differs from `until`.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"forever\\\\\\\" />\\\\n+### forever(fn, errback)\\\\n+\\\\n+Calls the asynchronous function `fn` with a callback parameter that allows it to\\\\n+call itself again, in series, indefinitely.\\\\n+\\\\n+If an error is passed to the callback then `errback` is called with the\\\\n+error, and execution stops, otherwise it will never be called.\\\\n+\\\\n+```js\\\\n+async.forever(\\\\n+    function(next) {\\\\n+        // next is suitable for passing to things that need a callback(err [, whatever]);\\\\n+        // it will result in this function being called again.\\\\n+    },\\\\n+    function(err) {\\\\n+        // if next is called with a value in its first parameter, it will appear\\\\n+        // in here as 'err', and execution will stop.\\\\n+    }\\\\n+);\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"waterfall\\\\\\\" />\\\\n+### waterfall(tasks, [callback])\\\\n+\\\\n+Runs the `tasks` array of functions in series, each passing their results to the next in\\\\n+the array. However, if any of the `tasks` pass an error to their own callback, the\\\\n+next function is not executed, and the main `callback` is immediately called with\\\\n+the error.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array of functions to run, each function is passed a \\\\n+  `callback(err, result1, result2, ...)` it must call on completion. The first\\\\n+  argument is an error (which can be `null`) and any further arguments will be \\\\n+  passed as arguments in order to the next task.\\\\n+* `callback(err, [results])` - An optional callback to run once all the functions\\\\n+  have completed. This will be passed the results of the last task's callback.\\\\n+\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.waterfall([\\\\n+    function(callback){\\\\n+        callback(null, 'one', 'two');\\\\n+    },\\\\n+    function(arg1, arg2, callback){\\\\n+      // arg1 now equals 'one' and arg2 now equals 'two'\\\\n+        callback(null, 'three');\\\\n+    },\\\\n+    function(arg1, callback){\\\\n+        // arg1 now equals 'three'\\\\n+        callback(null, 'done');\\\\n+    }\\\\n+], function (err, result) {\\\\n+   // result now equals 'done'    \\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+<a name=\\\\\\\"compose\\\\\\\" />\\\\n+### compose(fn1, fn2...)\\\\n+\\\\n+Creates a function which is a composition of the passed asynchronous\\\\n+functions. Each function consumes the return value of the function that\\\\n+follows. Composing functions `f()`, `g()`, and `h()` would produce the result of\\\\n+`f(g(h()))`, only this version uses callbacks to obtain the return values.\\\\n+\\\\n+Each function is executed with the `this` binding of the composed function.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `functions...` - the asynchronous functions to compose\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+function add1(n, callback) {\\\\n+    setTimeout(function () {\\\\n+        callback(null, n + 1);\\\\n+    }, 10);\\\\n+}\\\\n+\\\\n+function mul3(n, callback) {\\\\n+    setTimeout(function () {\\\\n+        callback(null, n * 3);\\\\n+    }, 10);\\\\n+}\\\\n+\\\\n+var add1mul3 = async.compose(mul3, add1);\\\\n+\\\\n+add1mul3(4, function (err, result) {\\\\n+   // result now equals 15\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+<a name=\\\\\\\"seq\\\\\\\" />\\\\n+### seq(fn1, fn2...)\\\\n+\\\\n+Version of the compose function that is more natural to read.\\\\n+Each following function consumes the return value of the latter function. \\\\n+\\\\n+Each function is executed with the `this` binding of the composed function.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* functions... - the asynchronous functions to compose\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// Requires lodash (or underscore), express3 and dresende's orm2.\\\\n+// Part of an app, that fetches cats of the logged user.\\\\n+// This example uses `seq` function to avoid overnesting and error \\\\n+// handling clutter.\\\\n+app.get('/cats', function(request, response) {\\\\n+  function handleError(err, data, callback) {\\\\n+    if (err) {\\\\n+      console.error(err);\\\\n+      response.json({ status: 'error', message: err.message });\\\\n+    }\\\\n+    else {\\\\n+      callback(data);\\\\n+    }\\\\n+  }\\\\n+  var User = request.models.User;\\\\n+  async.seq(\\\\n+    _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\\\\n+    handleError,\\\\n+    function(user, fn) {\\\\n+      user.getCats(fn);      // 'getCats' has signature (callback(err, data))\\\\n+    },\\\\n+    handleError,\\\\n+    function(cats) {\\\\n+      response.json({ status: 'ok', message: 'Cats found', data: cats });\\\\n+    }\\\\n+  )(req.session.user_id);\\\\n+  }\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+<a name=\\\\\\\"applyEach\\\\\\\" />\\\\n+### applyEach(fns, args..., callback)\\\\n+\\\\n+Applies the provided arguments to each function in the array, calling \\\\n+`callback` after all functions have completed. If you only provide the first\\\\n+argument, then it will return a function which lets you pass in the\\\\n+arguments as if it were a single function call.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `fns` - the asynchronous functions to all call with the same arguments\\\\n+* `args...` - any number of separate arguments to pass to the function\\\\n+* `callback` - the final argument should be the callback, called when all\\\\n+  functions have completed processing\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.applyEach([enableSearch, updateSchema], 'bucket', callback);\\\\n+\\\\n+// partial application example:\\\\n+async.each(\\\\n+    buckets,\\\\n+    async.applyEach([enableSearch, updateSchema]),\\\\n+    callback\\\\n+);\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"applyEachSeries\\\\\\\" />\\\\n+### applyEachSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`applyEach`](#applyEach) only the functions are applied in series.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"queue\\\\\\\" />\\\\n+### queue(worker, concurrency)\\\\n+\\\\n+Creates a `queue` object with the specified `concurrency`. Tasks added to the\\\\n+`queue` are processed in parallel (up to the `concurrency` limit). If all\\\\n+`worker`s are in progress, the task is queued until one becomes available. \\\\n+Once a `worker` completes a `task`, that `task`'s callback is called.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `worker(task, callback)` - An asynchronous function for processing a queued\\\\n+  task, which must call its `callback(err)` argument when finished, with an \\\\n+  optional `error` as an argument.\\\\n+* `concurrency` - An `integer` for determining how many `worker` functions should be\\\\n+  run in parallel.\\\\n+\\\\n+__Queue objects__\\\\n+\\\\n+The `queue` object returned by this function has the following properties and\\\\n+methods:\\\\n+\\\\n+* `length()` - a function returning the number of items waiting to be processed.\\\\n+* `started` - a function returning whether or not any items have been pushed and processed by the queue\\\\n+* `running()` - a function returning the number of items currently being processed.\\\\n+* `idle()` - a function returning false if there are items waiting or being processed, or true if not.\\\\n+* `concurrency` - an integer for determining how many `worker` functions should be\\\\n+  run in parallel. This property can be changed after a `queue` is created to\\\\n+  alter the concurrency on-the-fly.\\\\n+* `push(task, [callback])` - add a new task to the `queue`. Calls `callback` once \\\\n+  the `worker` has finished processing the task. Instead of a single task, a `tasks` array\\\\n+  can be submitted. The respective callback is used for every task in the list.\\\\n+* `unshift(task, [callback])` - add a new task to the front of the `queue`.\\\\n+* `saturated` - a callback that is called when the `queue` length hits the `concurrency` limit, \\\\n+   and further tasks will be queued.\\\\n+* `empty` - a callback that is called when the last item from the `queue` is given to a `worker`.\\\\n+* `drain` - a callback that is called when the last item from the `queue` has returned from the `worker`.\\\\n+* `paused` - a boolean for determining whether the queue is in a paused state\\\\n+* `pause()` - a function that pauses the processing of tasks until `resume()` is called.\\\\n+* `resume()` - a function that resumes the processing of queued tasks when the queue is paused.\\\\n+* `kill()` - a function that empties remaining tasks from the queue forcing it to go idle.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// create a queue object with concurrency 2\\\\n+\\\\n+var q = async.queue(function (task, callback) {\\\\n+    console.log('hello ' + task.name);\\\\n+    callback();\\\\n+}, 2);\\\\n+\\\\n+\\\\n+// assign a callback\\\\n+q.drain = function() {\\\\n+    console.log('all items have been processed');\\\\n+}\\\\n+\\\\n+// add some items to the queue\\\\n+\\\\n+q.push({name: 'foo'}, function (err) {\\\\n+    console.log('finished processing foo');\\\\n+});\\\\n+q.push({name: 'bar'}, function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+\\\\n+// add some items to the queue (batch-wise)\\\\n+\\\\n+q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+\\\\n+// add some items to the front of the queue\\\\n+\\\\n+q.unshift({name: 'bar'}, function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+```\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"priorityQueue\\\\\\\" />\\\\n+### priorityQueue(worker, concurrency)\\\\n+\\\\n+The same as [`queue`](#queue) only tasks are assigned a priority and completed in ascending priority order. There are two differences between `queue` and `priorityQueue` objects:\\\\n+\\\\n+* `push(task, priority, [callback])` - `priority` should be a number. If an array of\\\\n+  `tasks` is given, all tasks will be assigned the same priority.\\\\n+* The `unshift` method was removed.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"cargo\\\\\\\" />\\\\n+### cargo(worker, [payload])\\\\n+\\\\n+Creates a `cargo` object with the specified payload. Tasks added to the\\\\n+cargo will be processed altogether (up to the `payload` limit). If the\\\\n+`worker` is in progress, the task is queued until it becomes available. Once\\\\n+the `worker` has completed some tasks, each callback of those tasks is called.\\\\n+Check out [this animation](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) for how `cargo` and `queue` work.\\\\n+\\\\n+While [queue](#queue) passes only one task to one of a group of workers\\\\n+at a time, cargo passes an array of tasks to a single worker, repeating\\\\n+when the worker is finished.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `worker(tasks, callback)` - An asynchronous function for processing an array of\\\\n+  queued tasks, which must call its `callback(err)` argument when finished, with \\\\n+  an optional `err` argument.\\\\n+* `payload` - An optional `integer` for determining how many tasks should be\\\\n+  processed per round; if omitted, the default is unlimited.\\\\n+\\\\n+__Cargo objects__\\\\n+\\\\n+The `cargo` object returned by this function has the following properties and\\\\n+methods:\\\\n+\\\\n+* `length()` - A function returning the number of items waiting to be processed.\\\\n+* `payload` - An `integer` for determining how many tasks should be\\\\n+  process per round. This property can be changed after a `cargo` is created to\\\\n+  alter the payload on-the-fly.\\\\n+* `push(task, [callback])` - Adds `task` to the `queue`. The callback is called\\\\n+  once the `worker` has finished processing the task. Instead of a single task, an array of `tasks` \\\\n+  can be submitted. The respective callback is used for every task in the list.\\\\n+* `saturated` - A callback that is called when the `queue.length()` hits the concurrency and further tasks will be queued.\\\\n+* `empty` - A callback that is called when the last item from the `queue` is given to a `worker`.\\\\n+* `drain` - A callback that is called when the last item from the `queue` has returned from the `worker`.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// create a cargo object with payload 2\\\\n+\\\\n+var cargo = async.cargo(function (tasks, callback) {\\\\n+    for(var i=0; i<tasks.length; i++){\\\\n+      console.log('hello ' + tasks[i].name);\\\\n+    }\\\\n+    callback();\\\\n+}, 2);\\\\n+\\\\n+\\\\n+// add some items\\\\n+\\\\n+cargo.push({name: 'foo'}, function (err) {\\\\n+    console.log('finished processing foo');\\\\n+});\\\\n+cargo.push({name: 'bar'}, function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+cargo.push({name: 'baz'}, function (err) {\\\\n+    console.log('finished processing baz');\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"auto\\\\\\\" />\\\\n+### auto(tasks, [callback])\\\\n+\\\\n+Determines the best order for running the functions in `tasks`, based on their \\\\n+requirements. Each function can optionally depend on other functions being completed \\\\n+first, and each function is run as soon as its requirements are satisfied. \\\\n+\\\\n+If any of the functions pass an error to their callback, it will not \\\\n+complete (so any other functions depending on it will not run), and the main \\\\n+`callback` is immediately called with the error. Functions also receive an \\\\n+object containing the results of functions which have completed so far.\\\\n+\\\\n+Note, all functions are called with a `results` object as a second argument, \\\\n+so it is unsafe to pass functions in the `tasks` object which cannot handle the\\\\n+extra argument. \\\\n+\\\\n+For example, this snippet of code:\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+  readData: async.apply(fs.readFile, 'data.txt', 'utf-8')\\\\n+}, callback);\\\\n+```\\\\n+\\\\n+will have the effect of calling `readFile` with the results object as the last\\\\n+argument, which will fail:\\\\n+\\\\n+```js\\\\n+fs.readFile('data.txt', 'utf-8', cb, {});\\\\n+```\\\\n+\\\\n+Instead, wrap the call to `readFile` in a function which does not forward the \\\\n+`results` object:\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+  readData: function(cb, results){\\\\n+    fs.readFile('data.txt', 'utf-8', cb);\\\\n+  }\\\\n+}, callback);\\\\n+```\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An object. Each of its properties is either a function or an array of\\\\n+  requirements, with the function itself the last item in the array. The object's key\\\\n+  of a property serves as the name of the task defined by that property,\\\\n+  i.e. can be used when specifying requirements for other tasks.\\\\n+  The function receives two arguments: (1) a `callback(err, result)` which must be \\\\n+  called when finished, passing an `error` (which can be `null`) and the result of \\\\n+  the function's execution, and (2) a `results` object, containing the results of\\\\n+  the previously executed functions.\\\\n+* `callback(err, results)` - An optional callback which is called when all the\\\\n+  tasks have been completed. It receives the `err` argument if any `tasks` \\\\n+  pass an error to their callback. Results are always returned; however, if \\\\n+  an error occurs, no further `tasks` will be performed, and the results\\\\n+  object will only contain partial results.\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+    get_data: function(callback){\\\\n+        console.log('in get_data');\\\\n+        // async code to get some data\\\\n+        callback(null, 'data', 'converted to array');\\\\n+    },\\\\n+    make_folder: function(callback){\\\\n+        console.log('in make_folder');\\\\n+        // async code to create a directory to store a file in\\\\n+        // this is run at the same time as getting the data\\\\n+        callback(null, 'folder');\\\\n+    },\\\\n+    write_file: ['get_data', 'make_folder', function(callback, results){\\\\n+        console.log('in write_file', JSON.stringify(results));\\\\n+        // once there is some data and the directory exists,\\\\n+        // write the data to a file in the directory\\\\n+        callback(null, 'filename');\\\\n+    }],\\\\n+    email_link: ['write_file', function(callback, results){\\\\n+        console.log('in email_link', JSON.stringify(results));\\\\n+        // once the file is written let's email a link to it...\\\\n+        // results.write_file contains the filename returned by write_file.\\\\n+        callback(null, {'file':results.write_file, 'email':'user@example.com'});\\\\n+    }]\\\\n+}, function(err, results) {\\\\n+    console.log('err = ', err);\\\\n+    console.log('results = ', results);\\\\n+});\\\\n+```\\\\n+\\\\n+This is a fairly trivial example, but to do this using the basic parallel and\\\\n+series functions would look like this:\\\\n+\\\\n+```js\\\\n+async.parallel([\\\\n+    function(callback){\\\\n+        console.log('in get_data');\\\\n+        // async code to get some data\\\\n+        callback(null, 'data', 'converted to array');\\\\n+    },\\\\n+    function(callback){\\\\n+        console.log('in make_folder');\\\\n+        // async code to create a directory to store a file in\\\\n+        // this is run at the same time as getting the data\\\\n+        callback(null, 'folder');\\\\n+    }\\\\n+],\\\\n+function(err, results){\\\\n+    async.series([\\\\n+        function(callback){\\\\n+            console.log('in write_file', JSON.stringify(results));\\\\n+            // once there is some data and the directory exists,\\\\n+            // write the data to a file in the directory\\\\n+            results.push('filename');\\\\n+            callback(null);\\\\n+        },\\\\n+        function(callback){\\\\n+            console.log('in email_link', JSON.stringify(results));\\\\n+            // once the file is written let's email a link to it...\\\\n+            callback(null, {'file':results.pop(), 'email':'user@example.com'});\\\\n+        }\\\\n+    ]);\\\\n+});\\\\n+```\\\\n+\\\\n+For a complicated series of `async` tasks, using the [`auto`](#auto) function makes adding\\\\n+new tasks much easier (and the code more readable).\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"retry\\\\\\\" />\\\\n+### retry([times = 5], task, [callback])\\\\n+\\\\n+Attempts to get a successful response from `task` no more than `times` times before\\\\n+returning an error. If the task is successful, the `callback` will be passed the result\\\\n+of the successfull task. If all attemps fail, the callback will be passed the error and\\\\n+result (if any) of the final attempt.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `times` - An integer indicating how many times to attempt the `task` before giving up. Defaults to 5.\\\\n+* `task(callback, results)` - A function which receives two arguments: (1) a `callback(err, result)`\\\\n+  which must be called when finished, passing `err` (which can be `null`) and the `result` of \\\\n+  the function's execution, and (2) a `results` object, containing the results of\\\\n+  the previously executed functions (if nested inside another control flow).\\\\n+* `callback(err, results)` - An optional callback which is called when the\\\\n+  task has succeeded, or after the final failed attempt. It receives the `err` and `result` arguments of the last attempt at completing the `task`.\\\\n+\\\\n+The [`retry`](#retry) function can be used as a stand-alone control flow by passing a\\\\n+callback, as shown below:\\\\n+\\\\n+```js\\\\n+async.retry(3, apiMethod, function(err, result) {\\\\n+    // do something with the result\\\\n+});\\\\n+```\\\\n+\\\\n+It can also be embeded within other control flow functions to retry individual methods\\\\n+that are not as reliable, like this:\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+    users: api.getUsers.bind(api),\\\\n+    payments: async.retry(3, api.getPayments.bind(api))\\\\n+}, function(err, results) {\\\\n+  // do something with the results\\\\n+});\\\\n+```\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"iterator\\\\\\\" />\\\\n+### iterator(tasks)\\\\n+\\\\n+Creates an iterator function which calls the next function in the `tasks` array,\\\\n+returning a continuation to call the next one after that. It's also possible to\\\\n+“peek” at the next iterator with `iterator.next()`.\\\\n+\\\\n+This function is used internally by the `async` module, but can be useful when\\\\n+you want to manually control the flow of functions in series.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array of functions to run.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var iterator = async.iterator([\\\\n+    function(){ sys.p('one'); },\\\\n+    function(){ sys.p('two'); },\\\\n+    function(){ sys.p('three'); }\\\\n+]);\\\\n+\\\\n+node> var iterator2 = iterator();\\\\n+'one'\\\\n+node> var iterator3 = iterator2();\\\\n+'two'\\\\n+node> iterator3();\\\\n+'three'\\\\n+node> var nextfn = iterator2.next();\\\\n+node> nextfn();\\\\n+'three'\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"apply\\\\\\\" />\\\\n+### apply(function, arguments..)\\\\n+\\\\n+Creates a continuation function with some arguments already applied. \\\\n+\\\\n+Useful as a shorthand when combined with other control flow functions. Any arguments\\\\n+passed to the returned function are added to the arguments originally passed\\\\n+to apply.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\n+* `arguments...` - Any number of arguments to automatically apply when the\\\\n+  continuation is called.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// using apply\\\\n+\\\\n+async.parallel([\\\\n+    async.apply(fs.writeFile, 'testfile1', 'test1'),\\\\n+    async.apply(fs.writeFile, 'testfile2', 'test2'),\\\\n+]);\\\\n+\\\\n+\\\\n+// the same process without using apply\\\\n+\\\\n+async.parallel([\\\\n+    function(callback){\\\\n+        fs.writeFile('testfile1', 'test1', callback);\\\\n+    },\\\\n+    function(callback){\\\\n+        fs.writeFile('testfile2', 'test2', callback);\\\\n+    }\\\\n+]);\\\\n+```\\\\n+\\\\n+It's possible to pass any number of additional arguments when calling the\\\\n+continuation:\\\\n+\\\\n+```js\\\\n+node> var fn = async.apply(sys.puts, 'one');\\\\n+node> fn('two', 'three');\\\\n+one\\\\n+two\\\\n+three\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"nextTick\\\\\\\" />\\\\n+### nextTick(callback)\\\\n+\\\\n+Calls `callback` on a later loop around the event loop. In Node.js this just\\\\n+calls `process.nextTick`; in the browser it falls back to `setImmediate(callback)`\\\\n+if available, otherwise `setTimeout(callback, 0)`, which means other higher priority\\\\n+events may precede the execution of `callback`.\\\\n+\\\\n+This is used internally for browser-compatibility purposes.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `callback` - The function to call on a later loop around the event loop.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var call_order = [];\\\\n+async.nextTick(function(){\\\\n+    call_order.push('two');\\\\n+    // call_order now equals ['one','two']\\\\n+});\\\\n+call_order.push('one')\\\\n+```\\\\n+\\\\n+<a name=\\\\\\\"times\\\\\\\" />\\\\n+### times(n, callback)\\\\n+\\\\n+Calls the `callback` function `n` times, and accumulates results in the same manner\\\\n+you would use with [`map`](#map).\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `n` - The number of times to run the function.\\\\n+* `callback` - The function to call `n` times.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// Pretend this is some complicated async factory\\\\n+var createUser = function(id, callback) {\\\\n+  callback(null, {\\\\n+    id: 'user' + id\\\\n+  })\\\\n+}\\\\n+// generate 5 users\\\\n+async.times(5, function(n, next){\\\\n+    createUser(n, function(err, user) {\\\\n+      next(err, user)\\\\n+    })\\\\n+}, function(err, users) {\\\\n+  // we should now have 5 users\\\\n+});\\\\n+```\\\\n+\\\\n+<a name=\\\\\\\"timesSeries\\\\\\\" />\\\\n+### timesSeries(n, callback)\\\\n+\\\\n+The same as [`times`](#times), only the iterator is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+The results array will be in the same order as the original.\\\\n+\\\\n+\\\\n+## Utils\\\\n+\\\\n+<a name=\\\\\\\"memoize\\\\\\\" />\\\\n+### memoize(fn, [hasher])\\\\n+\\\\n+Caches the results of an `async` function. When creating a hash to store function\\\\n+results against, the callback is omitted from the hash and an optional hash\\\\n+function can be used.\\\\n+\\\\n+The cache of results is exposed as the `memo` property of the function returned\\\\n+by `memoize`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `fn` - The function to proxy and cache results from.\\\\n+* `hasher` - Tn optional function for generating a custom hash for storing\\\\n+  results. It has all the arguments applied to it apart from the callback, and\\\\n+  must be synchronous.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var slow_fn = function (name, callback) {\\\\n+    // do something\\\\n+    callback(null, result);\\\\n+};\\\\n+var fn = async.memoize(slow_fn);\\\\n+\\\\n+// fn can now be used as if it were slow_fn\\\\n+fn('some name', function () {\\\\n+    // callback\\\\n+});\\\\n+```\\\\n+\\\\n+<a name=\\\\\\\"unmemoize\\\\\\\" />\\\\n+### unmemoize(fn)\\\\n+\\\\n+Undoes a [`memoize`](#memoize)d function, reverting it to the original, unmemoized\\\\n+form. Handy for testing.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `fn` - the memoized function\\\\n+\\\\n+<a name=\\\\\\\"log\\\\\\\" />\\\\n+### log(function, arguments)\\\\n+\\\\n+Logs the result of an `async` function to the `console`. Only works in Node.js or\\\\n+in browsers that support `console.log` and `console.error` (such as FF and Chrome).\\\\n+If multiple arguments are returned from the async function, `console.log` is\\\\n+called on each argument in order.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\n+* `arguments...` - Any number of arguments to apply to the function.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var hello = function(name, callback){\\\\n+    setTimeout(function(){\\\\n+        callback(null, 'hello ' + name);\\\\n+    }, 1000);\\\\n+};\\\\n+```\\\\n+```js\\\\n+node> async.log(hello, 'world');\\\\n+'hello world'\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"dir\\\\\\\" />\\\\n+### dir(function, arguments)\\\\n+\\\\n+Logs the result of an `async` function to the `console` using `console.dir` to\\\\n+display the properties of the resulting object. Only works in Node.js or\\\\n+in browsers that support `console.dir` and `console.error` (such as FF and Chrome).\\\\n+If multiple arguments are returned from the async function, `console.dir` is\\\\n+called on each argument in order.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\n+* `arguments...` - Any number of arguments to apply to the function.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var hello = function(name, callback){\\\\n+    setTimeout(function(){\\\\n+        callback(null, {hello: name});\\\\n+    }, 1000);\\\\n+};\\\\n+```\\\\n+```js\\\\n+node> async.dir(hello, 'world');\\\\n+{hello: 'world'}\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"noConflict\\\\\\\" />\\\\n+### noConflict()\\\\n+\\\\n+Changes the value of `async` back to its original value, returning a reference to the\\\\n+`async` object.\\\\ndiff --git a/node_modules/async/component.json b/node_modules/async/component.json\\\\nnew file mode 100644\\\\nindex 0000000..bbb0115\\\\n--- /dev/null\\\\n+++ b/node_modules/async/component.json\\\\n@@ -0,0 +1,11 @@\\\\n+{\\\\n+  \\\\\\\"name\\\\\\\": \\\\\\\"async\\\\\\\",\\\\n+  \\\\\\\"repo\\\\\\\": \\\\\\\"caolan/async\\\\\\\",\\\\n+  \\\\\\\"description\\\\\\\": \\\\\\\"Higher-order functions and common patterns for asynchronous code\\\\\\\",\\\\n+  \\\\\\\"version\\\\\\\": \\\\\\\"0.1.23\\\\\\\",\\\\n+  \\\\\\\"keywords\\\\\\\": [],\\\\n+  \\\\\\\"dependencies\\\\\\\": {},\\\\n+  \\\\\\\"development\\\\\\\": {},\\\\n+  \\\\\\\"main\\\\\\\": \\\\\\\"lib/async.js\\\\\\\",\\\\n+  \\\\\\\"scripts\\\\\\\": [ \\\\\\\"lib/async.js\\\\\\\" ]\\\\n+}\\\\ndiff --git a/node_modules/async/lib/async.js b/node_modules/async/lib/async.js\\\\nnew file mode 100644\\\\nindex 0000000..01e8afc\\\\n--- /dev/null\\\\n+++ b/node_modules/async/lib/async.js\\\\n@@ -0,0 +1,1123 @@\\\\n+/*!\\\\n+ * async\\\\n+ * https://github.com/caolan/async\\\\n+ *\\\\n+ * Copyright 2010-2014 Caolan McMahon\\\\n+ * Released under the MIT license\\\\n+ */\\\\n+/*jshint onevar: false, indent:4 */\\\\n+/*global setImmediate: false, setTimeout: false, console: false */\\\\n+(function () {\\\\n+\\\\n+    var async = {};\\\\n+\\\\n+    // global on the server, window in the browser\\\\n+    var root, previous_async;\\\\n+\\\\n+    root = this;\\\\n+    if (root != null) {\\\\n+      previous_async = root.async;\\\\n+    }\\\\n+\\\\n+    async.noConflict = function () {\\\\n+        root.async = previous_async;\\\\n+        return async;\\\\n+    };\\\\n+\\\\n+    function only_once(fn) {\\\\n+        var called = false;\\\\n+        return function() {\\\\n+            if (called) throw new Error(\\\\\\\"Callback was already called.\\\\\\\");\\\\n+            called = true;\\\\n+            fn.apply(root, arguments);\\\\n+        }\\\\n+    }\\\\n+\\\\n+    //// cross-browser compatiblity functions ////\\\\n+\\\\n+    var _toString = Object.prototype.toString;\\\\n+\\\\n+    var _isArray = Array.isArray || function (obj) {\\\\n+        return _toString.call(obj) === '[object Array]';\\\\n+    };\\\\n+\\\\n+    var _each = function (arr, iterator) {\\\\n+        if (arr.forEach) {\\\\n+            return arr.forEach(iterator);\\\\n+        }\\\\n+        for (var i = 0; i < arr.length; i += 1) {\\\\n+            iterator(arr[i], i, arr);\\\\n+        }\\\\n+    };\\\\n+\\\\n+    var _map = function (arr, iterator) {\\\\n+        if (arr.map) {\\\\n+            return arr.map(iterator);\\\\n+        }\\\\n+        var results = [];\\\\n+        _each(arr, function (x, i, a) {\\\\n+            results.push(iterator(x, i, a));\\\\n+        });\\\\n+        return results;\\\\n+    };\\\\n+\\\\n+    var _reduce = function (arr, iterator, memo) {\\\\n+        if (arr.reduce) {\\\\n+            return arr.reduce(iterator, memo);\\\\n+        }\\\\n+        _each(arr, function (x, i, a) {\\\\n+            memo = iterator(memo, x, i, a);\\\\n+        });\\\\n+        return memo;\\\\n+    };\\\\n+\\\\n+    var _keys = function (obj) {\\\\n+        if (Object.keys) {\\\\n+            return Object.keys(obj);\\\\n+        }\\\\n+        var keys = [];\\\\n+        for (var k in obj) {\\\\n+            if (obj.hasOwnProperty(k)) {\\\\n+                keys.push(k);\\\\n+            }\\\\n+        }\\\\n+        return keys;\\\\n+    };\\\\n+\\\\n+    //// exported async module functions ////\\\\n+\\\\n+    //// nextTick implementation with browser-compatible fallback ////\\\\n+    if (typeof process === 'undefined' || !(process.nextTick)) {\\\\n+        if (typeof setImmediate === 'function') {\\\\n+            async.nextTick = function (fn) {\\\\n+                // not a direct alias for IE10 compatibility\\\\n+                setImmediate(fn);\\\\n+            };\\\\n+            async.setImmediate = async.nextTick;\\\\n+        }\\\\n+        else {\\\\n+            async.nextTick = function (fn) {\\\\n+                setTimeout(fn, 0);\\\\n+            };\\\\n+            async.setImmediate = async.nextTick;\\\\n+        }\\\\n+    }\\\\n+    else {\\\\n+        async.nextTick = process.nextTick;\\\\n+        if (typeof setImmediate !== 'undefined') {\\\\n+            async.setImmediate = function (fn) {\\\\n+              // not a direct alias for IE10 compatibility\\\\n+              setImmediate(fn);\\\\n+            };\\\\n+        }\\\\n+        else {\\\\n+            async.setImmediate = async.nextTick;\\\\n+        }\\\\n+    }\\\\n+\\\\n+    async.each = function (arr, iterator, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (!arr.length) {\\\\n+            return callback();\\\\n+        }\\\\n+        var completed = 0;\\\\n+        _each(arr, function (x) {\\\\n+            iterator(x, only_once(done) );\\\\n+        });\\\\n+        function done(err) {\\\\n+          if (err) {\\\\n+              callback(err);\\\\n+              callback = function () {};\\\\n+          }\\\\n+          else {\\\\n+              completed += 1;\\\\n+              if (completed >= arr.length) {\\\\n+                  callback();\\\\n+              }\\\\n+          }\\\\n+        }\\\\n+    };\\\\n+    async.forEach = async.each;\\\\n+\\\\n+    async.eachSeries = function (arr, iterator, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (!arr.length) {\\\\n+            return callback();\\\\n+        }\\\\n+        var completed = 0;\\\\n+        var iterate = function () {\\\\n+            iterator(arr[completed], function (err) {\\\\n+                if (err) {\\\\n+                    callback(err);\\\\n+                    callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    completed += 1;\\\\n+                    if (completed >= arr.length) {\\\\n+                        callback();\\\\n+                    }\\\\n+                    else {\\\\n+                        iterate();\\\\n+                    }\\\\n+                }\\\\n+            });\\\\n+        };\\\\n+        iterate();\\\\n+    };\\\\n+    async.forEachSeries = async.eachSeries;\\\\n+\\\\n+    async.eachLimit = function (arr, limit, iterator, callback) {\\\\n+        var fn = _eachLimit(limit);\\\\n+        fn.apply(null, [arr, iterator, callback]);\\\\n+    };\\\\n+    async.forEachLimit = async.eachLimit;\\\\n+\\\\n+    var _eachLimit = function (limit) {\\\\n+\\\\n+        return function (arr, iterator, callback) {\\\\n+            callback = callback || function () {};\\\\n+            if (!arr.length || limit <= 0) {\\\\n+                return callback();\\\\n+            }\\\\n+            var completed = 0;\\\\n+            var started = 0;\\\\n+            var running = 0;\\\\n+\\\\n+            (function replenish () {\\\\n+                if (completed >= arr.length) {\\\\n+                    return callback();\\\\n+                }\\\\n+\\\\n+                while (running < limit && started < arr.length) {\\\\n+                    started += 1;\\\\n+                    running += 1;\\\\n+                    iterator(arr[started - 1], function (err) {\\\\n+                        if (err) {\\\\n+                            callback(err);\\\\n+                            callback = function () {};\\\\n+                        }\\\\n+                        else {\\\\n+                            completed += 1;\\\\n+                            running -= 1;\\\\n+                            if (completed >= arr.length) {\\\\n+                                callback();\\\\n+                            }\\\\n+                            else {\\\\n+                                replenish();\\\\n+                            }\\\\n+                        }\\\\n+                    });\\\\n+                }\\\\n+            })();\\\\n+        };\\\\n+    };\\\\n+\\\\n+\\\\n+    var doParallel = function (fn) {\\\\n+        return function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            return fn.apply(null, [async.each].concat(args));\\\\n+        };\\\\n+    };\\\\n+    var doParallelLimit = function(limit, fn) {\\\\n+        return function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            return fn.apply(null, [_eachLimit(limit)].concat(args));\\\\n+        };\\\\n+    };\\\\n+    var doSeries = function (fn) {\\\\n+        return function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            return fn.apply(null, [async.eachSeries].concat(args));\\\\n+        };\\\\n+    };\\\\n+\\\\n+\\\\n+    var _asyncMap = function (eachfn, arr, iterator, callback) {\\\\n+        arr = _map(arr, function (x, i) {\\\\n+            return {index: i, value: x};\\\\n+        });\\\\n+        if (!callback) {\\\\n+            eachfn(arr, function (x, callback) {\\\\n+                iterator(x.value, function (err) {\\\\n+                    callback(err);\\\\n+                });\\\\n+            });\\\\n+        } else {\\\\n+            var results = [];\\\\n+            eachfn(arr, function (x, callback) {\\\\n+                iterator(x.value, function (err, v) {\\\\n+                    results[x.index] = v;\\\\n+                    callback(err);\\\\n+                });\\\\n+            }, function (err) {\\\\n+                callback(err, results);\\\\n+            });\\\\n+        }\\\\n+    };\\\\n+    async.map = doParallel(_asyncMap);\\\\n+    async.mapSeries = doSeries(_asyncMap);\\\\n+    async.mapLimit = function (arr, limit, iterator, callback) {\\\\n+        return _mapLimit(limit)(arr, iterator, callback);\\\\n+    };\\\\n+\\\\n+    var _mapLimit = function(limit) {\\\\n+        return doParallelLimit(limit, _asyncMap);\\\\n+    };\\\\n+\\\\n+    // reduce only has a series version, as doing reduce in parallel won't\\\\n+    // work in many situations.\\\\n+    async.reduce = function (arr, memo, iterator, callback) {\\\\n+        async.eachSeries(arr, function (x, callback) {\\\\n+            iterator(memo, x, function (err, v) {\\\\n+                memo = v;\\\\n+                callback(err);\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(err, memo);\\\\n+        });\\\\n+    };\\\\n+    // inject alias\\\\n+    async.inject = async.reduce;\\\\n+    // foldl alias\\\\n+    async.foldl = async.reduce;\\\\n+\\\\n+    async.reduceRight = function (arr, memo, iterator, callback) {\\\\n+        var reversed = _map(arr, function (x) {\\\\n+            return x;\\\\n+        }).reverse();\\\\n+        async.reduce(reversed, memo, iterator, callback);\\\\n+    };\\\\n+    // foldr alias\\\\n+    async.foldr = async.reduceRight;\\\\n+\\\\n+    var _filter = function (eachfn, arr, iterator, callback) {\\\\n+        var results = [];\\\\n+        arr = _map(arr, function (x, i) {\\\\n+            return {index: i, value: x};\\\\n+        });\\\\n+        eachfn(arr, function (x, callback) {\\\\n+            iterator(x.value, function (v) {\\\\n+                if (v) {\\\\n+                    results.push(x);\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(_map(results.sort(function (a, b) {\\\\n+                return a.index - b.index;\\\\n+            }), function (x) {\\\\n+                return x.value;\\\\n+            }));\\\\n+        });\\\\n+    };\\\\n+    async.filter = doParallel(_filter);\\\\n+    async.filterSeries = doSeries(_filter);\\\\n+    // select alias\\\\n+    async.select = async.filter;\\\\n+    async.selectSeries = async.filterSeries;\\\\n+\\\\n+    var _reject = function (eachfn, arr, iterator, callback) {\\\\n+        var results = [];\\\\n+        arr = _map(arr, function (x, i) {\\\\n+            return {index: i, value: x};\\\\n+        });\\\\n+        eachfn(arr, function (x, callback) {\\\\n+            iterator(x.value, function (v) {\\\\n+                if (!v) {\\\\n+                    results.push(x);\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(_map(results.sort(function (a, b) {\\\\n+                return a.index - b.index;\\\\n+            }), function (x) {\\\\n+                return x.value;\\\\n+            }));\\\\n+        });\\\\n+    };\\\\n+    async.reject = doParallel(_reject);\\\\n+    async.rejectSeries = doSeries(_reject);\\\\n+\\\\n+    var _detect = function (eachfn, arr, iterator, main_callback) {\\\\n+        eachfn(arr, function (x, callback) {\\\\n+            iterator(x, function (result) {\\\\n+                if (result) {\\\\n+                    main_callback(x);\\\\n+                    main_callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    callback();\\\\n+                }\\\\n+            });\\\\n+        }, function (err) {\\\\n+            main_callback();\\\\n+        });\\\\n+    };\\\\n+    async.detect = doParallel(_detect);\\\\n+    async.detectSeries = doSeries(_detect);\\\\n+\\\\n+    async.some = function (arr, iterator, main_callback) {\\\\n+        async.each(arr, function (x, callback) {\\\\n+            iterator(x, function (v) {\\\\n+                if (v) {\\\\n+                    main_callback(true);\\\\n+                    main_callback = function () {};\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            main_callback(false);\\\\n+        });\\\\n+    };\\\\n+    // any alias\\\\n+    async.any = async.some;\\\\n+\\\\n+    async.every = function (arr, iterator, main_callback) {\\\\n+        async.each(arr, function (x, callback) {\\\\n+            iterator(x, function (v) {\\\\n+                if (!v) {\\\\n+                    main_callback(false);\\\\n+                    main_callback = function () {};\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            main_callback(true);\\\\n+        });\\\\n+    };\\\\n+    // all alias\\\\n+    async.all = async.every;\\\\n+\\\\n+    async.sortBy = function (arr, iterator, callback) {\\\\n+        async.map(arr, function (x, callback) {\\\\n+            iterator(x, function (err, criteria) {\\\\n+                if (err) {\\\\n+                    callback(err);\\\\n+                }\\\\n+                else {\\\\n+                    callback(null, {value: x, criteria: criteria});\\\\n+                }\\\\n+            });\\\\n+        }, function (err, results) {\\\\n+            if (err) {\\\\n+                return callback(err);\\\\n+            }\\\\n+            else {\\\\n+                var fn = function (left, right) {\\\\n+                    var a = left.criteria, b = right.criteria;\\\\n+                    return a < b ? -1 : a > b ? 1 : 0;\\\\n+                };\\\\n+                callback(null, _map(results.sort(fn), function (x) {\\\\n+                    return x.value;\\\\n+                }));\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.auto = function (tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        var keys = _keys(tasks);\\\\n+        var remainingTasks = keys.length\\\\n+        if (!remainingTasks) {\\\\n+            return callback();\\\\n+        }\\\\n+\\\\n+        var results = {};\\\\n+\\\\n+        var listeners = [];\\\\n+        var addListener = function (fn) {\\\\n+            listeners.unshift(fn);\\\\n+        };\\\\n+        var removeListener = function (fn) {\\\\n+            for (var i = 0; i < listeners.length; i += 1) {\\\\n+                if (listeners[i] === fn) {\\\\n+                    listeners.splice(i, 1);\\\\n+                    return;\\\\n+                }\\\\n+            }\\\\n+        };\\\\n+        var taskComplete = function () {\\\\n+            remainingTasks--\\\\n+            _each(listeners.slice(0), function (fn) {\\\\n+                fn();\\\\n+            });\\\\n+        };\\\\n+\\\\n+        addListener(function () {\\\\n+            if (!remainingTasks) {\\\\n+                var theCallback = callback;\\\\n+                // prevent final callback from calling itself if it errors\\\\n+                callback = function () {};\\\\n+\\\\n+                theCallback(null, results);\\\\n+            }\\\\n+        });\\\\n+\\\\n+        _each(keys, function (k) {\\\\n+            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\\\\n+            var taskCallback = function (err) {\\\\n+                var args = Array.prototype.slice.call(arguments, 1);\\\\n+                if (args.length <= 1) {\\\\n+                    args = args[0];\\\\n+                }\\\\n+                if (err) {\\\\n+                    var safeResults = {};\\\\n+                    _each(_keys(results), function(rkey) {\\\\n+                        safeResults[rkey] = results[rkey];\\\\n+                    });\\\\n+                    safeResults[k] = args;\\\\n+                    callback(err, safeResults);\\\\n+                    // stop subsequent errors hitting callback multiple times\\\\n+                    callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    results[k] = args;\\\\n+                    async.setImmediate(taskComplete);\\\\n+                }\\\\n+            };\\\\n+            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\\\\n+            var ready = function () {\\\\n+                return _reduce(requires, function (a, x) {\\\\n+                    return (a && results.hasOwnProperty(x));\\\\n+                }, true) && !results.hasOwnProperty(k);\\\\n+            };\\\\n+            if (ready()) {\\\\n+                task[task.length - 1](taskCallback, results);\\\\n+            }\\\\n+            else {\\\\n+                var listener = function () {\\\\n+                    if (ready()) {\\\\n+                        removeListener(listener);\\\\n+                        task[task.length - 1](taskCallback, results);\\\\n+                    }\\\\n+                };\\\\n+                addListener(listener);\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.retry = function(times, task, callback) {\\\\n+        var DEFAULT_TIMES = 5;\\\\n+        var attempts = [];\\\\n+        // Use defaults if times not passed\\\\n+        if (typeof times === 'function') {\\\\n+            callback = task;\\\\n+            task = times;\\\\n+            times = DEFAULT_TIMES;\\\\n+        }\\\\n+        // Make sure times is a number\\\\n+        times = parseInt(times, 10) || DEFAULT_TIMES;\\\\n+        var wrappedTask = function(wrappedCallback, wrappedResults) {\\\\n+            var retryAttempt = function(task, finalAttempt) {\\\\n+                return function(seriesCallback) {\\\\n+                    task(function(err, result){\\\\n+                        seriesCallback(!err || finalAttempt, {err: err, result: result});\\\\n+                    }, wrappedResults);\\\\n+                };\\\\n+            };\\\\n+            while (times) {\\\\n+                attempts.push(retryAttempt(task, !(times-=1)));\\\\n+            }\\\\n+            async.series(attempts, function(done, data){\\\\n+                data = data[data.length - 1];\\\\n+                (wrappedCallback || callback)(data.err, data.result);\\\\n+            });\\\\n+        }\\\\n+        // If a callback is passed, run this as a controll flow\\\\n+        return callback ? wrappedTask() : wrappedTask\\\\n+    };\\\\n+\\\\n+    async.waterfall = function (tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (!_isArray(tasks)) {\\\\n+          var err = new Error('First argument to waterfall must be an array of functions');\\\\n+          return callback(err);\\\\n+        }\\\\n+        if (!tasks.length) {\\\\n+            return callback();\\\\n+        }\\\\n+        var wrapIterator = function (iterator) {\\\\n+            return function (err) {\\\\n+                if (err) {\\\\n+                    callback.apply(null, arguments);\\\\n+                    callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\n+                    var next = iterator.next();\\\\n+                    if (next) {\\\\n+                        args.push(wrapIterator(next));\\\\n+                    }\\\\n+                    else {\\\\n+                        args.push(callback);\\\\n+                    }\\\\n+                    async.setImmediate(function () {\\\\n+                        iterator.apply(null, args);\\\\n+                    });\\\\n+                }\\\\n+            };\\\\n+        };\\\\n+        wrapIterator(async.iterator(tasks))();\\\\n+    };\\\\n+\\\\n+    var _parallel = function(eachfn, tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (_isArray(tasks)) {\\\\n+            eachfn.map(tasks, function (fn, callback) {\\\\n+                if (fn) {\\\\n+                    fn(function (err) {\\\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\\\n+                        if (args.length <= 1) {\\\\n+                            args = args[0];\\\\n+                        }\\\\n+                        callback.call(null, err, args);\\\\n+                    });\\\\n+                }\\\\n+            }, callback);\\\\n+        }\\\\n+        else {\\\\n+            var results = {};\\\\n+            eachfn.each(_keys(tasks), function (k, callback) {\\\\n+                tasks[k](function (err) {\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\n+                    if (args.length <= 1) {\\\\n+                        args = args[0];\\\\n+                    }\\\\n+                    results[k] = args;\\\\n+                    callback(err);\\\\n+                });\\\\n+            }, function (err) {\\\\n+                callback(err, results);\\\\n+            });\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.parallel = function (tasks, callback) {\\\\n+        _parallel({ map: async.map, each: async.each }, tasks, callback);\\\\n+    };\\\\n+\\\\n+    async.parallelLimit = function(tasks, limit, callback) {\\\\n+        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\\\\n+    };\\\\n+\\\\n+    async.series = function (tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (_isArray(tasks)) {\\\\n+            async.mapSeries(tasks, function (fn, callback) {\\\\n+                if (fn) {\\\\n+                    fn(function (err) {\\\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\\\n+                        if (args.length <= 1) {\\\\n+                            args = args[0];\\\\n+                        }\\\\n+                        callback.call(null, err, args);\\\\n+                    });\\\\n+                }\\\\n+            }, callback);\\\\n+        }\\\\n+        else {\\\\n+            var results = {};\\\\n+            async.eachSeries(_keys(tasks), function (k, callback) {\\\\n+                tasks[k](function (err) {\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\n+                    if (args.length <= 1) {\\\\n+                        args = args[0];\\\\n+                    }\\\\n+                    results[k] = args;\\\\n+                    callback(err);\\\\n+                });\\\\n+            }, function (err) {\\\\n+                callback(err, results);\\\\n+            });\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.iterator = function (tasks) {\\\\n+        var makeCallback = function (index) {\\\\n+            var fn = function () {\\\\n+                if (tasks.length) {\\\\n+                    tasks[index].apply(null, arguments);\\\\n+                }\\\\n+                return fn.next();\\\\n+            };\\\\n+            fn.next = function () {\\\\n+                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\\\\n+            };\\\\n+            return fn;\\\\n+        };\\\\n+        return makeCallback(0);\\\\n+    };\\\\n+\\\\n+    async.apply = function (fn) {\\\\n+        var args = Array.prototype.slice.call(arguments, 1);\\\\n+        return function () {\\\\n+            return fn.apply(\\\\n+                null, args.concat(Array.prototype.slice.call(arguments))\\\\n+            );\\\\n+        };\\\\n+    };\\\\n+\\\\n+    var _concat = function (eachfn, arr, fn, callback) {\\\\n+        var r = [];\\\\n+        eachfn(arr, function (x, cb) {\\\\n+            fn(x, function (err, y) {\\\\n+                r = r.concat(y || []);\\\\n+                cb(err);\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(err, r);\\\\n+        });\\\\n+    };\\\\n+    async.concat = doParallel(_concat);\\\\n+    async.concatSeries = doSeries(_concat);\\\\n+\\\\n+    async.whilst = function (test, iterator, callback) {\\\\n+        if (test()) {\\\\n+            iterator(function (err) {\\\\n+                if (err) {\\\\n+                    return callback(err);\\\\n+                }\\\\n+                async.whilst(test, iterator, callback);\\\\n+            });\\\\n+        }\\\\n+        else {\\\\n+            callback();\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.doWhilst = function (iterator, test, callback) {\\\\n+        iterator(function (err) {\\\\n+            if (err) {\\\\n+                return callback(err);\\\\n+            }\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\n+            if (test.apply(null, args)) {\\\\n+                async.doWhilst(iterator, test, callback);\\\\n+            }\\\\n+            else {\\\\n+                callback();\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.until = function (test, iterator, callback) {\\\\n+        if (!test()) {\\\\n+            iterator(function (err) {\\\\n+                if (err) {\\\\n+                    return callback(err);\\\\n+                }\\\\n+                async.until(test, iterator, callback);\\\\n+            });\\\\n+        }\\\\n+        else {\\\\n+            callback();\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.doUntil = function (iterator, test, callback) {\\\\n+        iterator(function (err) {\\\\n+            if (err) {\\\\n+                return callback(err);\\\\n+            }\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\n+            if (!test.apply(null, args)) {\\\\n+                async.doUntil(iterator, test, callback);\\\\n+            }\\\\n+            else {\\\\n+                callback();\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.queue = function (worker, concurrency) {\\\\n+        if (concurrency === undefined) {\\\\n+            concurrency = 1;\\\\n+        }\\\\n+        function _insert(q, data, pos, callback) {\\\\n+          if (!q.started){\\\\n+            q.started = true;\\\\n+          }\\\\n+          if (!_isArray(data)) {\\\\n+              data = [data];\\\\n+          }\\\\n+          if(data.length == 0) {\\\\n+             // call drain immediately if there are no tasks\\\\n+             return async.setImmediate(function() {\\\\n+                 if (q.drain) {\\\\n+                     q.drain();\\\\n+                 }\\\\n+             });\\\\n+          }\\\\n+          _each(data, function(task) {\\\\n+              var item = {\\\\n+                  data: task,\\\\n+                  callback: typeof callback === 'function' ? callback : null\\\\n+              };\\\\n+\\\\n+              if (pos) {\\\\n+                q.tasks.unshift(item);\\\\n+              } else {\\\\n+                q.tasks.push(item);\\\\n+              }\\\\n+\\\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\\\n+                  q.saturated();\\\\n+              }\\\\n+              async.setImmediate(q.process);\\\\n+          });\\\\n+        }\\\\n+\\\\n+        var workers = 0;\\\\n+        var q = {\\\\n+            tasks: [],\\\\n+            concurrency: concurrency,\\\\n+            saturated: null,\\\\n+            empty: null,\\\\n+            drain: null,\\\\n+            started: false,\\\\n+            paused: false,\\\\n+            push: function (data, callback) {\\\\n+              _insert(q, data, false, callback);\\\\n+            },\\\\n+            kill: function () {\\\\n+              q.drain = null;\\\\n+              q.tasks = [];\\\\n+            },\\\\n+            unshift: function (data, callback) {\\\\n+              _insert(q, data, true, callback);\\\\n+            },\\\\n+            process: function () {\\\\n+                if (!q.paused && workers < q.concurrency && q.tasks.length) {\\\\n+                    var task = q.tasks.shift();\\\\n+                    if (q.empty && q.tasks.length === 0) {\\\\n+                        q.empty();\\\\n+                    }\\\\n+                    workers += 1;\\\\n+                    var next = function () {\\\\n+                        workers -= 1;\\\\n+                        if (task.callback) {\\\\n+                            task.callback.apply(task, arguments);\\\\n+                        }\\\\n+                        if (q.drain && q.tasks.length + workers === 0) {\\\\n+                            q.drain();\\\\n+                        }\\\\n+                        q.process();\\\\n+                    };\\\\n+                    var cb = only_once(next);\\\\n+                    worker(task.data, cb);\\\\n+                }\\\\n+            },\\\\n+            length: function () {\\\\n+                return q.tasks.length;\\\\n+            },\\\\n+            running: function () {\\\\n+                return workers;\\\\n+            },\\\\n+            idle: function() {\\\\n+                return q.tasks.length + workers === 0;\\\\n+            },\\\\n+            pause: function () {\\\\n+                if (q.paused === true) { return; }\\\\n+                q.paused = true;\\\\n+                q.process();\\\\n+            },\\\\n+            resume: function () {\\\\n+                if (q.paused === false) { return; }\\\\n+                q.paused = false;\\\\n+                q.process();\\\\n+            }\\\\n+        };\\\\n+        return q;\\\\n+    };\\\\n+    \\\\n+    async.priorityQueue = function (worker, concurrency) {\\\\n+        \\\\n+        function _compareTasks(a, b){\\\\n+          return a.priority - b.priority;\\\\n+        };\\\\n+        \\\\n+        function _binarySearch(sequence, item, compare) {\\\\n+          var beg = -1,\\\\n+              end = sequence.length - 1;\\\\n+          while (beg < end) {\\\\n+            var mid = beg + ((end - beg + 1) >>> 1);\\\\n+            if (compare(item, sequence[mid]) >= 0) {\\\\n+              beg = mid;\\\\n+            } else {\\\\n+              end = mid - 1;\\\\n+            }\\\\n+          }\\\\n+          return beg;\\\\n+        }\\\\n+        \\\\n+        function _insert(q, data, priority, callback) {\\\\n+          if (!q.started){\\\\n+            q.started = true;\\\\n+          }\\\\n+          if (!_isArray(data)) {\\\\n+              data = [data];\\\\n+          }\\\\n+          if(data.length == 0) {\\\\n+             // call drain immediately if there are no tasks\\\\n+             return async.setImmediate(function() {\\\\n+                 if (q.drain) {\\\\n+                     q.drain();\\\\n+                 }\\\\n+             });\\\\n+          }\\\\n+          _each(data, function(task) {\\\\n+              var item = {\\\\n+                  data: task,\\\\n+                  priority: priority,\\\\n+                  callback: typeof callback === 'function' ? callback : null\\\\n+              };\\\\n+              \\\\n+              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\\\\n+\\\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\\\n+                  q.saturated();\\\\n+              }\\\\n+              async.setImmediate(q.process);\\\\n+          });\\\\n+        }\\\\n+        \\\\n+        // Start with a normal queue\\\\n+        var q = async.queue(worker, concurrency);\\\\n+        \\\\n+        // Override push to accept second parameter representing priority\\\\n+        q.push = function (data, priority, callback) {\\\\n+          _insert(q, data, priority, callback);\\\\n+        };\\\\n+        \\\\n+        // Remove unshift function\\\\n+        delete q.unshift;\\\\n+\\\\n+        return q;\\\\n+    };\\\\n+\\\\n+    async.cargo = function (worker, payload) {\\\\n+        var working     = false,\\\\n+            tasks       = [];\\\\n+\\\\n+        var cargo = {\\\\n+            tasks: tasks,\\\\n+            payload: payload,\\\\n+            saturated: null,\\\\n+            empty: null,\\\\n+            drain: null,\\\\n+            drained: true,\\\\n+            push: function (data, callback) {\\\\n+                if (!_isArray(data)) {\\\\n+                    data = [data];\\\\n+                }\\\\n+                _each(data, function(task) {\\\\n+                    tasks.push({\\\\n+                        data: task,\\\\n+                        callback: typeof callback === 'function' ? callback : null\\\\n+                    });\\\\n+                    cargo.drained = false;\\\\n+                    if (cargo.saturated && tasks.length === payload) {\\\\n+                        cargo.saturated();\\\\n+                    }\\\\n+                });\\\\n+                async.setImmediate(cargo.process);\\\\n+            },\\\\n+            process: function process() {\\\\n+                if (working) return;\\\\n+                if (tasks.length === 0) {\\\\n+                    if(cargo.drain && !cargo.drained) cargo.drain();\\\\n+                    cargo.drained = true;\\\\n+                    return;\\\\n+                }\\\\n+\\\\n+                var ts = typeof payload === 'number'\\\\n+                            ? tasks.splice(0, payload)\\\\n+                            : tasks.splice(0, tasks.length);\\\\n+\\\\n+                var ds = _map(ts, function (task) {\\\\n+                    return task.data;\\\\n+                });\\\\n+\\\\n+                if(cargo.empty) cargo.empty();\\\\n+                working = true;\\\\n+                worker(ds, function () {\\\\n+                    working = false;\\\\n+\\\\n+                    var args = arguments;\\\\n+                    _each(ts, function (data) {\\\\n+                        if (data.callback) {\\\\n+                            data.callback.apply(null, args);\\\\n+                        }\\\\n+                    });\\\\n+\\\\n+                    process();\\\\n+                });\\\\n+            },\\\\n+            length: function () {\\\\n+                return tasks.length;\\\\n+            },\\\\n+            running: function () {\\\\n+                return working;\\\\n+            }\\\\n+        };\\\\n+        return cargo;\\\\n+    };\\\\n+\\\\n+    var _console_fn = function (name) {\\\\n+        return function (fn) {\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\n+            fn.apply(null, args.concat([function (err) {\\\\n+                var args = Array.prototype.slice.call(arguments, 1);\\\\n+                if (typeof console !== 'undefined') {\\\\n+                    if (err) {\\\\n+                        if (console.error) {\\\\n+                            console.error(err);\\\\n+                        }\\\\n+                    }\\\\n+                    else if (console[name]) {\\\\n+                        _each(args, function (x) {\\\\n+                            console[name](x);\\\\n+                        });\\\\n+                    }\\\\n+                }\\\\n+            }]));\\\\n+        };\\\\n+    };\\\\n+    async.log = _console_fn('log');\\\\n+    async.dir = _console_fn('dir');\\\\n+    /*async.info = _console_fn('info');\\\\n+    async.warn = _console_fn('warn');\\\\n+    async.error = _console_fn('error');*/\\\\n+\\\\n+    async.memoize = function (fn, hasher) {\\\\n+        var memo = {};\\\\n+        var queues = {};\\\\n+        hasher = hasher || function (x) {\\\\n+            return x;\\\\n+        };\\\\n+        var memoized = function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            var callback = args.pop();\\\\n+            var key = hasher.apply(null, args);\\\\n+            if (key in memo) {\\\\n+                async.nextTick(function () {\\\\n+                    callback.apply(null, memo[key]);\\\\n+                });\\\\n+            }\\\\n+            else if (key in queues) {\\\\n+                queues[key].push(callback);\\\\n+            }\\\\n+            else {\\\\n+                queues[key] = [callback];\\\\n+                fn.apply(null, args.concat([function () {\\\\n+                    memo[key] = arguments;\\\\n+                    var q = queues[key];\\\\n+                    delete queues[key];\\\\n+                    for (var i = 0, l = q.length; i < l; i++) {\\\\n+                      q[i].apply(null, arguments);\\\\n+                    }\\\\n+                }]));\\\\n+            }\\\\n+        };\\\\n+        memoized.memo = memo;\\\\n+        memoized.unmemoized = fn;\\\\n+        return memoized;\\\\n+    };\\\\n+\\\\n+    async.unmemoize = function (fn) {\\\\n+      return function () {\\\\n+        return (fn.unmemoized || fn).apply(null, arguments);\\\\n+      };\\\\n+    };\\\\n+\\\\n+    async.times = function (count, iterator, callback) {\\\\n+        var counter = [];\\\\n+        for (var i = 0; i < count; i++) {\\\\n+            counter.push(i);\\\\n+        }\\\\n+        return async.map(counter, iterator, callback);\\\\n+    };\\\\n+\\\\n+    async.timesSeries = function (count, iterator, callback) {\\\\n+        var counter = [];\\\\n+        for (var i = 0; i < count; i++) {\\\\n+            counter.push(i);\\\\n+        }\\\\n+        return async.mapSeries(counter, iterator, callback);\\\\n+    };\\\\n+\\\\n+    async.seq = function (/* functions... */) {\\\\n+        var fns = arguments;\\\\n+        return function () {\\\\n+            var that = this;\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            var callback = args.pop();\\\\n+            async.reduce(fns, args, function (newargs, fn, cb) {\\\\n+                fn.apply(that, newargs.concat([function () {\\\\n+                    var err = arguments[0];\\\\n+                    var nextargs = Array.prototype.slice.call(arguments, 1);\\\\n+                    cb(err, nextargs);\\\\n+                }]))\\\\n+            },\\\\n+            function (err, results) {\\\\n+                callback.apply(that, [err].concat(results));\\\\n+            });\\\\n+        };\\\\n+    };\\\\n+\\\\n+    async.compose = function (/* functions... */) {\\\\n+      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\\\\n+    };\\\\n+\\\\n+    var _applyEach = function (eachfn, fns /*args...*/) {\\\\n+        var go = function () {\\\\n+            var that = this;\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            var callback = args.pop();\\\\n+            return eachfn(fns, function (fn, cb) {\\\\n+                fn.apply(that, args.concat([cb]));\\\\n+            },\\\\n+            callback);\\\\n+        };\\\\n+        if (arguments.length > 2) {\\\\n+            var args = Array.prototype.slice.call(arguments, 2);\\\\n+            return go.apply(this, args);\\\\n+        }\\\\n+        else {\\\\n+            return go;\\\\n+        }\\\\n+    };\\\\n+    async.applyEach = doParallel(_applyEach);\\\\n+    async.applyEachSeries = doSeries(_applyEach);\\\\n+\\\\n+    async.forever = function (fn, callback) {\\\\n+        function next(err) {\\\\n+            if (err) {\\\\n+                if (callback) {\\\\n+                    return callback(err);\\\\n+                }\\\\n+                throw err;\\\\n+            }\\\\n+            fn(next);\\\\n+        }\\\\n+        next();\\\\n+    };\\\\n+\\\\n+    // Node.js\\\\n+    if (typeof module !== 'undefined' && module.exports) {\\\\n+        module.exports = async;\\\\n+    }\\\\n+    // AMD / RequireJS\\\\n+    else if (typeof define !== 'undefined' && define.amd) {\\\\n+        define([], function () {\\\\n+            return async;\\\\n+        });\\\\n+    }\\\\n+    // included directly via <script> tag\\\\n+    else {\\\\n+        root.async = async;\\\\n+    }\\\\n+\\\\n+}());\\\\ndiff --git a/node_modules/async/package.json b/node_modules/async/package.json\\\\nnew file mode 100644\\\\nindex 0000000..31a5200\\\\n--- /dev/null\\\\n+++ b/node_modules/async/package.json\\\\n@@ -0,0 +1,59 @@\\\\n+{\\\\n+  \\\\\\\"name\\\\\\\": \\\\\\\"async\\\\\\\",\\\\n+  \\\\\\\"description\\\\\\\": \\\\\\\"Higher-order functions and common patterns for asynchronous code\\\\\\\",\\\\n+  \\\\\\\"main\\\\\\\": \\\\\\\"./lib/async\\\\\\\",\\\\n+  \\\\\\\"author\\\\\\\": {\\\\n+    \\\\\\\"name\\\\\\\": \\\\\\\"Caolan McMahon\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"version\\\\\\\": \\\\\\\"0.9.0\\\\\\\",\\\\n+  \\\\\\\"repository\\\\\\\": {\\\\n+    \\\\\\\"type\\\\\\\": \\\\\\\"git\\\\\\\",\\\\n+    \\\\\\\"url\\\\\\\": \\\\\\\"https://github.com/caolan/async.git\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"bugs\\\\\\\": {\\\\n+    \\\\\\\"url\\\\\\\": \\\\\\\"https://github.com/caolan/async/issues\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"licenses\\\\\\\": [\\\\n+    {\\\\n+      \\\\\\\"type\\\\\\\": \\\\\\\"MIT\\\\\\\",\\\\n+      \\\\\\\"url\\\\\\\": \\\\\\\"https://github.com/caolan/async/raw/master/LICENSE\\\\\\\"\\\\n+    }\\\\n+  ],\\\\n+  \\\\\\\"devDependencies\\\\\\\": {\\\\n+    \\\\\\\"nodeunit\\\\\\\": \\\\\\\">0.0.0\\\\\\\",\\\\n+    \\\\\\\"uglify-js\\\\\\\": \\\\\\\"1.2.x\\\\\\\",\\\\n+    \\\\\\\"nodelint\\\\\\\": \\\\\\\">0.0.0\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"jam\\\\\\\": {\\\\n+    \\\\\\\"main\\\\\\\": \\\\\\\"lib/async.js\\\\\\\",\\\\n+    \\\\\\\"include\\\\\\\": [\\\\n+      \\\\\\\"lib/async.js\\\\\\\",\\\\n+      \\\\\\\"README.md\\\\\\\",\\\\n+      \\\\\\\"LICENSE\\\\\\\"\\\\n+    ]\\\\n+  },\\\\n+  \\\\\\\"scripts\\\\\\\": {\\\\n+    \\\\\\\"test\\\\\\\": \\\\\\\"nodeunit test/test-async.js\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"homepage\\\\\\\": \\\\\\\"https://github.com/caolan/async\\\\\\\",\\\\n+  \\\\\\\"_id\\\\\\\": \\\\\\\"async@0.9.0\\\\\\\",\\\\n+  \\\\\\\"dist\\\\\\\": {\\\\n+    \\\\\\\"shasum\\\\\\\": \\\\\\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\\\\\",\\\\n+    \\\\\\\"tarball\\\\\\\": \\\\\\\"http://registry.npmjs.org/async/-/async-0.9.0.tgz\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"_from\\\\\\\": \\\\\\\"async@*\\\\\\\",\\\\n+  \\\\\\\"_npmVersion\\\\\\\": \\\\\\\"1.4.3\\\\\\\",\\\\n+  \\\\\\\"_npmUser\\\\\\\": {\\\\n+    \\\\\\\"name\\\\\\\": \\\\\\\"caolan\\\\\\\",\\\\n+    \\\\\\\"email\\\\\\\": \\\\\\\"caolan.mcmahon@gmail.com\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"maintainers\\\\\\\": [\\\\n+    {\\\\n+      \\\\\\\"name\\\\\\\": \\\\\\\"caolan\\\\\\\",\\\\n+      \\\\\\\"email\\\\\\\": \\\\\\\"caolan@caolanmcmahon.com\\\\\\\"\\\\n+    }\\\\n+  ],\\\\n+  \\\\\\\"directories\\\\\\\": {},\\\\n+  \\\\\\\"_shasum\\\\\\\": \\\\\\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\\\\\",\\\\n+  \\\\\\\"_resolved\\\\\\\": \\\\\\\"https://registry.npmjs.org/async/-/async-0.9.0.tgz\\\\\\\"\\\\n+}\\\\ndiff --git a/package.json b/package.json\\\\nindex 5f21627..6033d43 100644\\\\n--- a/package.json\\\\n+++ b/package.json\\\\n@@ -4,7 +4,8 @@\\\\n   \\\\\\\"description\\\\\\\": \\\\\\\"Sous project\\\\\\\",\\\\n   \\\\\\\"main\\\\\\\": \\\\\\\"main.js\\\\\\\",\\\\n   \\\\\\\"dependencies\\\\\\\": {\\\\n-},\\\\n+    \\\\\\\"async\\\\\\\": \\\\\\\"*\\\\\\\"\\\\n+  },\\\\n   \\\\\\\"devDependencies\\\\\\\": {},\\\\n   \\\\\\\"scripts\\\\\\\": {\\\\n     \\\\\\\"test\\\\\\\": \\\\\\\"echo \\\\\\\\\\\\\\\"Error: no test specified\\\\\\\\\\\\\\\" && exit 1\\\\\\\"\\\\ndiff --git a/patches.sousp b/patches.sousp\\\\nindex 16405a3..d71e511 100644\\\\n--- a/patches.sousp\\\\n+++ b/patches.sousp\\\\n@@ -1,31 +1 @@\\\\n-diff --git a/main.js b/main.js\\\\n-index f81b54e..744cdd5 100644\\\\n---- a/main.js\\\\n-+++ b/main.js\\\\n-@@ -35,7 +35,7 @@ fs.exists('.git', function (exists) {\\\\n-         cp.exec('git diff', function(error, stdout, stderr) {\\\\n-             console.log(stdout);\\\\n- \\\\n--            //fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", stdout);\\\\n-+            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", stdout);\\\\n- \\\\n-             if (error !== null) {\\\\n-                 console.log('stderr: ' + stderr);\\\\n-@@ -44,7 +44,7 @@ fs.exists('.git', function (exists) {\\\\n-         });\\\\n- \\\\n-         cp.exec('git log', function(error, stdout, stderr) {\\\\n--            //console.log(stdout);\\\\n-+            console.log(stdout);\\\\n- \\\\n-             var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n-             var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n-@@ -53,7 +53,7 @@ fs.exists('.git', function (exists) {\\\\n-             console.log(comments);\\\\n-             console.log(dates);\\\\n- \\\\n--            //fs.writeFileSync(\\\\\\\"comments.sousc\\\\\\\", stdout);\\\\n-+            fs.writeFileSync(\\\\\\\"comments.sousc\\\\\\\", stdout);\\\\n- \\\\n-             if (error !== null) {\\\\n-                 console.log('stderr: ' + stderr);\\\\n+[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]\\\\n\\\\\\\\ No newline at end of file\\\\ndiff --git a/test.js b/test.js\\\\nnew file mode 100644\\\\nindex 0000000..5ca759c\\\\n--- /dev/null\\\\n+++ b/test.js\\\\n@@ -0,0 +1,21 @@\\\\n+/**\\\\n+ * Created by Nick on 18.05.2015.\\\\n+ */\\\\n+var async = require('async')\\\\n+    , tasksIndex = [\\\\n+        function (callback) {\\\\n+            // Вымышленный метод который вернет 231\\\\n+            var viewsNumber = models.stat.viewsNumber();\\\\n+            callback(null, viewsNumber);\\\\n+        }\\\\n+        , function (callback) {\\\\n+            // Вымышленный метод который вернет 24\\\\n+            var growFactor = models.stat.growFactor();\\\\n+            callback(null, growFactor);\\\\n+        }\\\\n+    ];\\\\n+\\\\n+async.series(tasksIndex, function (err, results) {\\\\n+    // Результат будет массивом\\\\n+    console.log(results); // [231, 24]\\\\n+});\\\\n\\\\\\\\ No newline at end of file\\\\n\\\"}\\n\\\\ No newline at end of file\\ndiff --git a/patches.txt b/patches.txt\\nnew file mode 100644\\nindex 0000000..300c6a9\\n--- /dev/null\\n+++ b/patches.txt\\n@@ -0,0 +1 @@\\n+{\\\"commit\\\":\\\"1e947f613e976945de85ae35ed923aa470f0be72\\\",\\\"author\\\":\\\"Nick Stepanenko <massaalonso@yandex.ru>\\\",\\\"date\\\":\\\"Tue May 19 00:12:12 2015 +0800\\\",\\\"comment\\\":\\\"Latest updates\\\",\\\"content\\\":\\\"diff --git a/comments.sousc b/comments.sousc\\\\nindex 150b0f6..cb3a850 100644\\\\n--- a/comments.sousc\\\\n+++ b/comments.sousc\\\\n@@ -1,3 +1,27 @@\\\\n+commit 4420cabefc1f470af341af11ed595df67e25c51f\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 17:05:35 2015 +0800\\\\n+\\\\n+    Paste old program code\\\\n+\\\\n+commit 9ef3d25fd4c3afdbcc3107a0abf6d7a2e29cb4dd\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 17:04:52 2015 +0800\\\\n+\\\\n+    Adding new file\\\\n+\\\\n+commit 64814d140d2fab6ae153cac485008119f29bf230\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 17:03:58 2015 +0800\\\\n+\\\\n+    From clear list\\\\n+\\\\n+commit c9d318fea74ea288d544ecf72f00b12c130cf2ef\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 16:59:40 2015 +0800\\\\n+\\\\n+    Create system files\\\\n+\\\\n commit e3c853a4282dfe8f000685dc1d39bd55a4a946c4\\\\n Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n Date:   Sun May 17 16:54:58 2015 +0800\\\\ndiff --git a/main.js b/main.js\\\\nindex e34dc18..86f30c2 100644\\\\n--- a/main.js\\\\n+++ b/main.js\\\\n@@ -3,6 +3,56 @@\\\\n  */\\\\n \\\\n var fs = require('fs');\\\\n+var cp = require('child_process');\\\\n+var data = [];\\\\n+\\\\n+var async = require('async');\\\\n+    /*tasks = [\\\\n+        function (callback) {\\\\n+            cp.exec('git log', function(error, stdout, stderr) {\\\\n+                var listOfCommits = [];\\\\n+                var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n+                var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n+                var comments = findComments(stdout);\\\\n+                var commitNumbers = findCommitNumbers(stdout);\\\\n+\\\\n+                for(i=0; i<authors.length; i++) {\\\\n+                    var commit = {\\\\n+                        \\\\\\\"commit\\\\\\\": commitNumbers[i],\\\\n+                        \\\\\\\"author\\\\\\\": authors[i],\\\\n+                        \\\\\\\"date\\\\\\\": dates[i],\\\\n+                        \\\\\\\"comment\\\\\\\": comments[i],\\\\n+                        \\\\\\\"content\\\\\\\": 'Original'\\\\n+                    };\\\\n+\\\\n+                    listOfCommits[listOfCommits.length] = commit;\\\\n+                }\\\\n+\\\\n+                data = listOfCommits.reverse();\\\\n+\\\\n+                callback(null, data);\\\\n+\\\\n+                if (error !== null) {\\\\n+                    console.log('stderr: ' + stderr);\\\\n+                    console.log('exec error: ' + error);\\\\n+                }\\\\n+            });\\\\n+        }\\\\n+    ],\\\\n+    secondTasks = [\\\\n+        function some_function(callback) {\\\\n+            cp.exec('git diff', function(error, stdout, stderr) {\\\\n+                var currentContent = stdout;\\\\n+\\\\n+                if (error !== null) {\\\\n+                    console.log('stderr: ' + stderr);\\\\n+                    console.log('exec error: ' + error);\\\\n+                }\\\\n+\\\\n+                callback(null, currentContent);\\\\n+            });\\\\n+        }\\\\n+    ];*/\\\\n \\\\n function findData(text, keyword) {\\\\n     var data = [];\\\\n@@ -28,38 +78,106 @@ function findComments(text) {\\\\n     return comments;\\\\n }\\\\n \\\\n+function findCommitNumbers(text) {\\\\n+    var commits = [];\\\\n+    var splittext = text.split('\\\\\\\\n');\\\\n+\\\\n+    for(i=0; i<splittext.length; i++) {\\\\n+        if(splittext[i].slice(0, 6) == \\\\\\\"commit\\\\\\\") {\\\\n+            commits[commits.length] = splittext[i].slice(6).trim();\\\\n+        }\\\\n+    }\\\\n+\\\\n+    return commits;\\\\n+}\\\\n+\\\\n+/*function pullCommitContent(first, second) {\\\\n+\\\\n+    cp.exec('git diff' + ' ' + first + ' ' + second, function(error, stdout, stderr) {\\\\n+        var currentContent = stdout;\\\\n+\\\\n+        if (error !== null) {\\\\n+            console.log('stderr: ' + stderr);\\\\n+            console.log('exec error: ' + error);\\\\n+        }\\\\n+\\\\n+        return currentContent;\\\\n+    });\\\\n+}*/\\\\n+\\\\n+var commitsInfo = [];\\\\n+\\\\n fs.exists('.git', function (exists) {\\\\n     if(exists) {\\\\n-        var cp = require('child_process');\\\\n+        /*async.series(tasks, function(err, result) {\\\\n+            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", JSON.stringify(result));\\\\n+\\\\n+            var data = result[0];\\\\n \\\\n-        cp.exec('git diff', function(error, stdout, stderr) {\\\\n-            console.log(stdout);\\\\n+            /*function some_function(arg1, arg2, callback) {\\\\n+                cp.exec('git diff' + ' ' + arg1 + ' ' + arg2, function(error, stdout, stderr) {\\\\n+                    var currentContent = 54321;//stdout;\\\\n \\\\n-            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", stdout);\\\\n+                    if (error !== null) {\\\\n+                        console.log('stderr: ' + stderr);\\\\n+                        console.log('exec error: ' + error);\\\\n+                    }\\\\n \\\\n-            if (error !== null) {\\\\n-                console.log('stderr: ' + stderr);\\\\n-                console.log('exec error: ' + error);\\\\n+                    callback(null, currentContent);\\\\n+                });\\\\n             }\\\\n-        });\\\\n+        });*/\\\\n+\\\\n+        async.waterfall([\\\\n+            function getCommitsInfo(callback) {\\\\n+                cp.exec('git log', function(error, stdout, stderr) {\\\\n+                    var listOfCommits = [];\\\\n+                    var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n+                    var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n+                    var comments = findComments(stdout);\\\\n+                    var commitNumbers = findCommitNumbers(stdout);\\\\n \\\\n-        cp.exec('git log', function(error, stdout, stderr) {\\\\n-            console.log(stdout);\\\\n+                    for(i=0; i<authors.length; i++) {\\\\n+                        var commit = {\\\\n+                            \\\\\\\"commit\\\\\\\": commitNumbers[i],\\\\n+                            \\\\\\\"author\\\\\\\": authors[i],\\\\n+                            \\\\\\\"date\\\\\\\": dates[i],\\\\n+                            \\\\\\\"comment\\\\\\\": comments[i],\\\\n+                            \\\\\\\"content\\\\\\\": 'Original'\\\\n+                        };\\\\n+                        listOfCommits[listOfCommits.length] = commit;\\\\n+                    }\\\\n \\\\n-            var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n-            var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n-            var comments = findComments(stdout);\\\\n-            console.log(authors);\\\\n-            console.log(comments);\\\\n-            console.log(dates);\\\\n+                    callback(null, listOfCommits.reverse());\\\\n \\\\n-            fs.writeFileSync(\\\\\\\"comments.sousc\\\\\\\", stdout);\\\\n+                    if (error !== null) {\\\\n+                        console.log('stderr: ' + stderr);\\\\n+                        console.log('exec error: ' + error);\\\\n+                    }\\\\n+                });\\\\n+            },\\\\n+            function getCommitsContent(commits, callback) {\\\\n+                console.log(commits);\\\\n+                var commitsData = commits;\\\\n \\\\n-            if (error !== null) {\\\\n-                console.log('stderr: ' + stderr);\\\\n-                console.log('exec error: ' + error);\\\\n+                for(i=1; i<commitsData.length; i++) {\\\\n+                    cp.exec('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit, function(error, stdout, stderr) {\\\\n+                        commitsData[i].content = stdout;\\\\n+\\\\n+                        if (error !== null) {\\\\n+                            console.log('stderr: ' + stderr);\\\\n+                            console.log('exec error: ' + error);\\\\n+                        }\\\\n+                    });\\\\n+                }\\\\n+\\\\n+                callback(null, commitsData);\\\\n             }\\\\n+        ], function (err, result) {\\\\n+            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", result);\\\\n         });\\\\n+\\\\n+        //commitsInfo = JSON.parse(fs.readFileSync(\\\\\\\"patches.sousp\\\\\\\"));\\\\n+        //console.log(commitsInfo);\\\\n     }\\\\n-    else console.log(\\\\\\\"Error.\\\\\\\");\\\\n });\\\\n\\\\\\\\ No newline at end of file\\\\ndiff --git a/node_modules/async/.travis.yml b/node_modules/async/.travis.yml\\\\nnew file mode 100644\\\\nindex 0000000..6e5919d\\\\n--- /dev/null\\\\n+++ b/node_modules/async/.travis.yml\\\\n@@ -0,0 +1,3 @@\\\\n+language: node_js\\\\n+node_js:\\\\n+  - \\\\\\\"0.10\\\\\\\"\\\\ndiff --git a/node_modules/async/LICENSE b/node_modules/async/LICENSE\\\\nnew file mode 100644\\\\nindex 0000000..8f29698\\\\n--- /dev/null\\\\n+++ b/node_modules/async/LICENSE\\\\n@@ -0,0 +1,19 @@\\\\n+Copyright (c) 2010-2014 Caolan McMahon\\\\n+\\\\n+Permission is hereby granted, free of charge, to any person obtaining a copy\\\\n+of this software and associated documentation files (the \\\\\\\"Software\\\\\\\"), to deal\\\\n+in the Software without restriction, including without limitation the rights\\\\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\\\n+copies of the Software, and to permit persons to whom the Software is\\\\n+furnished to do so, subject to the following conditions:\\\\n+\\\\n+The above copyright notice and this permission notice shall be included in\\\\n+all copies or substantial portions of the Software.\\\\n+\\\\n+THE SOFTWARE IS PROVIDED \\\\\\\"AS IS\\\\\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\\\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\\\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\\\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\\\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\\\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\\\n+THE SOFTWARE.\\\\ndiff --git a/node_modules/async/README.md b/node_modules/async/README.md\\\\nnew file mode 100644\\\\nindex 0000000..0bea531\\\\n--- /dev/null\\\\n+++ b/node_modules/async/README.md\\\\n@@ -0,0 +1,1646 @@\\\\n+# Async.js\\\\n+\\\\n+[![Build Status via Travis CI](https://travis-ci.org/caolan/async.svg?branch=master)](https://travis-ci.org/caolan/async)\\\\n+\\\\n+\\\\n+Async is a utility module which provides straight-forward, powerful functions\\\\n+for working with asynchronous JavaScript. Although originally designed for\\\\n+use with [Node.js](http://nodejs.org), it can also be used directly in the\\\\n+browser. Also supports [component](https://github.com/component/component).\\\\n+\\\\n+Async provides around 20 functions that include the usual 'functional'\\\\n+suspects (`map`, `reduce`, `filter`, `each`…) as well as some common patterns\\\\n+for asynchronous control flow (`parallel`, `series`, `waterfall`…). All these\\\\n+functions assume you follow the Node.js convention of providing a single\\\\n+callback as the last argument of your `async` function.\\\\n+\\\\n+\\\\n+## Quick Examples\\\\n+\\\\n+```javascript\\\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\\\n+    // results is now an array of stats for each file\\\\n+});\\\\n+\\\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\\\n+    // results now equals an array of the existing files\\\\n+});\\\\n+\\\\n+async.parallel([\\\\n+    function(){ ... },\\\\n+    function(){ ... }\\\\n+], callback);\\\\n+\\\\n+async.series([\\\\n+    function(){ ... },\\\\n+    function(){ ... }\\\\n+]);\\\\n+```\\\\n+\\\\n+There are many more functions available so take a look at the docs below for a\\\\n+full list. This module aims to be comprehensive, so if you feel anything is\\\\n+missing please create a GitHub issue for it.\\\\n+\\\\n+## Common Pitfalls\\\\n+\\\\n+### Binding a context to an iterator\\\\n+\\\\n+This section is really about `bind`, not about `async`. If you are wondering how to\\\\n+make `async` execute your iterators in a given context, or are confused as to why\\\\n+a method of another library isn't working as an iterator, study this example:\\\\n+\\\\n+```js\\\\n+// Here is a simple object with an (unnecessarily roundabout) squaring method\\\\n+var AsyncSquaringLibrary = {\\\\n+  squareExponent: 2,\\\\n+  square: function(number, callback){ \\\\n+    var result = Math.pow(number, this.squareExponent);\\\\n+    setTimeout(function(){\\\\n+      callback(null, result);\\\\n+    }, 200);\\\\n+  }\\\\n+};\\\\n+\\\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square, function(err, result){\\\\n+  // result is [NaN, NaN, NaN]\\\\n+  // This fails because the `this.squareExponent` expression in the square\\\\n+  // function is not evaluated in the context of AsyncSquaringLibrary, and is\\\\n+  // therefore undefined.\\\\n+});\\\\n+\\\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), function(err, result){\\\\n+  // result is [1, 4, 9]\\\\n+  // With the help of bind we can attach a context to the iterator before\\\\n+  // passing it to async. Now the square function will be executed in its \\\\n+  // 'home' AsyncSquaringLibrary context and the value of `this.squareExponent`\\\\n+  // will be as expected.\\\\n+});\\\\n+```\\\\n+\\\\n+## Download\\\\n+\\\\n+The source is available for download from\\\\n+[GitHub](http://github.com/caolan/async).\\\\n+Alternatively, you can install using Node Package Manager (`npm`):\\\\n+\\\\n+    npm install async\\\\n+\\\\n+__Development:__ [async.js](https://github.com/caolan/async/raw/master/lib/async.js) - 29.6kb Uncompressed\\\\n+\\\\n+## In the Browser\\\\n+\\\\n+So far it's been tested in IE6, IE7, IE8, FF3.6 and Chrome 5. \\\\n+\\\\n+Usage:\\\\n+\\\\n+```html\\\\n+<script type=\\\\\\\"text/javascript\\\\\\\" src=\\\\\\\"async.js\\\\\\\"></script>\\\\n+<script type=\\\\\\\"text/javascript\\\\\\\">\\\\n+\\\\n+    async.map(data, asyncProcess, function(err, results){\\\\n+        alert(results);\\\\n+    });\\\\n+\\\\n+</script>\\\\n+```\\\\n+\\\\n+## Documentation\\\\n+\\\\n+### Collections\\\\n+\\\\n+* [`each`](#each)\\\\n+* [`eachSeries`](#eachSeries)\\\\n+* [`eachLimit`](#eachLimit)\\\\n+* [`map`](#map)\\\\n+* [`mapSeries`](#mapSeries)\\\\n+* [`mapLimit`](#mapLimit)\\\\n+* [`filter`](#filter)\\\\n+* [`filterSeries`](#filterSeries)\\\\n+* [`reject`](#reject)\\\\n+* [`rejectSeries`](#rejectSeries)\\\\n+* [`reduce`](#reduce)\\\\n+* [`reduceRight`](#reduceRight)\\\\n+* [`detect`](#detect)\\\\n+* [`detectSeries`](#detectSeries)\\\\n+* [`sortBy`](#sortBy)\\\\n+* [`some`](#some)\\\\n+* [`every`](#every)\\\\n+* [`concat`](#concat)\\\\n+* [`concatSeries`](#concatSeries)\\\\n+\\\\n+### Control Flow\\\\n+\\\\n+* [`series`](#seriestasks-callback)\\\\n+* [`parallel`](#parallel)\\\\n+* [`parallelLimit`](#parallellimittasks-limit-callback)\\\\n+* [`whilst`](#whilst)\\\\n+* [`doWhilst`](#doWhilst)\\\\n+* [`until`](#until)\\\\n+* [`doUntil`](#doUntil)\\\\n+* [`forever`](#forever)\\\\n+* [`waterfall`](#waterfall)\\\\n+* [`compose`](#compose)\\\\n+* [`seq`](#seq)\\\\n+* [`applyEach`](#applyEach)\\\\n+* [`applyEachSeries`](#applyEachSeries)\\\\n+* [`queue`](#queue)\\\\n+* [`priorityQueue`](#priorityQueue)\\\\n+* [`cargo`](#cargo)\\\\n+* [`auto`](#auto)\\\\n+* [`retry`](#retry)\\\\n+* [`iterator`](#iterator)\\\\n+* [`apply`](#apply)\\\\n+* [`nextTick`](#nextTick)\\\\n+* [`times`](#times)\\\\n+* [`timesSeries`](#timesSeries)\\\\n+\\\\n+### Utils\\\\n+\\\\n+* [`memoize`](#memoize)\\\\n+* [`unmemoize`](#unmemoize)\\\\n+* [`log`](#log)\\\\n+* [`dir`](#dir)\\\\n+* [`noConflict`](#noConflict)\\\\n+\\\\n+\\\\n+## Collections\\\\n+\\\\n+<a name=\\\\\\\"forEach\\\\\\\" />\\\\n+<a name=\\\\\\\"each\\\\\\\" />\\\\n+### each(arr, iterator, callback)\\\\n+\\\\n+Applies the function `iterator` to each item in `arr`, in parallel.\\\\n+The `iterator` is called with an item from the list, and a callback for when it\\\\n+has finished. If the `iterator` passes an error to its `callback`, the main\\\\n+`callback` (for the `each` function) is immediately called with the error.\\\\n+\\\\n+Note, that since this function applies `iterator` to each item in parallel,\\\\n+there is no guarantee that the iterator functions will complete in order.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err)` which must be called once it has \\\\n+  completed. If no error has occured, the `callback` should be run without \\\\n+  arguments or with an explicit `null` argument.\\\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\\\n+  have finished, or an error occurs.\\\\n+\\\\n+__Examples__\\\\n+\\\\n+\\\\n+```js\\\\n+// assuming openFiles is an array of file names and saveFile is a function\\\\n+// to save the modified contents of that file:\\\\n+\\\\n+async.each(openFiles, saveFile, function(err){\\\\n+    // if any of the saves produced an error, err would equal that error\\\\n+});\\\\n+```\\\\n+\\\\n+```js\\\\n+// assuming openFiles is an array of file names \\\\n+\\\\n+async.each(openFiles, function( file, callback) {\\\\n+  \\\\n+  // Perform operation on file here.\\\\n+  console.log('Processing file ' + file);\\\\n+  \\\\n+  if( file.length > 32 ) {\\\\n+    console.log('This file name is too long');\\\\n+    callback('File name too long');\\\\n+  } else {\\\\n+    // Do work to process file here\\\\n+    console.log('File processed');\\\\n+    callback();\\\\n+  }\\\\n+}, function(err){\\\\n+    // if any of the file processing produced an error, err would equal that error\\\\n+    if( err ) {\\\\n+      // One of the iterations produced an error.\\\\n+      // All processing will now stop.\\\\n+      console.log('A file failed to process');\\\\n+    } else {\\\\n+      console.log('All files have been processed successfully');\\\\n+    }\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"forEachSeries\\\\\\\" />\\\\n+<a name=\\\\\\\"eachSeries\\\\\\\" />\\\\n+### eachSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`each`](#each), only `iterator` is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+This means the `iterator` functions will complete in order.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"forEachLimit\\\\\\\" />\\\\n+<a name=\\\\\\\"eachLimit\\\\\\\" />\\\\n+### eachLimit(arr, limit, iterator, callback)\\\\n+\\\\n+The same as [`each`](#each), only no more than `limit` `iterator`s will be simultaneously \\\\n+running at any time.\\\\n+\\\\n+Note that the items in `arr` are not processed in batches, so there is no guarantee that \\\\n+the first `limit` `iterator` functions will complete before any others are started.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err)` which must be called once it has \\\\n+  completed. If no error has occured, the callback should be run without \\\\n+  arguments or with an explicit `null` argument.\\\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\\\n+  have finished, or an error occurs.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// Assume documents is an array of JSON objects and requestApi is a\\\\n+// function that interacts with a rate-limited REST api.\\\\n+\\\\n+async.eachLimit(documents, 20, requestApi, function(err){\\\\n+    // if any of the saves produced an error, err would equal that error\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"map\\\\\\\" />\\\\n+### map(arr, iterator, callback)\\\\n+\\\\n+Produces a new array of values by mapping each value in `arr` through\\\\n+the `iterator` function. The `iterator` is called with an item from `arr` and a\\\\n+callback for when it has finished processing. Each of these callback takes 2 arguments: \\\\n+an `error`, and the transformed item from `arr`. If `iterator` passes an error to this \\\\n+callback, the main `callback` (for the `map` function) is immediately called with the error.\\\\n+\\\\n+Note, that since this function applies the `iterator` to each item in parallel,\\\\n+there is no guarantee that the `iterator` functions will complete in order. \\\\n+However, the results array will be in the same order as the original `arr`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\\\n+  it has completed with an error (which can be `null`) and a transformed item.\\\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\\\n+  functions have finished, or an error occurs. Results is an array of the\\\\n+  transformed items from the `arr`.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\\\n+    // results is now an array of stats for each file\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"mapSeries\\\\\\\" />\\\\n+### mapSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`map`](#map), only the `iterator` is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+The results array will be in the same order as the original.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"mapLimit\\\\\\\" />\\\\n+### mapLimit(arr, limit, iterator, callback)\\\\n+\\\\n+The same as [`map`](#map), only no more than `limit` `iterator`s will be simultaneously \\\\n+running at any time.\\\\n+\\\\n+Note that the items are not processed in batches, so there is no guarantee that \\\\n+the first `limit` `iterator` functions will complete before any others are started.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\\\n+  it has completed with an error (which can be `null`) and a transformed item.\\\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\\\n+  calls have finished, or an error occurs. The result is an array of the\\\\n+  transformed items from the original `arr`.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.mapLimit(['file1','file2','file3'], 1, fs.stat, function(err, results){\\\\n+    // results is now an array of stats for each file\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"select\\\\\\\" />\\\\n+<a name=\\\\\\\"filter\\\\\\\" />\\\\n+### filter(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `select`\\\\n+\\\\n+Returns a new array of all the values in `arr` which pass an async truth test.\\\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\n+way node libraries work with truth tests like `fs.exists`. This operation is\\\\n+performed in parallel, but the results array will be in the same order as the\\\\n+original.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\\\n+  The `iterator` is passed a `callback(truthValue)`, which must be called with a \\\\n+  boolean argument once it has completed.\\\\n+* `callback(results)` - A callback which is called after all the `iterator`\\\\n+  functions have finished.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\\\n+    // results now equals an array of the existing files\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"selectSeries\\\\\\\" />\\\\n+<a name=\\\\\\\"filterSeries\\\\\\\" />\\\\n+### filterSeries(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `selectSeries`\\\\n+\\\\n+The same as [`filter`](#filter) only the `iterator` is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+The results array will be in the same order as the original.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"reject\\\\\\\" />\\\\n+### reject(arr, iterator, callback)\\\\n+\\\\n+The opposite of [`filter`](#filter). Removes values that pass an `async` truth test.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"rejectSeries\\\\\\\" />\\\\n+### rejectSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`reject`](#reject), only the `iterator` is applied to each item in `arr`\\\\n+in series.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"reduce\\\\\\\" />\\\\n+### reduce(arr, memo, iterator, callback)\\\\n+\\\\n+__Aliases:__ `inject`, `foldl`\\\\n+\\\\n+Reduces `arr` into a single value using an async `iterator` to return\\\\n+each successive step. `memo` is the initial state of the reduction. \\\\n+This function only operates in series. \\\\n+\\\\n+For performance reasons, it may make sense to split a call to this function into \\\\n+a parallel map, and then use the normal `Array.prototype.reduce` on the results. \\\\n+This function is for situations where each step in the reduction needs to be async; \\\\n+if you can get the data before reducing it, then it's probably a good idea to do so.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `memo` - The initial state of the reduction.\\\\n+* `iterator(memo, item, callback)` - A function applied to each item in the\\\\n+  array to produce the next step in the reduction. The `iterator` is passed a\\\\n+  `callback(err, reduction)` which accepts an optional error as its first \\\\n+  argument, and the state of the reduction as the second. If an error is \\\\n+  passed to the callback, the reduction is stopped and the main `callback` is \\\\n+  immediately called with the error.\\\\n+* `callback(err, result)` - A callback which is called after all the `iterator`\\\\n+  functions have finished. Result is the reduced value.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.reduce([1,2,3], 0, function(memo, item, callback){\\\\n+    // pointless async:\\\\n+    process.nextTick(function(){\\\\n+        callback(null, memo + item)\\\\n+    });\\\\n+}, function(err, result){\\\\n+    // result is now equal to the last value of memo, which is 6\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"reduceRight\\\\\\\" />\\\\n+### reduceRight(arr, memo, iterator, callback)\\\\n+\\\\n+__Alias:__ `foldr`\\\\n+\\\\n+Same as [`reduce`](#reduce), only operates on `arr` in reverse order.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"detect\\\\\\\" />\\\\n+### detect(arr, iterator, callback)\\\\n+\\\\n+Returns the first value in `arr` that passes an async truth test. The\\\\n+`iterator` is applied in parallel, meaning the first iterator to return `true` will\\\\n+fire the detect `callback` with that result. That means the result might not be\\\\n+the first item in the original `arr` (in terms of order) that passes the test.\\\\n+\\\\n+If order within the original `arr` is important, then look at [`detectSeries`](#detectSeries).\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(truthValue)` which must be called with a \\\\n+  boolean argument once it has completed.\\\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\\\n+  `true`, or after all the `iterator` functions have finished. Result will be\\\\n+  the first item in the array that passes the truth test (iterator) or the\\\\n+  value `undefined` if none passed.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.detect(['file1','file2','file3'], fs.exists, function(result){\\\\n+    // result now equals the first file in the list that exists\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"detectSeries\\\\\\\" />\\\\n+### detectSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`detect`](#detect), only the `iterator` is applied to each item in `arr`\\\\n+in series. This means the result is always the first in the original `arr` (in\\\\n+terms of array order) that passes the truth test.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"sortBy\\\\\\\" />\\\\n+### sortBy(arr, iterator, callback)\\\\n+\\\\n+Sorts a list by the results of running each `arr` value through an async `iterator`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, sortValue)` which must be called once it\\\\n+  has completed with an error (which can be `null`) and a value to use as the sort\\\\n+  criteria.\\\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\\\n+  functions have finished, or an error occurs. Results is the items from\\\\n+  the original `arr` sorted by the values returned by the `iterator` calls.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.sortBy(['file1','file2','file3'], function(file, callback){\\\\n+    fs.stat(file, function(err, stats){\\\\n+        callback(err, stats.mtime);\\\\n+    });\\\\n+}, function(err, results){\\\\n+    // results is now the original array of files sorted by\\\\n+    // modified date\\\\n+});\\\\n+```\\\\n+\\\\n+__Sort Order__\\\\n+\\\\n+By modifying the callback parameter the sorting order can be influenced:\\\\n+\\\\n+```js\\\\n+//ascending order\\\\n+async.sortBy([1,9,3,5], function(x, callback){\\\\n+    callback(err, x);\\\\n+}, function(err,result){\\\\n+    //result callback\\\\n+} );\\\\n+\\\\n+//descending order\\\\n+async.sortBy([1,9,3,5], function(x, callback){\\\\n+    callback(err, x*-1);    //<- x*-1 instead of x, turns the order around\\\\n+}, function(err,result){\\\\n+    //result callback\\\\n+} );\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"some\\\\\\\" />\\\\n+### some(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `any`\\\\n+\\\\n+Returns `true` if at least one element in the `arr` satisfies an async test.\\\\n+_The callback for each iterator call only accepts a single argument of `true` or\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\n+way node libraries work with truth tests like `fs.exists`. Once any iterator\\\\n+call returns `true`, the main `callback` is immediately called.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\\\n+  called with a boolean argument once it has completed.\\\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\\\n+  `true`, or after all the iterator functions have finished. Result will be\\\\n+  either `true` or `false` depending on the values of the async tests.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.some(['file1','file2','file3'], fs.exists, function(result){\\\\n+    // if result is true then at least one of the files exists\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"every\\\\\\\" />\\\\n+### every(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `all`\\\\n+\\\\n+Returns `true` if every element in `arr` satisfies an async test.\\\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\n+way node libraries work with truth tests like `fs.exists`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\\\n+  called with a  boolean argument once it has completed.\\\\n+* `callback(result)` - A callback which is called after all the `iterator`\\\\n+  functions have finished. Result will be either `true` or `false` depending on\\\\n+  the values of the async tests.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.every(['file1','file2','file3'], fs.exists, function(result){\\\\n+    // if result is true then every file exists\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"concat\\\\\\\" />\\\\n+### concat(arr, iterator, callback)\\\\n+\\\\n+Applies `iterator` to each item in `arr`, concatenating the results. Returns the\\\\n+concatenated list. The `iterator`s are called in parallel, and the results are\\\\n+concatenated as they return. There is no guarantee that the results array will\\\\n+be returned in the original order of `arr` passed to the `iterator` function.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, results)` which must be called once it \\\\n+  has completed with an error (which can be `null`) and an array of results.\\\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\\\n+  functions have finished, or an error occurs. Results is an array containing\\\\n+  the concatenated results of the `iterator` function.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files){\\\\n+    // files is now a list of filenames that exist in the 3 directories\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"concatSeries\\\\\\\" />\\\\n+### concatSeries(arr, iterator, callback)\\\\n+\\\\n+Same as [`concat`](#concat), but executes in series instead of parallel.\\\\n+\\\\n+\\\\n+## Control Flow\\\\n+\\\\n+<a name=\\\\\\\"series\\\\\\\" />\\\\n+### series(tasks, [callback])\\\\n+\\\\n+Run the functions in the `tasks` array in series, each one running once the previous\\\\n+function has completed. If any functions in the series pass an error to its\\\\n+callback, no more functions are run, and `callback` is immediately called with the value of the error. \\\\n+Otherwise, `callback` receives an array of results when `tasks` have completed.\\\\n+\\\\n+It is also possible to use an object instead of an array. Each property will be\\\\n+run as a function, and the results will be passed to the final `callback` as an object\\\\n+instead of an array. This can be a more readable way of handling results from\\\\n+[`series`](#series).\\\\n+\\\\n+**Note** that while many implementations preserve the order of object properties, the\\\\n+[ECMAScript Language Specifcation](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6) \\\\n+explicitly states that\\\\n+\\\\n+> The mechanics and order of enumerating the properties is not specified.\\\\n+\\\\n+So if you rely on the order in which your series of functions are executed, and want\\\\n+this to work on all platforms, consider using an array. \\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array or object containing functions to run, each function is passed\\\\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\\\n+  be `null`) and an optional `result` value.\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\n+  have completed. This function gets a results array (or object) containing all \\\\n+  the result arguments passed to the `task` callbacks.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.series([\\\\n+    function(callback){\\\\n+        // do some stuff ...\\\\n+        callback(null, 'one');\\\\n+    },\\\\n+    function(callback){\\\\n+        // do some more stuff ...\\\\n+        callback(null, 'two');\\\\n+    }\\\\n+],\\\\n+// optional callback\\\\n+function(err, results){\\\\n+    // results is now equal to ['one', 'two']\\\\n+});\\\\n+\\\\n+\\\\n+// an example using an object instead of an array\\\\n+async.series({\\\\n+    one: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 1);\\\\n+        }, 200);\\\\n+    },\\\\n+    two: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 2);\\\\n+        }, 100);\\\\n+    }\\\\n+},\\\\n+function(err, results) {\\\\n+    // results is now equal to: {one: 1, two: 2}\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"parallel\\\\\\\" />\\\\n+### parallel(tasks, [callback])\\\\n+\\\\n+Run the `tasks` array of functions in parallel, without waiting until the previous\\\\n+function has completed. If any of the functions pass an error to its\\\\n+callback, the main `callback` is immediately called with the value of the error.\\\\n+Once the `tasks` have completed, the results are passed to the final `callback` as an\\\\n+array.\\\\n+\\\\n+It is also possible to use an object instead of an array. Each property will be\\\\n+run as a function and the results will be passed to the final `callback` as an object\\\\n+instead of an array. This can be a more readable way of handling results from\\\\n+[`parallel`](#parallel).\\\\n+\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array or object containing functions to run. Each function is passed \\\\n+  a `callback(err, result)` which it must call on completion with an error `err` \\\\n+  (which can be `null`) and an optional `result` value.\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\n+  have completed. This function gets a results array (or object) containing all \\\\n+  the result arguments passed to the task callbacks.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.parallel([\\\\n+    function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 'one');\\\\n+        }, 200);\\\\n+    },\\\\n+    function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 'two');\\\\n+        }, 100);\\\\n+    }\\\\n+],\\\\n+// optional callback\\\\n+function(err, results){\\\\n+    // the results array will equal ['one','two'] even though\\\\n+    // the second function had a shorter timeout.\\\\n+});\\\\n+\\\\n+\\\\n+// an example using an object instead of an array\\\\n+async.parallel({\\\\n+    one: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 1);\\\\n+        }, 200);\\\\n+    },\\\\n+    two: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 2);\\\\n+        }, 100);\\\\n+    }\\\\n+},\\\\n+function(err, results) {\\\\n+    // results is now equals to: {one: 1, two: 2}\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"parallelLimit\\\\\\\" />\\\\n+### parallelLimit(tasks, limit, [callback])\\\\n+\\\\n+The same as [`parallel`](#parallel), only `tasks` are executed in parallel \\\\n+with a maximum of `limit` tasks executing at any time.\\\\n+\\\\n+Note that the `tasks` are not executed in batches, so there is no guarantee that \\\\n+the first `limit` tasks will complete before any others are started.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array or object containing functions to run, each function is passed \\\\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\\\n+  be `null`) and an optional `result` value.\\\\n+* `limit` - The maximum number of `tasks` to run at any time.\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\n+  have completed. This function gets a results array (or object) containing all \\\\n+  the result arguments passed to the `task` callbacks.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"whilst\\\\\\\" />\\\\n+### whilst(test, fn, callback)\\\\n+\\\\n+Repeatedly call `fn`, while `test` returns `true`. Calls `callback` when stopped,\\\\n+or an error occurs.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `test()` - synchronous truth test to perform before each execution of `fn`.\\\\n+* `fn(callback)` - A function which is called each time `test` passes. The function is\\\\n+  passed a `callback(err)`, which must be called once it has completed with an \\\\n+  optional `err` argument.\\\\n+* `callback(err)` - A callback which is called after the test fails and repeated\\\\n+  execution of `fn` has stopped.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var count = 0;\\\\n+\\\\n+async.whilst(\\\\n+    function () { return count < 5; },\\\\n+    function (callback) {\\\\n+        count++;\\\\n+        setTimeout(callback, 1000);\\\\n+    },\\\\n+    function (err) {\\\\n+        // 5 seconds have passed\\\\n+    }\\\\n+);\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"doWhilst\\\\\\\" />\\\\n+### doWhilst(fn, test, callback)\\\\n+\\\\n+The post-check version of [`whilst`](#whilst). To reflect the difference in \\\\n+the order of operations, the arguments `test` and `fn` are switched. \\\\n+\\\\n+`doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"until\\\\\\\" />\\\\n+### until(test, fn, callback)\\\\n+\\\\n+Repeatedly call `fn` until `test` returns `true`. Calls `callback` when stopped,\\\\n+or an error occurs.\\\\n+\\\\n+The inverse of [`whilst`](#whilst).\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"doUntil\\\\\\\" />\\\\n+### doUntil(fn, test, callback)\\\\n+\\\\n+Like [`doWhilst`](#doWhilst), except the `test` is inverted. Note the argument ordering differs from `until`.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"forever\\\\\\\" />\\\\n+### forever(fn, errback)\\\\n+\\\\n+Calls the asynchronous function `fn` with a callback parameter that allows it to\\\\n+call itself again, in series, indefinitely.\\\\n+\\\\n+If an error is passed to the callback then `errback` is called with the\\\\n+error, and execution stops, otherwise it will never be called.\\\\n+\\\\n+```js\\\\n+async.forever(\\\\n+    function(next) {\\\\n+        // next is suitable for passing to things that need a callback(err [, whatever]);\\\\n+        // it will result in this function being called again.\\\\n+    },\\\\n+    function(err) {\\\\n+        // if next is called with a value in its first parameter, it will appear\\\\n+        // in here as 'err', and execution will stop.\\\\n+    }\\\\n+);\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"waterfall\\\\\\\" />\\\\n+### waterfall(tasks, [callback])\\\\n+\\\\n+Runs the `tasks` array of functions in series, each passing their results to the next in\\\\n+the array. However, if any of the `tasks` pass an error to their own callback, the\\\\n+next function is not executed, and the main `callback` is immediately called with\\\\n+the error.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array of functions to run, each function is passed a \\\\n+  `callback(err, result1, result2, ...)` it must call on completion. The first\\\\n+  argument is an error (which can be `null`) and any further arguments will be \\\\n+  passed as arguments in order to the next task.\\\\n+* `callback(err, [results])` - An optional callback to run once all the functions\\\\n+  have completed. This will be passed the results of the last task's callback.\\\\n+\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.waterfall([\\\\n+    function(callback){\\\\n+        callback(null, 'one', 'two');\\\\n+    },\\\\n+    function(arg1, arg2, callback){\\\\n+      // arg1 now equals 'one' and arg2 now equals 'two'\\\\n+        callback(null, 'three');\\\\n+    },\\\\n+    function(arg1, callback){\\\\n+        // arg1 now equals 'three'\\\\n+        callback(null, 'done');\\\\n+    }\\\\n+], function (err, result) {\\\\n+   // result now equals 'done'    \\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+<a name=\\\\\\\"compose\\\\\\\" />\\\\n+### compose(fn1, fn2...)\\\\n+\\\\n+Creates a function which is a composition of the passed asynchronous\\\\n+functions. Each function consumes the return value of the function that\\\\n+follows. Composing functions `f()`, `g()`, and `h()` would produce the result of\\\\n+`f(g(h()))`, only this version uses callbacks to obtain the return values.\\\\n+\\\\n+Each function is executed with the `this` binding of the composed function.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `functions...` - the asynchronous functions to compose\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+function add1(n, callback) {\\\\n+    setTimeout(function () {\\\\n+        callback(null, n + 1);\\\\n+    }, 10);\\\\n+}\\\\n+\\\\n+function mul3(n, callback) {\\\\n+    setTimeout(function () {\\\\n+        callback(null, n * 3);\\\\n+    }, 10);\\\\n+}\\\\n+\\\\n+var add1mul3 = async.compose(mul3, add1);\\\\n+\\\\n+add1mul3(4, function (err, result) {\\\\n+   // result now equals 15\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+<a name=\\\\\\\"seq\\\\\\\" />\\\\n+### seq(fn1, fn2...)\\\\n+\\\\n+Version of the compose function that is more natural to read.\\\\n+Each following function consumes the return value of the latter function. \\\\n+\\\\n+Each function is executed with the `this` binding of the composed function.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* functions... - the asynchronous functions to compose\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// Requires lodash (or underscore), express3 and dresende's orm2.\\\\n+// Part of an app, that fetches cats of the logged user.\\\\n+// This example uses `seq` function to avoid overnesting and error \\\\n+// handling clutter.\\\\n+app.get('/cats', function(request, response) {\\\\n+  function handleError(err, data, callback) {\\\\n+    if (err) {\\\\n+      console.error(err);\\\\n+      response.json({ status: 'error', message: err.message });\\\\n+    }\\\\n+    else {\\\\n+      callback(data);\\\\n+    }\\\\n+  }\\\\n+  var User = request.models.User;\\\\n+  async.seq(\\\\n+    _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\\\\n+    handleError,\\\\n+    function(user, fn) {\\\\n+      user.getCats(fn);      // 'getCats' has signature (callback(err, data))\\\\n+    },\\\\n+    handleError,\\\\n+    function(cats) {\\\\n+      response.json({ status: 'ok', message: 'Cats found', data: cats });\\\\n+    }\\\\n+  )(req.session.user_id);\\\\n+  }\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+<a name=\\\\\\\"applyEach\\\\\\\" />\\\\n+### applyEach(fns, args..., callback)\\\\n+\\\\n+Applies the provided arguments to each function in the array, calling \\\\n+`callback` after all functions have completed. If you only provide the first\\\\n+argument, then it will return a function which lets you pass in the\\\\n+arguments as if it were a single function call.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `fns` - the asynchronous functions to all call with the same arguments\\\\n+* `args...` - any number of separate arguments to pass to the function\\\\n+* `callback` - the final argument should be the callback, called when all\\\\n+  functions have completed processing\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.applyEach([enableSearch, updateSchema], 'bucket', callback);\\\\n+\\\\n+// partial application example:\\\\n+async.each(\\\\n+    buckets,\\\\n+    async.applyEach([enableSearch, updateSchema]),\\\\n+    callback\\\\n+);\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"applyEachSeries\\\\\\\" />\\\\n+### applyEachSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`applyEach`](#applyEach) only the functions are applied in series.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"queue\\\\\\\" />\\\\n+### queue(worker, concurrency)\\\\n+\\\\n+Creates a `queue` object with the specified `concurrency`. Tasks added to the\\\\n+`queue` are processed in parallel (up to the `concurrency` limit). If all\\\\n+`worker`s are in progress, the task is queued until one becomes available. \\\\n+Once a `worker` completes a `task`, that `task`'s callback is called.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `worker(task, callback)` - An asynchronous function for processing a queued\\\\n+  task, which must call its `callback(err)` argument when finished, with an \\\\n+  optional `error` as an argument.\\\\n+* `concurrency` - An `integer` for determining how many `worker` functions should be\\\\n+  run in parallel.\\\\n+\\\\n+__Queue objects__\\\\n+\\\\n+The `queue` object returned by this function has the following properties and\\\\n+methods:\\\\n+\\\\n+* `length()` - a function returning the number of items waiting to be processed.\\\\n+* `started` - a function returning whether or not any items have been pushed and processed by the queue\\\\n+* `running()` - a function returning the number of items currently being processed.\\\\n+* `idle()` - a function returning false if there are items waiting or being processed, or true if not.\\\\n+* `concurrency` - an integer for determining how many `worker` functions should be\\\\n+  run in parallel. This property can be changed after a `queue` is created to\\\\n+  alter the concurrency on-the-fly.\\\\n+* `push(task, [callback])` - add a new task to the `queue`. Calls `callback` once \\\\n+  the `worker` has finished processing the task. Instead of a single task, a `tasks` array\\\\n+  can be submitted. The respective callback is used for every task in the list.\\\\n+* `unshift(task, [callback])` - add a new task to the front of the `queue`.\\\\n+* `saturated` - a callback that is called when the `queue` length hits the `concurrency` limit, \\\\n+   and further tasks will be queued.\\\\n+* `empty` - a callback that is called when the last item from the `queue` is given to a `worker`.\\\\n+* `drain` - a callback that is called when the last item from the `queue` has returned from the `worker`.\\\\n+* `paused` - a boolean for determining whether the queue is in a paused state\\\\n+* `pause()` - a function that pauses the processing of tasks until `resume()` is called.\\\\n+* `resume()` - a function that resumes the processing of queued tasks when the queue is paused.\\\\n+* `kill()` - a function that empties remaining tasks from the queue forcing it to go idle.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// create a queue object with concurrency 2\\\\n+\\\\n+var q = async.queue(function (task, callback) {\\\\n+    console.log('hello ' + task.name);\\\\n+    callback();\\\\n+}, 2);\\\\n+\\\\n+\\\\n+// assign a callback\\\\n+q.drain = function() {\\\\n+    console.log('all items have been processed');\\\\n+}\\\\n+\\\\n+// add some items to the queue\\\\n+\\\\n+q.push({name: 'foo'}, function (err) {\\\\n+    console.log('finished processing foo');\\\\n+});\\\\n+q.push({name: 'bar'}, function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+\\\\n+// add some items to the queue (batch-wise)\\\\n+\\\\n+q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+\\\\n+// add some items to the front of the queue\\\\n+\\\\n+q.unshift({name: 'bar'}, function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+```\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"priorityQueue\\\\\\\" />\\\\n+### priorityQueue(worker, concurrency)\\\\n+\\\\n+The same as [`queue`](#queue) only tasks are assigned a priority and completed in ascending priority order. There are two differences between `queue` and `priorityQueue` objects:\\\\n+\\\\n+* `push(task, priority, [callback])` - `priority` should be a number. If an array of\\\\n+  `tasks` is given, all tasks will be assigned the same priority.\\\\n+* The `unshift` method was removed.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"cargo\\\\\\\" />\\\\n+### cargo(worker, [payload])\\\\n+\\\\n+Creates a `cargo` object with the specified payload. Tasks added to the\\\\n+cargo will be processed altogether (up to the `payload` limit). If the\\\\n+`worker` is in progress, the task is queued until it becomes available. Once\\\\n+the `worker` has completed some tasks, each callback of those tasks is called.\\\\n+Check out [this animation](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) for how `cargo` and `queue` work.\\\\n+\\\\n+While [queue](#queue) passes only one task to one of a group of workers\\\\n+at a time, cargo passes an array of tasks to a single worker, repeating\\\\n+when the worker is finished.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `worker(tasks, callback)` - An asynchronous function for processing an array of\\\\n+  queued tasks, which must call its `callback(err)` argument when finished, with \\\\n+  an optional `err` argument.\\\\n+* `payload` - An optional `integer` for determining how many tasks should be\\\\n+  processed per round; if omitted, the default is unlimited.\\\\n+\\\\n+__Cargo objects__\\\\n+\\\\n+The `cargo` object returned by this function has the following properties and\\\\n+methods:\\\\n+\\\\n+* `length()` - A function returning the number of items waiting to be processed.\\\\n+* `payload` - An `integer` for determining how many tasks should be\\\\n+  process per round. This property can be changed after a `cargo` is created to\\\\n+  alter the payload on-the-fly.\\\\n+* `push(task, [callback])` - Adds `task` to the `queue`. The callback is called\\\\n+  once the `worker` has finished processing the task. Instead of a single task, an array of `tasks` \\\\n+  can be submitted. The respective callback is used for every task in the list.\\\\n+* `saturated` - A callback that is called when the `queue.length()` hits the concurrency and further tasks will be queued.\\\\n+* `empty` - A callback that is called when the last item from the `queue` is given to a `worker`.\\\\n+* `drain` - A callback that is called when the last item from the `queue` has returned from the `worker`.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// create a cargo object with payload 2\\\\n+\\\\n+var cargo = async.cargo(function (tasks, callback) {\\\\n+    for(var i=0; i<tasks.length; i++){\\\\n+      console.log('hello ' + tasks[i].name);\\\\n+    }\\\\n+    callback();\\\\n+}, 2);\\\\n+\\\\n+\\\\n+// add some items\\\\n+\\\\n+cargo.push({name: 'foo'}, function (err) {\\\\n+    console.log('finished processing foo');\\\\n+});\\\\n+cargo.push({name: 'bar'}, function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+cargo.push({name: 'baz'}, function (err) {\\\\n+    console.log('finished processing baz');\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"auto\\\\\\\" />\\\\n+### auto(tasks, [callback])\\\\n+\\\\n+Determines the best order for running the functions in `tasks`, based on their \\\\n+requirements. Each function can optionally depend on other functions being completed \\\\n+first, and each function is run as soon as its requirements are satisfied. \\\\n+\\\\n+If any of the functions pass an error to their callback, it will not \\\\n+complete (so any other functions depending on it will not run), and the main \\\\n+`callback` is immediately called with the error. Functions also receive an \\\\n+object containing the results of functions which have completed so far.\\\\n+\\\\n+Note, all functions are called with a `results` object as a second argument, \\\\n+so it is unsafe to pass functions in the `tasks` object which cannot handle the\\\\n+extra argument. \\\\n+\\\\n+For example, this snippet of code:\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+  readData: async.apply(fs.readFile, 'data.txt', 'utf-8')\\\\n+}, callback);\\\\n+```\\\\n+\\\\n+will have the effect of calling `readFile` with the results object as the last\\\\n+argument, which will fail:\\\\n+\\\\n+```js\\\\n+fs.readFile('data.txt', 'utf-8', cb, {});\\\\n+```\\\\n+\\\\n+Instead, wrap the call to `readFile` in a function which does not forward the \\\\n+`results` object:\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+  readData: function(cb, results){\\\\n+    fs.readFile('data.txt', 'utf-8', cb);\\\\n+  }\\\\n+}, callback);\\\\n+```\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An object. Each of its properties is either a function or an array of\\\\n+  requirements, with the function itself the last item in the array. The object's key\\\\n+  of a property serves as the name of the task defined by that property,\\\\n+  i.e. can be used when specifying requirements for other tasks.\\\\n+  The function receives two arguments: (1) a `callback(err, result)` which must be \\\\n+  called when finished, passing an `error` (which can be `null`) and the result of \\\\n+  the function's execution, and (2) a `results` object, containing the results of\\\\n+  the previously executed functions.\\\\n+* `callback(err, results)` - An optional callback which is called when all the\\\\n+  tasks have been completed. It receives the `err` argument if any `tasks` \\\\n+  pass an error to their callback. Results are always returned; however, if \\\\n+  an error occurs, no further `tasks` will be performed, and the results\\\\n+  object will only contain partial results.\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+    get_data: function(callback){\\\\n+        console.log('in get_data');\\\\n+        // async code to get some data\\\\n+        callback(null, 'data', 'converted to array');\\\\n+    },\\\\n+    make_folder: function(callback){\\\\n+        console.log('in make_folder');\\\\n+        // async code to create a directory to store a file in\\\\n+        // this is run at the same time as getting the data\\\\n+        callback(null, 'folder');\\\\n+    },\\\\n+    write_file: ['get_data', 'make_folder', function(callback, results){\\\\n+        console.log('in write_file', JSON.stringify(results));\\\\n+        // once there is some data and the directory exists,\\\\n+        // write the data to a file in the directory\\\\n+        callback(null, 'filename');\\\\n+    }],\\\\n+    email_link: ['write_file', function(callback, results){\\\\n+        console.log('in email_link', JSON.stringify(results));\\\\n+        // once the file is written let's email a link to it...\\\\n+        // results.write_file contains the filename returned by write_file.\\\\n+        callback(null, {'file':results.write_file, 'email':'user@example.com'});\\\\n+    }]\\\\n+}, function(err, results) {\\\\n+    console.log('err = ', err);\\\\n+    console.log('results = ', results);\\\\n+});\\\\n+```\\\\n+\\\\n+This is a fairly trivial example, but to do this using the basic parallel and\\\\n+series functions would look like this:\\\\n+\\\\n+```js\\\\n+async.parallel([\\\\n+    function(callback){\\\\n+        console.log('in get_data');\\\\n+        // async code to get some data\\\\n+        callback(null, 'data', 'converted to array');\\\\n+    },\\\\n+    function(callback){\\\\n+        console.log('in make_folder');\\\\n+        // async code to create a directory to store a file in\\\\n+        // this is run at the same time as getting the data\\\\n+        callback(null, 'folder');\\\\n+    }\\\\n+],\\\\n+function(err, results){\\\\n+    async.series([\\\\n+        function(callback){\\\\n+            console.log('in write_file', JSON.stringify(results));\\\\n+            // once there is some data and the directory exists,\\\\n+            // write the data to a file in the directory\\\\n+            results.push('filename');\\\\n+            callback(null);\\\\n+        },\\\\n+        function(callback){\\\\n+            console.log('in email_link', JSON.stringify(results));\\\\n+            // once the file is written let's email a link to it...\\\\n+            callback(null, {'file':results.pop(), 'email':'user@example.com'});\\\\n+        }\\\\n+    ]);\\\\n+});\\\\n+```\\\\n+\\\\n+For a complicated series of `async` tasks, using the [`auto`](#auto) function makes adding\\\\n+new tasks much easier (and the code more readable).\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"retry\\\\\\\" />\\\\n+### retry([times = 5], task, [callback])\\\\n+\\\\n+Attempts to get a successful response from `task` no more than `times` times before\\\\n+returning an error. If the task is successful, the `callback` will be passed the result\\\\n+of the successfull task. If all attemps fail, the callback will be passed the error and\\\\n+result (if any) of the final attempt.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `times` - An integer indicating how many times to attempt the `task` before giving up. Defaults to 5.\\\\n+* `task(callback, results)` - A function which receives two arguments: (1) a `callback(err, result)`\\\\n+  which must be called when finished, passing `err` (which can be `null`) and the `result` of \\\\n+  the function's execution, and (2) a `results` object, containing the results of\\\\n+  the previously executed functions (if nested inside another control flow).\\\\n+* `callback(err, results)` - An optional callback which is called when the\\\\n+  task has succeeded, or after the final failed attempt. It receives the `err` and `result` arguments of the last attempt at completing the `task`.\\\\n+\\\\n+The [`retry`](#retry) function can be used as a stand-alone control flow by passing a\\\\n+callback, as shown below:\\\\n+\\\\n+```js\\\\n+async.retry(3, apiMethod, function(err, result) {\\\\n+    // do something with the result\\\\n+});\\\\n+```\\\\n+\\\\n+It can also be embeded within other control flow functions to retry individual methods\\\\n+that are not as reliable, like this:\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+    users: api.getUsers.bind(api),\\\\n+    payments: async.retry(3, api.getPayments.bind(api))\\\\n+}, function(err, results) {\\\\n+  // do something with the results\\\\n+});\\\\n+```\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"iterator\\\\\\\" />\\\\n+### iterator(tasks)\\\\n+\\\\n+Creates an iterator function which calls the next function in the `tasks` array,\\\\n+returning a continuation to call the next one after that. It's also possible to\\\\n+“peek” at the next iterator with `iterator.next()`.\\\\n+\\\\n+This function is used internally by the `async` module, but can be useful when\\\\n+you want to manually control the flow of functions in series.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array of functions to run.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var iterator = async.iterator([\\\\n+    function(){ sys.p('one'); },\\\\n+    function(){ sys.p('two'); },\\\\n+    function(){ sys.p('three'); }\\\\n+]);\\\\n+\\\\n+node> var iterator2 = iterator();\\\\n+'one'\\\\n+node> var iterator3 = iterator2();\\\\n+'two'\\\\n+node> iterator3();\\\\n+'three'\\\\n+node> var nextfn = iterator2.next();\\\\n+node> nextfn();\\\\n+'three'\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"apply\\\\\\\" />\\\\n+### apply(function, arguments..)\\\\n+\\\\n+Creates a continuation function with some arguments already applied. \\\\n+\\\\n+Useful as a shorthand when combined with other control flow functions. Any arguments\\\\n+passed to the returned function are added to the arguments originally passed\\\\n+to apply.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\n+* `arguments...` - Any number of arguments to automatically apply when the\\\\n+  continuation is called.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// using apply\\\\n+\\\\n+async.parallel([\\\\n+    async.apply(fs.writeFile, 'testfile1', 'test1'),\\\\n+    async.apply(fs.writeFile, 'testfile2', 'test2'),\\\\n+]);\\\\n+\\\\n+\\\\n+// the same process without using apply\\\\n+\\\\n+async.parallel([\\\\n+    function(callback){\\\\n+        fs.writeFile('testfile1', 'test1', callback);\\\\n+    },\\\\n+    function(callback){\\\\n+        fs.writeFile('testfile2', 'test2', callback);\\\\n+    }\\\\n+]);\\\\n+```\\\\n+\\\\n+It's possible to pass any number of additional arguments when calling the\\\\n+continuation:\\\\n+\\\\n+```js\\\\n+node> var fn = async.apply(sys.puts, 'one');\\\\n+node> fn('two', 'three');\\\\n+one\\\\n+two\\\\n+three\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"nextTick\\\\\\\" />\\\\n+### nextTick(callback)\\\\n+\\\\n+Calls `callback` on a later loop around the event loop. In Node.js this just\\\\n+calls `process.nextTick`; in the browser it falls back to `setImmediate(callback)`\\\\n+if available, otherwise `setTimeout(callback, 0)`, which means other higher priority\\\\n+events may precede the execution of `callback`.\\\\n+\\\\n+This is used internally for browser-compatibility purposes.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `callback` - The function to call on a later loop around the event loop.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var call_order = [];\\\\n+async.nextTick(function(){\\\\n+    call_order.push('two');\\\\n+    // call_order now equals ['one','two']\\\\n+});\\\\n+call_order.push('one')\\\\n+```\\\\n+\\\\n+<a name=\\\\\\\"times\\\\\\\" />\\\\n+### times(n, callback)\\\\n+\\\\n+Calls the `callback` function `n` times, and accumulates results in the same manner\\\\n+you would use with [`map`](#map).\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `n` - The number of times to run the function.\\\\n+* `callback` - The function to call `n` times.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// Pretend this is some complicated async factory\\\\n+var createUser = function(id, callback) {\\\\n+  callback(null, {\\\\n+    id: 'user' + id\\\\n+  })\\\\n+}\\\\n+// generate 5 users\\\\n+async.times(5, function(n, next){\\\\n+    createUser(n, function(err, user) {\\\\n+      next(err, user)\\\\n+    })\\\\n+}, function(err, users) {\\\\n+  // we should now have 5 users\\\\n+});\\\\n+```\\\\n+\\\\n+<a name=\\\\\\\"timesSeries\\\\\\\" />\\\\n+### timesSeries(n, callback)\\\\n+\\\\n+The same as [`times`](#times), only the iterator is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+The results array will be in the same order as the original.\\\\n+\\\\n+\\\\n+## Utils\\\\n+\\\\n+<a name=\\\\\\\"memoize\\\\\\\" />\\\\n+### memoize(fn, [hasher])\\\\n+\\\\n+Caches the results of an `async` function. When creating a hash to store function\\\\n+results against, the callback is omitted from the hash and an optional hash\\\\n+function can be used.\\\\n+\\\\n+The cache of results is exposed as the `memo` property of the function returned\\\\n+by `memoize`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `fn` - The function to proxy and cache results from.\\\\n+* `hasher` - Tn optional function for generating a custom hash for storing\\\\n+  results. It has all the arguments applied to it apart from the callback, and\\\\n+  must be synchronous.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var slow_fn = function (name, callback) {\\\\n+    // do something\\\\n+    callback(null, result);\\\\n+};\\\\n+var fn = async.memoize(slow_fn);\\\\n+\\\\n+// fn can now be used as if it were slow_fn\\\\n+fn('some name', function () {\\\\n+    // callback\\\\n+});\\\\n+```\\\\n+\\\\n+<a name=\\\\\\\"unmemoize\\\\\\\" />\\\\n+### unmemoize(fn)\\\\n+\\\\n+Undoes a [`memoize`](#memoize)d function, reverting it to the original, unmemoized\\\\n+form. Handy for testing.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `fn` - the memoized function\\\\n+\\\\n+<a name=\\\\\\\"log\\\\\\\" />\\\\n+### log(function, arguments)\\\\n+\\\\n+Logs the result of an `async` function to the `console`. Only works in Node.js or\\\\n+in browsers that support `console.log` and `console.error` (such as FF and Chrome).\\\\n+If multiple arguments are returned from the async function, `console.log` is\\\\n+called on each argument in order.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\n+* `arguments...` - Any number of arguments to apply to the function.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var hello = function(name, callback){\\\\n+    setTimeout(function(){\\\\n+        callback(null, 'hello ' + name);\\\\n+    }, 1000);\\\\n+};\\\\n+```\\\\n+```js\\\\n+node> async.log(hello, 'world');\\\\n+'hello world'\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"dir\\\\\\\" />\\\\n+### dir(function, arguments)\\\\n+\\\\n+Logs the result of an `async` function to the `console` using `console.dir` to\\\\n+display the properties of the resulting object. Only works in Node.js or\\\\n+in browsers that support `console.dir` and `console.error` (such as FF and Chrome).\\\\n+If multiple arguments are returned from the async function, `console.dir` is\\\\n+called on each argument in order.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\n+* `arguments...` - Any number of arguments to apply to the function.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var hello = function(name, callback){\\\\n+    setTimeout(function(){\\\\n+        callback(null, {hello: name});\\\\n+    }, 1000);\\\\n+};\\\\n+```\\\\n+```js\\\\n+node> async.dir(hello, 'world');\\\\n+{hello: 'world'}\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"noConflict\\\\\\\" />\\\\n+### noConflict()\\\\n+\\\\n+Changes the value of `async` back to its original value, returning a reference to the\\\\n+`async` object.\\\\ndiff --git a/node_modules/async/component.json b/node_modules/async/component.json\\\\nnew file mode 100644\\\\nindex 0000000..bbb0115\\\\n--- /dev/null\\\\n+++ b/node_modules/async/component.json\\\\n@@ -0,0 +1,11 @@\\\\n+{\\\\n+  \\\\\\\"name\\\\\\\": \\\\\\\"async\\\\\\\",\\\\n+  \\\\\\\"repo\\\\\\\": \\\\\\\"caolan/async\\\\\\\",\\\\n+  \\\\\\\"description\\\\\\\": \\\\\\\"Higher-order functions and common patterns for asynchronous code\\\\\\\",\\\\n+  \\\\\\\"version\\\\\\\": \\\\\\\"0.1.23\\\\\\\",\\\\n+  \\\\\\\"keywords\\\\\\\": [],\\\\n+  \\\\\\\"dependencies\\\\\\\": {},\\\\n+  \\\\\\\"development\\\\\\\": {},\\\\n+  \\\\\\\"main\\\\\\\": \\\\\\\"lib/async.js\\\\\\\",\\\\n+  \\\\\\\"scripts\\\\\\\": [ \\\\\\\"lib/async.js\\\\\\\" ]\\\\n+}\\\\ndiff --git a/node_modules/async/lib/async.js b/node_modules/async/lib/async.js\\\\nnew file mode 100644\\\\nindex 0000000..01e8afc\\\\n--- /dev/null\\\\n+++ b/node_modules/async/lib/async.js\\\\n@@ -0,0 +1,1123 @@\\\\n+/*!\\\\n+ * async\\\\n+ * https://github.com/caolan/async\\\\n+ *\\\\n+ * Copyright 2010-2014 Caolan McMahon\\\\n+ * Released under the MIT license\\\\n+ */\\\\n+/*jshint onevar: false, indent:4 */\\\\n+/*global setImmediate: false, setTimeout: false, console: false */\\\\n+(function () {\\\\n+\\\\n+    var async = {};\\\\n+\\\\n+    // global on the server, window in the browser\\\\n+    var root, previous_async;\\\\n+\\\\n+    root = this;\\\\n+    if (root != null) {\\\\n+      previous_async = root.async;\\\\n+    }\\\\n+\\\\n+    async.noConflict = function () {\\\\n+        root.async = previous_async;\\\\n+        return async;\\\\n+    };\\\\n+\\\\n+    function only_once(fn) {\\\\n+        var called = false;\\\\n+        return function() {\\\\n+            if (called) throw new Error(\\\\\\\"Callback was already called.\\\\\\\");\\\\n+            called = true;\\\\n+            fn.apply(root, arguments);\\\\n+        }\\\\n+    }\\\\n+\\\\n+    //// cross-browser compatiblity functions ////\\\\n+\\\\n+    var _toString = Object.prototype.toString;\\\\n+\\\\n+    var _isArray = Array.isArray || function (obj) {\\\\n+        return _toString.call(obj) === '[object Array]';\\\\n+    };\\\\n+\\\\n+    var _each = function (arr, iterator) {\\\\n+        if (arr.forEach) {\\\\n+            return arr.forEach(iterator);\\\\n+        }\\\\n+        for (var i = 0; i < arr.length; i += 1) {\\\\n+            iterator(arr[i], i, arr);\\\\n+        }\\\\n+    };\\\\n+\\\\n+    var _map = function (arr, iterator) {\\\\n+        if (arr.map) {\\\\n+            return arr.map(iterator);\\\\n+        }\\\\n+        var results = [];\\\\n+        _each(arr, function (x, i, a) {\\\\n+            results.push(iterator(x, i, a));\\\\n+        });\\\\n+        return results;\\\\n+    };\\\\n+\\\\n+    var _reduce = function (arr, iterator, memo) {\\\\n+        if (arr.reduce) {\\\\n+            return arr.reduce(iterator, memo);\\\\n+        }\\\\n+        _each(arr, function (x, i, a) {\\\\n+            memo = iterator(memo, x, i, a);\\\\n+        });\\\\n+        return memo;\\\\n+    };\\\\n+\\\\n+    var _keys = function (obj) {\\\\n+        if (Object.keys) {\\\\n+            return Object.keys(obj);\\\\n+        }\\\\n+        var keys = [];\\\\n+        for (var k in obj) {\\\\n+            if (obj.hasOwnProperty(k)) {\\\\n+                keys.push(k);\\\\n+            }\\\\n+        }\\\\n+        return keys;\\\\n+    };\\\\n+\\\\n+    //// exported async module functions ////\\\\n+\\\\n+    //// nextTick implementation with browser-compatible fallback ////\\\\n+    if (typeof process === 'undefined' || !(process.nextTick)) {\\\\n+        if (typeof setImmediate === 'function') {\\\\n+            async.nextTick = function (fn) {\\\\n+                // not a direct alias for IE10 compatibility\\\\n+                setImmediate(fn);\\\\n+            };\\\\n+            async.setImmediate = async.nextTick;\\\\n+        }\\\\n+        else {\\\\n+            async.nextTick = function (fn) {\\\\n+                setTimeout(fn, 0);\\\\n+            };\\\\n+            async.setImmediate = async.nextTick;\\\\n+        }\\\\n+    }\\\\n+    else {\\\\n+        async.nextTick = process.nextTick;\\\\n+        if (typeof setImmediate !== 'undefined') {\\\\n+            async.setImmediate = function (fn) {\\\\n+              // not a direct alias for IE10 compatibility\\\\n+              setImmediate(fn);\\\\n+            };\\\\n+        }\\\\n+        else {\\\\n+            async.setImmediate = async.nextTick;\\\\n+        }\\\\n+    }\\\\n+\\\\n+    async.each = function (arr, iterator, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (!arr.length) {\\\\n+            return callback();\\\\n+        }\\\\n+        var completed = 0;\\\\n+        _each(arr, function (x) {\\\\n+            iterator(x, only_once(done) );\\\\n+        });\\\\n+        function done(err) {\\\\n+          if (err) {\\\\n+              callback(err);\\\\n+              callback = function () {};\\\\n+          }\\\\n+          else {\\\\n+              completed += 1;\\\\n+              if (completed >= arr.length) {\\\\n+                  callback();\\\\n+              }\\\\n+          }\\\\n+        }\\\\n+    };\\\\n+    async.forEach = async.each;\\\\n+\\\\n+    async.eachSeries = function (arr, iterator, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (!arr.length) {\\\\n+            return callback();\\\\n+        }\\\\n+        var completed = 0;\\\\n+        var iterate = function () {\\\\n+            iterator(arr[completed], function (err) {\\\\n+                if (err) {\\\\n+                    callback(err);\\\\n+                    callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    completed += 1;\\\\n+                    if (completed >= arr.length) {\\\\n+                        callback();\\\\n+                    }\\\\n+                    else {\\\\n+                        iterate();\\\\n+                    }\\\\n+                }\\\\n+            });\\\\n+        };\\\\n+        iterate();\\\\n+    };\\\\n+    async.forEachSeries = async.eachSeries;\\\\n+\\\\n+    async.eachLimit = function (arr, limit, iterator, callback) {\\\\n+        var fn = _eachLimit(limit);\\\\n+        fn.apply(null, [arr, iterator, callback]);\\\\n+    };\\\\n+    async.forEachLimit = async.eachLimit;\\\\n+\\\\n+    var _eachLimit = function (limit) {\\\\n+\\\\n+        return function (arr, iterator, callback) {\\\\n+            callback = callback || function () {};\\\\n+            if (!arr.length || limit <= 0) {\\\\n+                return callback();\\\\n+            }\\\\n+            var completed = 0;\\\\n+            var started = 0;\\\\n+            var running = 0;\\\\n+\\\\n+            (function replenish () {\\\\n+                if (completed >= arr.length) {\\\\n+                    return callback();\\\\n+                }\\\\n+\\\\n+                while (running < limit && started < arr.length) {\\\\n+                    started += 1;\\\\n+                    running += 1;\\\\n+                    iterator(arr[started - 1], function (err) {\\\\n+                        if (err) {\\\\n+                            callback(err);\\\\n+                            callback = function () {};\\\\n+                        }\\\\n+                        else {\\\\n+                            completed += 1;\\\\n+                            running -= 1;\\\\n+                            if (completed >= arr.length) {\\\\n+                                callback();\\\\n+                            }\\\\n+                            else {\\\\n+                                replenish();\\\\n+                            }\\\\n+                        }\\\\n+                    });\\\\n+                }\\\\n+            })();\\\\n+        };\\\\n+    };\\\\n+\\\\n+\\\\n+    var doParallel = function (fn) {\\\\n+        return function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            return fn.apply(null, [async.each].concat(args));\\\\n+        };\\\\n+    };\\\\n+    var doParallelLimit = function(limit, fn) {\\\\n+        return function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            return fn.apply(null, [_eachLimit(limit)].concat(args));\\\\n+        };\\\\n+    };\\\\n+    var doSeries = function (fn) {\\\\n+        return function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            return fn.apply(null, [async.eachSeries].concat(args));\\\\n+        };\\\\n+    };\\\\n+\\\\n+\\\\n+    var _asyncMap = function (eachfn, arr, iterator, callback) {\\\\n+        arr = _map(arr, function (x, i) {\\\\n+            return {index: i, value: x};\\\\n+        });\\\\n+        if (!callback) {\\\\n+            eachfn(arr, function (x, callback) {\\\\n+                iterator(x.value, function (err) {\\\\n+                    callback(err);\\\\n+                });\\\\n+            });\\\\n+        } else {\\\\n+            var results = [];\\\\n+            eachfn(arr, function (x, callback) {\\\\n+                iterator(x.value, function (err, v) {\\\\n+                    results[x.index] = v;\\\\n+                    callback(err);\\\\n+                });\\\\n+            }, function (err) {\\\\n+                callback(err, results);\\\\n+            });\\\\n+        }\\\\n+    };\\\\n+    async.map = doParallel(_asyncMap);\\\\n+    async.mapSeries = doSeries(_asyncMap);\\\\n+    async.mapLimit = function (arr, limit, iterator, callback) {\\\\n+        return _mapLimit(limit)(arr, iterator, callback);\\\\n+    };\\\\n+\\\\n+    var _mapLimit = function(limit) {\\\\n+        return doParallelLimit(limit, _asyncMap);\\\\n+    };\\\\n+\\\\n+    // reduce only has a series version, as doing reduce in parallel won't\\\\n+    // work in many situations.\\\\n+    async.reduce = function (arr, memo, iterator, callback) {\\\\n+        async.eachSeries(arr, function (x, callback) {\\\\n+            iterator(memo, x, function (err, v) {\\\\n+                memo = v;\\\\n+                callback(err);\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(err, memo);\\\\n+        });\\\\n+    };\\\\n+    // inject alias\\\\n+    async.inject = async.reduce;\\\\n+    // foldl alias\\\\n+    async.foldl = async.reduce;\\\\n+\\\\n+    async.reduceRight = function (arr, memo, iterator, callback) {\\\\n+        var reversed = _map(arr, function (x) {\\\\n+            return x;\\\\n+        }).reverse();\\\\n+        async.reduce(reversed, memo, iterator, callback);\\\\n+    };\\\\n+    // foldr alias\\\\n+    async.foldr = async.reduceRight;\\\\n+\\\\n+    var _filter = function (eachfn, arr, iterator, callback) {\\\\n+        var results = [];\\\\n+        arr = _map(arr, function (x, i) {\\\\n+            return {index: i, value: x};\\\\n+        });\\\\n+        eachfn(arr, function (x, callback) {\\\\n+            iterator(x.value, function (v) {\\\\n+                if (v) {\\\\n+                    results.push(x);\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(_map(results.sort(function (a, b) {\\\\n+                return a.index - b.index;\\\\n+            }), function (x) {\\\\n+                return x.value;\\\\n+            }));\\\\n+        });\\\\n+    };\\\\n+    async.filter = doParallel(_filter);\\\\n+    async.filterSeries = doSeries(_filter);\\\\n+    // select alias\\\\n+    async.select = async.filter;\\\\n+    async.selectSeries = async.filterSeries;\\\\n+\\\\n+    var _reject = function (eachfn, arr, iterator, callback) {\\\\n+        var results = [];\\\\n+        arr = _map(arr, function (x, i) {\\\\n+            return {index: i, value: x};\\\\n+        });\\\\n+        eachfn(arr, function (x, callback) {\\\\n+            iterator(x.value, function (v) {\\\\n+                if (!v) {\\\\n+                    results.push(x);\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(_map(results.sort(function (a, b) {\\\\n+                return a.index - b.index;\\\\n+            }), function (x) {\\\\n+                return x.value;\\\\n+            }));\\\\n+        });\\\\n+    };\\\\n+    async.reject = doParallel(_reject);\\\\n+    async.rejectSeries = doSeries(_reject);\\\\n+\\\\n+    var _detect = function (eachfn, arr, iterator, main_callback) {\\\\n+        eachfn(arr, function (x, callback) {\\\\n+            iterator(x, function (result) {\\\\n+                if (result) {\\\\n+                    main_callback(x);\\\\n+                    main_callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    callback();\\\\n+                }\\\\n+            });\\\\n+        }, function (err) {\\\\n+            main_callback();\\\\n+        });\\\\n+    };\\\\n+    async.detect = doParallel(_detect);\\\\n+    async.detectSeries = doSeries(_detect);\\\\n+\\\\n+    async.some = function (arr, iterator, main_callback) {\\\\n+        async.each(arr, function (x, callback) {\\\\n+            iterator(x, function (v) {\\\\n+                if (v) {\\\\n+                    main_callback(true);\\\\n+                    main_callback = function () {};\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            main_callback(false);\\\\n+        });\\\\n+    };\\\\n+    // any alias\\\\n+    async.any = async.some;\\\\n+\\\\n+    async.every = function (arr, iterator, main_callback) {\\\\n+        async.each(arr, function (x, callback) {\\\\n+            iterator(x, function (v) {\\\\n+                if (!v) {\\\\n+                    main_callback(false);\\\\n+                    main_callback = function () {};\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            main_callback(true);\\\\n+        });\\\\n+    };\\\\n+    // all alias\\\\n+    async.all = async.every;\\\\n+\\\\n+    async.sortBy = function (arr, iterator, callback) {\\\\n+        async.map(arr, function (x, callback) {\\\\n+            iterator(x, function (err, criteria) {\\\\n+                if (err) {\\\\n+                    callback(err);\\\\n+                }\\\\n+                else {\\\\n+                    callback(null, {value: x, criteria: criteria});\\\\n+                }\\\\n+            });\\\\n+        }, function (err, results) {\\\\n+            if (err) {\\\\n+                return callback(err);\\\\n+            }\\\\n+            else {\\\\n+                var fn = function (left, right) {\\\\n+                    var a = left.criteria, b = right.criteria;\\\\n+                    return a < b ? -1 : a > b ? 1 : 0;\\\\n+                };\\\\n+                callback(null, _map(results.sort(fn), function (x) {\\\\n+                    return x.value;\\\\n+                }));\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.auto = function (tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        var keys = _keys(tasks);\\\\n+        var remainingTasks = keys.length\\\\n+        if (!remainingTasks) {\\\\n+            return callback();\\\\n+        }\\\\n+\\\\n+        var results = {};\\\\n+\\\\n+        var listeners = [];\\\\n+        var addListener = function (fn) {\\\\n+            listeners.unshift(fn);\\\\n+        };\\\\n+        var removeListener = function (fn) {\\\\n+            for (var i = 0; i < listeners.length; i += 1) {\\\\n+                if (listeners[i] === fn) {\\\\n+                    listeners.splice(i, 1);\\\\n+                    return;\\\\n+                }\\\\n+            }\\\\n+        };\\\\n+        var taskComplete = function () {\\\\n+            remainingTasks--\\\\n+            _each(listeners.slice(0), function (fn) {\\\\n+                fn();\\\\n+            });\\\\n+        };\\\\n+\\\\n+        addListener(function () {\\\\n+            if (!remainingTasks) {\\\\n+                var theCallback = callback;\\\\n+                // prevent final callback from calling itself if it errors\\\\n+                callback = function () {};\\\\n+\\\\n+                theCallback(null, results);\\\\n+            }\\\\n+        });\\\\n+\\\\n+        _each(keys, function (k) {\\\\n+            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\\\\n+            var taskCallback = function (err) {\\\\n+                var args = Array.prototype.slice.call(arguments, 1);\\\\n+                if (args.length <= 1) {\\\\n+                    args = args[0];\\\\n+                }\\\\n+                if (err) {\\\\n+                    var safeResults = {};\\\\n+                    _each(_keys(results), function(rkey) {\\\\n+                        safeResults[rkey] = results[rkey];\\\\n+                    });\\\\n+                    safeResults[k] = args;\\\\n+                    callback(err, safeResults);\\\\n+                    // stop subsequent errors hitting callback multiple times\\\\n+                    callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    results[k] = args;\\\\n+                    async.setImmediate(taskComplete);\\\\n+                }\\\\n+            };\\\\n+            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\\\\n+            var ready = function () {\\\\n+                return _reduce(requires, function (a, x) {\\\\n+                    return (a && results.hasOwnProperty(x));\\\\n+                }, true) && !results.hasOwnProperty(k);\\\\n+            };\\\\n+            if (ready()) {\\\\n+                task[task.length - 1](taskCallback, results);\\\\n+            }\\\\n+            else {\\\\n+                var listener = function () {\\\\n+                    if (ready()) {\\\\n+                        removeListener(listener);\\\\n+                        task[task.length - 1](taskCallback, results);\\\\n+                    }\\\\n+                };\\\\n+                addListener(listener);\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.retry = function(times, task, callback) {\\\\n+        var DEFAULT_TIMES = 5;\\\\n+        var attempts = [];\\\\n+        // Use defaults if times not passed\\\\n+        if (typeof times === 'function') {\\\\n+            callback = task;\\\\n+            task = times;\\\\n+            times = DEFAULT_TIMES;\\\\n+        }\\\\n+        // Make sure times is a number\\\\n+        times = parseInt(times, 10) || DEFAULT_TIMES;\\\\n+        var wrappedTask = function(wrappedCallback, wrappedResults) {\\\\n+            var retryAttempt = function(task, finalAttempt) {\\\\n+                return function(seriesCallback) {\\\\n+                    task(function(err, result){\\\\n+                        seriesCallback(!err || finalAttempt, {err: err, result: result});\\\\n+                    }, wrappedResults);\\\\n+                };\\\\n+            };\\\\n+            while (times) {\\\\n+                attempts.push(retryAttempt(task, !(times-=1)));\\\\n+            }\\\\n+            async.series(attempts, function(done, data){\\\\n+                data = data[data.length - 1];\\\\n+                (wrappedCallback || callback)(data.err, data.result);\\\\n+            });\\\\n+        }\\\\n+        // If a callback is passed, run this as a controll flow\\\\n+        return callback ? wrappedTask() : wrappedTask\\\\n+    };\\\\n+\\\\n+    async.waterfall = function (tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (!_isArray(tasks)) {\\\\n+          var err = new Error('First argument to waterfall must be an array of functions');\\\\n+          return callback(err);\\\\n+        }\\\\n+        if (!tasks.length) {\\\\n+            return callback();\\\\n+        }\\\\n+        var wrapIterator = function (iterator) {\\\\n+            return function (err) {\\\\n+                if (err) {\\\\n+                    callback.apply(null, arguments);\\\\n+                    callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\n+                    var next = iterator.next();\\\\n+                    if (next) {\\\\n+                        args.push(wrapIterator(next));\\\\n+                    }\\\\n+                    else {\\\\n+                        args.push(callback);\\\\n+                    }\\\\n+                    async.setImmediate(function () {\\\\n+                        iterator.apply(null, args);\\\\n+                    });\\\\n+                }\\\\n+            };\\\\n+        };\\\\n+        wrapIterator(async.iterator(tasks))();\\\\n+    };\\\\n+\\\\n+    var _parallel = function(eachfn, tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (_isArray(tasks)) {\\\\n+            eachfn.map(tasks, function (fn, callback) {\\\\n+                if (fn) {\\\\n+                    fn(function (err) {\\\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\\\n+                        if (args.length <= 1) {\\\\n+                            args = args[0];\\\\n+                        }\\\\n+                        callback.call(null, err, args);\\\\n+                    });\\\\n+                }\\\\n+            }, callback);\\\\n+        }\\\\n+        else {\\\\n+            var results = {};\\\\n+            eachfn.each(_keys(tasks), function (k, callback) {\\\\n+                tasks[k](function (err) {\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\n+                    if (args.length <= 1) {\\\\n+                        args = args[0];\\\\n+                    }\\\\n+                    results[k] = args;\\\\n+                    callback(err);\\\\n+                });\\\\n+            }, function (err) {\\\\n+                callback(err, results);\\\\n+            });\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.parallel = function (tasks, callback) {\\\\n+        _parallel({ map: async.map, each: async.each }, tasks, callback);\\\\n+    };\\\\n+\\\\n+    async.parallelLimit = function(tasks, limit, callback) {\\\\n+        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\\\\n+    };\\\\n+\\\\n+    async.series = function (tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (_isArray(tasks)) {\\\\n+            async.mapSeries(tasks, function (fn, callback) {\\\\n+                if (fn) {\\\\n+                    fn(function (err) {\\\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\\\n+                        if (args.length <= 1) {\\\\n+                            args = args[0];\\\\n+                        }\\\\n+                        callback.call(null, err, args);\\\\n+                    });\\\\n+                }\\\\n+            }, callback);\\\\n+        }\\\\n+        else {\\\\n+            var results = {};\\\\n+            async.eachSeries(_keys(tasks), function (k, callback) {\\\\n+                tasks[k](function (err) {\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\n+                    if (args.length <= 1) {\\\\n+                        args = args[0];\\\\n+                    }\\\\n+                    results[k] = args;\\\\n+                    callback(err);\\\\n+                });\\\\n+            }, function (err) {\\\\n+                callback(err, results);\\\\n+            });\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.iterator = function (tasks) {\\\\n+        var makeCallback = function (index) {\\\\n+            var fn = function () {\\\\n+                if (tasks.length) {\\\\n+                    tasks[index].apply(null, arguments);\\\\n+                }\\\\n+                return fn.next();\\\\n+            };\\\\n+            fn.next = function () {\\\\n+                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\\\\n+            };\\\\n+            return fn;\\\\n+        };\\\\n+        return makeCallback(0);\\\\n+    };\\\\n+\\\\n+    async.apply = function (fn) {\\\\n+        var args = Array.prototype.slice.call(arguments, 1);\\\\n+        return function () {\\\\n+            return fn.apply(\\\\n+                null, args.concat(Array.prototype.slice.call(arguments))\\\\n+            );\\\\n+        };\\\\n+    };\\\\n+\\\\n+    var _concat = function (eachfn, arr, fn, callback) {\\\\n+        var r = [];\\\\n+        eachfn(arr, function (x, cb) {\\\\n+            fn(x, function (err, y) {\\\\n+                r = r.concat(y || []);\\\\n+                cb(err);\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(err, r);\\\\n+        });\\\\n+    };\\\\n+    async.concat = doParallel(_concat);\\\\n+    async.concatSeries = doSeries(_concat);\\\\n+\\\\n+    async.whilst = function (test, iterator, callback) {\\\\n+        if (test()) {\\\\n+            iterator(function (err) {\\\\n+                if (err) {\\\\n+                    return callback(err);\\\\n+                }\\\\n+                async.whilst(test, iterator, callback);\\\\n+            });\\\\n+        }\\\\n+        else {\\\\n+            callback();\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.doWhilst = function (iterator, test, callback) {\\\\n+        iterator(function (err) {\\\\n+            if (err) {\\\\n+                return callback(err);\\\\n+            }\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\n+            if (test.apply(null, args)) {\\\\n+                async.doWhilst(iterator, test, callback);\\\\n+            }\\\\n+            else {\\\\n+                callback();\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.until = function (test, iterator, callback) {\\\\n+        if (!test()) {\\\\n+            iterator(function (err) {\\\\n+                if (err) {\\\\n+                    return callback(err);\\\\n+                }\\\\n+                async.until(test, iterator, callback);\\\\n+            });\\\\n+        }\\\\n+        else {\\\\n+            callback();\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.doUntil = function (iterator, test, callback) {\\\\n+        iterator(function (err) {\\\\n+            if (err) {\\\\n+                return callback(err);\\\\n+            }\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\n+            if (!test.apply(null, args)) {\\\\n+                async.doUntil(iterator, test, callback);\\\\n+            }\\\\n+            else {\\\\n+                callback();\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.queue = function (worker, concurrency) {\\\\n+        if (concurrency === undefined) {\\\\n+            concurrency = 1;\\\\n+        }\\\\n+        function _insert(q, data, pos, callback) {\\\\n+          if (!q.started){\\\\n+            q.started = true;\\\\n+          }\\\\n+          if (!_isArray(data)) {\\\\n+              data = [data];\\\\n+          }\\\\n+          if(data.length == 0) {\\\\n+             // call drain immediately if there are no tasks\\\\n+             return async.setImmediate(function() {\\\\n+                 if (q.drain) {\\\\n+                     q.drain();\\\\n+                 }\\\\n+             });\\\\n+          }\\\\n+          _each(data, function(task) {\\\\n+              var item = {\\\\n+                  data: task,\\\\n+                  callback: typeof callback === 'function' ? callback : null\\\\n+              };\\\\n+\\\\n+              if (pos) {\\\\n+                q.tasks.unshift(item);\\\\n+              } else {\\\\n+                q.tasks.push(item);\\\\n+              }\\\\n+\\\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\\\n+                  q.saturated();\\\\n+              }\\\\n+              async.setImmediate(q.process);\\\\n+          });\\\\n+        }\\\\n+\\\\n+        var workers = 0;\\\\n+        var q = {\\\\n+            tasks: [],\\\\n+            concurrency: concurrency,\\\\n+            saturated: null,\\\\n+            empty: null,\\\\n+            drain: null,\\\\n+            started: false,\\\\n+            paused: false,\\\\n+            push: function (data, callback) {\\\\n+              _insert(q, data, false, callback);\\\\n+            },\\\\n+            kill: function () {\\\\n+              q.drain = null;\\\\n+              q.tasks = [];\\\\n+            },\\\\n+            unshift: function (data, callback) {\\\\n+              _insert(q, data, true, callback);\\\\n+            },\\\\n+            process: function () {\\\\n+                if (!q.paused && workers < q.concurrency && q.tasks.length) {\\\\n+                    var task = q.tasks.shift();\\\\n+                    if (q.empty && q.tasks.length === 0) {\\\\n+                        q.empty();\\\\n+                    }\\\\n+                    workers += 1;\\\\n+                    var next = function () {\\\\n+                        workers -= 1;\\\\n+                        if (task.callback) {\\\\n+                            task.callback.apply(task, arguments);\\\\n+                        }\\\\n+                        if (q.drain && q.tasks.length + workers === 0) {\\\\n+                            q.drain();\\\\n+                        }\\\\n+                        q.process();\\\\n+                    };\\\\n+                    var cb = only_once(next);\\\\n+                    worker(task.data, cb);\\\\n+                }\\\\n+            },\\\\n+            length: function () {\\\\n+                return q.tasks.length;\\\\n+            },\\\\n+            running: function () {\\\\n+                return workers;\\\\n+            },\\\\n+            idle: function() {\\\\n+                return q.tasks.length + workers === 0;\\\\n+            },\\\\n+            pause: function () {\\\\n+                if (q.paused === true) { return; }\\\\n+                q.paused = true;\\\\n+                q.process();\\\\n+            },\\\\n+            resume: function () {\\\\n+                if (q.paused === false) { return; }\\\\n+                q.paused = false;\\\\n+                q.process();\\\\n+            }\\\\n+        };\\\\n+        return q;\\\\n+    };\\\\n+    \\\\n+    async.priorityQueue = function (worker, concurrency) {\\\\n+        \\\\n+        function _compareTasks(a, b){\\\\n+          return a.priority - b.priority;\\\\n+        };\\\\n+        \\\\n+        function _binarySearch(sequence, item, compare) {\\\\n+          var beg = -1,\\\\n+              end = sequence.length - 1;\\\\n+          while (beg < end) {\\\\n+            var mid = beg + ((end - beg + 1) >>> 1);\\\\n+            if (compare(item, sequence[mid]) >= 0) {\\\\n+              beg = mid;\\\\n+            } else {\\\\n+              end = mid - 1;\\\\n+            }\\\\n+          }\\\\n+          return beg;\\\\n+        }\\\\n+        \\\\n+        function _insert(q, data, priority, callback) {\\\\n+          if (!q.started){\\\\n+            q.started = true;\\\\n+          }\\\\n+          if (!_isArray(data)) {\\\\n+              data = [data];\\\\n+          }\\\\n+          if(data.length == 0) {\\\\n+             // call drain immediately if there are no tasks\\\\n+             return async.setImmediate(function() {\\\\n+                 if (q.drain) {\\\\n+                     q.drain();\\\\n+                 }\\\\n+             });\\\\n+          }\\\\n+          _each(data, function(task) {\\\\n+              var item = {\\\\n+                  data: task,\\\\n+                  priority: priority,\\\\n+                  callback: typeof callback === 'function' ? callback : null\\\\n+              };\\\\n+              \\\\n+              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\\\\n+\\\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\\\n+                  q.saturated();\\\\n+              }\\\\n+              async.setImmediate(q.process);\\\\n+          });\\\\n+        }\\\\n+        \\\\n+        // Start with a normal queue\\\\n+        var q = async.queue(worker, concurrency);\\\\n+        \\\\n+        // Override push to accept second parameter representing priority\\\\n+        q.push = function (data, priority, callback) {\\\\n+          _insert(q, data, priority, callback);\\\\n+        };\\\\n+        \\\\n+        // Remove unshift function\\\\n+        delete q.unshift;\\\\n+\\\\n+        return q;\\\\n+    };\\\\n+\\\\n+    async.cargo = function (worker, payload) {\\\\n+        var working     = false,\\\\n+            tasks       = [];\\\\n+\\\\n+        var cargo = {\\\\n+            tasks: tasks,\\\\n+            payload: payload,\\\\n+            saturated: null,\\\\n+            empty: null,\\\\n+            drain: null,\\\\n+            drained: true,\\\\n+            push: function (data, callback) {\\\\n+                if (!_isArray(data)) {\\\\n+                    data = [data];\\\\n+                }\\\\n+                _each(data, function(task) {\\\\n+                    tasks.push({\\\\n+                        data: task,\\\\n+                        callback: typeof callback === 'function' ? callback : null\\\\n+                    });\\\\n+                    cargo.drained = false;\\\\n+                    if (cargo.saturated && tasks.length === payload) {\\\\n+                        cargo.saturated();\\\\n+                    }\\\\n+                });\\\\n+                async.setImmediate(cargo.process);\\\\n+            },\\\\n+            process: function process() {\\\\n+                if (working) return;\\\\n+                if (tasks.length === 0) {\\\\n+                    if(cargo.drain && !cargo.drained) cargo.drain();\\\\n+                    cargo.drained = true;\\\\n+                    return;\\\\n+                }\\\\n+\\\\n+                var ts = typeof payload === 'number'\\\\n+                            ? tasks.splice(0, payload)\\\\n+                            : tasks.splice(0, tasks.length);\\\\n+\\\\n+                var ds = _map(ts, function (task) {\\\\n+                    return task.data;\\\\n+                });\\\\n+\\\\n+                if(cargo.empty) cargo.empty();\\\\n+                working = true;\\\\n+                worker(ds, function () {\\\\n+                    working = false;\\\\n+\\\\n+                    var args = arguments;\\\\n+                    _each(ts, function (data) {\\\\n+                        if (data.callback) {\\\\n+                            data.callback.apply(null, args);\\\\n+                        }\\\\n+                    });\\\\n+\\\\n+                    process();\\\\n+                });\\\\n+            },\\\\n+            length: function () {\\\\n+                return tasks.length;\\\\n+            },\\\\n+            running: function () {\\\\n+                return working;\\\\n+            }\\\\n+        };\\\\n+        return cargo;\\\\n+    };\\\\n+\\\\n+    var _console_fn = function (name) {\\\\n+        return function (fn) {\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\n+            fn.apply(null, args.concat([function (err) {\\\\n+                var args = Array.prototype.slice.call(arguments, 1);\\\\n+                if (typeof console !== 'undefined') {\\\\n+                    if (err) {\\\\n+                        if (console.error) {\\\\n+                            console.error(err);\\\\n+                        }\\\\n+                    }\\\\n+                    else if (console[name]) {\\\\n+                        _each(args, function (x) {\\\\n+                            console[name](x);\\\\n+                        });\\\\n+                    }\\\\n+                }\\\\n+            }]));\\\\n+        };\\\\n+    };\\\\n+    async.log = _console_fn('log');\\\\n+    async.dir = _console_fn('dir');\\\\n+    /*async.info = _console_fn('info');\\\\n+    async.warn = _console_fn('warn');\\\\n+    async.error = _console_fn('error');*/\\\\n+\\\\n+    async.memoize = function (fn, hasher) {\\\\n+        var memo = {};\\\\n+        var queues = {};\\\\n+        hasher = hasher || function (x) {\\\\n+            return x;\\\\n+        };\\\\n+        var memoized = function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            var callback = args.pop();\\\\n+            var key = hasher.apply(null, args);\\\\n+            if (key in memo) {\\\\n+                async.nextTick(function () {\\\\n+                    callback.apply(null, memo[key]);\\\\n+                });\\\\n+            }\\\\n+            else if (key in queues) {\\\\n+                queues[key].push(callback);\\\\n+            }\\\\n+            else {\\\\n+                queues[key] = [callback];\\\\n+                fn.apply(null, args.concat([function () {\\\\n+                    memo[key] = arguments;\\\\n+                    var q = queues[key];\\\\n+                    delete queues[key];\\\\n+                    for (var i = 0, l = q.length; i < l; i++) {\\\\n+                      q[i].apply(null, arguments);\\\\n+                    }\\\\n+                }]));\\\\n+            }\\\\n+        };\\\\n+        memoized.memo = memo;\\\\n+        memoized.unmemoized = fn;\\\\n+        return memoized;\\\\n+    };\\\\n+\\\\n+    async.unmemoize = function (fn) {\\\\n+      return function () {\\\\n+        return (fn.unmemoized || fn).apply(null, arguments);\\\\n+      };\\\\n+    };\\\\n+\\\\n+    async.times = function (count, iterator, callback) {\\\\n+        var counter = [];\\\\n+        for (var i = 0; i < count; i++) {\\\\n+            counter.push(i);\\\\n+        }\\\\n+        return async.map(counter, iterator, callback);\\\\n+    };\\\\n+\\\\n+    async.timesSeries = function (count, iterator, callback) {\\\\n+        var counter = [];\\\\n+        for (var i = 0; i < count; i++) {\\\\n+            counter.push(i);\\\\n+        }\\\\n+        return async.mapSeries(counter, iterator, callback);\\\\n+    };\\\\n+\\\\n+    async.seq = function (/* functions... */) {\\\\n+        var fns = arguments;\\\\n+        return function () {\\\\n+            var that = this;\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            var callback = args.pop();\\\\n+            async.reduce(fns, args, function (newargs, fn, cb) {\\\\n+                fn.apply(that, newargs.concat([function () {\\\\n+                    var err = arguments[0];\\\\n+                    var nextargs = Array.prototype.slice.call(arguments, 1);\\\\n+                    cb(err, nextargs);\\\\n+                }]))\\\\n+            },\\\\n+            function (err, results) {\\\\n+                callback.apply(that, [err].concat(results));\\\\n+            });\\\\n+        };\\\\n+    };\\\\n+\\\\n+    async.compose = function (/* functions... */) {\\\\n+      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\\\\n+    };\\\\n+\\\\n+    var _applyEach = function (eachfn, fns /*args...*/) {\\\\n+        var go = function () {\\\\n+            var that = this;\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            var callback = args.pop();\\\\n+            return eachfn(fns, function (fn, cb) {\\\\n+                fn.apply(that, args.concat([cb]));\\\\n+            },\\\\n+            callback);\\\\n+        };\\\\n+        if (arguments.length > 2) {\\\\n+            var args = Array.prototype.slice.call(arguments, 2);\\\\n+            return go.apply(this, args);\\\\n+        }\\\\n+        else {\\\\n+            return go;\\\\n+        }\\\\n+    };\\\\n+    async.applyEach = doParallel(_applyEach);\\\\n+    async.applyEachSeries = doSeries(_applyEach);\\\\n+\\\\n+    async.forever = function (fn, callback) {\\\\n+        function next(err) {\\\\n+            if (err) {\\\\n+                if (callback) {\\\\n+                    return callback(err);\\\\n+                }\\\\n+                throw err;\\\\n+            }\\\\n+            fn(next);\\\\n+        }\\\\n+        next();\\\\n+    };\\\\n+\\\\n+    // Node.js\\\\n+    if (typeof module !== 'undefined' && module.exports) {\\\\n+        module.exports = async;\\\\n+    }\\\\n+    // AMD / RequireJS\\\\n+    else if (typeof define !== 'undefined' && define.amd) {\\\\n+        define([], function () {\\\\n+            return async;\\\\n+        });\\\\n+    }\\\\n+    // included directly via <script> tag\\\\n+    else {\\\\n+        root.async = async;\\\\n+    }\\\\n+\\\\n+}());\\\\ndiff --git a/node_modules/async/package.json b/node_modules/async/package.json\\\\nnew file mode 100644\\\\nindex 0000000..31a5200\\\\n--- /dev/null\\\\n+++ b/node_modules/async/package.json\\\\n@@ -0,0 +1,59 @@\\\\n+{\\\\n+  \\\\\\\"name\\\\\\\": \\\\\\\"async\\\\\\\",\\\\n+  \\\\\\\"description\\\\\\\": \\\\\\\"Higher-order functions and common patterns for asynchronous code\\\\\\\",\\\\n+  \\\\\\\"main\\\\\\\": \\\\\\\"./lib/async\\\\\\\",\\\\n+  \\\\\\\"author\\\\\\\": {\\\\n+    \\\\\\\"name\\\\\\\": \\\\\\\"Caolan McMahon\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"version\\\\\\\": \\\\\\\"0.9.0\\\\\\\",\\\\n+  \\\\\\\"repository\\\\\\\": {\\\\n+    \\\\\\\"type\\\\\\\": \\\\\\\"git\\\\\\\",\\\\n+    \\\\\\\"url\\\\\\\": \\\\\\\"https://github.com/caolan/async.git\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"bugs\\\\\\\": {\\\\n+    \\\\\\\"url\\\\\\\": \\\\\\\"https://github.com/caolan/async/issues\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"licenses\\\\\\\": [\\\\n+    {\\\\n+      \\\\\\\"type\\\\\\\": \\\\\\\"MIT\\\\\\\",\\\\n+      \\\\\\\"url\\\\\\\": \\\\\\\"https://github.com/caolan/async/raw/master/LICENSE\\\\\\\"\\\\n+    }\\\\n+  ],\\\\n+  \\\\\\\"devDependencies\\\\\\\": {\\\\n+    \\\\\\\"nodeunit\\\\\\\": \\\\\\\">0.0.0\\\\\\\",\\\\n+    \\\\\\\"uglify-js\\\\\\\": \\\\\\\"1.2.x\\\\\\\",\\\\n+    \\\\\\\"nodelint\\\\\\\": \\\\\\\">0.0.0\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"jam\\\\\\\": {\\\\n+    \\\\\\\"main\\\\\\\": \\\\\\\"lib/async.js\\\\\\\",\\\\n+    \\\\\\\"include\\\\\\\": [\\\\n+      \\\\\\\"lib/async.js\\\\\\\",\\\\n+      \\\\\\\"README.md\\\\\\\",\\\\n+      \\\\\\\"LICENSE\\\\\\\"\\\\n+    ]\\\\n+  },\\\\n+  \\\\\\\"scripts\\\\\\\": {\\\\n+    \\\\\\\"test\\\\\\\": \\\\\\\"nodeunit test/test-async.js\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"homepage\\\\\\\": \\\\\\\"https://github.com/caolan/async\\\\\\\",\\\\n+  \\\\\\\"_id\\\\\\\": \\\\\\\"async@0.9.0\\\\\\\",\\\\n+  \\\\\\\"dist\\\\\\\": {\\\\n+    \\\\\\\"shasum\\\\\\\": \\\\\\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\\\\\",\\\\n+    \\\\\\\"tarball\\\\\\\": \\\\\\\"http://registry.npmjs.org/async/-/async-0.9.0.tgz\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"_from\\\\\\\": \\\\\\\"async@*\\\\\\\",\\\\n+  \\\\\\\"_npmVersion\\\\\\\": \\\\\\\"1.4.3\\\\\\\",\\\\n+  \\\\\\\"_npmUser\\\\\\\": {\\\\n+    \\\\\\\"name\\\\\\\": \\\\\\\"caolan\\\\\\\",\\\\n+    \\\\\\\"email\\\\\\\": \\\\\\\"caolan.mcmahon@gmail.com\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"maintainers\\\\\\\": [\\\\n+    {\\\\n+      \\\\\\\"name\\\\\\\": \\\\\\\"caolan\\\\\\\",\\\\n+      \\\\\\\"email\\\\\\\": \\\\\\\"caolan@caolanmcmahon.com\\\\\\\"\\\\n+    }\\\\n+  ],\\\\n+  \\\\\\\"directories\\\\\\\": {},\\\\n+  \\\\\\\"_shasum\\\\\\\": \\\\\\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\\\\\",\\\\n+  \\\\\\\"_resolved\\\\\\\": \\\\\\\"https://registry.npmjs.org/async/-/async-0.9.0.tgz\\\\\\\"\\\\n+}\\\\ndiff --git a/package.json b/package.json\\\\nindex 5f21627..6033d43 100644\\\\n--- a/package.json\\\\n+++ b/package.json\\\\n@@ -4,7 +4,8 @@\\\\n   \\\\\\\"description\\\\\\\": \\\\\\\"Sous project\\\\\\\",\\\\n   \\\\\\\"main\\\\\\\": \\\\\\\"main.js\\\\\\\",\\\\n   \\\\\\\"dependencies\\\\\\\": {\\\\n-},\\\\n+    \\\\\\\"async\\\\\\\": \\\\\\\"*\\\\\\\"\\\\n+  },\\\\n   \\\\\\\"devDependencies\\\\\\\": {},\\\\n   \\\\\\\"scripts\\\\\\\": {\\\\n     \\\\\\\"test\\\\\\\": \\\\\\\"echo \\\\\\\\\\\\\\\"Error: no test specified\\\\\\\\\\\\\\\" && exit 1\\\\\\\"\\\\ndiff --git a/patches.sousp b/patches.sousp\\\\nindex 16405a3..d71e511 100644\\\\n--- a/patches.sousp\\\\n+++ b/patches.sousp\\\\n@@ -1,31 +1 @@\\\\n-diff --git a/main.js b/main.js\\\\n-index f81b54e..744cdd5 100644\\\\n---- a/main.js\\\\n-+++ b/main.js\\\\n-@@ -35,7 +35,7 @@ fs.exists('.git', function (exists) {\\\\n-         cp.exec('git diff', function(error, stdout, stderr) {\\\\n-             console.log(stdout);\\\\n- \\\\n--            //fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", stdout);\\\\n-+            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", stdout);\\\\n- \\\\n-             if (error !== null) {\\\\n-                 console.log('stderr: ' + stderr);\\\\n-@@ -44,7 +44,7 @@ fs.exists('.git', function (exists) {\\\\n-         });\\\\n- \\\\n-         cp.exec('git log', function(error, stdout, stderr) {\\\\n--            //console.log(stdout);\\\\n-+            console.log(stdout);\\\\n- \\\\n-             var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n-             var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n-@@ -53,7 +53,7 @@ fs.exists('.git', function (exists) {\\\\n-             console.log(comments);\\\\n-             console.log(dates);\\\\n- \\\\n--            //fs.writeFileSync(\\\\\\\"comments.sousc\\\\\\\", stdout);\\\\n-+            fs.writeFileSync(\\\\\\\"comments.sousc\\\\\\\", stdout);\\\\n- \\\\n-             if (error !== null) {\\\\n-                 console.log('stderr: ' + stderr);\\\\n+[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]\\\\n\\\\\\\\ No newline at end of file\\\\ndiff --git a/test.js b/test.js\\\\nnew file mode 100644\\\\nindex 0000000..5ca759c\\\\n--- /dev/null\\\\n+++ b/test.js\\\\n@@ -0,0 +1,21 @@\\\\n+/**\\\\n+ * Created by Nick on 18.05.2015.\\\\n+ */\\\\n+var async = require('async')\\\\n+    , tasksIndex = [\\\\n+        function (callback) {\\\\n+            // Вымышленный метод который вернет 231\\\\n+            var viewsNumber = models.stat.viewsNumber();\\\\n+            callback(null, viewsNumber);\\\\n+        }\\\\n+        , function (callback) {\\\\n+            // Вымышленный метод который вернет 24\\\\n+            var growFactor = models.stat.growFactor();\\\\n+            callback(null, growFactor);\\\\n+        }\\\\n+    ];\\\\n+\\\\n+async.series(tasksIndex, function (err, results) {\\\\n+    // Результат будет массивом\\\\n+    console.log(results); // [231, 24]\\\\n+});\\\\n\\\\\\\\ No newline at end of file\\\\n\\\"}\\n\\\\ No newline at end of file\\n\"}\n\\ No newline at end of file\n+{\"commit\":\"8e1ca32cec51a8884adff9ff63ad53f459ce5d8c\",\"author\":\"Nick <massaalonso@yandex.ru>\",\"date\":\"Sun May 17 16:40:02 2015 +0800\",\"comment\":\"Initial commit\",\"content\":\"Original\"},{\"commit\":\"bd0049f4d0639be5d3ff5f666c2568c7008cdaef\",\"author\":\"Nick Stepanenko <massaalonso@yandex.ru>\",\"date\":\"Sun May 17 16:46:31 2015 +0800\",\"comment\":\"New commit\",\"content\":\"diff --git a/.gitignore b/.gitignore\\nnew file mode 100644\\nindex 0000000..723ef36\\n--- /dev/null\\n+++ b/.gitignore\\n@@ -0,0 +1 @@\\n+.idea\\n\\\\ No newline at end of file\\ndiff --git a/main.js b/main.js\\nnew file mode 100644\\nindex 0000000..a4f68be\\n--- /dev/null\\n+++ b/main.js\\n@@ -0,0 +1,65 @@\\n+/**\\n+ * Created by Nick on 16.03.2015.\\n+ */\\n+\\n+var fs = require('fs');\\n+\\n+function findData(text, keyword) {\\n+    var data = [];\\n+    var splittext = text.split('\\\\n');\\n+\\n+    for(i=0; i<splittext.length; i++) {\\n+        if(splittext[i].indexOf(keyword) > -1) {\\n+            data[data.length] = splittext[i].slice(keyword.length+1).trim();\\n+        }\\n+    }\\n+\\n+    return data;\\n+}\\n+\\n+function findComments(text) {\\n+    var comments = [];\\n+    var splittext = text.split('\\\\n\\\\n');\\n+\\n+    for(i=1; i<splittext.length; i+=2) {\\n+        comments[comments.length] = splittext[i].trim();\\n+    }\\n+\\n+    return comments;\\n+}\\n+\\n+fs.exists('../.git', function (exists) {\\n+    if(exists) {\\n+        var cp = require('child_process');\\n+\\n+        cp.exec('git diff', function(error, stdout, stderr) {\\n+            console.log(stdout);\\n+\\n+            //fs.writeFileSync(\\\"patches.sousp\\\", stdout);\\n+\\n+            if (error !== null) {\\n+                console.log('stderr: ' + stderr);\\n+                console.log('exec error: ' + error);\\n+            }\\n+        });\\n+\\n+        cp.exec('git log', function(error, stdout, stderr) {\\n+            //console.log(stdout);\\n+\\n+            var authors = findData(stdout, \\\"Author:\\\");\\n+            var dates = findData(stdout, \\\"Date:\\\");\\n+            var comments = findComments(stdout);\\n+            //console.log(authors);\\n+            //console.log(comments);\\n+            //console.log(dates);\\n+\\n+            //fs.writeFileSync(\\\"comments.sousc\\\", stdout);\\n+\\n+            if (error !== null) {\\n+                console.log('stderr: ' + stderr);\\n+                console.log('exec error: ' + error);\\n+            }\\n+        });\\n+    }\\n+    else console.log(\\\"Error.\\\");\\n+});\\n\\\\ No newline at end of file\\ndiff --git a/package.json b/package.json\\nnew file mode 100644\\nindex 0000000..5f21627\\n--- /dev/null\\n+++ b/package.json\\n@@ -0,0 +1,22 @@\\n+{\\n+  \\\"name\\\": \\\"sous\\\",\\n+  \\\"version\\\": \\\"0.0.1\\\",\\n+  \\\"description\\\": \\\"Sous project\\\",\\n+  \\\"main\\\": \\\"main.js\\\",\\n+  \\\"dependencies\\\": {\\n+},\\n+  \\\"devDependencies\\\": {},\\n+  \\\"scripts\\\": {\\n+    \\\"test\\\": \\\"echo \\\\\\\"Error: no test specified\\\\\\\" && exit 1\\\"\\n+  },\\n+  \\\"repository\\\": {\\n+    \\\"type\\\": \\\"git\\\",\\n+    \\\"url\\\": \\\"https://github.com/NickStepanenko/sous.git\\\"\\n+  },\\n+  \\\"author\\\": \\\"Nick Stepanenko <massaalonso@yandex.ru>\\\",\\n+  \\\"license\\\": \\\"ISC\\\",\\n+  \\\"bugs\\\": {\\n+    \\\"url\\\": \\\"https://github.com/NickStepanenko/sous/issues\\\"\\n+  },\\n+  \\\"homepage\\\": \\\"https://github.com/NickStepanenko/sous\\\"\\n+}\\n\"},{\"commit\":\"be4929d2307043334b29b872760f31b1f2387a10\",\"author\":\"Nick Stepanenko <massaalonso@yandex.ru>\",\"date\":\"Sun May 17 16:54:24 2015 +0800\",\"comment\":\"Clean main.js\",\"content\":\"diff --git a/main.js b/main.js\\nindex a4f68be..e69de29 100644\\n--- a/main.js\\n+++ b/main.js\\n@@ -1,65 +0,0 @@\\n-/**\\n- * Created by Nick on 16.03.2015.\\n- */\\n-\\n-var fs = require('fs');\\n-\\n-function findData(text, keyword) {\\n-    var data = [];\\n-    var splittext = text.split('\\\\n');\\n-\\n-    for(i=0; i<splittext.length; i++) {\\n-        if(splittext[i].indexOf(keyword) > -1) {\\n-            data[data.length] = splittext[i].slice(keyword.length+1).trim();\\n-        }\\n-    }\\n-\\n-    return data;\\n-}\\n-\\n-function findComments(text) {\\n-    var comments = [];\\n-    var splittext = text.split('\\\\n\\\\n');\\n-\\n-    for(i=1; i<splittext.length; i+=2) {\\n-        comments[comments.length] = splittext[i].trim();\\n-    }\\n-\\n-    return comments;\\n-}\\n-\\n-fs.exists('../.git', function (exists) {\\n-    if(exists) {\\n-        var cp = require('child_process');\\n-\\n-        cp.exec('git diff', function(error, stdout, stderr) {\\n-            console.log(stdout);\\n-\\n-            //fs.writeFileSync(\\\"patches.sousp\\\", stdout);\\n-\\n-            if (error !== null) {\\n-                console.log('stderr: ' + stderr);\\n-                console.log('exec error: ' + error);\\n-            }\\n-        });\\n-\\n-        cp.exec('git log', function(error, stdout, stderr) {\\n-            //console.log(stdout);\\n-\\n-            var authors = findData(stdout, \\\"Author:\\\");\\n-            var dates = findData(stdout, \\\"Date:\\\");\\n-            var comments = findComments(stdout);\\n-            //console.log(authors);\\n-            //console.log(comments);\\n-            //console.log(dates);\\n-\\n-            //fs.writeFileSync(\\\"comments.sousc\\\", stdout);\\n-\\n-            if (error !== null) {\\n-                console.log('stderr: ' + stderr);\\n-                console.log('exec error: ' + error);\\n-            }\\n-        });\\n-    }\\n-    else console.log(\\\"Error.\\\");\\n-});\\n\\\\ No newline at end of file\\n\"},{\"commit\":\"e3c853a4282dfe8f000685dc1d39bd55a4a946c4\",\"author\":\"Nick Stepanenko <massaalonso@yandex.ru>\",\"date\":\"Sun May 17 16:54:58 2015 +0800\",\"comment\":\"Recovered main.js\",\"content\":\"diff --git a/main.js b/main.js\\nindex e69de29..f81b54e 100644\\n--- a/main.js\\n+++ b/main.js\\n@@ -0,0 +1,65 @@\\n+/**\\n+ * Created by Nick on 16.03.2015.\\n+ */\\n+\\n+var fs = require('fs');\\n+\\n+function findData(text, keyword) {\\n+    var data = [];\\n+    var splittext = text.split('\\\\n');\\n+\\n+    for(i=0; i<splittext.length; i++) {\\n+        if(splittext[i].indexOf(keyword) > -1) {\\n+            data[data.length] = splittext[i].slice(keyword.length+1).trim();\\n+        }\\n+    }\\n+\\n+    return data;\\n+}\\n+\\n+function findComments(text) {\\n+    var comments = [];\\n+    var splittext = text.split('\\\\n\\\\n');\\n+\\n+    for(i=1; i<splittext.length; i+=2) {\\n+        comments[comments.length] = splittext[i].trim();\\n+    }\\n+\\n+    return comments;\\n+}\\n+\\n+fs.exists('.git', function (exists) {\\n+    if(exists) {\\n+        var cp = require('child_process');\\n+\\n+        cp.exec('git diff', function(error, stdout, stderr) {\\n+            console.log(stdout);\\n+\\n+            //fs.writeFileSync(\\\"patches.sousp\\\", stdout);\\n+\\n+            if (error !== null) {\\n+                console.log('stderr: ' + stderr);\\n+                console.log('exec error: ' + error);\\n+            }\\n+        });\\n+\\n+        cp.exec('git log', function(error, stdout, stderr) {\\n+            //console.log(stdout);\\n+\\n+            var authors = findData(stdout, \\\"Author:\\\");\\n+            var dates = findData(stdout, \\\"Date:\\\");\\n+            var comments = findComments(stdout);\\n+            console.log(authors);\\n+            console.log(comments);\\n+            console.log(dates);\\n+\\n+            //fs.writeFileSync(\\\"comments.sousc\\\", stdout);\\n+\\n+            if (error !== null) {\\n+                console.log('stderr: ' + stderr);\\n+                console.log('exec error: ' + error);\\n+            }\\n+        });\\n+    }\\n+    else console.log(\\\"Error.\\\");\\n+});\\n\\\\ No newline at end of file\\n\"},{\"commit\":\"c9d318fea74ea288d544ecf72f00b12c130cf2ef\",\"author\":\"Nick Stepanenko <massaalonso@yandex.ru>\",\"date\":\"Sun May 17 16:59:40 2015 +0800\",\"comment\":\"Create system files\",\"content\":\"diff --git a/comments.sousc b/comments.sousc\\nnew file mode 100644\\nindex 0000000..150b0f6\\n--- /dev/null\\n+++ b/comments.sousc\\n@@ -0,0 +1,23 @@\\n+commit e3c853a4282dfe8f000685dc1d39bd55a4a946c4\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\n+Date:   Sun May 17 16:54:58 2015 +0800\\n+\\n+    Recovered main.js\\n+\\n+commit be4929d2307043334b29b872760f31b1f2387a10\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\n+Date:   Sun May 17 16:54:24 2015 +0800\\n+\\n+    Clean main.js\\n+\\n+commit bd0049f4d0639be5d3ff5f666c2568c7008cdaef\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\n+Date:   Sun May 17 16:46:31 2015 +0800\\n+\\n+    New commit\\n+\\n+commit 8e1ca32cec51a8884adff9ff63ad53f459ce5d8c\\n+Author: Nick <massaalonso@yandex.ru>\\n+Date:   Sun May 17 16:40:02 2015 +0800\\n+\\n+    Initial commit\\ndiff --git a/main.js b/main.js\\nindex f81b54e..744cdd5 100644\\n--- a/main.js\\n+++ b/main.js\\n@@ -35,7 +35,7 @@ fs.exists('.git', function (exists) {\\n         cp.exec('git diff', function(error, stdout, stderr) {\\n             console.log(stdout);\\n \\n-            //fs.writeFileSync(\\\"patches.sousp\\\", stdout);\\n+            fs.writeFileSync(\\\"patches.sousp\\\", stdout);\\n \\n             if (error !== null) {\\n                 console.log('stderr: ' + stderr);\\n@@ -44,7 +44,7 @@ fs.exists('.git', function (exists) {\\n         });\\n \\n         cp.exec('git log', function(error, stdout, stderr) {\\n-            //console.log(stdout);\\n+            console.log(stdout);\\n \\n             var authors = findData(stdout, \\\"Author:\\\");\\n             var dates = findData(stdout, \\\"Date:\\\");\\n@@ -53,7 +53,7 @@ fs.exists('.git', function (exists) {\\n             console.log(comments);\\n             console.log(dates);\\n \\n-            //fs.writeFileSync(\\\"comments.sousc\\\", stdout);\\n+            fs.writeFileSync(\\\"comments.sousc\\\", stdout);\\n \\n             if (error !== null) {\\n                 console.log('stderr: ' + stderr);\\ndiff --git a/patches.sousp b/patches.sousp\\nnew file mode 100644\\nindex 0000000..16405a3\\n--- /dev/null\\n+++ b/patches.sousp\\n@@ -0,0 +1,31 @@\\n+diff --git a/main.js b/main.js\\n+index f81b54e..744cdd5 100644\\n+--- a/main.js\\n++++ b/main.js\\n+@@ -35,7 +35,7 @@ fs.exists('.git', function (exists) {\\n+         cp.exec('git diff', function(error, stdout, stderr) {\\n+             console.log(stdout);\\n+ \\n+-            //fs.writeFileSync(\\\"patches.sousp\\\", stdout);\\n++            fs.writeFileSync(\\\"patches.sousp\\\", stdout);\\n+ \\n+             if (error !== null) {\\n+                 console.log('stderr: ' + stderr);\\n+@@ -44,7 +44,7 @@ fs.exists('.git', function (exists) {\\n+         });\\n+ \\n+         cp.exec('git log', function(error, stdout, stderr) {\\n+-            //console.log(stdout);\\n++            console.log(stdout);\\n+ \\n+             var authors = findData(stdout, \\\"Author:\\\");\\n+             var dates = findData(stdout, \\\"Date:\\\");\\n+@@ -53,7 +53,7 @@ fs.exists('.git', function (exists) {\\n+             console.log(comments);\\n+             console.log(dates);\\n+ \\n+-            //fs.writeFileSync(\\\"comments.sousc\\\", stdout);\\n++            fs.writeFileSync(\\\"comments.sousc\\\", stdout);\\n+ \\n+             if (error !== null) {\\n+                 console.log('stderr: ' + stderr);\\n\"},{\"commit\":\"64814d140d2fab6ae153cac485008119f29bf230\",\"author\":\"Nick Stepanenko <massaalonso@yandex.ru>\",\"date\":\"Sun May 17 17:03:58 2015 +0800\",\"comment\":\"From clear list\",\"content\":\"diff --git a/main.js b/main.js\\ndeleted file mode 100644\\nindex 744cdd5..0000000\\n--- a/main.js\\n+++ /dev/null\\n@@ -1,65 +0,0 @@\\n-/**\\n- * Created by Nick on 16.03.2015.\\n- */\\n-\\n-var fs = require('fs');\\n-\\n-function findData(text, keyword) {\\n-    var data = [];\\n-    var splittext = text.split('\\\\n');\\n-\\n-    for(i=0; i<splittext.length; i++) {\\n-        if(splittext[i].indexOf(keyword) > -1) {\\n-            data[data.length] = splittext[i].slice(keyword.length+1).trim();\\n-        }\\n-    }\\n-\\n-    return data;\\n-}\\n-\\n-function findComments(text) {\\n-    var comments = [];\\n-    var splittext = text.split('\\\\n\\\\n');\\n-\\n-    for(i=1; i<splittext.length; i+=2) {\\n-        comments[comments.length] = splittext[i].trim();\\n-    }\\n-\\n-    return comments;\\n-}\\n-\\n-fs.exists('.git', function (exists) {\\n-    if(exists) {\\n-        var cp = require('child_process');\\n-\\n-        cp.exec('git diff', function(error, stdout, stderr) {\\n-            console.log(stdout);\\n-\\n-            fs.writeFileSync(\\\"patches.sousp\\\", stdout);\\n-\\n-            if (error !== null) {\\n-                console.log('stderr: ' + stderr);\\n-                console.log('exec error: ' + error);\\n-            }\\n-        });\\n-\\n-        cp.exec('git log', function(error, stdout, stderr) {\\n-            console.log(stdout);\\n-\\n-            var authors = findData(stdout, \\\"Author:\\\");\\n-            var dates = findData(stdout, \\\"Date:\\\");\\n-            var comments = findComments(stdout);\\n-            console.log(authors);\\n-            console.log(comments);\\n-            console.log(dates);\\n-\\n-            fs.writeFileSync(\\\"comments.sousc\\\", stdout);\\n-\\n-            if (error !== null) {\\n-                console.log('stderr: ' + stderr);\\n-                console.log('exec error: ' + error);\\n-            }\\n-        });\\n-    }\\n-    else console.log(\\\"Error.\\\");\\n-});\\n\\\\ No newline at end of file\\n\"},{\"commit\":\"9ef3d25fd4c3afdbcc3107a0abf6d7a2e29cb4dd\",\"author\":\"Nick Stepanenko <massaalonso@yandex.ru>\",\"date\":\"Sun May 17 17:04:52 2015 +0800\",\"comment\":\"Adding new file\",\"content\":\"diff --git a/main.js b/main.js\\nnew file mode 100644\\nindex 0000000..6793bb9\\n--- /dev/null\\n+++ b/main.js\\n@@ -0,0 +1,3 @@\\n+/**\\n+ * Created by Nick on 17.05.2015.\\n+ */\\n\"},{\"commit\":\"4420cabefc1f470af341af11ed595df67e25c51f\",\"author\":\"Nick Stepanenko <massaalonso@yandex.ru>\",\"date\":\"Sun May 17 17:05:35 2015 +0800\",\"comment\":\"Paste old program code\",\"content\":\"diff --git a/main.js b/main.js\\nindex 6793bb9..e34dc18 100644\\n--- a/main.js\\n+++ b/main.js\\n@@ -1,3 +1,65 @@\\n /**\\n  * Created by Nick on 17.05.2015.\\n  */\\n+\\n+var fs = require('fs');\\n+\\n+function findData(text, keyword) {\\n+    var data = [];\\n+    var splittext = text.split('\\\\n');\\n+\\n+    for(i=0; i<splittext.length; i++) {\\n+        if(splittext[i].indexOf(keyword) > -1) {\\n+            data[data.length] = splittext[i].slice(keyword.length+1).trim();\\n+        }\\n+    }\\n+\\n+    return data;\\n+}\\n+\\n+function findComments(text) {\\n+    var comments = [];\\n+    var splittext = text.split('\\\\n\\\\n');\\n+\\n+    for(i=1; i<splittext.length; i+=2) {\\n+        comments[comments.length] = splittext[i].trim();\\n+    }\\n+\\n+    return comments;\\n+}\\n+\\n+fs.exists('.git', function (exists) {\\n+    if(exists) {\\n+        var cp = require('child_process');\\n+\\n+        cp.exec('git diff', function(error, stdout, stderr) {\\n+            console.log(stdout);\\n+\\n+            fs.writeFileSync(\\\"patches.sousp\\\", stdout);\\n+\\n+            if (error !== null) {\\n+                console.log('stderr: ' + stderr);\\n+                console.log('exec error: ' + error);\\n+            }\\n+        });\\n+\\n+        cp.exec('git log', function(error, stdout, stderr) {\\n+            console.log(stdout);\\n+\\n+            var authors = findData(stdout, \\\"Author:\\\");\\n+            var dates = findData(stdout, \\\"Date:\\\");\\n+            var comments = findComments(stdout);\\n+            console.log(authors);\\n+            console.log(comments);\\n+            console.log(dates);\\n+\\n+            fs.writeFileSync(\\\"comments.sousc\\\", stdout);\\n+\\n+            if (error !== null) {\\n+                console.log('stderr: ' + stderr);\\n+                console.log('exec error: ' + error);\\n+            }\\n+        });\\n+    }\\n+    else console.log(\\\"Error.\\\");\\n+});\\n\\\\ No newline at end of file\\n\"},{\"commit\":\"1e947f613e976945de85ae35ed923aa470f0be72\",\"author\":\"Nick Stepanenko <massaalonso@yandex.ru>\",\"date\":\"Tue May 19 00:12:12 2015 +0800\",\"comment\":\"Latest updates\",\"content\":\"diff --git a/comments.sousc b/comments.sousc\\nindex 150b0f6..cb3a850 100644\\n--- a/comments.sousc\\n+++ b/comments.sousc\\n@@ -1,3 +1,27 @@\\n+commit 4420cabefc1f470af341af11ed595df67e25c51f\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\n+Date:   Sun May 17 17:05:35 2015 +0800\\n+\\n+    Paste old program code\\n+\\n+commit 9ef3d25fd4c3afdbcc3107a0abf6d7a2e29cb4dd\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\n+Date:   Sun May 17 17:04:52 2015 +0800\\n+\\n+    Adding new file\\n+\\n+commit 64814d140d2fab6ae153cac485008119f29bf230\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\n+Date:   Sun May 17 17:03:58 2015 +0800\\n+\\n+    From clear list\\n+\\n+commit c9d318fea74ea288d544ecf72f00b12c130cf2ef\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\n+Date:   Sun May 17 16:59:40 2015 +0800\\n+\\n+    Create system files\\n+\\n commit e3c853a4282dfe8f000685dc1d39bd55a4a946c4\\n Author: Nick Stepanenko <massaalonso@yandex.ru>\\n Date:   Sun May 17 16:54:58 2015 +0800\\ndiff --git a/main.js b/main.js\\nindex e34dc18..86f30c2 100644\\n--- a/main.js\\n+++ b/main.js\\n@@ -3,6 +3,56 @@\\n  */\\n \\n var fs = require('fs');\\n+var cp = require('child_process');\\n+var data = [];\\n+\\n+var async = require('async');\\n+    /*tasks = [\\n+        function (callback) {\\n+            cp.exec('git log', function(error, stdout, stderr) {\\n+                var listOfCommits = [];\\n+                var authors = findData(stdout, \\\"Author:\\\");\\n+                var dates = findData(stdout, \\\"Date:\\\");\\n+                var comments = findComments(stdout);\\n+                var commitNumbers = findCommitNumbers(stdout);\\n+\\n+                for(i=0; i<authors.length; i++) {\\n+                    var commit = {\\n+                        \\\"commit\\\": commitNumbers[i],\\n+                        \\\"author\\\": authors[i],\\n+                        \\\"date\\\": dates[i],\\n+                        \\\"comment\\\": comments[i],\\n+                        \\\"content\\\": 'Original'\\n+                    };\\n+\\n+                    listOfCommits[listOfCommits.length] = commit;\\n+                }\\n+\\n+                data = listOfCommits.reverse();\\n+\\n+                callback(null, data);\\n+\\n+                if (error !== null) {\\n+                    console.log('stderr: ' + stderr);\\n+                    console.log('exec error: ' + error);\\n+                }\\n+            });\\n+        }\\n+    ],\\n+    secondTasks = [\\n+        function some_function(callback) {\\n+            cp.exec('git diff', function(error, stdout, stderr) {\\n+                var currentContent = stdout;\\n+\\n+                if (error !== null) {\\n+                    console.log('stderr: ' + stderr);\\n+                    console.log('exec error: ' + error);\\n+                }\\n+\\n+                callback(null, currentContent);\\n+            });\\n+        }\\n+    ];*/\\n \\n function findData(text, keyword) {\\n     var data = [];\\n@@ -28,38 +78,106 @@ function findComments(text) {\\n     return comments;\\n }\\n \\n+function findCommitNumbers(text) {\\n+    var commits = [];\\n+    var splittext = text.split('\\\\n');\\n+\\n+    for(i=0; i<splittext.length; i++) {\\n+        if(splittext[i].slice(0, 6) == \\\"commit\\\") {\\n+            commits[commits.length] = splittext[i].slice(6).trim();\\n+        }\\n+    }\\n+\\n+    return commits;\\n+}\\n+\\n+/*function pullCommitContent(first, second) {\\n+\\n+    cp.exec('git diff' + ' ' + first + ' ' + second, function(error, stdout, stderr) {\\n+        var currentContent = stdout;\\n+\\n+        if (error !== null) {\\n+            console.log('stderr: ' + stderr);\\n+            console.log('exec error: ' + error);\\n+        }\\n+\\n+        return currentContent;\\n+    });\\n+}*/\\n+\\n+var commitsInfo = [];\\n+\\n fs.exists('.git', function (exists) {\\n     if(exists) {\\n-        var cp = require('child_process');\\n+        /*async.series(tasks, function(err, result) {\\n+            fs.writeFileSync(\\\"patches.sousp\\\", JSON.stringify(result));\\n+\\n+            var data = result[0];\\n \\n-        cp.exec('git diff', function(error, stdout, stderr) {\\n-            console.log(stdout);\\n+            /*function some_function(arg1, arg2, callback) {\\n+                cp.exec('git diff' + ' ' + arg1 + ' ' + arg2, function(error, stdout, stderr) {\\n+                    var currentContent = 54321;//stdout;\\n \\n-            fs.writeFileSync(\\\"patches.sousp\\\", stdout);\\n+                    if (error !== null) {\\n+                        console.log('stderr: ' + stderr);\\n+                        console.log('exec error: ' + error);\\n+                    }\\n \\n-            if (error !== null) {\\n-                console.log('stderr: ' + stderr);\\n-                console.log('exec error: ' + error);\\n+                    callback(null, currentContent);\\n+                });\\n             }\\n-        });\\n+        });*/\\n+\\n+        async.waterfall([\\n+            function getCommitsInfo(callback) {\\n+                cp.exec('git log', function(error, stdout, stderr) {\\n+                    var listOfCommits = [];\\n+                    var authors = findData(stdout, \\\"Author:\\\");\\n+                    var dates = findData(stdout, \\\"Date:\\\");\\n+                    var comments = findComments(stdout);\\n+                    var commitNumbers = findCommitNumbers(stdout);\\n \\n-        cp.exec('git log', function(error, stdout, stderr) {\\n-            console.log(stdout);\\n+                    for(i=0; i<authors.length; i++) {\\n+                        var commit = {\\n+                            \\\"commit\\\": commitNumbers[i],\\n+                            \\\"author\\\": authors[i],\\n+                            \\\"date\\\": dates[i],\\n+                            \\\"comment\\\": comments[i],\\n+                            \\\"content\\\": 'Original'\\n+                        };\\n+                        listOfCommits[listOfCommits.length] = commit;\\n+                    }\\n \\n-            var authors = findData(stdout, \\\"Author:\\\");\\n-            var dates = findData(stdout, \\\"Date:\\\");\\n-            var comments = findComments(stdout);\\n-            console.log(authors);\\n-            console.log(comments);\\n-            console.log(dates);\\n+                    callback(null, listOfCommits.reverse());\\n \\n-            fs.writeFileSync(\\\"comments.sousc\\\", stdout);\\n+                    if (error !== null) {\\n+                        console.log('stderr: ' + stderr);\\n+                        console.log('exec error: ' + error);\\n+                    }\\n+                });\\n+            },\\n+            function getCommitsContent(commits, callback) {\\n+                console.log(commits);\\n+                var commitsData = commits;\\n \\n-            if (error !== null) {\\n-                console.log('stderr: ' + stderr);\\n-                console.log('exec error: ' + error);\\n+                for(i=1; i<commitsData.length; i++) {\\n+                    cp.exec('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit, function(error, stdout, stderr) {\\n+                        commitsData[i].content = stdout;\\n+\\n+                        if (error !== null) {\\n+                            console.log('stderr: ' + stderr);\\n+                            console.log('exec error: ' + error);\\n+                        }\\n+                    });\\n+                }\\n+\\n+                callback(null, commitsData);\\n             }\\n+        ], function (err, result) {\\n+            fs.writeFileSync(\\\"patches.sousp\\\", result);\\n         });\\n+\\n+        //commitsInfo = JSON.parse(fs.readFileSync(\\\"patches.sousp\\\"));\\n+        //console.log(commitsInfo);\\n     }\\n-    else console.log(\\\"Error.\\\");\\n });\\n\\\\ No newline at end of file\\ndiff --git a/node_modules/async/.travis.yml b/node_modules/async/.travis.yml\\nnew file mode 100644\\nindex 0000000..6e5919d\\n--- /dev/null\\n+++ b/node_modules/async/.travis.yml\\n@@ -0,0 +1,3 @@\\n+language: node_js\\n+node_js:\\n+  - \\\"0.10\\\"\\ndiff --git a/node_modules/async/LICENSE b/node_modules/async/LICENSE\\nnew file mode 100644\\nindex 0000000..8f29698\\n--- /dev/null\\n+++ b/node_modules/async/LICENSE\\n@@ -0,0 +1,19 @@\\n+Copyright (c) 2010-2014 Caolan McMahon\\n+\\n+Permission is hereby granted, free of charge, to any person obtaining a copy\\n+of this software and associated documentation files (the \\\"Software\\\"), to deal\\n+in the Software without restriction, including without limitation the rights\\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n+copies of the Software, and to permit persons to whom the Software is\\n+furnished to do so, subject to the following conditions:\\n+\\n+The above copyright notice and this permission notice shall be included in\\n+all copies or substantial portions of the Software.\\n+\\n+THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n+THE SOFTWARE.\\ndiff --git a/node_modules/async/README.md b/node_modules/async/README.md\\nnew file mode 100644\\nindex 0000000..0bea531\\n--- /dev/null\\n+++ b/node_modules/async/README.md\\n@@ -0,0 +1,1646 @@\\n+# Async.js\\n+\\n+[![Build Status via Travis CI](https://travis-ci.org/caolan/async.svg?branch=master)](https://travis-ci.org/caolan/async)\\n+\\n+\\n+Async is a utility module which provides straight-forward, powerful functions\\n+for working with asynchronous JavaScript. Although originally designed for\\n+use with [Node.js](http://nodejs.org), it can also be used directly in the\\n+browser. Also supports [component](https://github.com/component/component).\\n+\\n+Async provides around 20 functions that include the usual 'functional'\\n+suspects (`map`, `reduce`, `filter`, `each`…) as well as some common patterns\\n+for asynchronous control flow (`parallel`, `series`, `waterfall`…). All these\\n+functions assume you follow the Node.js convention of providing a single\\n+callback as the last argument of your `async` function.\\n+\\n+\\n+## Quick Examples\\n+\\n+```javascript\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\n+    // results is now an array of stats for each file\\n+});\\n+\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\n+    // results now equals an array of the existing files\\n+});\\n+\\n+async.parallel([\\n+    function(){ ... },\\n+    function(){ ... }\\n+], callback);\\n+\\n+async.series([\\n+    function(){ ... },\\n+    function(){ ... }\\n+]);\\n+```\\n+\\n+There are many more functions available so take a look at the docs below for a\\n+full list. This module aims to be comprehensive, so if you feel anything is\\n+missing please create a GitHub issue for it.\\n+\\n+## Common Pitfalls\\n+\\n+### Binding a context to an iterator\\n+\\n+This section is really about `bind`, not about `async`. If you are wondering how to\\n+make `async` execute your iterators in a given context, or are confused as to why\\n+a method of another library isn't working as an iterator, study this example:\\n+\\n+```js\\n+// Here is a simple object with an (unnecessarily roundabout) squaring method\\n+var AsyncSquaringLibrary = {\\n+  squareExponent: 2,\\n+  square: function(number, callback){ \\n+    var result = Math.pow(number, this.squareExponent);\\n+    setTimeout(function(){\\n+      callback(null, result);\\n+    }, 200);\\n+  }\\n+};\\n+\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square, function(err, result){\\n+  // result is [NaN, NaN, NaN]\\n+  // This fails because the `this.squareExponent` expression in the square\\n+  // function is not evaluated in the context of AsyncSquaringLibrary, and is\\n+  // therefore undefined.\\n+});\\n+\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), function(err, result){\\n+  // result is [1, 4, 9]\\n+  // With the help of bind we can attach a context to the iterator before\\n+  // passing it to async. Now the square function will be executed in its \\n+  // 'home' AsyncSquaringLibrary context and the value of `this.squareExponent`\\n+  // will be as expected.\\n+});\\n+```\\n+\\n+## Download\\n+\\n+The source is available for download from\\n+[GitHub](http://github.com/caolan/async).\\n+Alternatively, you can install using Node Package Manager (`npm`):\\n+\\n+    npm install async\\n+\\n+__Development:__ [async.js](https://github.com/caolan/async/raw/master/lib/async.js) - 29.6kb Uncompressed\\n+\\n+## In the Browser\\n+\\n+So far it's been tested in IE6, IE7, IE8, FF3.6 and Chrome 5. \\n+\\n+Usage:\\n+\\n+```html\\n+<script type=\\\"text/javascript\\\" src=\\\"async.js\\\"></script>\\n+<script type=\\\"text/javascript\\\">\\n+\\n+    async.map(data, asyncProcess, function(err, results){\\n+        alert(results);\\n+    });\\n+\\n+</script>\\n+```\\n+\\n+## Documentation\\n+\\n+### Collections\\n+\\n+* [`each`](#each)\\n+* [`eachSeries`](#eachSeries)\\n+* [`eachLimit`](#eachLimit)\\n+* [`map`](#map)\\n+* [`mapSeries`](#mapSeries)\\n+* [`mapLimit`](#mapLimit)\\n+* [`filter`](#filter)\\n+* [`filterSeries`](#filterSeries)\\n+* [`reject`](#reject)\\n+* [`rejectSeries`](#rejectSeries)\\n+* [`reduce`](#reduce)\\n+* [`reduceRight`](#reduceRight)\\n+* [`detect`](#detect)\\n+* [`detectSeries`](#detectSeries)\\n+* [`sortBy`](#sortBy)\\n+* [`some`](#some)\\n+* [`every`](#every)\\n+* [`concat`](#concat)\\n+* [`concatSeries`](#concatSeries)\\n+\\n+### Control Flow\\n+\\n+* [`series`](#seriestasks-callback)\\n+* [`parallel`](#parallel)\\n+* [`parallelLimit`](#parallellimittasks-limit-callback)\\n+* [`whilst`](#whilst)\\n+* [`doWhilst`](#doWhilst)\\n+* [`until`](#until)\\n+* [`doUntil`](#doUntil)\\n+* [`forever`](#forever)\\n+* [`waterfall`](#waterfall)\\n+* [`compose`](#compose)\\n+* [`seq`](#seq)\\n+* [`applyEach`](#applyEach)\\n+* [`applyEachSeries`](#applyEachSeries)\\n+* [`queue`](#queue)\\n+* [`priorityQueue`](#priorityQueue)\\n+* [`cargo`](#cargo)\\n+* [`auto`](#auto)\\n+* [`retry`](#retry)\\n+* [`iterator`](#iterator)\\n+* [`apply`](#apply)\\n+* [`nextTick`](#nextTick)\\n+* [`times`](#times)\\n+* [`timesSeries`](#timesSeries)\\n+\\n+### Utils\\n+\\n+* [`memoize`](#memoize)\\n+* [`unmemoize`](#unmemoize)\\n+* [`log`](#log)\\n+* [`dir`](#dir)\\n+* [`noConflict`](#noConflict)\\n+\\n+\\n+## Collections\\n+\\n+<a name=\\\"forEach\\\" />\\n+<a name=\\\"each\\\" />\\n+### each(arr, iterator, callback)\\n+\\n+Applies the function `iterator` to each item in `arr`, in parallel.\\n+The `iterator` is called with an item from the list, and a callback for when it\\n+has finished. If the `iterator` passes an error to its `callback`, the main\\n+`callback` (for the `each` function) is immediately called with the error.\\n+\\n+Note, that since this function applies `iterator` to each item in parallel,\\n+there is no guarantee that the iterator functions will complete in order.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err)` which must be called once it has \\n+  completed. If no error has occured, the `callback` should be run without \\n+  arguments or with an explicit `null` argument.\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\n+  have finished, or an error occurs.\\n+\\n+__Examples__\\n+\\n+\\n+```js\\n+// assuming openFiles is an array of file names and saveFile is a function\\n+// to save the modified contents of that file:\\n+\\n+async.each(openFiles, saveFile, function(err){\\n+    // if any of the saves produced an error, err would equal that error\\n+});\\n+```\\n+\\n+```js\\n+// assuming openFiles is an array of file names \\n+\\n+async.each(openFiles, function( file, callback) {\\n+  \\n+  // Perform operation on file here.\\n+  console.log('Processing file ' + file);\\n+  \\n+  if( file.length > 32 ) {\\n+    console.log('This file name is too long');\\n+    callback('File name too long');\\n+  } else {\\n+    // Do work to process file here\\n+    console.log('File processed');\\n+    callback();\\n+  }\\n+}, function(err){\\n+    // if any of the file processing produced an error, err would equal that error\\n+    if( err ) {\\n+      // One of the iterations produced an error.\\n+      // All processing will now stop.\\n+      console.log('A file failed to process');\\n+    } else {\\n+      console.log('All files have been processed successfully');\\n+    }\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"forEachSeries\\\" />\\n+<a name=\\\"eachSeries\\\" />\\n+### eachSeries(arr, iterator, callback)\\n+\\n+The same as [`each`](#each), only `iterator` is applied to each item in `arr` in\\n+series. The next `iterator` is only called once the current one has completed. \\n+This means the `iterator` functions will complete in order.\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"forEachLimit\\\" />\\n+<a name=\\\"eachLimit\\\" />\\n+### eachLimit(arr, limit, iterator, callback)\\n+\\n+The same as [`each`](#each), only no more than `limit` `iterator`s will be simultaneously \\n+running at any time.\\n+\\n+Note that the items in `arr` are not processed in batches, so there is no guarantee that \\n+the first `limit` `iterator` functions will complete before any others are started.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err)` which must be called once it has \\n+  completed. If no error has occured, the callback should be run without \\n+  arguments or with an explicit `null` argument.\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\n+  have finished, or an error occurs.\\n+\\n+__Example__\\n+\\n+```js\\n+// Assume documents is an array of JSON objects and requestApi is a\\n+// function that interacts with a rate-limited REST api.\\n+\\n+async.eachLimit(documents, 20, requestApi, function(err){\\n+    // if any of the saves produced an error, err would equal that error\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"map\\\" />\\n+### map(arr, iterator, callback)\\n+\\n+Produces a new array of values by mapping each value in `arr` through\\n+the `iterator` function. The `iterator` is called with an item from `arr` and a\\n+callback for when it has finished processing. Each of these callback takes 2 arguments: \\n+an `error`, and the transformed item from `arr`. If `iterator` passes an error to this \\n+callback, the main `callback` (for the `map` function) is immediately called with the error.\\n+\\n+Note, that since this function applies the `iterator` to each item in parallel,\\n+there is no guarantee that the `iterator` functions will complete in order. \\n+However, the results array will be in the same order as the original `arr`.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\n+  it has completed with an error (which can be `null`) and a transformed item.\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\n+  functions have finished, or an error occurs. Results is an array of the\\n+  transformed items from the `arr`.\\n+\\n+__Example__\\n+\\n+```js\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\n+    // results is now an array of stats for each file\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"mapSeries\\\" />\\n+### mapSeries(arr, iterator, callback)\\n+\\n+The same as [`map`](#map), only the `iterator` is applied to each item in `arr` in\\n+series. The next `iterator` is only called once the current one has completed. \\n+The results array will be in the same order as the original.\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"mapLimit\\\" />\\n+### mapLimit(arr, limit, iterator, callback)\\n+\\n+The same as [`map`](#map), only no more than `limit` `iterator`s will be simultaneously \\n+running at any time.\\n+\\n+Note that the items are not processed in batches, so there is no guarantee that \\n+the first `limit` `iterator` functions will complete before any others are started.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\n+  it has completed with an error (which can be `null`) and a transformed item.\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\n+  calls have finished, or an error occurs. The result is an array of the\\n+  transformed items from the original `arr`.\\n+\\n+__Example__\\n+\\n+```js\\n+async.mapLimit(['file1','file2','file3'], 1, fs.stat, function(err, results){\\n+    // results is now an array of stats for each file\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"select\\\" />\\n+<a name=\\\"filter\\\" />\\n+### filter(arr, iterator, callback)\\n+\\n+__Alias:__ `select`\\n+\\n+Returns a new array of all the values in `arr` which pass an async truth test.\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\n+way node libraries work with truth tests like `fs.exists`. This operation is\\n+performed in parallel, but the results array will be in the same order as the\\n+original.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\n+  The `iterator` is passed a `callback(truthValue)`, which must be called with a \\n+  boolean argument once it has completed.\\n+* `callback(results)` - A callback which is called after all the `iterator`\\n+  functions have finished.\\n+\\n+__Example__\\n+\\n+```js\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\n+    // results now equals an array of the existing files\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"selectSeries\\\" />\\n+<a name=\\\"filterSeries\\\" />\\n+### filterSeries(arr, iterator, callback)\\n+\\n+__Alias:__ `selectSeries`\\n+\\n+The same as [`filter`](#filter) only the `iterator` is applied to each item in `arr` in\\n+series. The next `iterator` is only called once the current one has completed. \\n+The results array will be in the same order as the original.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"reject\\\" />\\n+### reject(arr, iterator, callback)\\n+\\n+The opposite of [`filter`](#filter). Removes values that pass an `async` truth test.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"rejectSeries\\\" />\\n+### rejectSeries(arr, iterator, callback)\\n+\\n+The same as [`reject`](#reject), only the `iterator` is applied to each item in `arr`\\n+in series.\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"reduce\\\" />\\n+### reduce(arr, memo, iterator, callback)\\n+\\n+__Aliases:__ `inject`, `foldl`\\n+\\n+Reduces `arr` into a single value using an async `iterator` to return\\n+each successive step. `memo` is the initial state of the reduction. \\n+This function only operates in series. \\n+\\n+For performance reasons, it may make sense to split a call to this function into \\n+a parallel map, and then use the normal `Array.prototype.reduce` on the results. \\n+This function is for situations where each step in the reduction needs to be async; \\n+if you can get the data before reducing it, then it's probably a good idea to do so.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `memo` - The initial state of the reduction.\\n+* `iterator(memo, item, callback)` - A function applied to each item in the\\n+  array to produce the next step in the reduction. The `iterator` is passed a\\n+  `callback(err, reduction)` which accepts an optional error as its first \\n+  argument, and the state of the reduction as the second. If an error is \\n+  passed to the callback, the reduction is stopped and the main `callback` is \\n+  immediately called with the error.\\n+* `callback(err, result)` - A callback which is called after all the `iterator`\\n+  functions have finished. Result is the reduced value.\\n+\\n+__Example__\\n+\\n+```js\\n+async.reduce([1,2,3], 0, function(memo, item, callback){\\n+    // pointless async:\\n+    process.nextTick(function(){\\n+        callback(null, memo + item)\\n+    });\\n+}, function(err, result){\\n+    // result is now equal to the last value of memo, which is 6\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"reduceRight\\\" />\\n+### reduceRight(arr, memo, iterator, callback)\\n+\\n+__Alias:__ `foldr`\\n+\\n+Same as [`reduce`](#reduce), only operates on `arr` in reverse order.\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"detect\\\" />\\n+### detect(arr, iterator, callback)\\n+\\n+Returns the first value in `arr` that passes an async truth test. The\\n+`iterator` is applied in parallel, meaning the first iterator to return `true` will\\n+fire the detect `callback` with that result. That means the result might not be\\n+the first item in the original `arr` (in terms of order) that passes the test.\\n+\\n+If order within the original `arr` is important, then look at [`detectSeries`](#detectSeries).\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\n+  The iterator is passed a `callback(truthValue)` which must be called with a \\n+  boolean argument once it has completed.\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\n+  `true`, or after all the `iterator` functions have finished. Result will be\\n+  the first item in the array that passes the truth test (iterator) or the\\n+  value `undefined` if none passed.\\n+\\n+__Example__\\n+\\n+```js\\n+async.detect(['file1','file2','file3'], fs.exists, function(result){\\n+    // result now equals the first file in the list that exists\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"detectSeries\\\" />\\n+### detectSeries(arr, iterator, callback)\\n+\\n+The same as [`detect`](#detect), only the `iterator` is applied to each item in `arr`\\n+in series. This means the result is always the first in the original `arr` (in\\n+terms of array order) that passes the truth test.\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"sortBy\\\" />\\n+### sortBy(arr, iterator, callback)\\n+\\n+Sorts a list by the results of running each `arr` value through an async `iterator`.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err, sortValue)` which must be called once it\\n+  has completed with an error (which can be `null`) and a value to use as the sort\\n+  criteria.\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\n+  functions have finished, or an error occurs. Results is the items from\\n+  the original `arr` sorted by the values returned by the `iterator` calls.\\n+\\n+__Example__\\n+\\n+```js\\n+async.sortBy(['file1','file2','file3'], function(file, callback){\\n+    fs.stat(file, function(err, stats){\\n+        callback(err, stats.mtime);\\n+    });\\n+}, function(err, results){\\n+    // results is now the original array of files sorted by\\n+    // modified date\\n+});\\n+```\\n+\\n+__Sort Order__\\n+\\n+By modifying the callback parameter the sorting order can be influenced:\\n+\\n+```js\\n+//ascending order\\n+async.sortBy([1,9,3,5], function(x, callback){\\n+    callback(err, x);\\n+}, function(err,result){\\n+    //result callback\\n+} );\\n+\\n+//descending order\\n+async.sortBy([1,9,3,5], function(x, callback){\\n+    callback(err, x*-1);    //<- x*-1 instead of x, turns the order around\\n+}, function(err,result){\\n+    //result callback\\n+} );\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"some\\\" />\\n+### some(arr, iterator, callback)\\n+\\n+__Alias:__ `any`\\n+\\n+Returns `true` if at least one element in the `arr` satisfies an async test.\\n+_The callback for each iterator call only accepts a single argument of `true` or\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\n+way node libraries work with truth tests like `fs.exists`. Once any iterator\\n+call returns `true`, the main `callback` is immediately called.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\n+  called with a boolean argument once it has completed.\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\n+  `true`, or after all the iterator functions have finished. Result will be\\n+  either `true` or `false` depending on the values of the async tests.\\n+\\n+__Example__\\n+\\n+```js\\n+async.some(['file1','file2','file3'], fs.exists, function(result){\\n+    // if result is true then at least one of the files exists\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"every\\\" />\\n+### every(arr, iterator, callback)\\n+\\n+__Alias:__ `all`\\n+\\n+Returns `true` if every element in `arr` satisfies an async test.\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\n+way node libraries work with truth tests like `fs.exists`.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\n+  called with a  boolean argument once it has completed.\\n+* `callback(result)` - A callback which is called after all the `iterator`\\n+  functions have finished. Result will be either `true` or `false` depending on\\n+  the values of the async tests.\\n+\\n+__Example__\\n+\\n+```js\\n+async.every(['file1','file2','file3'], fs.exists, function(result){\\n+    // if result is true then every file exists\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"concat\\\" />\\n+### concat(arr, iterator, callback)\\n+\\n+Applies `iterator` to each item in `arr`, concatenating the results. Returns the\\n+concatenated list. The `iterator`s are called in parallel, and the results are\\n+concatenated as they return. There is no guarantee that the results array will\\n+be returned in the original order of `arr` passed to the `iterator` function.\\n+\\n+__Arguments__\\n+\\n+* `arr` - An array to iterate over.\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\n+  The iterator is passed a `callback(err, results)` which must be called once it \\n+  has completed with an error (which can be `null`) and an array of results.\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\n+  functions have finished, or an error occurs. Results is an array containing\\n+  the concatenated results of the `iterator` function.\\n+\\n+__Example__\\n+\\n+```js\\n+async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files){\\n+    // files is now a list of filenames that exist in the 3 directories\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"concatSeries\\\" />\\n+### concatSeries(arr, iterator, callback)\\n+\\n+Same as [`concat`](#concat), but executes in series instead of parallel.\\n+\\n+\\n+## Control Flow\\n+\\n+<a name=\\\"series\\\" />\\n+### series(tasks, [callback])\\n+\\n+Run the functions in the `tasks` array in series, each one running once the previous\\n+function has completed. If any functions in the series pass an error to its\\n+callback, no more functions are run, and `callback` is immediately called with the value of the error. \\n+Otherwise, `callback` receives an array of results when `tasks` have completed.\\n+\\n+It is also possible to use an object instead of an array. Each property will be\\n+run as a function, and the results will be passed to the final `callback` as an object\\n+instead of an array. This can be a more readable way of handling results from\\n+[`series`](#series).\\n+\\n+**Note** that while many implementations preserve the order of object properties, the\\n+[ECMAScript Language Specifcation](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6) \\n+explicitly states that\\n+\\n+> The mechanics and order of enumerating the properties is not specified.\\n+\\n+So if you rely on the order in which your series of functions are executed, and want\\n+this to work on all platforms, consider using an array. \\n+\\n+__Arguments__\\n+\\n+* `tasks` - An array or object containing functions to run, each function is passed\\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\n+  be `null`) and an optional `result` value.\\n+* `callback(err, results)` - An optional callback to run once all the functions\\n+  have completed. This function gets a results array (or object) containing all \\n+  the result arguments passed to the `task` callbacks.\\n+\\n+__Example__\\n+\\n+```js\\n+async.series([\\n+    function(callback){\\n+        // do some stuff ...\\n+        callback(null, 'one');\\n+    },\\n+    function(callback){\\n+        // do some more stuff ...\\n+        callback(null, 'two');\\n+    }\\n+],\\n+// optional callback\\n+function(err, results){\\n+    // results is now equal to ['one', 'two']\\n+});\\n+\\n+\\n+// an example using an object instead of an array\\n+async.series({\\n+    one: function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 1);\\n+        }, 200);\\n+    },\\n+    two: function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 2);\\n+        }, 100);\\n+    }\\n+},\\n+function(err, results) {\\n+    // results is now equal to: {one: 1, two: 2}\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"parallel\\\" />\\n+### parallel(tasks, [callback])\\n+\\n+Run the `tasks` array of functions in parallel, without waiting until the previous\\n+function has completed. If any of the functions pass an error to its\\n+callback, the main `callback` is immediately called with the value of the error.\\n+Once the `tasks` have completed, the results are passed to the final `callback` as an\\n+array.\\n+\\n+It is also possible to use an object instead of an array. Each property will be\\n+run as a function and the results will be passed to the final `callback` as an object\\n+instead of an array. This can be a more readable way of handling results from\\n+[`parallel`](#parallel).\\n+\\n+\\n+__Arguments__\\n+\\n+* `tasks` - An array or object containing functions to run. Each function is passed \\n+  a `callback(err, result)` which it must call on completion with an error `err` \\n+  (which can be `null`) and an optional `result` value.\\n+* `callback(err, results)` - An optional callback to run once all the functions\\n+  have completed. This function gets a results array (or object) containing all \\n+  the result arguments passed to the task callbacks.\\n+\\n+__Example__\\n+\\n+```js\\n+async.parallel([\\n+    function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 'one');\\n+        }, 200);\\n+    },\\n+    function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 'two');\\n+        }, 100);\\n+    }\\n+],\\n+// optional callback\\n+function(err, results){\\n+    // the results array will equal ['one','two'] even though\\n+    // the second function had a shorter timeout.\\n+});\\n+\\n+\\n+// an example using an object instead of an array\\n+async.parallel({\\n+    one: function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 1);\\n+        }, 200);\\n+    },\\n+    two: function(callback){\\n+        setTimeout(function(){\\n+            callback(null, 2);\\n+        }, 100);\\n+    }\\n+},\\n+function(err, results) {\\n+    // results is now equals to: {one: 1, two: 2}\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"parallelLimit\\\" />\\n+### parallelLimit(tasks, limit, [callback])\\n+\\n+The same as [`parallel`](#parallel), only `tasks` are executed in parallel \\n+with a maximum of `limit` tasks executing at any time.\\n+\\n+Note that the `tasks` are not executed in batches, so there is no guarantee that \\n+the first `limit` tasks will complete before any others are started.\\n+\\n+__Arguments__\\n+\\n+* `tasks` - An array or object containing functions to run, each function is passed \\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\n+  be `null`) and an optional `result` value.\\n+* `limit` - The maximum number of `tasks` to run at any time.\\n+* `callback(err, results)` - An optional callback to run once all the functions\\n+  have completed. This function gets a results array (or object) containing all \\n+  the result arguments passed to the `task` callbacks.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"whilst\\\" />\\n+### whilst(test, fn, callback)\\n+\\n+Repeatedly call `fn`, while `test` returns `true`. Calls `callback` when stopped,\\n+or an error occurs.\\n+\\n+__Arguments__\\n+\\n+* `test()` - synchronous truth test to perform before each execution of `fn`.\\n+* `fn(callback)` - A function which is called each time `test` passes. The function is\\n+  passed a `callback(err)`, which must be called once it has completed with an \\n+  optional `err` argument.\\n+* `callback(err)` - A callback which is called after the test fails and repeated\\n+  execution of `fn` has stopped.\\n+\\n+__Example__\\n+\\n+```js\\n+var count = 0;\\n+\\n+async.whilst(\\n+    function () { return count < 5; },\\n+    function (callback) {\\n+        count++;\\n+        setTimeout(callback, 1000);\\n+    },\\n+    function (err) {\\n+        // 5 seconds have passed\\n+    }\\n+);\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"doWhilst\\\" />\\n+### doWhilst(fn, test, callback)\\n+\\n+The post-check version of [`whilst`](#whilst). To reflect the difference in \\n+the order of operations, the arguments `test` and `fn` are switched. \\n+\\n+`doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"until\\\" />\\n+### until(test, fn, callback)\\n+\\n+Repeatedly call `fn` until `test` returns `true`. Calls `callback` when stopped,\\n+or an error occurs.\\n+\\n+The inverse of [`whilst`](#whilst).\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"doUntil\\\" />\\n+### doUntil(fn, test, callback)\\n+\\n+Like [`doWhilst`](#doWhilst), except the `test` is inverted. Note the argument ordering differs from `until`.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"forever\\\" />\\n+### forever(fn, errback)\\n+\\n+Calls the asynchronous function `fn` with a callback parameter that allows it to\\n+call itself again, in series, indefinitely.\\n+\\n+If an error is passed to the callback then `errback` is called with the\\n+error, and execution stops, otherwise it will never be called.\\n+\\n+```js\\n+async.forever(\\n+    function(next) {\\n+        // next is suitable for passing to things that need a callback(err [, whatever]);\\n+        // it will result in this function being called again.\\n+    },\\n+    function(err) {\\n+        // if next is called with a value in its first parameter, it will appear\\n+        // in here as 'err', and execution will stop.\\n+    }\\n+);\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"waterfall\\\" />\\n+### waterfall(tasks, [callback])\\n+\\n+Runs the `tasks` array of functions in series, each passing their results to the next in\\n+the array. However, if any of the `tasks` pass an error to their own callback, the\\n+next function is not executed, and the main `callback` is immediately called with\\n+the error.\\n+\\n+__Arguments__\\n+\\n+* `tasks` - An array of functions to run, each function is passed a \\n+  `callback(err, result1, result2, ...)` it must call on completion. The first\\n+  argument is an error (which can be `null`) and any further arguments will be \\n+  passed as arguments in order to the next task.\\n+* `callback(err, [results])` - An optional callback to run once all the functions\\n+  have completed. This will be passed the results of the last task's callback.\\n+\\n+\\n+\\n+__Example__\\n+\\n+```js\\n+async.waterfall([\\n+    function(callback){\\n+        callback(null, 'one', 'two');\\n+    },\\n+    function(arg1, arg2, callback){\\n+      // arg1 now equals 'one' and arg2 now equals 'two'\\n+        callback(null, 'three');\\n+    },\\n+    function(arg1, callback){\\n+        // arg1 now equals 'three'\\n+        callback(null, 'done');\\n+    }\\n+], function (err, result) {\\n+   // result now equals 'done'    \\n+});\\n+```\\n+\\n+---------------------------------------\\n+<a name=\\\"compose\\\" />\\n+### compose(fn1, fn2...)\\n+\\n+Creates a function which is a composition of the passed asynchronous\\n+functions. Each function consumes the return value of the function that\\n+follows. Composing functions `f()`, `g()`, and `h()` would produce the result of\\n+`f(g(h()))`, only this version uses callbacks to obtain the return values.\\n+\\n+Each function is executed with the `this` binding of the composed function.\\n+\\n+__Arguments__\\n+\\n+* `functions...` - the asynchronous functions to compose\\n+\\n+\\n+__Example__\\n+\\n+```js\\n+function add1(n, callback) {\\n+    setTimeout(function () {\\n+        callback(null, n + 1);\\n+    }, 10);\\n+}\\n+\\n+function mul3(n, callback) {\\n+    setTimeout(function () {\\n+        callback(null, n * 3);\\n+    }, 10);\\n+}\\n+\\n+var add1mul3 = async.compose(mul3, add1);\\n+\\n+add1mul3(4, function (err, result) {\\n+   // result now equals 15\\n+});\\n+```\\n+\\n+---------------------------------------\\n+<a name=\\\"seq\\\" />\\n+### seq(fn1, fn2...)\\n+\\n+Version of the compose function that is more natural to read.\\n+Each following function consumes the return value of the latter function. \\n+\\n+Each function is executed with the `this` binding of the composed function.\\n+\\n+__Arguments__\\n+\\n+* functions... - the asynchronous functions to compose\\n+\\n+\\n+__Example__\\n+\\n+```js\\n+// Requires lodash (or underscore), express3 and dresende's orm2.\\n+// Part of an app, that fetches cats of the logged user.\\n+// This example uses `seq` function to avoid overnesting and error \\n+// handling clutter.\\n+app.get('/cats', function(request, response) {\\n+  function handleError(err, data, callback) {\\n+    if (err) {\\n+      console.error(err);\\n+      response.json({ status: 'error', message: err.message });\\n+    }\\n+    else {\\n+      callback(data);\\n+    }\\n+  }\\n+  var User = request.models.User;\\n+  async.seq(\\n+    _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\\n+    handleError,\\n+    function(user, fn) {\\n+      user.getCats(fn);      // 'getCats' has signature (callback(err, data))\\n+    },\\n+    handleError,\\n+    function(cats) {\\n+      response.json({ status: 'ok', message: 'Cats found', data: cats });\\n+    }\\n+  )(req.session.user_id);\\n+  }\\n+});\\n+```\\n+\\n+---------------------------------------\\n+<a name=\\\"applyEach\\\" />\\n+### applyEach(fns, args..., callback)\\n+\\n+Applies the provided arguments to each function in the array, calling \\n+`callback` after all functions have completed. If you only provide the first\\n+argument, then it will return a function which lets you pass in the\\n+arguments as if it were a single function call.\\n+\\n+__Arguments__\\n+\\n+* `fns` - the asynchronous functions to all call with the same arguments\\n+* `args...` - any number of separate arguments to pass to the function\\n+* `callback` - the final argument should be the callback, called when all\\n+  functions have completed processing\\n+\\n+\\n+__Example__\\n+\\n+```js\\n+async.applyEach([enableSearch, updateSchema], 'bucket', callback);\\n+\\n+// partial application example:\\n+async.each(\\n+    buckets,\\n+    async.applyEach([enableSearch, updateSchema]),\\n+    callback\\n+);\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"applyEachSeries\\\" />\\n+### applyEachSeries(arr, iterator, callback)\\n+\\n+The same as [`applyEach`](#applyEach) only the functions are applied in series.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"queue\\\" />\\n+### queue(worker, concurrency)\\n+\\n+Creates a `queue` object with the specified `concurrency`. Tasks added to the\\n+`queue` are processed in parallel (up to the `concurrency` limit). If all\\n+`worker`s are in progress, the task is queued until one becomes available. \\n+Once a `worker` completes a `task`, that `task`'s callback is called.\\n+\\n+__Arguments__\\n+\\n+* `worker(task, callback)` - An asynchronous function for processing a queued\\n+  task, which must call its `callback(err)` argument when finished, with an \\n+  optional `error` as an argument.\\n+* `concurrency` - An `integer` for determining how many `worker` functions should be\\n+  run in parallel.\\n+\\n+__Queue objects__\\n+\\n+The `queue` object returned by this function has the following properties and\\n+methods:\\n+\\n+* `length()` - a function returning the number of items waiting to be processed.\\n+* `started` - a function returning whether or not any items have been pushed and processed by the queue\\n+* `running()` - a function returning the number of items currently being processed.\\n+* `idle()` - a function returning false if there are items waiting or being processed, or true if not.\\n+* `concurrency` - an integer for determining how many `worker` functions should be\\n+  run in parallel. This property can be changed after a `queue` is created to\\n+  alter the concurrency on-the-fly.\\n+* `push(task, [callback])` - add a new task to the `queue`. Calls `callback` once \\n+  the `worker` has finished processing the task. Instead of a single task, a `tasks` array\\n+  can be submitted. The respective callback is used for every task in the list.\\n+* `unshift(task, [callback])` - add a new task to the front of the `queue`.\\n+* `saturated` - a callback that is called when the `queue` length hits the `concurrency` limit, \\n+   and further tasks will be queued.\\n+* `empty` - a callback that is called when the last item from the `queue` is given to a `worker`.\\n+* `drain` - a callback that is called when the last item from the `queue` has returned from the `worker`.\\n+* `paused` - a boolean for determining whether the queue is in a paused state\\n+* `pause()` - a function that pauses the processing of tasks until `resume()` is called.\\n+* `resume()` - a function that resumes the processing of queued tasks when the queue is paused.\\n+* `kill()` - a function that empties remaining tasks from the queue forcing it to go idle.\\n+\\n+__Example__\\n+\\n+```js\\n+// create a queue object with concurrency 2\\n+\\n+var q = async.queue(function (task, callback) {\\n+    console.log('hello ' + task.name);\\n+    callback();\\n+}, 2);\\n+\\n+\\n+// assign a callback\\n+q.drain = function() {\\n+    console.log('all items have been processed');\\n+}\\n+\\n+// add some items to the queue\\n+\\n+q.push({name: 'foo'}, function (err) {\\n+    console.log('finished processing foo');\\n+});\\n+q.push({name: 'bar'}, function (err) {\\n+    console.log('finished processing bar');\\n+});\\n+\\n+// add some items to the queue (batch-wise)\\n+\\n+q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function (err) {\\n+    console.log('finished processing bar');\\n+});\\n+\\n+// add some items to the front of the queue\\n+\\n+q.unshift({name: 'bar'}, function (err) {\\n+    console.log('finished processing bar');\\n+});\\n+```\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"priorityQueue\\\" />\\n+### priorityQueue(worker, concurrency)\\n+\\n+The same as [`queue`](#queue) only tasks are assigned a priority and completed in ascending priority order. There are two differences between `queue` and `priorityQueue` objects:\\n+\\n+* `push(task, priority, [callback])` - `priority` should be a number. If an array of\\n+  `tasks` is given, all tasks will be assigned the same priority.\\n+* The `unshift` method was removed.\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"cargo\\\" />\\n+### cargo(worker, [payload])\\n+\\n+Creates a `cargo` object with the specified payload. Tasks added to the\\n+cargo will be processed altogether (up to the `payload` limit). If the\\n+`worker` is in progress, the task is queued until it becomes available. Once\\n+the `worker` has completed some tasks, each callback of those tasks is called.\\n+Check out [this animation](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) for how `cargo` and `queue` work.\\n+\\n+While [queue](#queue) passes only one task to one of a group of workers\\n+at a time, cargo passes an array of tasks to a single worker, repeating\\n+when the worker is finished.\\n+\\n+__Arguments__\\n+\\n+* `worker(tasks, callback)` - An asynchronous function for processing an array of\\n+  queued tasks, which must call its `callback(err)` argument when finished, with \\n+  an optional `err` argument.\\n+* `payload` - An optional `integer` for determining how many tasks should be\\n+  processed per round; if omitted, the default is unlimited.\\n+\\n+__Cargo objects__\\n+\\n+The `cargo` object returned by this function has the following properties and\\n+methods:\\n+\\n+* `length()` - A function returning the number of items waiting to be processed.\\n+* `payload` - An `integer` for determining how many tasks should be\\n+  process per round. This property can be changed after a `cargo` is created to\\n+  alter the payload on-the-fly.\\n+* `push(task, [callback])` - Adds `task` to the `queue`. The callback is called\\n+  once the `worker` has finished processing the task. Instead of a single task, an array of `tasks` \\n+  can be submitted. The respective callback is used for every task in the list.\\n+* `saturated` - A callback that is called when the `queue.length()` hits the concurrency and further tasks will be queued.\\n+* `empty` - A callback that is called when the last item from the `queue` is given to a `worker`.\\n+* `drain` - A callback that is called when the last item from the `queue` has returned from the `worker`.\\n+\\n+__Example__\\n+\\n+```js\\n+// create a cargo object with payload 2\\n+\\n+var cargo = async.cargo(function (tasks, callback) {\\n+    for(var i=0; i<tasks.length; i++){\\n+      console.log('hello ' + tasks[i].name);\\n+    }\\n+    callback();\\n+}, 2);\\n+\\n+\\n+// add some items\\n+\\n+cargo.push({name: 'foo'}, function (err) {\\n+    console.log('finished processing foo');\\n+});\\n+cargo.push({name: 'bar'}, function (err) {\\n+    console.log('finished processing bar');\\n+});\\n+cargo.push({name: 'baz'}, function (err) {\\n+    console.log('finished processing baz');\\n+});\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"auto\\\" />\\n+### auto(tasks, [callback])\\n+\\n+Determines the best order for running the functions in `tasks`, based on their \\n+requirements. Each function can optionally depend on other functions being completed \\n+first, and each function is run as soon as its requirements are satisfied. \\n+\\n+If any of the functions pass an error to their callback, it will not \\n+complete (so any other functions depending on it will not run), and the main \\n+`callback` is immediately called with the error. Functions also receive an \\n+object containing the results of functions which have completed so far.\\n+\\n+Note, all functions are called with a `results` object as a second argument, \\n+so it is unsafe to pass functions in the `tasks` object which cannot handle the\\n+extra argument. \\n+\\n+For example, this snippet of code:\\n+\\n+```js\\n+async.auto({\\n+  readData: async.apply(fs.readFile, 'data.txt', 'utf-8')\\n+}, callback);\\n+```\\n+\\n+will have the effect of calling `readFile` with the results object as the last\\n+argument, which will fail:\\n+\\n+```js\\n+fs.readFile('data.txt', 'utf-8', cb, {});\\n+```\\n+\\n+Instead, wrap the call to `readFile` in a function which does not forward the \\n+`results` object:\\n+\\n+```js\\n+async.auto({\\n+  readData: function(cb, results){\\n+    fs.readFile('data.txt', 'utf-8', cb);\\n+  }\\n+}, callback);\\n+```\\n+\\n+__Arguments__\\n+\\n+* `tasks` - An object. Each of its properties is either a function or an array of\\n+  requirements, with the function itself the last item in the array. The object's key\\n+  of a property serves as the name of the task defined by that property,\\n+  i.e. can be used when specifying requirements for other tasks.\\n+  The function receives two arguments: (1) a `callback(err, result)` which must be \\n+  called when finished, passing an `error` (which can be `null`) and the result of \\n+  the function's execution, and (2) a `results` object, containing the results of\\n+  the previously executed functions.\\n+* `callback(err, results)` - An optional callback which is called when all the\\n+  tasks have been completed. It receives the `err` argument if any `tasks` \\n+  pass an error to their callback. Results are always returned; however, if \\n+  an error occurs, no further `tasks` will be performed, and the results\\n+  object will only contain partial results.\\n+\\n+\\n+__Example__\\n+\\n+```js\\n+async.auto({\\n+    get_data: function(callback){\\n+        console.log('in get_data');\\n+        // async code to get some data\\n+        callback(null, 'data', 'converted to array');\\n+    },\\n+    make_folder: function(callback){\\n+        console.log('in make_folder');\\n+        // async code to create a directory to store a file in\\n+        // this is run at the same time as getting the data\\n+        callback(null, 'folder');\\n+    },\\n+    write_file: ['get_data', 'make_folder', function(callback, results){\\n+        console.log('in write_file', JSON.stringify(results));\\n+        // once there is some data and the directory exists,\\n+        // write the data to a file in the directory\\n+        callback(null, 'filename');\\n+    }],\\n+    email_link: ['write_file', function(callback, results){\\n+        console.log('in email_link', JSON.stringify(results));\\n+        // once the file is written let's email a link to it...\\n+        // results.write_file contains the filename returned by write_file.\\n+        callback(null, {'file':results.write_file, 'email':'user@example.com'});\\n+    }]\\n+}, function(err, results) {\\n+    console.log('err = ', err);\\n+    console.log('results = ', results);\\n+});\\n+```\\n+\\n+This is a fairly trivial example, but to do this using the basic parallel and\\n+series functions would look like this:\\n+\\n+```js\\n+async.parallel([\\n+    function(callback){\\n+        console.log('in get_data');\\n+        // async code to get some data\\n+        callback(null, 'data', 'converted to array');\\n+    },\\n+    function(callback){\\n+        console.log('in make_folder');\\n+        // async code to create a directory to store a file in\\n+        // this is run at the same time as getting the data\\n+        callback(null, 'folder');\\n+    }\\n+],\\n+function(err, results){\\n+    async.series([\\n+        function(callback){\\n+            console.log('in write_file', JSON.stringify(results));\\n+            // once there is some data and the directory exists,\\n+            // write the data to a file in the directory\\n+            results.push('filename');\\n+            callback(null);\\n+        },\\n+        function(callback){\\n+            console.log('in email_link', JSON.stringify(results));\\n+            // once the file is written let's email a link to it...\\n+            callback(null, {'file':results.pop(), 'email':'user@example.com'});\\n+        }\\n+    ]);\\n+});\\n+```\\n+\\n+For a complicated series of `async` tasks, using the [`auto`](#auto) function makes adding\\n+new tasks much easier (and the code more readable).\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"retry\\\" />\\n+### retry([times = 5], task, [callback])\\n+\\n+Attempts to get a successful response from `task` no more than `times` times before\\n+returning an error. If the task is successful, the `callback` will be passed the result\\n+of the successfull task. If all attemps fail, the callback will be passed the error and\\n+result (if any) of the final attempt.\\n+\\n+__Arguments__\\n+\\n+* `times` - An integer indicating how many times to attempt the `task` before giving up. Defaults to 5.\\n+* `task(callback, results)` - A function which receives two arguments: (1) a `callback(err, result)`\\n+  which must be called when finished, passing `err` (which can be `null`) and the `result` of \\n+  the function's execution, and (2) a `results` object, containing the results of\\n+  the previously executed functions (if nested inside another control flow).\\n+* `callback(err, results)` - An optional callback which is called when the\\n+  task has succeeded, or after the final failed attempt. It receives the `err` and `result` arguments of the last attempt at completing the `task`.\\n+\\n+The [`retry`](#retry) function can be used as a stand-alone control flow by passing a\\n+callback, as shown below:\\n+\\n+```js\\n+async.retry(3, apiMethod, function(err, result) {\\n+    // do something with the result\\n+});\\n+```\\n+\\n+It can also be embeded within other control flow functions to retry individual methods\\n+that are not as reliable, like this:\\n+\\n+```js\\n+async.auto({\\n+    users: api.getUsers.bind(api),\\n+    payments: async.retry(3, api.getPayments.bind(api))\\n+}, function(err, results) {\\n+  // do something with the results\\n+});\\n+```\\n+\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"iterator\\\" />\\n+### iterator(tasks)\\n+\\n+Creates an iterator function which calls the next function in the `tasks` array,\\n+returning a continuation to call the next one after that. It's also possible to\\n+“peek” at the next iterator with `iterator.next()`.\\n+\\n+This function is used internally by the `async` module, but can be useful when\\n+you want to manually control the flow of functions in series.\\n+\\n+__Arguments__\\n+\\n+* `tasks` - An array of functions to run.\\n+\\n+__Example__\\n+\\n+```js\\n+var iterator = async.iterator([\\n+    function(){ sys.p('one'); },\\n+    function(){ sys.p('two'); },\\n+    function(){ sys.p('three'); }\\n+]);\\n+\\n+node> var iterator2 = iterator();\\n+'one'\\n+node> var iterator3 = iterator2();\\n+'two'\\n+node> iterator3();\\n+'three'\\n+node> var nextfn = iterator2.next();\\n+node> nextfn();\\n+'three'\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"apply\\\" />\\n+### apply(function, arguments..)\\n+\\n+Creates a continuation function with some arguments already applied. \\n+\\n+Useful as a shorthand when combined with other control flow functions. Any arguments\\n+passed to the returned function are added to the arguments originally passed\\n+to apply.\\n+\\n+__Arguments__\\n+\\n+* `function` - The function you want to eventually apply all arguments to.\\n+* `arguments...` - Any number of arguments to automatically apply when the\\n+  continuation is called.\\n+\\n+__Example__\\n+\\n+```js\\n+// using apply\\n+\\n+async.parallel([\\n+    async.apply(fs.writeFile, 'testfile1', 'test1'),\\n+    async.apply(fs.writeFile, 'testfile2', 'test2'),\\n+]);\\n+\\n+\\n+// the same process without using apply\\n+\\n+async.parallel([\\n+    function(callback){\\n+        fs.writeFile('testfile1', 'test1', callback);\\n+    },\\n+    function(callback){\\n+        fs.writeFile('testfile2', 'test2', callback);\\n+    }\\n+]);\\n+```\\n+\\n+It's possible to pass any number of additional arguments when calling the\\n+continuation:\\n+\\n+```js\\n+node> var fn = async.apply(sys.puts, 'one');\\n+node> fn('two', 'three');\\n+one\\n+two\\n+three\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"nextTick\\\" />\\n+### nextTick(callback)\\n+\\n+Calls `callback` on a later loop around the event loop. In Node.js this just\\n+calls `process.nextTick`; in the browser it falls back to `setImmediate(callback)`\\n+if available, otherwise `setTimeout(callback, 0)`, which means other higher priority\\n+events may precede the execution of `callback`.\\n+\\n+This is used internally for browser-compatibility purposes.\\n+\\n+__Arguments__\\n+\\n+* `callback` - The function to call on a later loop around the event loop.\\n+\\n+__Example__\\n+\\n+```js\\n+var call_order = [];\\n+async.nextTick(function(){\\n+    call_order.push('two');\\n+    // call_order now equals ['one','two']\\n+});\\n+call_order.push('one')\\n+```\\n+\\n+<a name=\\\"times\\\" />\\n+### times(n, callback)\\n+\\n+Calls the `callback` function `n` times, and accumulates results in the same manner\\n+you would use with [`map`](#map).\\n+\\n+__Arguments__\\n+\\n+* `n` - The number of times to run the function.\\n+* `callback` - The function to call `n` times.\\n+\\n+__Example__\\n+\\n+```js\\n+// Pretend this is some complicated async factory\\n+var createUser = function(id, callback) {\\n+  callback(null, {\\n+    id: 'user' + id\\n+  })\\n+}\\n+// generate 5 users\\n+async.times(5, function(n, next){\\n+    createUser(n, function(err, user) {\\n+      next(err, user)\\n+    })\\n+}, function(err, users) {\\n+  // we should now have 5 users\\n+});\\n+```\\n+\\n+<a name=\\\"timesSeries\\\" />\\n+### timesSeries(n, callback)\\n+\\n+The same as [`times`](#times), only the iterator is applied to each item in `arr` in\\n+series. The next `iterator` is only called once the current one has completed. \\n+The results array will be in the same order as the original.\\n+\\n+\\n+## Utils\\n+\\n+<a name=\\\"memoize\\\" />\\n+### memoize(fn, [hasher])\\n+\\n+Caches the results of an `async` function. When creating a hash to store function\\n+results against, the callback is omitted from the hash and an optional hash\\n+function can be used.\\n+\\n+The cache of results is exposed as the `memo` property of the function returned\\n+by `memoize`.\\n+\\n+__Arguments__\\n+\\n+* `fn` - The function to proxy and cache results from.\\n+* `hasher` - Tn optional function for generating a custom hash for storing\\n+  results. It has all the arguments applied to it apart from the callback, and\\n+  must be synchronous.\\n+\\n+__Example__\\n+\\n+```js\\n+var slow_fn = function (name, callback) {\\n+    // do something\\n+    callback(null, result);\\n+};\\n+var fn = async.memoize(slow_fn);\\n+\\n+// fn can now be used as if it were slow_fn\\n+fn('some name', function () {\\n+    // callback\\n+});\\n+```\\n+\\n+<a name=\\\"unmemoize\\\" />\\n+### unmemoize(fn)\\n+\\n+Undoes a [`memoize`](#memoize)d function, reverting it to the original, unmemoized\\n+form. Handy for testing.\\n+\\n+__Arguments__\\n+\\n+* `fn` - the memoized function\\n+\\n+<a name=\\\"log\\\" />\\n+### log(function, arguments)\\n+\\n+Logs the result of an `async` function to the `console`. Only works in Node.js or\\n+in browsers that support `console.log` and `console.error` (such as FF and Chrome).\\n+If multiple arguments are returned from the async function, `console.log` is\\n+called on each argument in order.\\n+\\n+__Arguments__\\n+\\n+* `function` - The function you want to eventually apply all arguments to.\\n+* `arguments...` - Any number of arguments to apply to the function.\\n+\\n+__Example__\\n+\\n+```js\\n+var hello = function(name, callback){\\n+    setTimeout(function(){\\n+        callback(null, 'hello ' + name);\\n+    }, 1000);\\n+};\\n+```\\n+```js\\n+node> async.log(hello, 'world');\\n+'hello world'\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"dir\\\" />\\n+### dir(function, arguments)\\n+\\n+Logs the result of an `async` function to the `console` using `console.dir` to\\n+display the properties of the resulting object. Only works in Node.js or\\n+in browsers that support `console.dir` and `console.error` (such as FF and Chrome).\\n+If multiple arguments are returned from the async function, `console.dir` is\\n+called on each argument in order.\\n+\\n+__Arguments__\\n+\\n+* `function` - The function you want to eventually apply all arguments to.\\n+* `arguments...` - Any number of arguments to apply to the function.\\n+\\n+__Example__\\n+\\n+```js\\n+var hello = function(name, callback){\\n+    setTimeout(function(){\\n+        callback(null, {hello: name});\\n+    }, 1000);\\n+};\\n+```\\n+```js\\n+node> async.dir(hello, 'world');\\n+{hello: 'world'}\\n+```\\n+\\n+---------------------------------------\\n+\\n+<a name=\\\"noConflict\\\" />\\n+### noConflict()\\n+\\n+Changes the value of `async` back to its original value, returning a reference to the\\n+`async` object.\\ndiff --git a/node_modules/async/component.json b/node_modules/async/component.json\\nnew file mode 100644\\nindex 0000000..bbb0115\\n--- /dev/null\\n+++ b/node_modules/async/component.json\\n@@ -0,0 +1,11 @@\\n+{\\n+  \\\"name\\\": \\\"async\\\",\\n+  \\\"repo\\\": \\\"caolan/async\\\",\\n+  \\\"description\\\": \\\"Higher-order functions and common patterns for asynchronous code\\\",\\n+  \\\"version\\\": \\\"0.1.23\\\",\\n+  \\\"keywords\\\": [],\\n+  \\\"dependencies\\\": {},\\n+  \\\"development\\\": {},\\n+  \\\"main\\\": \\\"lib/async.js\\\",\\n+  \\\"scripts\\\": [ \\\"lib/async.js\\\" ]\\n+}\\ndiff --git a/node_modules/async/lib/async.js b/node_modules/async/lib/async.js\\nnew file mode 100644\\nindex 0000000..01e8afc\\n--- /dev/null\\n+++ b/node_modules/async/lib/async.js\\n@@ -0,0 +1,1123 @@\\n+/*!\\n+ * async\\n+ * https://github.com/caolan/async\\n+ *\\n+ * Copyright 2010-2014 Caolan McMahon\\n+ * Released under the MIT license\\n+ */\\n+/*jshint onevar: false, indent:4 */\\n+/*global setImmediate: false, setTimeout: false, console: false */\\n+(function () {\\n+\\n+    var async = {};\\n+\\n+    // global on the server, window in the browser\\n+    var root, previous_async;\\n+\\n+    root = this;\\n+    if (root != null) {\\n+      previous_async = root.async;\\n+    }\\n+\\n+    async.noConflict = function () {\\n+        root.async = previous_async;\\n+        return async;\\n+    };\\n+\\n+    function only_once(fn) {\\n+        var called = false;\\n+        return function() {\\n+            if (called) throw new Error(\\\"Callback was already called.\\\");\\n+            called = true;\\n+            fn.apply(root, arguments);\\n+        }\\n+    }\\n+\\n+    //// cross-browser compatiblity functions ////\\n+\\n+    var _toString = Object.prototype.toString;\\n+\\n+    var _isArray = Array.isArray || function (obj) {\\n+        return _toString.call(obj) === '[object Array]';\\n+    };\\n+\\n+    var _each = function (arr, iterator) {\\n+        if (arr.forEach) {\\n+            return arr.forEach(iterator);\\n+        }\\n+        for (var i = 0; i < arr.length; i += 1) {\\n+            iterator(arr[i], i, arr);\\n+        }\\n+    };\\n+\\n+    var _map = function (arr, iterator) {\\n+        if (arr.map) {\\n+            return arr.map(iterator);\\n+        }\\n+        var results = [];\\n+        _each(arr, function (x, i, a) {\\n+            results.push(iterator(x, i, a));\\n+        });\\n+        return results;\\n+    };\\n+\\n+    var _reduce = function (arr, iterator, memo) {\\n+        if (arr.reduce) {\\n+            return arr.reduce(iterator, memo);\\n+        }\\n+        _each(arr, function (x, i, a) {\\n+            memo = iterator(memo, x, i, a);\\n+        });\\n+        return memo;\\n+    };\\n+\\n+    var _keys = function (obj) {\\n+        if (Object.keys) {\\n+            return Object.keys(obj);\\n+        }\\n+        var keys = [];\\n+        for (var k in obj) {\\n+            if (obj.hasOwnProperty(k)) {\\n+                keys.push(k);\\n+            }\\n+        }\\n+        return keys;\\n+    };\\n+\\n+    //// exported async module functions ////\\n+\\n+    //// nextTick implementation with browser-compatible fallback ////\\n+    if (typeof process === 'undefined' || !(process.nextTick)) {\\n+        if (typeof setImmediate === 'function') {\\n+            async.nextTick = function (fn) {\\n+                // not a direct alias for IE10 compatibility\\n+                setImmediate(fn);\\n+            };\\n+            async.setImmediate = async.nextTick;\\n+        }\\n+        else {\\n+            async.nextTick = function (fn) {\\n+                setTimeout(fn, 0);\\n+            };\\n+            async.setImmediate = async.nextTick;\\n+        }\\n+    }\\n+    else {\\n+        async.nextTick = process.nextTick;\\n+        if (typeof setImmediate !== 'undefined') {\\n+            async.setImmediate = function (fn) {\\n+              // not a direct alias for IE10 compatibility\\n+              setImmediate(fn);\\n+            };\\n+        }\\n+        else {\\n+            async.setImmediate = async.nextTick;\\n+        }\\n+    }\\n+\\n+    async.each = function (arr, iterator, callback) {\\n+        callback = callback || function () {};\\n+        if (!arr.length) {\\n+            return callback();\\n+        }\\n+        var completed = 0;\\n+        _each(arr, function (x) {\\n+            iterator(x, only_once(done) );\\n+        });\\n+        function done(err) {\\n+          if (err) {\\n+              callback(err);\\n+              callback = function () {};\\n+          }\\n+          else {\\n+              completed += 1;\\n+              if (completed >= arr.length) {\\n+                  callback();\\n+              }\\n+          }\\n+        }\\n+    };\\n+    async.forEach = async.each;\\n+\\n+    async.eachSeries = function (arr, iterator, callback) {\\n+        callback = callback || function () {};\\n+        if (!arr.length) {\\n+            return callback();\\n+        }\\n+        var completed = 0;\\n+        var iterate = function () {\\n+            iterator(arr[completed], function (err) {\\n+                if (err) {\\n+                    callback(err);\\n+                    callback = function () {};\\n+                }\\n+                else {\\n+                    completed += 1;\\n+                    if (completed >= arr.length) {\\n+                        callback();\\n+                    }\\n+                    else {\\n+                        iterate();\\n+                    }\\n+                }\\n+            });\\n+        };\\n+        iterate();\\n+    };\\n+    async.forEachSeries = async.eachSeries;\\n+\\n+    async.eachLimit = function (arr, limit, iterator, callback) {\\n+        var fn = _eachLimit(limit);\\n+        fn.apply(null, [arr, iterator, callback]);\\n+    };\\n+    async.forEachLimit = async.eachLimit;\\n+\\n+    var _eachLimit = function (limit) {\\n+\\n+        return function (arr, iterator, callback) {\\n+            callback = callback || function () {};\\n+            if (!arr.length || limit <= 0) {\\n+                return callback();\\n+            }\\n+            var completed = 0;\\n+            var started = 0;\\n+            var running = 0;\\n+\\n+            (function replenish () {\\n+                if (completed >= arr.length) {\\n+                    return callback();\\n+                }\\n+\\n+                while (running < limit && started < arr.length) {\\n+                    started += 1;\\n+                    running += 1;\\n+                    iterator(arr[started - 1], function (err) {\\n+                        if (err) {\\n+                            callback(err);\\n+                            callback = function () {};\\n+                        }\\n+                        else {\\n+                            completed += 1;\\n+                            running -= 1;\\n+                            if (completed >= arr.length) {\\n+                                callback();\\n+                            }\\n+                            else {\\n+                                replenish();\\n+                            }\\n+                        }\\n+                    });\\n+                }\\n+            })();\\n+        };\\n+    };\\n+\\n+\\n+    var doParallel = function (fn) {\\n+        return function () {\\n+            var args = Array.prototype.slice.call(arguments);\\n+            return fn.apply(null, [async.each].concat(args));\\n+        };\\n+    };\\n+    var doParallelLimit = function(limit, fn) {\\n+        return function () {\\n+            var args = Array.prototype.slice.call(arguments);\\n+            return fn.apply(null, [_eachLimit(limit)].concat(args));\\n+        };\\n+    };\\n+    var doSeries = function (fn) {\\n+        return function () {\\n+            var args = Array.prototype.slice.call(arguments);\\n+            return fn.apply(null, [async.eachSeries].concat(args));\\n+        };\\n+    };\\n+\\n+\\n+    var _asyncMap = function (eachfn, arr, iterator, callback) {\\n+        arr = _map(arr, function (x, i) {\\n+            return {index: i, value: x};\\n+        });\\n+        if (!callback) {\\n+            eachfn(arr, function (x, callback) {\\n+                iterator(x.value, function (err) {\\n+                    callback(err);\\n+                });\\n+            });\\n+        } else {\\n+            var results = [];\\n+            eachfn(arr, function (x, callback) {\\n+                iterator(x.value, function (err, v) {\\n+                    results[x.index] = v;\\n+                    callback(err);\\n+                });\\n+            }, function (err) {\\n+                callback(err, results);\\n+            });\\n+        }\\n+    };\\n+    async.map = doParallel(_asyncMap);\\n+    async.mapSeries = doSeries(_asyncMap);\\n+    async.mapLimit = function (arr, limit, iterator, callback) {\\n+        return _mapLimit(limit)(arr, iterator, callback);\\n+    };\\n+\\n+    var _mapLimit = function(limit) {\\n+        return doParallelLimit(limit, _asyncMap);\\n+    };\\n+\\n+    // reduce only has a series version, as doing reduce in parallel won't\\n+    // work in many situations.\\n+    async.reduce = function (arr, memo, iterator, callback) {\\n+        async.eachSeries(arr, function (x, callback) {\\n+            iterator(memo, x, function (err, v) {\\n+                memo = v;\\n+                callback(err);\\n+            });\\n+        }, function (err) {\\n+            callback(err, memo);\\n+        });\\n+    };\\n+    // inject alias\\n+    async.inject = async.reduce;\\n+    // foldl alias\\n+    async.foldl = async.reduce;\\n+\\n+    async.reduceRight = function (arr, memo, iterator, callback) {\\n+        var reversed = _map(arr, function (x) {\\n+            return x;\\n+        }).reverse();\\n+        async.reduce(reversed, memo, iterator, callback);\\n+    };\\n+    // foldr alias\\n+    async.foldr = async.reduceRight;\\n+\\n+    var _filter = function (eachfn, arr, iterator, callback) {\\n+        var results = [];\\n+        arr = _map(arr, function (x, i) {\\n+            return {index: i, value: x};\\n+        });\\n+        eachfn(arr, function (x, callback) {\\n+            iterator(x.value, function (v) {\\n+                if (v) {\\n+                    results.push(x);\\n+                }\\n+                callback();\\n+            });\\n+        }, function (err) {\\n+            callback(_map(results.sort(function (a, b) {\\n+                return a.index - b.index;\\n+            }), function (x) {\\n+                return x.value;\\n+            }));\\n+        });\\n+    };\\n+    async.filter = doParallel(_filter);\\n+    async.filterSeries = doSeries(_filter);\\n+    // select alias\\n+    async.select = async.filter;\\n+    async.selectSeries = async.filterSeries;\\n+\\n+    var _reject = function (eachfn, arr, iterator, callback) {\\n+        var results = [];\\n+        arr = _map(arr, function (x, i) {\\n+            return {index: i, value: x};\\n+        });\\n+        eachfn(arr, function (x, callback) {\\n+            iterator(x.value, function (v) {\\n+                if (!v) {\\n+                    results.push(x);\\n+                }\\n+                callback();\\n+            });\\n+        }, function (err) {\\n+            callback(_map(results.sort(function (a, b) {\\n+                return a.index - b.index;\\n+            }), function (x) {\\n+                return x.value;\\n+            }));\\n+        });\\n+    };\\n+    async.reject = doParallel(_reject);\\n+    async.rejectSeries = doSeries(_reject);\\n+\\n+    var _detect = function (eachfn, arr, iterator, main_callback) {\\n+        eachfn(arr, function (x, callback) {\\n+            iterator(x, function (result) {\\n+                if (result) {\\n+                    main_callback(x);\\n+                    main_callback = function () {};\\n+                }\\n+                else {\\n+                    callback();\\n+                }\\n+            });\\n+        }, function (err) {\\n+            main_callback();\\n+        });\\n+    };\\n+    async.detect = doParallel(_detect);\\n+    async.detectSeries = doSeries(_detect);\\n+\\n+    async.some = function (arr, iterator, main_callback) {\\n+        async.each(arr, function (x, callback) {\\n+            iterator(x, function (v) {\\n+                if (v) {\\n+                    main_callback(true);\\n+                    main_callback = function () {};\\n+                }\\n+                callback();\\n+            });\\n+        }, function (err) {\\n+            main_callback(false);\\n+        });\\n+    };\\n+    // any alias\\n+    async.any = async.some;\\n+\\n+    async.every = function (arr, iterator, main_callback) {\\n+        async.each(arr, function (x, callback) {\\n+            iterator(x, function (v) {\\n+                if (!v) {\\n+                    main_callback(false);\\n+                    main_callback = function () {};\\n+                }\\n+                callback();\\n+            });\\n+        }, function (err) {\\n+            main_callback(true);\\n+        });\\n+    };\\n+    // all alias\\n+    async.all = async.every;\\n+\\n+    async.sortBy = function (arr, iterator, callback) {\\n+        async.map(arr, function (x, callback) {\\n+            iterator(x, function (err, criteria) {\\n+                if (err) {\\n+                    callback(err);\\n+                }\\n+                else {\\n+                    callback(null, {value: x, criteria: criteria});\\n+                }\\n+            });\\n+        }, function (err, results) {\\n+            if (err) {\\n+                return callback(err);\\n+            }\\n+            else {\\n+                var fn = function (left, right) {\\n+                    var a = left.criteria, b = right.criteria;\\n+                    return a < b ? -1 : a > b ? 1 : 0;\\n+                };\\n+                callback(null, _map(results.sort(fn), function (x) {\\n+                    return x.value;\\n+                }));\\n+            }\\n+        });\\n+    };\\n+\\n+    async.auto = function (tasks, callback) {\\n+        callback = callback || function () {};\\n+        var keys = _keys(tasks);\\n+        var remainingTasks = keys.length\\n+        if (!remainingTasks) {\\n+            return callback();\\n+        }\\n+\\n+        var results = {};\\n+\\n+        var listeners = [];\\n+        var addListener = function (fn) {\\n+            listeners.unshift(fn);\\n+        };\\n+        var removeListener = function (fn) {\\n+            for (var i = 0; i < listeners.length; i += 1) {\\n+                if (listeners[i] === fn) {\\n+                    listeners.splice(i, 1);\\n+                    return;\\n+                }\\n+            }\\n+        };\\n+        var taskComplete = function () {\\n+            remainingTasks--\\n+            _each(listeners.slice(0), function (fn) {\\n+                fn();\\n+            });\\n+        };\\n+\\n+        addListener(function () {\\n+            if (!remainingTasks) {\\n+                var theCallback = callback;\\n+                // prevent final callback from calling itself if it errors\\n+                callback = function () {};\\n+\\n+                theCallback(null, results);\\n+            }\\n+        });\\n+\\n+        _each(keys, function (k) {\\n+            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\\n+            var taskCallback = function (err) {\\n+                var args = Array.prototype.slice.call(arguments, 1);\\n+                if (args.length <= 1) {\\n+                    args = args[0];\\n+                }\\n+                if (err) {\\n+                    var safeResults = {};\\n+                    _each(_keys(results), function(rkey) {\\n+                        safeResults[rkey] = results[rkey];\\n+                    });\\n+                    safeResults[k] = args;\\n+                    callback(err, safeResults);\\n+                    // stop subsequent errors hitting callback multiple times\\n+                    callback = function () {};\\n+                }\\n+                else {\\n+                    results[k] = args;\\n+                    async.setImmediate(taskComplete);\\n+                }\\n+            };\\n+            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\\n+            var ready = function () {\\n+                return _reduce(requires, function (a, x) {\\n+                    return (a && results.hasOwnProperty(x));\\n+                }, true) && !results.hasOwnProperty(k);\\n+            };\\n+            if (ready()) {\\n+                task[task.length - 1](taskCallback, results);\\n+            }\\n+            else {\\n+                var listener = function () {\\n+                    if (ready()) {\\n+                        removeListener(listener);\\n+                        task[task.length - 1](taskCallback, results);\\n+                    }\\n+                };\\n+                addListener(listener);\\n+            }\\n+        });\\n+    };\\n+\\n+    async.retry = function(times, task, callback) {\\n+        var DEFAULT_TIMES = 5;\\n+        var attempts = [];\\n+        // Use defaults if times not passed\\n+        if (typeof times === 'function') {\\n+            callback = task;\\n+            task = times;\\n+            times = DEFAULT_TIMES;\\n+        }\\n+        // Make sure times is a number\\n+        times = parseInt(times, 10) || DEFAULT_TIMES;\\n+        var wrappedTask = function(wrappedCallback, wrappedResults) {\\n+            var retryAttempt = function(task, finalAttempt) {\\n+                return function(seriesCallback) {\\n+                    task(function(err, result){\\n+                        seriesCallback(!err || finalAttempt, {err: err, result: result});\\n+                    }, wrappedResults);\\n+                };\\n+            };\\n+            while (times) {\\n+                attempts.push(retryAttempt(task, !(times-=1)));\\n+            }\\n+            async.series(attempts, function(done, data){\\n+                data = data[data.length - 1];\\n+                (wrappedCallback || callback)(data.err, data.result);\\n+            });\\n+        }\\n+        // If a callback is passed, run this as a controll flow\\n+        return callback ? wrappedTask() : wrappedTask\\n+    };\\n+\\n+    async.waterfall = function (tasks, callback) {\\n+        callback = callback || function () {};\\n+        if (!_isArray(tasks)) {\\n+          var err = new Error('First argument to waterfall must be an array of functions');\\n+          return callback(err);\\n+        }\\n+        if (!tasks.length) {\\n+            return callback();\\n+        }\\n+        var wrapIterator = function (iterator) {\\n+            return function (err) {\\n+                if (err) {\\n+                    callback.apply(null, arguments);\\n+                    callback = function () {};\\n+                }\\n+                else {\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\n+                    var next = iterator.next();\\n+                    if (next) {\\n+                        args.push(wrapIterator(next));\\n+                    }\\n+                    else {\\n+                        args.push(callback);\\n+                    }\\n+                    async.setImmediate(function () {\\n+                        iterator.apply(null, args);\\n+                    });\\n+                }\\n+            };\\n+        };\\n+        wrapIterator(async.iterator(tasks))();\\n+    };\\n+\\n+    var _parallel = function(eachfn, tasks, callback) {\\n+        callback = callback || function () {};\\n+        if (_isArray(tasks)) {\\n+            eachfn.map(tasks, function (fn, callback) {\\n+                if (fn) {\\n+                    fn(function (err) {\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\n+                        if (args.length <= 1) {\\n+                            args = args[0];\\n+                        }\\n+                        callback.call(null, err, args);\\n+                    });\\n+                }\\n+            }, callback);\\n+        }\\n+        else {\\n+            var results = {};\\n+            eachfn.each(_keys(tasks), function (k, callback) {\\n+                tasks[k](function (err) {\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\n+                    if (args.length <= 1) {\\n+                        args = args[0];\\n+                    }\\n+                    results[k] = args;\\n+                    callback(err);\\n+                });\\n+            }, function (err) {\\n+                callback(err, results);\\n+            });\\n+        }\\n+    };\\n+\\n+    async.parallel = function (tasks, callback) {\\n+        _parallel({ map: async.map, each: async.each }, tasks, callback);\\n+    };\\n+\\n+    async.parallelLimit = function(tasks, limit, callback) {\\n+        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\\n+    };\\n+\\n+    async.series = function (tasks, callback) {\\n+        callback = callback || function () {};\\n+        if (_isArray(tasks)) {\\n+            async.mapSeries(tasks, function (fn, callback) {\\n+                if (fn) {\\n+                    fn(function (err) {\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\n+                        if (args.length <= 1) {\\n+                            args = args[0];\\n+                        }\\n+                        callback.call(null, err, args);\\n+                    });\\n+                }\\n+            }, callback);\\n+        }\\n+        else {\\n+            var results = {};\\n+            async.eachSeries(_keys(tasks), function (k, callback) {\\n+                tasks[k](function (err) {\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\n+                    if (args.length <= 1) {\\n+                        args = args[0];\\n+                    }\\n+                    results[k] = args;\\n+                    callback(err);\\n+                });\\n+            }, function (err) {\\n+                callback(err, results);\\n+            });\\n+        }\\n+    };\\n+\\n+    async.iterator = function (tasks) {\\n+        var makeCallback = function (index) {\\n+            var fn = function () {\\n+                if (tasks.length) {\\n+                    tasks[index].apply(null, arguments);\\n+                }\\n+                return fn.next();\\n+            };\\n+            fn.next = function () {\\n+                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\\n+            };\\n+            return fn;\\n+        };\\n+        return makeCallback(0);\\n+    };\\n+\\n+    async.apply = function (fn) {\\n+        var args = Array.prototype.slice.call(arguments, 1);\\n+        return function () {\\n+            return fn.apply(\\n+                null, args.concat(Array.prototype.slice.call(arguments))\\n+            );\\n+        };\\n+    };\\n+\\n+    var _concat = function (eachfn, arr, fn, callback) {\\n+        var r = [];\\n+        eachfn(arr, function (x, cb) {\\n+            fn(x, function (err, y) {\\n+                r = r.concat(y || []);\\n+                cb(err);\\n+            });\\n+        }, function (err) {\\n+            callback(err, r);\\n+        });\\n+    };\\n+    async.concat = doParallel(_concat);\\n+    async.concatSeries = doSeries(_concat);\\n+\\n+    async.whilst = function (test, iterator, callback) {\\n+        if (test()) {\\n+            iterator(function (err) {\\n+                if (err) {\\n+                    return callback(err);\\n+                }\\n+                async.whilst(test, iterator, callback);\\n+            });\\n+        }\\n+        else {\\n+            callback();\\n+        }\\n+    };\\n+\\n+    async.doWhilst = function (iterator, test, callback) {\\n+        iterator(function (err) {\\n+            if (err) {\\n+                return callback(err);\\n+            }\\n+            var args = Array.prototype.slice.call(arguments, 1);\\n+            if (test.apply(null, args)) {\\n+                async.doWhilst(iterator, test, callback);\\n+            }\\n+            else {\\n+                callback();\\n+            }\\n+        });\\n+    };\\n+\\n+    async.until = function (test, iterator, callback) {\\n+        if (!test()) {\\n+            iterator(function (err) {\\n+                if (err) {\\n+                    return callback(err);\\n+                }\\n+                async.until(test, iterator, callback);\\n+            });\\n+        }\\n+        else {\\n+            callback();\\n+        }\\n+    };\\n+\\n+    async.doUntil = function (iterator, test, callback) {\\n+        iterator(function (err) {\\n+            if (err) {\\n+                return callback(err);\\n+            }\\n+            var args = Array.prototype.slice.call(arguments, 1);\\n+            if (!test.apply(null, args)) {\\n+                async.doUntil(iterator, test, callback);\\n+            }\\n+            else {\\n+                callback();\\n+            }\\n+        });\\n+    };\\n+\\n+    async.queue = function (worker, concurrency) {\\n+        if (concurrency === undefined) {\\n+            concurrency = 1;\\n+        }\\n+        function _insert(q, data, pos, callback) {\\n+          if (!q.started){\\n+            q.started = true;\\n+          }\\n+          if (!_isArray(data)) {\\n+              data = [data];\\n+          }\\n+          if(data.length == 0) {\\n+             // call drain immediately if there are no tasks\\n+             return async.setImmediate(function() {\\n+                 if (q.drain) {\\n+                     q.drain();\\n+                 }\\n+             });\\n+          }\\n+          _each(data, function(task) {\\n+              var item = {\\n+                  data: task,\\n+                  callback: typeof callback === 'function' ? callback : null\\n+              };\\n+\\n+              if (pos) {\\n+                q.tasks.unshift(item);\\n+              } else {\\n+                q.tasks.push(item);\\n+              }\\n+\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\n+                  q.saturated();\\n+              }\\n+              async.setImmediate(q.process);\\n+          });\\n+        }\\n+\\n+        var workers = 0;\\n+        var q = {\\n+            tasks: [],\\n+            concurrency: concurrency,\\n+            saturated: null,\\n+            empty: null,\\n+            drain: null,\\n+            started: false,\\n+            paused: false,\\n+            push: function (data, callback) {\\n+              _insert(q, data, false, callback);\\n+            },\\n+            kill: function () {\\n+              q.drain = null;\\n+              q.tasks = [];\\n+            },\\n+            unshift: function (data, callback) {\\n+              _insert(q, data, true, callback);\\n+            },\\n+            process: function () {\\n+                if (!q.paused && workers < q.concurrency && q.tasks.length) {\\n+                    var task = q.tasks.shift();\\n+                    if (q.empty && q.tasks.length === 0) {\\n+                        q.empty();\\n+                    }\\n+                    workers += 1;\\n+                    var next = function () {\\n+                        workers -= 1;\\n+                        if (task.callback) {\\n+                            task.callback.apply(task, arguments);\\n+                        }\\n+                        if (q.drain && q.tasks.length + workers === 0) {\\n+                            q.drain();\\n+                        }\\n+                        q.process();\\n+                    };\\n+                    var cb = only_once(next);\\n+                    worker(task.data, cb);\\n+                }\\n+            },\\n+            length: function () {\\n+                return q.tasks.length;\\n+            },\\n+            running: function () {\\n+                return workers;\\n+            },\\n+            idle: function() {\\n+                return q.tasks.length + workers === 0;\\n+            },\\n+            pause: function () {\\n+                if (q.paused === true) { return; }\\n+                q.paused = true;\\n+                q.process();\\n+            },\\n+            resume: function () {\\n+                if (q.paused === false) { return; }\\n+                q.paused = false;\\n+                q.process();\\n+            }\\n+        };\\n+        return q;\\n+    };\\n+    \\n+    async.priorityQueue = function (worker, concurrency) {\\n+        \\n+        function _compareTasks(a, b){\\n+          return a.priority - b.priority;\\n+        };\\n+        \\n+        function _binarySearch(sequence, item, compare) {\\n+          var beg = -1,\\n+              end = sequence.length - 1;\\n+          while (beg < end) {\\n+            var mid = beg + ((end - beg + 1) >>> 1);\\n+            if (compare(item, sequence[mid]) >= 0) {\\n+              beg = mid;\\n+            } else {\\n+              end = mid - 1;\\n+            }\\n+          }\\n+          return beg;\\n+        }\\n+        \\n+        function _insert(q, data, priority, callback) {\\n+          if (!q.started){\\n+            q.started = true;\\n+          }\\n+          if (!_isArray(data)) {\\n+              data = [data];\\n+          }\\n+          if(data.length == 0) {\\n+             // call drain immediately if there are no tasks\\n+             return async.setImmediate(function() {\\n+                 if (q.drain) {\\n+                     q.drain();\\n+                 }\\n+             });\\n+          }\\n+          _each(data, function(task) {\\n+              var item = {\\n+                  data: task,\\n+                  priority: priority,\\n+                  callback: typeof callback === 'function' ? callback : null\\n+              };\\n+              \\n+              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\\n+\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\n+                  q.saturated();\\n+              }\\n+              async.setImmediate(q.process);\\n+          });\\n+        }\\n+        \\n+        // Start with a normal queue\\n+        var q = async.queue(worker, concurrency);\\n+        \\n+        // Override push to accept second parameter representing priority\\n+        q.push = function (data, priority, callback) {\\n+          _insert(q, data, priority, callback);\\n+        };\\n+        \\n+        // Remove unshift function\\n+        delete q.unshift;\\n+\\n+        return q;\\n+    };\\n+\\n+    async.cargo = function (worker, payload) {\\n+        var working     = false,\\n+            tasks       = [];\\n+\\n+        var cargo = {\\n+            tasks: tasks,\\n+            payload: payload,\\n+            saturated: null,\\n+            empty: null,\\n+            drain: null,\\n+            drained: true,\\n+            push: function (data, callback) {\\n+                if (!_isArray(data)) {\\n+                    data = [data];\\n+                }\\n+                _each(data, function(task) {\\n+                    tasks.push({\\n+                        data: task,\\n+                        callback: typeof callback === 'function' ? callback : null\\n+                    });\\n+                    cargo.drained = false;\\n+                    if (cargo.saturated && tasks.length === payload) {\\n+                        cargo.saturated();\\n+                    }\\n+                });\\n+                async.setImmediate(cargo.process);\\n+            },\\n+            process: function process() {\\n+                if (working) return;\\n+                if (tasks.length === 0) {\\n+                    if(cargo.drain && !cargo.drained) cargo.drain();\\n+                    cargo.drained = true;\\n+                    return;\\n+                }\\n+\\n+                var ts = typeof payload === 'number'\\n+                            ? tasks.splice(0, payload)\\n+                            : tasks.splice(0, tasks.length);\\n+\\n+                var ds = _map(ts, function (task) {\\n+                    return task.data;\\n+                });\\n+\\n+                if(cargo.empty) cargo.empty();\\n+                working = true;\\n+                worker(ds, function () {\\n+                    working = false;\\n+\\n+                    var args = arguments;\\n+                    _each(ts, function (data) {\\n+                        if (data.callback) {\\n+                            data.callback.apply(null, args);\\n+                        }\\n+                    });\\n+\\n+                    process();\\n+                });\\n+            },\\n+            length: function () {\\n+                return tasks.length;\\n+            },\\n+            running: function () {\\n+                return working;\\n+            }\\n+        };\\n+        return cargo;\\n+    };\\n+\\n+    var _console_fn = function (name) {\\n+        return function (fn) {\\n+            var args = Array.prototype.slice.call(arguments, 1);\\n+            fn.apply(null, args.concat([function (err) {\\n+                var args = Array.prototype.slice.call(arguments, 1);\\n+                if (typeof console !== 'undefined') {\\n+                    if (err) {\\n+                        if (console.error) {\\n+                            console.error(err);\\n+                        }\\n+                    }\\n+                    else if (console[name]) {\\n+                        _each(args, function (x) {\\n+                            console[name](x);\\n+                        });\\n+                    }\\n+                }\\n+            }]));\\n+        };\\n+    };\\n+    async.log = _console_fn('log');\\n+    async.dir = _console_fn('dir');\\n+    /*async.info = _console_fn('info');\\n+    async.warn = _console_fn('warn');\\n+    async.error = _console_fn('error');*/\\n+\\n+    async.memoize = function (fn, hasher) {\\n+        var memo = {};\\n+        var queues = {};\\n+        hasher = hasher || function (x) {\\n+            return x;\\n+        };\\n+        var memoized = function () {\\n+            var args = Array.prototype.slice.call(arguments);\\n+            var callback = args.pop();\\n+            var key = hasher.apply(null, args);\\n+            if (key in memo) {\\n+                async.nextTick(function () {\\n+                    callback.apply(null, memo[key]);\\n+                });\\n+            }\\n+            else if (key in queues) {\\n+                queues[key].push(callback);\\n+            }\\n+            else {\\n+                queues[key] = [callback];\\n+                fn.apply(null, args.concat([function () {\\n+                    memo[key] = arguments;\\n+                    var q = queues[key];\\n+                    delete queues[key];\\n+                    for (var i = 0, l = q.length; i < l; i++) {\\n+                      q[i].apply(null, arguments);\\n+                    }\\n+                }]));\\n+            }\\n+        };\\n+        memoized.memo = memo;\\n+        memoized.unmemoized = fn;\\n+        return memoized;\\n+    };\\n+\\n+    async.unmemoize = function (fn) {\\n+      return function () {\\n+        return (fn.unmemoized || fn).apply(null, arguments);\\n+      };\\n+    };\\n+\\n+    async.times = function (count, iterator, callback) {\\n+        var counter = [];\\n+        for (var i = 0; i < count; i++) {\\n+            counter.push(i);\\n+        }\\n+        return async.map(counter, iterator, callback);\\n+    };\\n+\\n+    async.timesSeries = function (count, iterator, callback) {\\n+        var counter = [];\\n+        for (var i = 0; i < count; i++) {\\n+            counter.push(i);\\n+        }\\n+        return async.mapSeries(counter, iterator, callback);\\n+    };\\n+\\n+    async.seq = function (/* functions... */) {\\n+        var fns = arguments;\\n+        return function () {\\n+            var that = this;\\n+            var args = Array.prototype.slice.call(arguments);\\n+            var callback = args.pop();\\n+            async.reduce(fns, args, function (newargs, fn, cb) {\\n+                fn.apply(that, newargs.concat([function () {\\n+                    var err = arguments[0];\\n+                    var nextargs = Array.prototype.slice.call(arguments, 1);\\n+                    cb(err, nextargs);\\n+                }]))\\n+            },\\n+            function (err, results) {\\n+                callback.apply(that, [err].concat(results));\\n+            });\\n+        };\\n+    };\\n+\\n+    async.compose = function (/* functions... */) {\\n+      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\\n+    };\\n+\\n+    var _applyEach = function (eachfn, fns /*args...*/) {\\n+        var go = function () {\\n+            var that = this;\\n+            var args = Array.prototype.slice.call(arguments);\\n+            var callback = args.pop();\\n+            return eachfn(fns, function (fn, cb) {\\n+                fn.apply(that, args.concat([cb]));\\n+            },\\n+            callback);\\n+        };\\n+        if (arguments.length > 2) {\\n+            var args = Array.prototype.slice.call(arguments, 2);\\n+            return go.apply(this, args);\\n+        }\\n+        else {\\n+            return go;\\n+        }\\n+    };\\n+    async.applyEach = doParallel(_applyEach);\\n+    async.applyEachSeries = doSeries(_applyEach);\\n+\\n+    async.forever = function (fn, callback) {\\n+        function next(err) {\\n+            if (err) {\\n+                if (callback) {\\n+                    return callback(err);\\n+                }\\n+                throw err;\\n+            }\\n+            fn(next);\\n+        }\\n+        next();\\n+    };\\n+\\n+    // Node.js\\n+    if (typeof module !== 'undefined' && module.exports) {\\n+        module.exports = async;\\n+    }\\n+    // AMD / RequireJS\\n+    else if (typeof define !== 'undefined' && define.amd) {\\n+        define([], function () {\\n+            return async;\\n+        });\\n+    }\\n+    // included directly via <script> tag\\n+    else {\\n+        root.async = async;\\n+    }\\n+\\n+}());\\ndiff --git a/node_modules/async/package.json b/node_modules/async/package.json\\nnew file mode 100644\\nindex 0000000..31a5200\\n--- /dev/null\\n+++ b/node_modules/async/package.json\\n@@ -0,0 +1,59 @@\\n+{\\n+  \\\"name\\\": \\\"async\\\",\\n+  \\\"description\\\": \\\"Higher-order functions and common patterns for asynchronous code\\\",\\n+  \\\"main\\\": \\\"./lib/async\\\",\\n+  \\\"author\\\": {\\n+    \\\"name\\\": \\\"Caolan McMahon\\\"\\n+  },\\n+  \\\"version\\\": \\\"0.9.0\\\",\\n+  \\\"repository\\\": {\\n+    \\\"type\\\": \\\"git\\\",\\n+    \\\"url\\\": \\\"https://github.com/caolan/async.git\\\"\\n+  },\\n+  \\\"bugs\\\": {\\n+    \\\"url\\\": \\\"https://github.com/caolan/async/issues\\\"\\n+  },\\n+  \\\"licenses\\\": [\\n+    {\\n+      \\\"type\\\": \\\"MIT\\\",\\n+      \\\"url\\\": \\\"https://github.com/caolan/async/raw/master/LICENSE\\\"\\n+    }\\n+  ],\\n+  \\\"devDependencies\\\": {\\n+    \\\"nodeunit\\\": \\\">0.0.0\\\",\\n+    \\\"uglify-js\\\": \\\"1.2.x\\\",\\n+    \\\"nodelint\\\": \\\">0.0.0\\\"\\n+  },\\n+  \\\"jam\\\": {\\n+    \\\"main\\\": \\\"lib/async.js\\\",\\n+    \\\"include\\\": [\\n+      \\\"lib/async.js\\\",\\n+      \\\"README.md\\\",\\n+      \\\"LICENSE\\\"\\n+    ]\\n+  },\\n+  \\\"scripts\\\": {\\n+    \\\"test\\\": \\\"nodeunit test/test-async.js\\\"\\n+  },\\n+  \\\"homepage\\\": \\\"https://github.com/caolan/async\\\",\\n+  \\\"_id\\\": \\\"async@0.9.0\\\",\\n+  \\\"dist\\\": {\\n+    \\\"shasum\\\": \\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\",\\n+    \\\"tarball\\\": \\\"http://registry.npmjs.org/async/-/async-0.9.0.tgz\\\"\\n+  },\\n+  \\\"_from\\\": \\\"async@*\\\",\\n+  \\\"_npmVersion\\\": \\\"1.4.3\\\",\\n+  \\\"_npmUser\\\": {\\n+    \\\"name\\\": \\\"caolan\\\",\\n+    \\\"email\\\": \\\"caolan.mcmahon@gmail.com\\\"\\n+  },\\n+  \\\"maintainers\\\": [\\n+    {\\n+      \\\"name\\\": \\\"caolan\\\",\\n+      \\\"email\\\": \\\"caolan@caolanmcmahon.com\\\"\\n+    }\\n+  ],\\n+  \\\"directories\\\": {},\\n+  \\\"_shasum\\\": \\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\",\\n+  \\\"_resolved\\\": \\\"https://registry.npmjs.org/async/-/async-0.9.0.tgz\\\"\\n+}\\ndiff --git a/package.json b/package.json\\nindex 5f21627..6033d43 100644\\n--- a/package.json\\n+++ b/package.json\\n@@ -4,7 +4,8 @@\\n   \\\"description\\\": \\\"Sous project\\\",\\n   \\\"main\\\": \\\"main.js\\\",\\n   \\\"dependencies\\\": {\\n-},\\n+    \\\"async\\\": \\\"*\\\"\\n+  },\\n   \\\"devDependencies\\\": {},\\n   \\\"scripts\\\": {\\n     \\\"test\\\": \\\"echo \\\\\\\"Error: no test specified\\\\\\\" && exit 1\\\"\\ndiff --git a/patches.sousp b/patches.sousp\\nindex 16405a3..d71e511 100644\\n--- a/patches.sousp\\n+++ b/patches.sousp\\n@@ -1,31 +1 @@\\n-diff --git a/main.js b/main.js\\n-index f81b54e..744cdd5 100644\\n---- a/main.js\\n-+++ b/main.js\\n-@@ -35,7 +35,7 @@ fs.exists('.git', function (exists) {\\n-         cp.exec('git diff', function(error, stdout, stderr) {\\n-             console.log(stdout);\\n- \\n--            //fs.writeFileSync(\\\"patches.sousp\\\", stdout);\\n-+            fs.writeFileSync(\\\"patches.sousp\\\", stdout);\\n- \\n-             if (error !== null) {\\n-                 console.log('stderr: ' + stderr);\\n-@@ -44,7 +44,7 @@ fs.exists('.git', function (exists) {\\n-         });\\n- \\n-         cp.exec('git log', function(error, stdout, stderr) {\\n--            //console.log(stdout);\\n-+            console.log(stdout);\\n- \\n-             var authors = findData(stdout, \\\"Author:\\\");\\n-             var dates = findData(stdout, \\\"Date:\\\");\\n-@@ -53,7 +53,7 @@ fs.exists('.git', function (exists) {\\n-             console.log(comments);\\n-             console.log(dates);\\n- \\n--            //fs.writeFileSync(\\\"comments.sousc\\\", stdout);\\n-+            fs.writeFileSync(\\\"comments.sousc\\\", stdout);\\n- \\n-             if (error !== null) {\\n-                 console.log('stderr: ' + stderr);\\n+[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]\\n\\\\ No newline at end of file\\ndiff --git a/test.js b/test.js\\nnew file mode 100644\\nindex 0000000..5ca759c\\n--- /dev/null\\n+++ b/test.js\\n@@ -0,0 +1,21 @@\\n+/**\\n+ * Created by Nick on 18.05.2015.\\n+ */\\n+var async = require('async')\\n+    , tasksIndex = [\\n+        function (callback) {\\n+            // Вымышленный метод который вернет 231\\n+            var viewsNumber = models.stat.viewsNumber();\\n+            callback(null, viewsNumber);\\n+        }\\n+        , function (callback) {\\n+            // Вымышленный метод который вернет 24\\n+            var growFactor = models.stat.growFactor();\\n+            callback(null, growFactor);\\n+        }\\n+    ];\\n+\\n+async.series(tasksIndex, function (err, results) {\\n+    // Результат будет массивом\\n+    console.log(results); // [231, 24]\\n+});\\n\\\\ No newline at end of file\\n\"},{\"commit\":\"dbe72b9889081e5856c1e2d72723e8ab2dc898bd\",\"author\":\"Nick Stepanenko <massaalonso@yandex.ru>\",\"date\":\"Tue May 19 01:41:21 2015 +0800\",\"comment\":\"Content will be added now.\",\"content\":\"diff --git a/main.js b/main.js\\nindex 86f30c2..ca7473f 100644\\n--- a/main.js\\n+++ b/main.js\\n@@ -148,7 +148,9 @@ fs.exists('.git', function (exists) {\\n                         listOfCommits[listOfCommits.length] = commit;\\n                     }\\n \\n-                    callback(null, listOfCommits.reverse());\\n+                    var commitsData = listOfCommits.reverse();\\n+\\n+                    callback(null, commitsData);\\n \\n                     if (error !== null) {\\n                         console.log('stderr: ' + stderr);\\n@@ -157,27 +159,18 @@ fs.exists('.git', function (exists) {\\n                 });\\n             },\\n             function getCommitsContent(commits, callback) {\\n-                console.log(commits);\\n                 var commitsData = commits;\\n \\n                 for(i=1; i<commitsData.length; i++) {\\n-                    cp.exec('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit, function(error, stdout, stderr) {\\n-                        commitsData[i].content = stdout;\\n-\\n-                        if (error !== null) {\\n-                            console.log('stderr: ' + stderr);\\n-                            console.log('exec error: ' + error);\\n-                        }\\n-                    });\\n+                    commitsData[i].content = cp.execSync('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit).toString('utf8');\\n                 }\\n \\n                 callback(null, commitsData);\\n             }\\n         ], function (err, result) {\\n-            fs.writeFileSync(\\\"patches.sousp\\\", result);\\n+            for(i=0; i<result.length; i++) {\\n+                fs.writeFileSync(\\\"patches.sousp\\\", JSON.stringify(result[i]));\\n+            }\\n         });\\n-\\n-        //commitsInfo = JSON.parse(fs.readFileSync(\\\"patches.sousp\\\"));\\n-        //console.log(commitsInfo);\\n     }\\n });\\n\\\\ No newline at end of file\\ndiff --git a/patches.sousp b/patches.sousp\\nindex d71e511..300c6a9 100644\\n--- a/patches.sousp\\n+++ b/patches.sousp\\n@@ -1 +1 @@\\n-[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]\\n\\\\ No newline at end of file\\n+{\\\"commit\\\":\\\"1e947f613e976945de85ae35ed923aa470f0be72\\\",\\\"author\\\":\\\"Nick Stepanenko <massaalonso@yandex.ru>\\\",\\\"date\\\":\\\"Tue May 19 00:12:12 2015 +0800\\\",\\\"comment\\\":\\\"Latest updates\\\",\\\"content\\\":\\\"diff --git a/comments.sousc b/comments.sousc\\\\nindex 150b0f6..cb3a850 100644\\\\n--- a/comments.sousc\\\\n+++ b/comments.sousc\\\\n@@ -1,3 +1,27 @@\\\\n+commit 4420cabefc1f470af341af11ed595df67e25c51f\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 17:05:35 2015 +0800\\\\n+\\\\n+    Paste old program code\\\\n+\\\\n+commit 9ef3d25fd4c3afdbcc3107a0abf6d7a2e29cb4dd\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 17:04:52 2015 +0800\\\\n+\\\\n+    Adding new file\\\\n+\\\\n+commit 64814d140d2fab6ae153cac485008119f29bf230\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 17:03:58 2015 +0800\\\\n+\\\\n+    From clear list\\\\n+\\\\n+commit c9d318fea74ea288d544ecf72f00b12c130cf2ef\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 16:59:40 2015 +0800\\\\n+\\\\n+    Create system files\\\\n+\\\\n commit e3c853a4282dfe8f000685dc1d39bd55a4a946c4\\\\n Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n Date:   Sun May 17 16:54:58 2015 +0800\\\\ndiff --git a/main.js b/main.js\\\\nindex e34dc18..86f30c2 100644\\\\n--- a/main.js\\\\n+++ b/main.js\\\\n@@ -3,6 +3,56 @@\\\\n  */\\\\n \\\\n var fs = require('fs');\\\\n+var cp = require('child_process');\\\\n+var data = [];\\\\n+\\\\n+var async = require('async');\\\\n+    /*tasks = [\\\\n+        function (callback) {\\\\n+            cp.exec('git log', function(error, stdout, stderr) {\\\\n+                var listOfCommits = [];\\\\n+                var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n+                var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n+                var comments = findComments(stdout);\\\\n+                var commitNumbers = findCommitNumbers(stdout);\\\\n+\\\\n+                for(i=0; i<authors.length; i++) {\\\\n+                    var commit = {\\\\n+                        \\\\\\\"commit\\\\\\\": commitNumbers[i],\\\\n+                        \\\\\\\"author\\\\\\\": authors[i],\\\\n+                        \\\\\\\"date\\\\\\\": dates[i],\\\\n+                        \\\\\\\"comment\\\\\\\": comments[i],\\\\n+                        \\\\\\\"content\\\\\\\": 'Original'\\\\n+                    };\\\\n+\\\\n+                    listOfCommits[listOfCommits.length] = commit;\\\\n+                }\\\\n+\\\\n+                data = listOfCommits.reverse();\\\\n+\\\\n+                callback(null, data);\\\\n+\\\\n+                if (error !== null) {\\\\n+                    console.log('stderr: ' + stderr);\\\\n+                    console.log('exec error: ' + error);\\\\n+                }\\\\n+            });\\\\n+        }\\\\n+    ],\\\\n+    secondTasks = [\\\\n+        function some_function(callback) {\\\\n+            cp.exec('git diff', function(error, stdout, stderr) {\\\\n+                var currentContent = stdout;\\\\n+\\\\n+                if (error !== null) {\\\\n+                    console.log('stderr: ' + stderr);\\\\n+                    console.log('exec error: ' + error);\\\\n+                }\\\\n+\\\\n+                callback(null, currentContent);\\\\n+            });\\\\n+        }\\\\n+    ];*/\\\\n \\\\n function findData(text, keyword) {\\\\n     var data = [];\\\\n@@ -28,38 +78,106 @@ function findComments(text) {\\\\n     return comments;\\\\n }\\\\n \\\\n+function findCommitNumbers(text) {\\\\n+    var commits = [];\\\\n+    var splittext = text.split('\\\\\\\\n');\\\\n+\\\\n+    for(i=0; i<splittext.length; i++) {\\\\n+        if(splittext[i].slice(0, 6) == \\\\\\\"commit\\\\\\\") {\\\\n+            commits[commits.length] = splittext[i].slice(6).trim();\\\\n+        }\\\\n+    }\\\\n+\\\\n+    return commits;\\\\n+}\\\\n+\\\\n+/*function pullCommitContent(first, second) {\\\\n+\\\\n+    cp.exec('git diff' + ' ' + first + ' ' + second, function(error, stdout, stderr) {\\\\n+        var currentContent = stdout;\\\\n+\\\\n+        if (error !== null) {\\\\n+            console.log('stderr: ' + stderr);\\\\n+            console.log('exec error: ' + error);\\\\n+        }\\\\n+\\\\n+        return currentContent;\\\\n+    });\\\\n+}*/\\\\n+\\\\n+var commitsInfo = [];\\\\n+\\\\n fs.exists('.git', function (exists) {\\\\n     if(exists) {\\\\n-        var cp = require('child_process');\\\\n+        /*async.series(tasks, function(err, result) {\\\\n+            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", JSON.stringify(result));\\\\n+\\\\n+            var data = result[0];\\\\n \\\\n-        cp.exec('git diff', function(error, stdout, stderr) {\\\\n-            console.log(stdout);\\\\n+            /*function some_function(arg1, arg2, callback) {\\\\n+                cp.exec('git diff' + ' ' + arg1 + ' ' + arg2, function(error, stdout, stderr) {\\\\n+                    var currentContent = 54321;//stdout;\\\\n \\\\n-            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", stdout);\\\\n+                    if (error !== null) {\\\\n+                        console.log('stderr: ' + stderr);\\\\n+                        console.log('exec error: ' + error);\\\\n+                    }\\\\n \\\\n-            if (error !== null) {\\\\n-                console.log('stderr: ' + stderr);\\\\n-                console.log('exec error: ' + error);\\\\n+                    callback(null, currentContent);\\\\n+                });\\\\n             }\\\\n-        });\\\\n+        });*/\\\\n+\\\\n+        async.waterfall([\\\\n+            function getCommitsInfo(callback) {\\\\n+                cp.exec('git log', function(error, stdout, stderr) {\\\\n+                    var listOfCommits = [];\\\\n+                    var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n+                    var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n+                    var comments = findComments(stdout);\\\\n+                    var commitNumbers = findCommitNumbers(stdout);\\\\n \\\\n-        cp.exec('git log', function(error, stdout, stderr) {\\\\n-            console.log(stdout);\\\\n+                    for(i=0; i<authors.length; i++) {\\\\n+                        var commit = {\\\\n+                            \\\\\\\"commit\\\\\\\": commitNumbers[i],\\\\n+                            \\\\\\\"author\\\\\\\": authors[i],\\\\n+                            \\\\\\\"date\\\\\\\": dates[i],\\\\n+                            \\\\\\\"comment\\\\\\\": comments[i],\\\\n+                            \\\\\\\"content\\\\\\\": 'Original'\\\\n+                        };\\\\n+                        listOfCommits[listOfCommits.length] = commit;\\\\n+                    }\\\\n \\\\n-            var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n-            var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n-            var comments = findComments(stdout);\\\\n-            console.log(authors);\\\\n-            console.log(comments);\\\\n-            console.log(dates);\\\\n+                    callback(null, listOfCommits.reverse());\\\\n \\\\n-            fs.writeFileSync(\\\\\\\"comments.sousc\\\\\\\", stdout);\\\\n+                    if (error !== null) {\\\\n+                        console.log('stderr: ' + stderr);\\\\n+                        console.log('exec error: ' + error);\\\\n+                    }\\\\n+                });\\\\n+            },\\\\n+            function getCommitsContent(commits, callback) {\\\\n+                console.log(commits);\\\\n+                var commitsData = commits;\\\\n \\\\n-            if (error !== null) {\\\\n-                console.log('stderr: ' + stderr);\\\\n-                console.log('exec error: ' + error);\\\\n+                for(i=1; i<commitsData.length; i++) {\\\\n+                    cp.exec('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit, function(error, stdout, stderr) {\\\\n+                        commitsData[i].content = stdout;\\\\n+\\\\n+                        if (error !== null) {\\\\n+                            console.log('stderr: ' + stderr);\\\\n+                            console.log('exec error: ' + error);\\\\n+                        }\\\\n+                    });\\\\n+                }\\\\n+\\\\n+                callback(null, commitsData);\\\\n             }\\\\n+        ], function (err, result) {\\\\n+            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", result);\\\\n         });\\\\n+\\\\n+        //commitsInfo = JSON.parse(fs.readFileSync(\\\\\\\"patches.sousp\\\\\\\"));\\\\n+        //console.log(commitsInfo);\\\\n     }\\\\n-    else console.log(\\\\\\\"Error.\\\\\\\");\\\\n });\\\\n\\\\\\\\ No newline at end of file\\\\ndiff --git a/node_modules/async/.travis.yml b/node_modules/async/.travis.yml\\\\nnew file mode 100644\\\\nindex 0000000..6e5919d\\\\n--- /dev/null\\\\n+++ b/node_modules/async/.travis.yml\\\\n@@ -0,0 +1,3 @@\\\\n+language: node_js\\\\n+node_js:\\\\n+  - \\\\\\\"0.10\\\\\\\"\\\\ndiff --git a/node_modules/async/LICENSE b/node_modules/async/LICENSE\\\\nnew file mode 100644\\\\nindex 0000000..8f29698\\\\n--- /dev/null\\\\n+++ b/node_modules/async/LICENSE\\\\n@@ -0,0 +1,19 @@\\\\n+Copyright (c) 2010-2014 Caolan McMahon\\\\n+\\\\n+Permission is hereby granted, free of charge, to any person obtaining a copy\\\\n+of this software and associated documentation files (the \\\\\\\"Software\\\\\\\"), to deal\\\\n+in the Software without restriction, including without limitation the rights\\\\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\\\n+copies of the Software, and to permit persons to whom the Software is\\\\n+furnished to do so, subject to the following conditions:\\\\n+\\\\n+The above copyright notice and this permission notice shall be included in\\\\n+all copies or substantial portions of the Software.\\\\n+\\\\n+THE SOFTWARE IS PROVIDED \\\\\\\"AS IS\\\\\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\\\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\\\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\\\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\\\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\\\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\\\n+THE SOFTWARE.\\\\ndiff --git a/node_modules/async/README.md b/node_modules/async/README.md\\\\nnew file mode 100644\\\\nindex 0000000..0bea531\\\\n--- /dev/null\\\\n+++ b/node_modules/async/README.md\\\\n@@ -0,0 +1,1646 @@\\\\n+# Async.js\\\\n+\\\\n+[![Build Status via Travis CI](https://travis-ci.org/caolan/async.svg?branch=master)](https://travis-ci.org/caolan/async)\\\\n+\\\\n+\\\\n+Async is a utility module which provides straight-forward, powerful functions\\\\n+for working with asynchronous JavaScript. Although originally designed for\\\\n+use with [Node.js](http://nodejs.org), it can also be used directly in the\\\\n+browser. Also supports [component](https://github.com/component/component).\\\\n+\\\\n+Async provides around 20 functions that include the usual 'functional'\\\\n+suspects (`map`, `reduce`, `filter`, `each`…) as well as some common patterns\\\\n+for asynchronous control flow (`parallel`, `series`, `waterfall`…). All these\\\\n+functions assume you follow the Node.js convention of providing a single\\\\n+callback as the last argument of your `async` function.\\\\n+\\\\n+\\\\n+## Quick Examples\\\\n+\\\\n+```javascript\\\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\\\n+    // results is now an array of stats for each file\\\\n+});\\\\n+\\\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\\\n+    // results now equals an array of the existing files\\\\n+});\\\\n+\\\\n+async.parallel([\\\\n+    function(){ ... },\\\\n+    function(){ ... }\\\\n+], callback);\\\\n+\\\\n+async.series([\\\\n+    function(){ ... },\\\\n+    function(){ ... }\\\\n+]);\\\\n+```\\\\n+\\\\n+There are many more functions available so take a look at the docs below for a\\\\n+full list. This module aims to be comprehensive, so if you feel anything is\\\\n+missing please create a GitHub issue for it.\\\\n+\\\\n+## Common Pitfalls\\\\n+\\\\n+### Binding a context to an iterator\\\\n+\\\\n+This section is really about `bind`, not about `async`. If you are wondering how to\\\\n+make `async` execute your iterators in a given context, or are confused as to why\\\\n+a method of another library isn't working as an iterator, study this example:\\\\n+\\\\n+```js\\\\n+// Here is a simple object with an (unnecessarily roundabout) squaring method\\\\n+var AsyncSquaringLibrary = {\\\\n+  squareExponent: 2,\\\\n+  square: function(number, callback){ \\\\n+    var result = Math.pow(number, this.squareExponent);\\\\n+    setTimeout(function(){\\\\n+      callback(null, result);\\\\n+    }, 200);\\\\n+  }\\\\n+};\\\\n+\\\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square, function(err, result){\\\\n+  // result is [NaN, NaN, NaN]\\\\n+  // This fails because the `this.squareExponent` expression in the square\\\\n+  // function is not evaluated in the context of AsyncSquaringLibrary, and is\\\\n+  // therefore undefined.\\\\n+});\\\\n+\\\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), function(err, result){\\\\n+  // result is [1, 4, 9]\\\\n+  // With the help of bind we can attach a context to the iterator before\\\\n+  // passing it to async. Now the square function will be executed in its \\\\n+  // 'home' AsyncSquaringLibrary context and the value of `this.squareExponent`\\\\n+  // will be as expected.\\\\n+});\\\\n+```\\\\n+\\\\n+## Download\\\\n+\\\\n+The source is available for download from\\\\n+[GitHub](http://github.com/caolan/async).\\\\n+Alternatively, you can install using Node Package Manager (`npm`):\\\\n+\\\\n+    npm install async\\\\n+\\\\n+__Development:__ [async.js](https://github.com/caolan/async/raw/master/lib/async.js) - 29.6kb Uncompressed\\\\n+\\\\n+## In the Browser\\\\n+\\\\n+So far it's been tested in IE6, IE7, IE8, FF3.6 and Chrome 5. \\\\n+\\\\n+Usage:\\\\n+\\\\n+```html\\\\n+<script type=\\\\\\\"text/javascript\\\\\\\" src=\\\\\\\"async.js\\\\\\\"></script>\\\\n+<script type=\\\\\\\"text/javascript\\\\\\\">\\\\n+\\\\n+    async.map(data, asyncProcess, function(err, results){\\\\n+        alert(results);\\\\n+    });\\\\n+\\\\n+</script>\\\\n+```\\\\n+\\\\n+## Documentation\\\\n+\\\\n+### Collections\\\\n+\\\\n+* [`each`](#each)\\\\n+* [`eachSeries`](#eachSeries)\\\\n+* [`eachLimit`](#eachLimit)\\\\n+* [`map`](#map)\\\\n+* [`mapSeries`](#mapSeries)\\\\n+* [`mapLimit`](#mapLimit)\\\\n+* [`filter`](#filter)\\\\n+* [`filterSeries`](#filterSeries)\\\\n+* [`reject`](#reject)\\\\n+* [`rejectSeries`](#rejectSeries)\\\\n+* [`reduce`](#reduce)\\\\n+* [`reduceRight`](#reduceRight)\\\\n+* [`detect`](#detect)\\\\n+* [`detectSeries`](#detectSeries)\\\\n+* [`sortBy`](#sortBy)\\\\n+* [`some`](#some)\\\\n+* [`every`](#every)\\\\n+* [`concat`](#concat)\\\\n+* [`concatSeries`](#concatSeries)\\\\n+\\\\n+### Control Flow\\\\n+\\\\n+* [`series`](#seriestasks-callback)\\\\n+* [`parallel`](#parallel)\\\\n+* [`parallelLimit`](#parallellimittasks-limit-callback)\\\\n+* [`whilst`](#whilst)\\\\n+* [`doWhilst`](#doWhilst)\\\\n+* [`until`](#until)\\\\n+* [`doUntil`](#doUntil)\\\\n+* [`forever`](#forever)\\\\n+* [`waterfall`](#waterfall)\\\\n+* [`compose`](#compose)\\\\n+* [`seq`](#seq)\\\\n+* [`applyEach`](#applyEach)\\\\n+* [`applyEachSeries`](#applyEachSeries)\\\\n+* [`queue`](#queue)\\\\n+* [`priorityQueue`](#priorityQueue)\\\\n+* [`cargo`](#cargo)\\\\n+* [`auto`](#auto)\\\\n+* [`retry`](#retry)\\\\n+* [`iterator`](#iterator)\\\\n+* [`apply`](#apply)\\\\n+* [`nextTick`](#nextTick)\\\\n+* [`times`](#times)\\\\n+* [`timesSeries`](#timesSeries)\\\\n+\\\\n+### Utils\\\\n+\\\\n+* [`memoize`](#memoize)\\\\n+* [`unmemoize`](#unmemoize)\\\\n+* [`log`](#log)\\\\n+* [`dir`](#dir)\\\\n+* [`noConflict`](#noConflict)\\\\n+\\\\n+\\\\n+## Collections\\\\n+\\\\n+<a name=\\\\\\\"forEach\\\\\\\" />\\\\n+<a name=\\\\\\\"each\\\\\\\" />\\\\n+### each(arr, iterator, callback)\\\\n+\\\\n+Applies the function `iterator` to each item in `arr`, in parallel.\\\\n+The `iterator` is called with an item from the list, and a callback for when it\\\\n+has finished. If the `iterator` passes an error to its `callback`, the main\\\\n+`callback` (for the `each` function) is immediately called with the error.\\\\n+\\\\n+Note, that since this function applies `iterator` to each item in parallel,\\\\n+there is no guarantee that the iterator functions will complete in order.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err)` which must be called once it has \\\\n+  completed. If no error has occured, the `callback` should be run without \\\\n+  arguments or with an explicit `null` argument.\\\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\\\n+  have finished, or an error occurs.\\\\n+\\\\n+__Examples__\\\\n+\\\\n+\\\\n+```js\\\\n+// assuming openFiles is an array of file names and saveFile is a function\\\\n+// to save the modified contents of that file:\\\\n+\\\\n+async.each(openFiles, saveFile, function(err){\\\\n+    // if any of the saves produced an error, err would equal that error\\\\n+});\\\\n+```\\\\n+\\\\n+```js\\\\n+// assuming openFiles is an array of file names \\\\n+\\\\n+async.each(openFiles, function( file, callback) {\\\\n+  \\\\n+  // Perform operation on file here.\\\\n+  console.log('Processing file ' + file);\\\\n+  \\\\n+  if( file.length > 32 ) {\\\\n+    console.log('This file name is too long');\\\\n+    callback('File name too long');\\\\n+  } else {\\\\n+    // Do work to process file here\\\\n+    console.log('File processed');\\\\n+    callback();\\\\n+  }\\\\n+}, function(err){\\\\n+    // if any of the file processing produced an error, err would equal that error\\\\n+    if( err ) {\\\\n+      // One of the iterations produced an error.\\\\n+      // All processing will now stop.\\\\n+      console.log('A file failed to process');\\\\n+    } else {\\\\n+      console.log('All files have been processed successfully');\\\\n+    }\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"forEachSeries\\\\\\\" />\\\\n+<a name=\\\\\\\"eachSeries\\\\\\\" />\\\\n+### eachSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`each`](#each), only `iterator` is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+This means the `iterator` functions will complete in order.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"forEachLimit\\\\\\\" />\\\\n+<a name=\\\\\\\"eachLimit\\\\\\\" />\\\\n+### eachLimit(arr, limit, iterator, callback)\\\\n+\\\\n+The same as [`each`](#each), only no more than `limit` `iterator`s will be simultaneously \\\\n+running at any time.\\\\n+\\\\n+Note that the items in `arr` are not processed in batches, so there is no guarantee that \\\\n+the first `limit` `iterator` functions will complete before any others are started.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err)` which must be called once it has \\\\n+  completed. If no error has occured, the callback should be run without \\\\n+  arguments or with an explicit `null` argument.\\\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\\\n+  have finished, or an error occurs.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// Assume documents is an array of JSON objects and requestApi is a\\\\n+// function that interacts with a rate-limited REST api.\\\\n+\\\\n+async.eachLimit(documents, 20, requestApi, function(err){\\\\n+    // if any of the saves produced an error, err would equal that error\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"map\\\\\\\" />\\\\n+### map(arr, iterator, callback)\\\\n+\\\\n+Produces a new array of values by mapping each value in `arr` through\\\\n+the `iterator` function. The `iterator` is called with an item from `arr` and a\\\\n+callback for when it has finished processing. Each of these callback takes 2 arguments: \\\\n+an `error`, and the transformed item from `arr`. If `iterator` passes an error to this \\\\n+callback, the main `callback` (for the `map` function) is immediately called with the error.\\\\n+\\\\n+Note, that since this function applies the `iterator` to each item in parallel,\\\\n+there is no guarantee that the `iterator` functions will complete in order. \\\\n+However, the results array will be in the same order as the original `arr`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\\\n+  it has completed with an error (which can be `null`) and a transformed item.\\\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\\\n+  functions have finished, or an error occurs. Results is an array of the\\\\n+  transformed items from the `arr`.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\\\n+    // results is now an array of stats for each file\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"mapSeries\\\\\\\" />\\\\n+### mapSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`map`](#map), only the `iterator` is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+The results array will be in the same order as the original.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"mapLimit\\\\\\\" />\\\\n+### mapLimit(arr, limit, iterator, callback)\\\\n+\\\\n+The same as [`map`](#map), only no more than `limit` `iterator`s will be simultaneously \\\\n+running at any time.\\\\n+\\\\n+Note that the items are not processed in batches, so there is no guarantee that \\\\n+the first `limit` `iterator` functions will complete before any others are started.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\\\n+  it has completed with an error (which can be `null`) and a transformed item.\\\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\\\n+  calls have finished, or an error occurs. The result is an array of the\\\\n+  transformed items from the original `arr`.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.mapLimit(['file1','file2','file3'], 1, fs.stat, function(err, results){\\\\n+    // results is now an array of stats for each file\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"select\\\\\\\" />\\\\n+<a name=\\\\\\\"filter\\\\\\\" />\\\\n+### filter(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `select`\\\\n+\\\\n+Returns a new array of all the values in `arr` which pass an async truth test.\\\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\n+way node libraries work with truth tests like `fs.exists`. This operation is\\\\n+performed in parallel, but the results array will be in the same order as the\\\\n+original.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\\\n+  The `iterator` is passed a `callback(truthValue)`, which must be called with a \\\\n+  boolean argument once it has completed.\\\\n+* `callback(results)` - A callback which is called after all the `iterator`\\\\n+  functions have finished.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\\\n+    // results now equals an array of the existing files\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"selectSeries\\\\\\\" />\\\\n+<a name=\\\\\\\"filterSeries\\\\\\\" />\\\\n+### filterSeries(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `selectSeries`\\\\n+\\\\n+The same as [`filter`](#filter) only the `iterator` is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+The results array will be in the same order as the original.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"reject\\\\\\\" />\\\\n+### reject(arr, iterator, callback)\\\\n+\\\\n+The opposite of [`filter`](#filter). Removes values that pass an `async` truth test.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"rejectSeries\\\\\\\" />\\\\n+### rejectSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`reject`](#reject), only the `iterator` is applied to each item in `arr`\\\\n+in series.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"reduce\\\\\\\" />\\\\n+### reduce(arr, memo, iterator, callback)\\\\n+\\\\n+__Aliases:__ `inject`, `foldl`\\\\n+\\\\n+Reduces `arr` into a single value using an async `iterator` to return\\\\n+each successive step. `memo` is the initial state of the reduction. \\\\n+This function only operates in series. \\\\n+\\\\n+For performance reasons, it may make sense to split a call to this function into \\\\n+a parallel map, and then use the normal `Array.prototype.reduce` on the results. \\\\n+This function is for situations where each step in the reduction needs to be async; \\\\n+if you can get the data before reducing it, then it's probably a good idea to do so.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `memo` - The initial state of the reduction.\\\\n+* `iterator(memo, item, callback)` - A function applied to each item in the\\\\n+  array to produce the next step in the reduction. The `iterator` is passed a\\\\n+  `callback(err, reduction)` which accepts an optional error as its first \\\\n+  argument, and the state of the reduction as the second. If an error is \\\\n+  passed to the callback, the reduction is stopped and the main `callback` is \\\\n+  immediately called with the error.\\\\n+* `callback(err, result)` - A callback which is called after all the `iterator`\\\\n+  functions have finished. Result is the reduced value.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.reduce([1,2,3], 0, function(memo, item, callback){\\\\n+    // pointless async:\\\\n+    process.nextTick(function(){\\\\n+        callback(null, memo + item)\\\\n+    });\\\\n+}, function(err, result){\\\\n+    // result is now equal to the last value of memo, which is 6\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"reduceRight\\\\\\\" />\\\\n+### reduceRight(arr, memo, iterator, callback)\\\\n+\\\\n+__Alias:__ `foldr`\\\\n+\\\\n+Same as [`reduce`](#reduce), only operates on `arr` in reverse order.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"detect\\\\\\\" />\\\\n+### detect(arr, iterator, callback)\\\\n+\\\\n+Returns the first value in `arr` that passes an async truth test. The\\\\n+`iterator` is applied in parallel, meaning the first iterator to return `true` will\\\\n+fire the detect `callback` with that result. That means the result might not be\\\\n+the first item in the original `arr` (in terms of order) that passes the test.\\\\n+\\\\n+If order within the original `arr` is important, then look at [`detectSeries`](#detectSeries).\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(truthValue)` which must be called with a \\\\n+  boolean argument once it has completed.\\\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\\\n+  `true`, or after all the `iterator` functions have finished. Result will be\\\\n+  the first item in the array that passes the truth test (iterator) or the\\\\n+  value `undefined` if none passed.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.detect(['file1','file2','file3'], fs.exists, function(result){\\\\n+    // result now equals the first file in the list that exists\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"detectSeries\\\\\\\" />\\\\n+### detectSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`detect`](#detect), only the `iterator` is applied to each item in `arr`\\\\n+in series. This means the result is always the first in the original `arr` (in\\\\n+terms of array order) that passes the truth test.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"sortBy\\\\\\\" />\\\\n+### sortBy(arr, iterator, callback)\\\\n+\\\\n+Sorts a list by the results of running each `arr` value through an async `iterator`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, sortValue)` which must be called once it\\\\n+  has completed with an error (which can be `null`) and a value to use as the sort\\\\n+  criteria.\\\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\\\n+  functions have finished, or an error occurs. Results is the items from\\\\n+  the original `arr` sorted by the values returned by the `iterator` calls.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.sortBy(['file1','file2','file3'], function(file, callback){\\\\n+    fs.stat(file, function(err, stats){\\\\n+        callback(err, stats.mtime);\\\\n+    });\\\\n+}, function(err, results){\\\\n+    // results is now the original array of files sorted by\\\\n+    // modified date\\\\n+});\\\\n+```\\\\n+\\\\n+__Sort Order__\\\\n+\\\\n+By modifying the callback parameter the sorting order can be influenced:\\\\n+\\\\n+```js\\\\n+//ascending order\\\\n+async.sortBy([1,9,3,5], function(x, callback){\\\\n+    callback(err, x);\\\\n+}, function(err,result){\\\\n+    //result callback\\\\n+} );\\\\n+\\\\n+//descending order\\\\n+async.sortBy([1,9,3,5], function(x, callback){\\\\n+    callback(err, x*-1);    //<- x*-1 instead of x, turns the order around\\\\n+}, function(err,result){\\\\n+    //result callback\\\\n+} );\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"some\\\\\\\" />\\\\n+### some(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `any`\\\\n+\\\\n+Returns `true` if at least one element in the `arr` satisfies an async test.\\\\n+_The callback for each iterator call only accepts a single argument of `true` or\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\n+way node libraries work with truth tests like `fs.exists`. Once any iterator\\\\n+call returns `true`, the main `callback` is immediately called.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\\\n+  called with a boolean argument once it has completed.\\\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\\\n+  `true`, or after all the iterator functions have finished. Result will be\\\\n+  either `true` or `false` depending on the values of the async tests.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.some(['file1','file2','file3'], fs.exists, function(result){\\\\n+    // if result is true then at least one of the files exists\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"every\\\\\\\" />\\\\n+### every(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `all`\\\\n+\\\\n+Returns `true` if every element in `arr` satisfies an async test.\\\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\n+way node libraries work with truth tests like `fs.exists`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\\\n+  called with a  boolean argument once it has completed.\\\\n+* `callback(result)` - A callback which is called after all the `iterator`\\\\n+  functions have finished. Result will be either `true` or `false` depending on\\\\n+  the values of the async tests.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.every(['file1','file2','file3'], fs.exists, function(result){\\\\n+    // if result is true then every file exists\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"concat\\\\\\\" />\\\\n+### concat(arr, iterator, callback)\\\\n+\\\\n+Applies `iterator` to each item in `arr`, concatenating the results. Returns the\\\\n+concatenated list. The `iterator`s are called in parallel, and the results are\\\\n+concatenated as they return. There is no guarantee that the results array will\\\\n+be returned in the original order of `arr` passed to the `iterator` function.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, results)` which must be called once it \\\\n+  has completed with an error (which can be `null`) and an array of results.\\\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\\\n+  functions have finished, or an error occurs. Results is an array containing\\\\n+  the concatenated results of the `iterator` function.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files){\\\\n+    // files is now a list of filenames that exist in the 3 directories\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"concatSeries\\\\\\\" />\\\\n+### concatSeries(arr, iterator, callback)\\\\n+\\\\n+Same as [`concat`](#concat), but executes in series instead of parallel.\\\\n+\\\\n+\\\\n+## Control Flow\\\\n+\\\\n+<a name=\\\\\\\"series\\\\\\\" />\\\\n+### series(tasks, [callback])\\\\n+\\\\n+Run the functions in the `tasks` array in series, each one running once the previous\\\\n+function has completed. If any functions in the series pass an error to its\\\\n+callback, no more functions are run, and `callback` is immediately called with the value of the error. \\\\n+Otherwise, `callback` receives an array of results when `tasks` have completed.\\\\n+\\\\n+It is also possible to use an object instead of an array. Each property will be\\\\n+run as a function, and the results will be passed to the final `callback` as an object\\\\n+instead of an array. This can be a more readable way of handling results from\\\\n+[`series`](#series).\\\\n+\\\\n+**Note** that while many implementations preserve the order of object properties, the\\\\n+[ECMAScript Language Specifcation](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6) \\\\n+explicitly states that\\\\n+\\\\n+> The mechanics and order of enumerating the properties is not specified.\\\\n+\\\\n+So if you rely on the order in which your series of functions are executed, and want\\\\n+this to work on all platforms, consider using an array. \\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array or object containing functions to run, each function is passed\\\\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\\\n+  be `null`) and an optional `result` value.\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\n+  have completed. This function gets a results array (or object) containing all \\\\n+  the result arguments passed to the `task` callbacks.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.series([\\\\n+    function(callback){\\\\n+        // do some stuff ...\\\\n+        callback(null, 'one');\\\\n+    },\\\\n+    function(callback){\\\\n+        // do some more stuff ...\\\\n+        callback(null, 'two');\\\\n+    }\\\\n+],\\\\n+// optional callback\\\\n+function(err, results){\\\\n+    // results is now equal to ['one', 'two']\\\\n+});\\\\n+\\\\n+\\\\n+// an example using an object instead of an array\\\\n+async.series({\\\\n+    one: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 1);\\\\n+        }, 200);\\\\n+    },\\\\n+    two: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 2);\\\\n+        }, 100);\\\\n+    }\\\\n+},\\\\n+function(err, results) {\\\\n+    // results is now equal to: {one: 1, two: 2}\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"parallel\\\\\\\" />\\\\n+### parallel(tasks, [callback])\\\\n+\\\\n+Run the `tasks` array of functions in parallel, without waiting until the previous\\\\n+function has completed. If any of the functions pass an error to its\\\\n+callback, the main `callback` is immediately called with the value of the error.\\\\n+Once the `tasks` have completed, the results are passed to the final `callback` as an\\\\n+array.\\\\n+\\\\n+It is also possible to use an object instead of an array. Each property will be\\\\n+run as a function and the results will be passed to the final `callback` as an object\\\\n+instead of an array. This can be a more readable way of handling results from\\\\n+[`parallel`](#parallel).\\\\n+\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array or object containing functions to run. Each function is passed \\\\n+  a `callback(err, result)` which it must call on completion with an error `err` \\\\n+  (which can be `null`) and an optional `result` value.\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\n+  have completed. This function gets a results array (or object) containing all \\\\n+  the result arguments passed to the task callbacks.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.parallel([\\\\n+    function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 'one');\\\\n+        }, 200);\\\\n+    },\\\\n+    function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 'two');\\\\n+        }, 100);\\\\n+    }\\\\n+],\\\\n+// optional callback\\\\n+function(err, results){\\\\n+    // the results array will equal ['one','two'] even though\\\\n+    // the second function had a shorter timeout.\\\\n+});\\\\n+\\\\n+\\\\n+// an example using an object instead of an array\\\\n+async.parallel({\\\\n+    one: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 1);\\\\n+        }, 200);\\\\n+    },\\\\n+    two: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 2);\\\\n+        }, 100);\\\\n+    }\\\\n+},\\\\n+function(err, results) {\\\\n+    // results is now equals to: {one: 1, two: 2}\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"parallelLimit\\\\\\\" />\\\\n+### parallelLimit(tasks, limit, [callback])\\\\n+\\\\n+The same as [`parallel`](#parallel), only `tasks` are executed in parallel \\\\n+with a maximum of `limit` tasks executing at any time.\\\\n+\\\\n+Note that the `tasks` are not executed in batches, so there is no guarantee that \\\\n+the first `limit` tasks will complete before any others are started.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array or object containing functions to run, each function is passed \\\\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\\\n+  be `null`) and an optional `result` value.\\\\n+* `limit` - The maximum number of `tasks` to run at any time.\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\n+  have completed. This function gets a results array (or object) containing all \\\\n+  the result arguments passed to the `task` callbacks.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"whilst\\\\\\\" />\\\\n+### whilst(test, fn, callback)\\\\n+\\\\n+Repeatedly call `fn`, while `test` returns `true`. Calls `callback` when stopped,\\\\n+or an error occurs.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `test()` - synchronous truth test to perform before each execution of `fn`.\\\\n+* `fn(callback)` - A function which is called each time `test` passes. The function is\\\\n+  passed a `callback(err)`, which must be called once it has completed with an \\\\n+  optional `err` argument.\\\\n+* `callback(err)` - A callback which is called after the test fails and repeated\\\\n+  execution of `fn` has stopped.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var count = 0;\\\\n+\\\\n+async.whilst(\\\\n+    function () { return count < 5; },\\\\n+    function (callback) {\\\\n+        count++;\\\\n+        setTimeout(callback, 1000);\\\\n+    },\\\\n+    function (err) {\\\\n+        // 5 seconds have passed\\\\n+    }\\\\n+);\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"doWhilst\\\\\\\" />\\\\n+### doWhilst(fn, test, callback)\\\\n+\\\\n+The post-check version of [`whilst`](#whilst). To reflect the difference in \\\\n+the order of operations, the arguments `test` and `fn` are switched. \\\\n+\\\\n+`doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"until\\\\\\\" />\\\\n+### until(test, fn, callback)\\\\n+\\\\n+Repeatedly call `fn` until `test` returns `true`. Calls `callback` when stopped,\\\\n+or an error occurs.\\\\n+\\\\n+The inverse of [`whilst`](#whilst).\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"doUntil\\\\\\\" />\\\\n+### doUntil(fn, test, callback)\\\\n+\\\\n+Like [`doWhilst`](#doWhilst), except the `test` is inverted. Note the argument ordering differs from `until`.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"forever\\\\\\\" />\\\\n+### forever(fn, errback)\\\\n+\\\\n+Calls the asynchronous function `fn` with a callback parameter that allows it to\\\\n+call itself again, in series, indefinitely.\\\\n+\\\\n+If an error is passed to the callback then `errback` is called with the\\\\n+error, and execution stops, otherwise it will never be called.\\\\n+\\\\n+```js\\\\n+async.forever(\\\\n+    function(next) {\\\\n+        // next is suitable for passing to things that need a callback(err [, whatever]);\\\\n+        // it will result in this function being called again.\\\\n+    },\\\\n+    function(err) {\\\\n+        // if next is called with a value in its first parameter, it will appear\\\\n+        // in here as 'err', and execution will stop.\\\\n+    }\\\\n+);\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"waterfall\\\\\\\" />\\\\n+### waterfall(tasks, [callback])\\\\n+\\\\n+Runs the `tasks` array of functions in series, each passing their results to the next in\\\\n+the array. However, if any of the `tasks` pass an error to their own callback, the\\\\n+next function is not executed, and the main `callback` is immediately called with\\\\n+the error.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array of functions to run, each function is passed a \\\\n+  `callback(err, result1, result2, ...)` it must call on completion. The first\\\\n+  argument is an error (which can be `null`) and any further arguments will be \\\\n+  passed as arguments in order to the next task.\\\\n+* `callback(err, [results])` - An optional callback to run once all the functions\\\\n+  have completed. This will be passed the results of the last task's callback.\\\\n+\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.waterfall([\\\\n+    function(callback){\\\\n+        callback(null, 'one', 'two');\\\\n+    },\\\\n+    function(arg1, arg2, callback){\\\\n+      // arg1 now equals 'one' and arg2 now equals 'two'\\\\n+        callback(null, 'three');\\\\n+    },\\\\n+    function(arg1, callback){\\\\n+        // arg1 now equals 'three'\\\\n+        callback(null, 'done');\\\\n+    }\\\\n+], function (err, result) {\\\\n+   // result now equals 'done'    \\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+<a name=\\\\\\\"compose\\\\\\\" />\\\\n+### compose(fn1, fn2...)\\\\n+\\\\n+Creates a function which is a composition of the passed asynchronous\\\\n+functions. Each function consumes the return value of the function that\\\\n+follows. Composing functions `f()`, `g()`, and `h()` would produce the result of\\\\n+`f(g(h()))`, only this version uses callbacks to obtain the return values.\\\\n+\\\\n+Each function is executed with the `this` binding of the composed function.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `functions...` - the asynchronous functions to compose\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+function add1(n, callback) {\\\\n+    setTimeout(function () {\\\\n+        callback(null, n + 1);\\\\n+    }, 10);\\\\n+}\\\\n+\\\\n+function mul3(n, callback) {\\\\n+    setTimeout(function () {\\\\n+        callback(null, n * 3);\\\\n+    }, 10);\\\\n+}\\\\n+\\\\n+var add1mul3 = async.compose(mul3, add1);\\\\n+\\\\n+add1mul3(4, function (err, result) {\\\\n+   // result now equals 15\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+<a name=\\\\\\\"seq\\\\\\\" />\\\\n+### seq(fn1, fn2...)\\\\n+\\\\n+Version of the compose function that is more natural to read.\\\\n+Each following function consumes the return value of the latter function. \\\\n+\\\\n+Each function is executed with the `this` binding of the composed function.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* functions... - the asynchronous functions to compose\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// Requires lodash (or underscore), express3 and dresende's orm2.\\\\n+// Part of an app, that fetches cats of the logged user.\\\\n+// This example uses `seq` function to avoid overnesting and error \\\\n+// handling clutter.\\\\n+app.get('/cats', function(request, response) {\\\\n+  function handleError(err, data, callback) {\\\\n+    if (err) {\\\\n+      console.error(err);\\\\n+      response.json({ status: 'error', message: err.message });\\\\n+    }\\\\n+    else {\\\\n+      callback(data);\\\\n+    }\\\\n+  }\\\\n+  var User = request.models.User;\\\\n+  async.seq(\\\\n+    _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\\\\n+    handleError,\\\\n+    function(user, fn) {\\\\n+      user.getCats(fn);      // 'getCats' has signature (callback(err, data))\\\\n+    },\\\\n+    handleError,\\\\n+    function(cats) {\\\\n+      response.json({ status: 'ok', message: 'Cats found', data: cats });\\\\n+    }\\\\n+  )(req.session.user_id);\\\\n+  }\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+<a name=\\\\\\\"applyEach\\\\\\\" />\\\\n+### applyEach(fns, args..., callback)\\\\n+\\\\n+Applies the provided arguments to each function in the array, calling \\\\n+`callback` after all functions have completed. If you only provide the first\\\\n+argument, then it will return a function which lets you pass in the\\\\n+arguments as if it were a single function call.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `fns` - the asynchronous functions to all call with the same arguments\\\\n+* `args...` - any number of separate arguments to pass to the function\\\\n+* `callback` - the final argument should be the callback, called when all\\\\n+  functions have completed processing\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.applyEach([enableSearch, updateSchema], 'bucket', callback);\\\\n+\\\\n+// partial application example:\\\\n+async.each(\\\\n+    buckets,\\\\n+    async.applyEach([enableSearch, updateSchema]),\\\\n+    callback\\\\n+);\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"applyEachSeries\\\\\\\" />\\\\n+### applyEachSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`applyEach`](#applyEach) only the functions are applied in series.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"queue\\\\\\\" />\\\\n+### queue(worker, concurrency)\\\\n+\\\\n+Creates a `queue` object with the specified `concurrency`. Tasks added to the\\\\n+`queue` are processed in parallel (up to the `concurrency` limit). If all\\\\n+`worker`s are in progress, the task is queued until one becomes available. \\\\n+Once a `worker` completes a `task`, that `task`'s callback is called.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `worker(task, callback)` - An asynchronous function for processing a queued\\\\n+  task, which must call its `callback(err)` argument when finished, with an \\\\n+  optional `error` as an argument.\\\\n+* `concurrency` - An `integer` for determining how many `worker` functions should be\\\\n+  run in parallel.\\\\n+\\\\n+__Queue objects__\\\\n+\\\\n+The `queue` object returned by this function has the following properties and\\\\n+methods:\\\\n+\\\\n+* `length()` - a function returning the number of items waiting to be processed.\\\\n+* `started` - a function returning whether or not any items have been pushed and processed by the queue\\\\n+* `running()` - a function returning the number of items currently being processed.\\\\n+* `idle()` - a function returning false if there are items waiting or being processed, or true if not.\\\\n+* `concurrency` - an integer for determining how many `worker` functions should be\\\\n+  run in parallel. This property can be changed after a `queue` is created to\\\\n+  alter the concurrency on-the-fly.\\\\n+* `push(task, [callback])` - add a new task to the `queue`. Calls `callback` once \\\\n+  the `worker` has finished processing the task. Instead of a single task, a `tasks` array\\\\n+  can be submitted. The respective callback is used for every task in the list.\\\\n+* `unshift(task, [callback])` - add a new task to the front of the `queue`.\\\\n+* `saturated` - a callback that is called when the `queue` length hits the `concurrency` limit, \\\\n+   and further tasks will be queued.\\\\n+* `empty` - a callback that is called when the last item from the `queue` is given to a `worker`.\\\\n+* `drain` - a callback that is called when the last item from the `queue` has returned from the `worker`.\\\\n+* `paused` - a boolean for determining whether the queue is in a paused state\\\\n+* `pause()` - a function that pauses the processing of tasks until `resume()` is called.\\\\n+* `resume()` - a function that resumes the processing of queued tasks when the queue is paused.\\\\n+* `kill()` - a function that empties remaining tasks from the queue forcing it to go idle.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// create a queue object with concurrency 2\\\\n+\\\\n+var q = async.queue(function (task, callback) {\\\\n+    console.log('hello ' + task.name);\\\\n+    callback();\\\\n+}, 2);\\\\n+\\\\n+\\\\n+// assign a callback\\\\n+q.drain = function() {\\\\n+    console.log('all items have been processed');\\\\n+}\\\\n+\\\\n+// add some items to the queue\\\\n+\\\\n+q.push({name: 'foo'}, function (err) {\\\\n+    console.log('finished processing foo');\\\\n+});\\\\n+q.push({name: 'bar'}, function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+\\\\n+// add some items to the queue (batch-wise)\\\\n+\\\\n+q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+\\\\n+// add some items to the front of the queue\\\\n+\\\\n+q.unshift({name: 'bar'}, function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+```\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"priorityQueue\\\\\\\" />\\\\n+### priorityQueue(worker, concurrency)\\\\n+\\\\n+The same as [`queue`](#queue) only tasks are assigned a priority and completed in ascending priority order. There are two differences between `queue` and `priorityQueue` objects:\\\\n+\\\\n+* `push(task, priority, [callback])` - `priority` should be a number. If an array of\\\\n+  `tasks` is given, all tasks will be assigned the same priority.\\\\n+* The `unshift` method was removed.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"cargo\\\\\\\" />\\\\n+### cargo(worker, [payload])\\\\n+\\\\n+Creates a `cargo` object with the specified payload. Tasks added to the\\\\n+cargo will be processed altogether (up to the `payload` limit). If the\\\\n+`worker` is in progress, the task is queued until it becomes available. Once\\\\n+the `worker` has completed some tasks, each callback of those tasks is called.\\\\n+Check out [this animation](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) for how `cargo` and `queue` work.\\\\n+\\\\n+While [queue](#queue) passes only one task to one of a group of workers\\\\n+at a time, cargo passes an array of tasks to a single worker, repeating\\\\n+when the worker is finished.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `worker(tasks, callback)` - An asynchronous function for processing an array of\\\\n+  queued tasks, which must call its `callback(err)` argument when finished, with \\\\n+  an optional `err` argument.\\\\n+* `payload` - An optional `integer` for determining how many tasks should be\\\\n+  processed per round; if omitted, the default is unlimited.\\\\n+\\\\n+__Cargo objects__\\\\n+\\\\n+The `cargo` object returned by this function has the following properties and\\\\n+methods:\\\\n+\\\\n+* `length()` - A function returning the number of items waiting to be processed.\\\\n+* `payload` - An `integer` for determining how many tasks should be\\\\n+  process per round. This property can be changed after a `cargo` is created to\\\\n+  alter the payload on-the-fly.\\\\n+* `push(task, [callback])` - Adds `task` to the `queue`. The callback is called\\\\n+  once the `worker` has finished processing the task. Instead of a single task, an array of `tasks` \\\\n+  can be submitted. The respective callback is used for every task in the list.\\\\n+* `saturated` - A callback that is called when the `queue.length()` hits the concurrency and further tasks will be queued.\\\\n+* `empty` - A callback that is called when the last item from the `queue` is given to a `worker`.\\\\n+* `drain` - A callback that is called when the last item from the `queue` has returned from the `worker`.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// create a cargo object with payload 2\\\\n+\\\\n+var cargo = async.cargo(function (tasks, callback) {\\\\n+    for(var i=0; i<tasks.length; i++){\\\\n+      console.log('hello ' + tasks[i].name);\\\\n+    }\\\\n+    callback();\\\\n+}, 2);\\\\n+\\\\n+\\\\n+// add some items\\\\n+\\\\n+cargo.push({name: 'foo'}, function (err) {\\\\n+    console.log('finished processing foo');\\\\n+});\\\\n+cargo.push({name: 'bar'}, function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+cargo.push({name: 'baz'}, function (err) {\\\\n+    console.log('finished processing baz');\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"auto\\\\\\\" />\\\\n+### auto(tasks, [callback])\\\\n+\\\\n+Determines the best order for running the functions in `tasks`, based on their \\\\n+requirements. Each function can optionally depend on other functions being completed \\\\n+first, and each function is run as soon as its requirements are satisfied. \\\\n+\\\\n+If any of the functions pass an error to their callback, it will not \\\\n+complete (so any other functions depending on it will not run), and the main \\\\n+`callback` is immediately called with the error. Functions also receive an \\\\n+object containing the results of functions which have completed so far.\\\\n+\\\\n+Note, all functions are called with a `results` object as a second argument, \\\\n+so it is unsafe to pass functions in the `tasks` object which cannot handle the\\\\n+extra argument. \\\\n+\\\\n+For example, this snippet of code:\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+  readData: async.apply(fs.readFile, 'data.txt', 'utf-8')\\\\n+}, callback);\\\\n+```\\\\n+\\\\n+will have the effect of calling `readFile` with the results object as the last\\\\n+argument, which will fail:\\\\n+\\\\n+```js\\\\n+fs.readFile('data.txt', 'utf-8', cb, {});\\\\n+```\\\\n+\\\\n+Instead, wrap the call to `readFile` in a function which does not forward the \\\\n+`results` object:\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+  readData: function(cb, results){\\\\n+    fs.readFile('data.txt', 'utf-8', cb);\\\\n+  }\\\\n+}, callback);\\\\n+```\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An object. Each of its properties is either a function or an array of\\\\n+  requirements, with the function itself the last item in the array. The object's key\\\\n+  of a property serves as the name of the task defined by that property,\\\\n+  i.e. can be used when specifying requirements for other tasks.\\\\n+  The function receives two arguments: (1) a `callback(err, result)` which must be \\\\n+  called when finished, passing an `error` (which can be `null`) and the result of \\\\n+  the function's execution, and (2) a `results` object, containing the results of\\\\n+  the previously executed functions.\\\\n+* `callback(err, results)` - An optional callback which is called when all the\\\\n+  tasks have been completed. It receives the `err` argument if any `tasks` \\\\n+  pass an error to their callback. Results are always returned; however, if \\\\n+  an error occurs, no further `tasks` will be performed, and the results\\\\n+  object will only contain partial results.\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+    get_data: function(callback){\\\\n+        console.log('in get_data');\\\\n+        // async code to get some data\\\\n+        callback(null, 'data', 'converted to array');\\\\n+    },\\\\n+    make_folder: function(callback){\\\\n+        console.log('in make_folder');\\\\n+        // async code to create a directory to store a file in\\\\n+        // this is run at the same time as getting the data\\\\n+        callback(null, 'folder');\\\\n+    },\\\\n+    write_file: ['get_data', 'make_folder', function(callback, results){\\\\n+        console.log('in write_file', JSON.stringify(results));\\\\n+        // once there is some data and the directory exists,\\\\n+        // write the data to a file in the directory\\\\n+        callback(null, 'filename');\\\\n+    }],\\\\n+    email_link: ['write_file', function(callback, results){\\\\n+        console.log('in email_link', JSON.stringify(results));\\\\n+        // once the file is written let's email a link to it...\\\\n+        // results.write_file contains the filename returned by write_file.\\\\n+        callback(null, {'file':results.write_file, 'email':'user@example.com'});\\\\n+    }]\\\\n+}, function(err, results) {\\\\n+    console.log('err = ', err);\\\\n+    console.log('results = ', results);\\\\n+});\\\\n+```\\\\n+\\\\n+This is a fairly trivial example, but to do this using the basic parallel and\\\\n+series functions would look like this:\\\\n+\\\\n+```js\\\\n+async.parallel([\\\\n+    function(callback){\\\\n+        console.log('in get_data');\\\\n+        // async code to get some data\\\\n+        callback(null, 'data', 'converted to array');\\\\n+    },\\\\n+    function(callback){\\\\n+        console.log('in make_folder');\\\\n+        // async code to create a directory to store a file in\\\\n+        // this is run at the same time as getting the data\\\\n+        callback(null, 'folder');\\\\n+    }\\\\n+],\\\\n+function(err, results){\\\\n+    async.series([\\\\n+        function(callback){\\\\n+            console.log('in write_file', JSON.stringify(results));\\\\n+            // once there is some data and the directory exists,\\\\n+            // write the data to a file in the directory\\\\n+            results.push('filename');\\\\n+            callback(null);\\\\n+        },\\\\n+        function(callback){\\\\n+            console.log('in email_link', JSON.stringify(results));\\\\n+            // once the file is written let's email a link to it...\\\\n+            callback(null, {'file':results.pop(), 'email':'user@example.com'});\\\\n+        }\\\\n+    ]);\\\\n+});\\\\n+```\\\\n+\\\\n+For a complicated series of `async` tasks, using the [`auto`](#auto) function makes adding\\\\n+new tasks much easier (and the code more readable).\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"retry\\\\\\\" />\\\\n+### retry([times = 5], task, [callback])\\\\n+\\\\n+Attempts to get a successful response from `task` no more than `times` times before\\\\n+returning an error. If the task is successful, the `callback` will be passed the result\\\\n+of the successfull task. If all attemps fail, the callback will be passed the error and\\\\n+result (if any) of the final attempt.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `times` - An integer indicating how many times to attempt the `task` before giving up. Defaults to 5.\\\\n+* `task(callback, results)` - A function which receives two arguments: (1) a `callback(err, result)`\\\\n+  which must be called when finished, passing `err` (which can be `null`) and the `result` of \\\\n+  the function's execution, and (2) a `results` object, containing the results of\\\\n+  the previously executed functions (if nested inside another control flow).\\\\n+* `callback(err, results)` - An optional callback which is called when the\\\\n+  task has succeeded, or after the final failed attempt. It receives the `err` and `result` arguments of the last attempt at completing the `task`.\\\\n+\\\\n+The [`retry`](#retry) function can be used as a stand-alone control flow by passing a\\\\n+callback, as shown below:\\\\n+\\\\n+```js\\\\n+async.retry(3, apiMethod, function(err, result) {\\\\n+    // do something with the result\\\\n+});\\\\n+```\\\\n+\\\\n+It can also be embeded within other control flow functions to retry individual methods\\\\n+that are not as reliable, like this:\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+    users: api.getUsers.bind(api),\\\\n+    payments: async.retry(3, api.getPayments.bind(api))\\\\n+}, function(err, results) {\\\\n+  // do something with the results\\\\n+});\\\\n+```\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"iterator\\\\\\\" />\\\\n+### iterator(tasks)\\\\n+\\\\n+Creates an iterator function which calls the next function in the `tasks` array,\\\\n+returning a continuation to call the next one after that. It's also possible to\\\\n+“peek” at the next iterator with `iterator.next()`.\\\\n+\\\\n+This function is used internally by the `async` module, but can be useful when\\\\n+you want to manually control the flow of functions in series.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array of functions to run.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var iterator = async.iterator([\\\\n+    function(){ sys.p('one'); },\\\\n+    function(){ sys.p('two'); },\\\\n+    function(){ sys.p('three'); }\\\\n+]);\\\\n+\\\\n+node> var iterator2 = iterator();\\\\n+'one'\\\\n+node> var iterator3 = iterator2();\\\\n+'two'\\\\n+node> iterator3();\\\\n+'three'\\\\n+node> var nextfn = iterator2.next();\\\\n+node> nextfn();\\\\n+'three'\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"apply\\\\\\\" />\\\\n+### apply(function, arguments..)\\\\n+\\\\n+Creates a continuation function with some arguments already applied. \\\\n+\\\\n+Useful as a shorthand when combined with other control flow functions. Any arguments\\\\n+passed to the returned function are added to the arguments originally passed\\\\n+to apply.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\n+* `arguments...` - Any number of arguments to automatically apply when the\\\\n+  continuation is called.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// using apply\\\\n+\\\\n+async.parallel([\\\\n+    async.apply(fs.writeFile, 'testfile1', 'test1'),\\\\n+    async.apply(fs.writeFile, 'testfile2', 'test2'),\\\\n+]);\\\\n+\\\\n+\\\\n+// the same process without using apply\\\\n+\\\\n+async.parallel([\\\\n+    function(callback){\\\\n+        fs.writeFile('testfile1', 'test1', callback);\\\\n+    },\\\\n+    function(callback){\\\\n+        fs.writeFile('testfile2', 'test2', callback);\\\\n+    }\\\\n+]);\\\\n+```\\\\n+\\\\n+It's possible to pass any number of additional arguments when calling the\\\\n+continuation:\\\\n+\\\\n+```js\\\\n+node> var fn = async.apply(sys.puts, 'one');\\\\n+node> fn('two', 'three');\\\\n+one\\\\n+two\\\\n+three\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"nextTick\\\\\\\" />\\\\n+### nextTick(callback)\\\\n+\\\\n+Calls `callback` on a later loop around the event loop. In Node.js this just\\\\n+calls `process.nextTick`; in the browser it falls back to `setImmediate(callback)`\\\\n+if available, otherwise `setTimeout(callback, 0)`, which means other higher priority\\\\n+events may precede the execution of `callback`.\\\\n+\\\\n+This is used internally for browser-compatibility purposes.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `callback` - The function to call on a later loop around the event loop.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var call_order = [];\\\\n+async.nextTick(function(){\\\\n+    call_order.push('two');\\\\n+    // call_order now equals ['one','two']\\\\n+});\\\\n+call_order.push('one')\\\\n+```\\\\n+\\\\n+<a name=\\\\\\\"times\\\\\\\" />\\\\n+### times(n, callback)\\\\n+\\\\n+Calls the `callback` function `n` times, and accumulates results in the same manner\\\\n+you would use with [`map`](#map).\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `n` - The number of times to run the function.\\\\n+* `callback` - The function to call `n` times.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// Pretend this is some complicated async factory\\\\n+var createUser = function(id, callback) {\\\\n+  callback(null, {\\\\n+    id: 'user' + id\\\\n+  })\\\\n+}\\\\n+// generate 5 users\\\\n+async.times(5, function(n, next){\\\\n+    createUser(n, function(err, user) {\\\\n+      next(err, user)\\\\n+    })\\\\n+}, function(err, users) {\\\\n+  // we should now have 5 users\\\\n+});\\\\n+```\\\\n+\\\\n+<a name=\\\\\\\"timesSeries\\\\\\\" />\\\\n+### timesSeries(n, callback)\\\\n+\\\\n+The same as [`times`](#times), only the iterator is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+The results array will be in the same order as the original.\\\\n+\\\\n+\\\\n+## Utils\\\\n+\\\\n+<a name=\\\\\\\"memoize\\\\\\\" />\\\\n+### memoize(fn, [hasher])\\\\n+\\\\n+Caches the results of an `async` function. When creating a hash to store function\\\\n+results against, the callback is omitted from the hash and an optional hash\\\\n+function can be used.\\\\n+\\\\n+The cache of results is exposed as the `memo` property of the function returned\\\\n+by `memoize`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `fn` - The function to proxy and cache results from.\\\\n+* `hasher` - Tn optional function for generating a custom hash for storing\\\\n+  results. It has all the arguments applied to it apart from the callback, and\\\\n+  must be synchronous.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var slow_fn = function (name, callback) {\\\\n+    // do something\\\\n+    callback(null, result);\\\\n+};\\\\n+var fn = async.memoize(slow_fn);\\\\n+\\\\n+// fn can now be used as if it were slow_fn\\\\n+fn('some name', function () {\\\\n+    // callback\\\\n+});\\\\n+```\\\\n+\\\\n+<a name=\\\\\\\"unmemoize\\\\\\\" />\\\\n+### unmemoize(fn)\\\\n+\\\\n+Undoes a [`memoize`](#memoize)d function, reverting it to the original, unmemoized\\\\n+form. Handy for testing.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `fn` - the memoized function\\\\n+\\\\n+<a name=\\\\\\\"log\\\\\\\" />\\\\n+### log(function, arguments)\\\\n+\\\\n+Logs the result of an `async` function to the `console`. Only works in Node.js or\\\\n+in browsers that support `console.log` and `console.error` (such as FF and Chrome).\\\\n+If multiple arguments are returned from the async function, `console.log` is\\\\n+called on each argument in order.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\n+* `arguments...` - Any number of arguments to apply to the function.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var hello = function(name, callback){\\\\n+    setTimeout(function(){\\\\n+        callback(null, 'hello ' + name);\\\\n+    }, 1000);\\\\n+};\\\\n+```\\\\n+```js\\\\n+node> async.log(hello, 'world');\\\\n+'hello world'\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"dir\\\\\\\" />\\\\n+### dir(function, arguments)\\\\n+\\\\n+Logs the result of an `async` function to the `console` using `console.dir` to\\\\n+display the properties of the resulting object. Only works in Node.js or\\\\n+in browsers that support `console.dir` and `console.error` (such as FF and Chrome).\\\\n+If multiple arguments are returned from the async function, `console.dir` is\\\\n+called on each argument in order.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\n+* `arguments...` - Any number of arguments to apply to the function.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var hello = function(name, callback){\\\\n+    setTimeout(function(){\\\\n+        callback(null, {hello: name});\\\\n+    }, 1000);\\\\n+};\\\\n+```\\\\n+```js\\\\n+node> async.dir(hello, 'world');\\\\n+{hello: 'world'}\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"noConflict\\\\\\\" />\\\\n+### noConflict()\\\\n+\\\\n+Changes the value of `async` back to its original value, returning a reference to the\\\\n+`async` object.\\\\ndiff --git a/node_modules/async/component.json b/node_modules/async/component.json\\\\nnew file mode 100644\\\\nindex 0000000..bbb0115\\\\n--- /dev/null\\\\n+++ b/node_modules/async/component.json\\\\n@@ -0,0 +1,11 @@\\\\n+{\\\\n+  \\\\\\\"name\\\\\\\": \\\\\\\"async\\\\\\\",\\\\n+  \\\\\\\"repo\\\\\\\": \\\\\\\"caolan/async\\\\\\\",\\\\n+  \\\\\\\"description\\\\\\\": \\\\\\\"Higher-order functions and common patterns for asynchronous code\\\\\\\",\\\\n+  \\\\\\\"version\\\\\\\": \\\\\\\"0.1.23\\\\\\\",\\\\n+  \\\\\\\"keywords\\\\\\\": [],\\\\n+  \\\\\\\"dependencies\\\\\\\": {},\\\\n+  \\\\\\\"development\\\\\\\": {},\\\\n+  \\\\\\\"main\\\\\\\": \\\\\\\"lib/async.js\\\\\\\",\\\\n+  \\\\\\\"scripts\\\\\\\": [ \\\\\\\"lib/async.js\\\\\\\" ]\\\\n+}\\\\ndiff --git a/node_modules/async/lib/async.js b/node_modules/async/lib/async.js\\\\nnew file mode 100644\\\\nindex 0000000..01e8afc\\\\n--- /dev/null\\\\n+++ b/node_modules/async/lib/async.js\\\\n@@ -0,0 +1,1123 @@\\\\n+/*!\\\\n+ * async\\\\n+ * https://github.com/caolan/async\\\\n+ *\\\\n+ * Copyright 2010-2014 Caolan McMahon\\\\n+ * Released under the MIT license\\\\n+ */\\\\n+/*jshint onevar: false, indent:4 */\\\\n+/*global setImmediate: false, setTimeout: false, console: false */\\\\n+(function () {\\\\n+\\\\n+    var async = {};\\\\n+\\\\n+    // global on the server, window in the browser\\\\n+    var root, previous_async;\\\\n+\\\\n+    root = this;\\\\n+    if (root != null) {\\\\n+      previous_async = root.async;\\\\n+    }\\\\n+\\\\n+    async.noConflict = function () {\\\\n+        root.async = previous_async;\\\\n+        return async;\\\\n+    };\\\\n+\\\\n+    function only_once(fn) {\\\\n+        var called = false;\\\\n+        return function() {\\\\n+            if (called) throw new Error(\\\\\\\"Callback was already called.\\\\\\\");\\\\n+            called = true;\\\\n+            fn.apply(root, arguments);\\\\n+        }\\\\n+    }\\\\n+\\\\n+    //// cross-browser compatiblity functions ////\\\\n+\\\\n+    var _toString = Object.prototype.toString;\\\\n+\\\\n+    var _isArray = Array.isArray || function (obj) {\\\\n+        return _toString.call(obj) === '[object Array]';\\\\n+    };\\\\n+\\\\n+    var _each = function (arr, iterator) {\\\\n+        if (arr.forEach) {\\\\n+            return arr.forEach(iterator);\\\\n+        }\\\\n+        for (var i = 0; i < arr.length; i += 1) {\\\\n+            iterator(arr[i], i, arr);\\\\n+        }\\\\n+    };\\\\n+\\\\n+    var _map = function (arr, iterator) {\\\\n+        if (arr.map) {\\\\n+            return arr.map(iterator);\\\\n+        }\\\\n+        var results = [];\\\\n+        _each(arr, function (x, i, a) {\\\\n+            results.push(iterator(x, i, a));\\\\n+        });\\\\n+        return results;\\\\n+    };\\\\n+\\\\n+    var _reduce = function (arr, iterator, memo) {\\\\n+        if (arr.reduce) {\\\\n+            return arr.reduce(iterator, memo);\\\\n+        }\\\\n+        _each(arr, function (x, i, a) {\\\\n+            memo = iterator(memo, x, i, a);\\\\n+        });\\\\n+        return memo;\\\\n+    };\\\\n+\\\\n+    var _keys = function (obj) {\\\\n+        if (Object.keys) {\\\\n+            return Object.keys(obj);\\\\n+        }\\\\n+        var keys = [];\\\\n+        for (var k in obj) {\\\\n+            if (obj.hasOwnProperty(k)) {\\\\n+                keys.push(k);\\\\n+            }\\\\n+        }\\\\n+        return keys;\\\\n+    };\\\\n+\\\\n+    //// exported async module functions ////\\\\n+\\\\n+    //// nextTick implementation with browser-compatible fallback ////\\\\n+    if (typeof process === 'undefined' || !(process.nextTick)) {\\\\n+        if (typeof setImmediate === 'function') {\\\\n+            async.nextTick = function (fn) {\\\\n+                // not a direct alias for IE10 compatibility\\\\n+                setImmediate(fn);\\\\n+            };\\\\n+            async.setImmediate = async.nextTick;\\\\n+        }\\\\n+        else {\\\\n+            async.nextTick = function (fn) {\\\\n+                setTimeout(fn, 0);\\\\n+            };\\\\n+            async.setImmediate = async.nextTick;\\\\n+        }\\\\n+    }\\\\n+    else {\\\\n+        async.nextTick = process.nextTick;\\\\n+        if (typeof setImmediate !== 'undefined') {\\\\n+            async.setImmediate = function (fn) {\\\\n+              // not a direct alias for IE10 compatibility\\\\n+              setImmediate(fn);\\\\n+            };\\\\n+        }\\\\n+        else {\\\\n+            async.setImmediate = async.nextTick;\\\\n+        }\\\\n+    }\\\\n+\\\\n+    async.each = function (arr, iterator, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (!arr.length) {\\\\n+            return callback();\\\\n+        }\\\\n+        var completed = 0;\\\\n+        _each(arr, function (x) {\\\\n+            iterator(x, only_once(done) );\\\\n+        });\\\\n+        function done(err) {\\\\n+          if (err) {\\\\n+              callback(err);\\\\n+              callback = function () {};\\\\n+          }\\\\n+          else {\\\\n+              completed += 1;\\\\n+              if (completed >= arr.length) {\\\\n+                  callback();\\\\n+              }\\\\n+          }\\\\n+        }\\\\n+    };\\\\n+    async.forEach = async.each;\\\\n+\\\\n+    async.eachSeries = function (arr, iterator, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (!arr.length) {\\\\n+            return callback();\\\\n+        }\\\\n+        var completed = 0;\\\\n+        var iterate = function () {\\\\n+            iterator(arr[completed], function (err) {\\\\n+                if (err) {\\\\n+                    callback(err);\\\\n+                    callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    completed += 1;\\\\n+                    if (completed >= arr.length) {\\\\n+                        callback();\\\\n+                    }\\\\n+                    else {\\\\n+                        iterate();\\\\n+                    }\\\\n+                }\\\\n+            });\\\\n+        };\\\\n+        iterate();\\\\n+    };\\\\n+    async.forEachSeries = async.eachSeries;\\\\n+\\\\n+    async.eachLimit = function (arr, limit, iterator, callback) {\\\\n+        var fn = _eachLimit(limit);\\\\n+        fn.apply(null, [arr, iterator, callback]);\\\\n+    };\\\\n+    async.forEachLimit = async.eachLimit;\\\\n+\\\\n+    var _eachLimit = function (limit) {\\\\n+\\\\n+        return function (arr, iterator, callback) {\\\\n+            callback = callback || function () {};\\\\n+            if (!arr.length || limit <= 0) {\\\\n+                return callback();\\\\n+            }\\\\n+            var completed = 0;\\\\n+            var started = 0;\\\\n+            var running = 0;\\\\n+\\\\n+            (function replenish () {\\\\n+                if (completed >= arr.length) {\\\\n+                    return callback();\\\\n+                }\\\\n+\\\\n+                while (running < limit && started < arr.length) {\\\\n+                    started += 1;\\\\n+                    running += 1;\\\\n+                    iterator(arr[started - 1], function (err) {\\\\n+                        if (err) {\\\\n+                            callback(err);\\\\n+                            callback = function () {};\\\\n+                        }\\\\n+                        else {\\\\n+                            completed += 1;\\\\n+                            running -= 1;\\\\n+                            if (completed >= arr.length) {\\\\n+                                callback();\\\\n+                            }\\\\n+                            else {\\\\n+                                replenish();\\\\n+                            }\\\\n+                        }\\\\n+                    });\\\\n+                }\\\\n+            })();\\\\n+        };\\\\n+    };\\\\n+\\\\n+\\\\n+    var doParallel = function (fn) {\\\\n+        return function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            return fn.apply(null, [async.each].concat(args));\\\\n+        };\\\\n+    };\\\\n+    var doParallelLimit = function(limit, fn) {\\\\n+        return function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            return fn.apply(null, [_eachLimit(limit)].concat(args));\\\\n+        };\\\\n+    };\\\\n+    var doSeries = function (fn) {\\\\n+        return function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            return fn.apply(null, [async.eachSeries].concat(args));\\\\n+        };\\\\n+    };\\\\n+\\\\n+\\\\n+    var _asyncMap = function (eachfn, arr, iterator, callback) {\\\\n+        arr = _map(arr, function (x, i) {\\\\n+            return {index: i, value: x};\\\\n+        });\\\\n+        if (!callback) {\\\\n+            eachfn(arr, function (x, callback) {\\\\n+                iterator(x.value, function (err) {\\\\n+                    callback(err);\\\\n+                });\\\\n+            });\\\\n+        } else {\\\\n+            var results = [];\\\\n+            eachfn(arr, function (x, callback) {\\\\n+                iterator(x.value, function (err, v) {\\\\n+                    results[x.index] = v;\\\\n+                    callback(err);\\\\n+                });\\\\n+            }, function (err) {\\\\n+                callback(err, results);\\\\n+            });\\\\n+        }\\\\n+    };\\\\n+    async.map = doParallel(_asyncMap);\\\\n+    async.mapSeries = doSeries(_asyncMap);\\\\n+    async.mapLimit = function (arr, limit, iterator, callback) {\\\\n+        return _mapLimit(limit)(arr, iterator, callback);\\\\n+    };\\\\n+\\\\n+    var _mapLimit = function(limit) {\\\\n+        return doParallelLimit(limit, _asyncMap);\\\\n+    };\\\\n+\\\\n+    // reduce only has a series version, as doing reduce in parallel won't\\\\n+    // work in many situations.\\\\n+    async.reduce = function (arr, memo, iterator, callback) {\\\\n+        async.eachSeries(arr, function (x, callback) {\\\\n+            iterator(memo, x, function (err, v) {\\\\n+                memo = v;\\\\n+                callback(err);\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(err, memo);\\\\n+        });\\\\n+    };\\\\n+    // inject alias\\\\n+    async.inject = async.reduce;\\\\n+    // foldl alias\\\\n+    async.foldl = async.reduce;\\\\n+\\\\n+    async.reduceRight = function (arr, memo, iterator, callback) {\\\\n+        var reversed = _map(arr, function (x) {\\\\n+            return x;\\\\n+        }).reverse();\\\\n+        async.reduce(reversed, memo, iterator, callback);\\\\n+    };\\\\n+    // foldr alias\\\\n+    async.foldr = async.reduceRight;\\\\n+\\\\n+    var _filter = function (eachfn, arr, iterator, callback) {\\\\n+        var results = [];\\\\n+        arr = _map(arr, function (x, i) {\\\\n+            return {index: i, value: x};\\\\n+        });\\\\n+        eachfn(arr, function (x, callback) {\\\\n+            iterator(x.value, function (v) {\\\\n+                if (v) {\\\\n+                    results.push(x);\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(_map(results.sort(function (a, b) {\\\\n+                return a.index - b.index;\\\\n+            }), function (x) {\\\\n+                return x.value;\\\\n+            }));\\\\n+        });\\\\n+    };\\\\n+    async.filter = doParallel(_filter);\\\\n+    async.filterSeries = doSeries(_filter);\\\\n+    // select alias\\\\n+    async.select = async.filter;\\\\n+    async.selectSeries = async.filterSeries;\\\\n+\\\\n+    var _reject = function (eachfn, arr, iterator, callback) {\\\\n+        var results = [];\\\\n+        arr = _map(arr, function (x, i) {\\\\n+            return {index: i, value: x};\\\\n+        });\\\\n+        eachfn(arr, function (x, callback) {\\\\n+            iterator(x.value, function (v) {\\\\n+                if (!v) {\\\\n+                    results.push(x);\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(_map(results.sort(function (a, b) {\\\\n+                return a.index - b.index;\\\\n+            }), function (x) {\\\\n+                return x.value;\\\\n+            }));\\\\n+        });\\\\n+    };\\\\n+    async.reject = doParallel(_reject);\\\\n+    async.rejectSeries = doSeries(_reject);\\\\n+\\\\n+    var _detect = function (eachfn, arr, iterator, main_callback) {\\\\n+        eachfn(arr, function (x, callback) {\\\\n+            iterator(x, function (result) {\\\\n+                if (result) {\\\\n+                    main_callback(x);\\\\n+                    main_callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    callback();\\\\n+                }\\\\n+            });\\\\n+        }, function (err) {\\\\n+            main_callback();\\\\n+        });\\\\n+    };\\\\n+    async.detect = doParallel(_detect);\\\\n+    async.detectSeries = doSeries(_detect);\\\\n+\\\\n+    async.some = function (arr, iterator, main_callback) {\\\\n+        async.each(arr, function (x, callback) {\\\\n+            iterator(x, function (v) {\\\\n+                if (v) {\\\\n+                    main_callback(true);\\\\n+                    main_callback = function () {};\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            main_callback(false);\\\\n+        });\\\\n+    };\\\\n+    // any alias\\\\n+    async.any = async.some;\\\\n+\\\\n+    async.every = function (arr, iterator, main_callback) {\\\\n+        async.each(arr, function (x, callback) {\\\\n+            iterator(x, function (v) {\\\\n+                if (!v) {\\\\n+                    main_callback(false);\\\\n+                    main_callback = function () {};\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            main_callback(true);\\\\n+        });\\\\n+    };\\\\n+    // all alias\\\\n+    async.all = async.every;\\\\n+\\\\n+    async.sortBy = function (arr, iterator, callback) {\\\\n+        async.map(arr, function (x, callback) {\\\\n+            iterator(x, function (err, criteria) {\\\\n+                if (err) {\\\\n+                    callback(err);\\\\n+                }\\\\n+                else {\\\\n+                    callback(null, {value: x, criteria: criteria});\\\\n+                }\\\\n+            });\\\\n+        }, function (err, results) {\\\\n+            if (err) {\\\\n+                return callback(err);\\\\n+            }\\\\n+            else {\\\\n+                var fn = function (left, right) {\\\\n+                    var a = left.criteria, b = right.criteria;\\\\n+                    return a < b ? -1 : a > b ? 1 : 0;\\\\n+                };\\\\n+                callback(null, _map(results.sort(fn), function (x) {\\\\n+                    return x.value;\\\\n+                }));\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.auto = function (tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        var keys = _keys(tasks);\\\\n+        var remainingTasks = keys.length\\\\n+        if (!remainingTasks) {\\\\n+            return callback();\\\\n+        }\\\\n+\\\\n+        var results = {};\\\\n+\\\\n+        var listeners = [];\\\\n+        var addListener = function (fn) {\\\\n+            listeners.unshift(fn);\\\\n+        };\\\\n+        var removeListener = function (fn) {\\\\n+            for (var i = 0; i < listeners.length; i += 1) {\\\\n+                if (listeners[i] === fn) {\\\\n+                    listeners.splice(i, 1);\\\\n+                    return;\\\\n+                }\\\\n+            }\\\\n+        };\\\\n+        var taskComplete = function () {\\\\n+            remainingTasks--\\\\n+            _each(listeners.slice(0), function (fn) {\\\\n+                fn();\\\\n+            });\\\\n+        };\\\\n+\\\\n+        addListener(function () {\\\\n+            if (!remainingTasks) {\\\\n+                var theCallback = callback;\\\\n+                // prevent final callback from calling itself if it errors\\\\n+                callback = function () {};\\\\n+\\\\n+                theCallback(null, results);\\\\n+            }\\\\n+        });\\\\n+\\\\n+        _each(keys, function (k) {\\\\n+            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\\\\n+            var taskCallback = function (err) {\\\\n+                var args = Array.prototype.slice.call(arguments, 1);\\\\n+                if (args.length <= 1) {\\\\n+                    args = args[0];\\\\n+                }\\\\n+                if (err) {\\\\n+                    var safeResults = {};\\\\n+                    _each(_keys(results), function(rkey) {\\\\n+                        safeResults[rkey] = results[rkey];\\\\n+                    });\\\\n+                    safeResults[k] = args;\\\\n+                    callback(err, safeResults);\\\\n+                    // stop subsequent errors hitting callback multiple times\\\\n+                    callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    results[k] = args;\\\\n+                    async.setImmediate(taskComplete);\\\\n+                }\\\\n+            };\\\\n+            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\\\\n+            var ready = function () {\\\\n+                return _reduce(requires, function (a, x) {\\\\n+                    return (a && results.hasOwnProperty(x));\\\\n+                }, true) && !results.hasOwnProperty(k);\\\\n+            };\\\\n+            if (ready()) {\\\\n+                task[task.length - 1](taskCallback, results);\\\\n+            }\\\\n+            else {\\\\n+                var listener = function () {\\\\n+                    if (ready()) {\\\\n+                        removeListener(listener);\\\\n+                        task[task.length - 1](taskCallback, results);\\\\n+                    }\\\\n+                };\\\\n+                addListener(listener);\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.retry = function(times, task, callback) {\\\\n+        var DEFAULT_TIMES = 5;\\\\n+        var attempts = [];\\\\n+        // Use defaults if times not passed\\\\n+        if (typeof times === 'function') {\\\\n+            callback = task;\\\\n+            task = times;\\\\n+            times = DEFAULT_TIMES;\\\\n+        }\\\\n+        // Make sure times is a number\\\\n+        times = parseInt(times, 10) || DEFAULT_TIMES;\\\\n+        var wrappedTask = function(wrappedCallback, wrappedResults) {\\\\n+            var retryAttempt = function(task, finalAttempt) {\\\\n+                return function(seriesCallback) {\\\\n+                    task(function(err, result){\\\\n+                        seriesCallback(!err || finalAttempt, {err: err, result: result});\\\\n+                    }, wrappedResults);\\\\n+                };\\\\n+            };\\\\n+            while (times) {\\\\n+                attempts.push(retryAttempt(task, !(times-=1)));\\\\n+            }\\\\n+            async.series(attempts, function(done, data){\\\\n+                data = data[data.length - 1];\\\\n+                (wrappedCallback || callback)(data.err, data.result);\\\\n+            });\\\\n+        }\\\\n+        // If a callback is passed, run this as a controll flow\\\\n+        return callback ? wrappedTask() : wrappedTask\\\\n+    };\\\\n+\\\\n+    async.waterfall = function (tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (!_isArray(tasks)) {\\\\n+          var err = new Error('First argument to waterfall must be an array of functions');\\\\n+          return callback(err);\\\\n+        }\\\\n+        if (!tasks.length) {\\\\n+            return callback();\\\\n+        }\\\\n+        var wrapIterator = function (iterator) {\\\\n+            return function (err) {\\\\n+                if (err) {\\\\n+                    callback.apply(null, arguments);\\\\n+                    callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\n+                    var next = iterator.next();\\\\n+                    if (next) {\\\\n+                        args.push(wrapIterator(next));\\\\n+                    }\\\\n+                    else {\\\\n+                        args.push(callback);\\\\n+                    }\\\\n+                    async.setImmediate(function () {\\\\n+                        iterator.apply(null, args);\\\\n+                    });\\\\n+                }\\\\n+            };\\\\n+        };\\\\n+        wrapIterator(async.iterator(tasks))();\\\\n+    };\\\\n+\\\\n+    var _parallel = function(eachfn, tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (_isArray(tasks)) {\\\\n+            eachfn.map(tasks, function (fn, callback) {\\\\n+                if (fn) {\\\\n+                    fn(function (err) {\\\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\\\n+                        if (args.length <= 1) {\\\\n+                            args = args[0];\\\\n+                        }\\\\n+                        callback.call(null, err, args);\\\\n+                    });\\\\n+                }\\\\n+            }, callback);\\\\n+        }\\\\n+        else {\\\\n+            var results = {};\\\\n+            eachfn.each(_keys(tasks), function (k, callback) {\\\\n+                tasks[k](function (err) {\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\n+                    if (args.length <= 1) {\\\\n+                        args = args[0];\\\\n+                    }\\\\n+                    results[k] = args;\\\\n+                    callback(err);\\\\n+                });\\\\n+            }, function (err) {\\\\n+                callback(err, results);\\\\n+            });\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.parallel = function (tasks, callback) {\\\\n+        _parallel({ map: async.map, each: async.each }, tasks, callback);\\\\n+    };\\\\n+\\\\n+    async.parallelLimit = function(tasks, limit, callback) {\\\\n+        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\\\\n+    };\\\\n+\\\\n+    async.series = function (tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (_isArray(tasks)) {\\\\n+            async.mapSeries(tasks, function (fn, callback) {\\\\n+                if (fn) {\\\\n+                    fn(function (err) {\\\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\\\n+                        if (args.length <= 1) {\\\\n+                            args = args[0];\\\\n+                        }\\\\n+                        callback.call(null, err, args);\\\\n+                    });\\\\n+                }\\\\n+            }, callback);\\\\n+        }\\\\n+        else {\\\\n+            var results = {};\\\\n+            async.eachSeries(_keys(tasks), function (k, callback) {\\\\n+                tasks[k](function (err) {\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\n+                    if (args.length <= 1) {\\\\n+                        args = args[0];\\\\n+                    }\\\\n+                    results[k] = args;\\\\n+                    callback(err);\\\\n+                });\\\\n+            }, function (err) {\\\\n+                callback(err, results);\\\\n+            });\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.iterator = function (tasks) {\\\\n+        var makeCallback = function (index) {\\\\n+            var fn = function () {\\\\n+                if (tasks.length) {\\\\n+                    tasks[index].apply(null, arguments);\\\\n+                }\\\\n+                return fn.next();\\\\n+            };\\\\n+            fn.next = function () {\\\\n+                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\\\\n+            };\\\\n+            return fn;\\\\n+        };\\\\n+        return makeCallback(0);\\\\n+    };\\\\n+\\\\n+    async.apply = function (fn) {\\\\n+        var args = Array.prototype.slice.call(arguments, 1);\\\\n+        return function () {\\\\n+            return fn.apply(\\\\n+                null, args.concat(Array.prototype.slice.call(arguments))\\\\n+            );\\\\n+        };\\\\n+    };\\\\n+\\\\n+    var _concat = function (eachfn, arr, fn, callback) {\\\\n+        var r = [];\\\\n+        eachfn(arr, function (x, cb) {\\\\n+            fn(x, function (err, y) {\\\\n+                r = r.concat(y || []);\\\\n+                cb(err);\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(err, r);\\\\n+        });\\\\n+    };\\\\n+    async.concat = doParallel(_concat);\\\\n+    async.concatSeries = doSeries(_concat);\\\\n+\\\\n+    async.whilst = function (test, iterator, callback) {\\\\n+        if (test()) {\\\\n+            iterator(function (err) {\\\\n+                if (err) {\\\\n+                    return callback(err);\\\\n+                }\\\\n+                async.whilst(test, iterator, callback);\\\\n+            });\\\\n+        }\\\\n+        else {\\\\n+            callback();\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.doWhilst = function (iterator, test, callback) {\\\\n+        iterator(function (err) {\\\\n+            if (err) {\\\\n+                return callback(err);\\\\n+            }\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\n+            if (test.apply(null, args)) {\\\\n+                async.doWhilst(iterator, test, callback);\\\\n+            }\\\\n+            else {\\\\n+                callback();\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.until = function (test, iterator, callback) {\\\\n+        if (!test()) {\\\\n+            iterator(function (err) {\\\\n+                if (err) {\\\\n+                    return callback(err);\\\\n+                }\\\\n+                async.until(test, iterator, callback);\\\\n+            });\\\\n+        }\\\\n+        else {\\\\n+            callback();\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.doUntil = function (iterator, test, callback) {\\\\n+        iterator(function (err) {\\\\n+            if (err) {\\\\n+                return callback(err);\\\\n+            }\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\n+            if (!test.apply(null, args)) {\\\\n+                async.doUntil(iterator, test, callback);\\\\n+            }\\\\n+            else {\\\\n+                callback();\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.queue = function (worker, concurrency) {\\\\n+        if (concurrency === undefined) {\\\\n+            concurrency = 1;\\\\n+        }\\\\n+        function _insert(q, data, pos, callback) {\\\\n+          if (!q.started){\\\\n+            q.started = true;\\\\n+          }\\\\n+          if (!_isArray(data)) {\\\\n+              data = [data];\\\\n+          }\\\\n+          if(data.length == 0) {\\\\n+             // call drain immediately if there are no tasks\\\\n+             return async.setImmediate(function() {\\\\n+                 if (q.drain) {\\\\n+                     q.drain();\\\\n+                 }\\\\n+             });\\\\n+          }\\\\n+          _each(data, function(task) {\\\\n+              var item = {\\\\n+                  data: task,\\\\n+                  callback: typeof callback === 'function' ? callback : null\\\\n+              };\\\\n+\\\\n+              if (pos) {\\\\n+                q.tasks.unshift(item);\\\\n+              } else {\\\\n+                q.tasks.push(item);\\\\n+              }\\\\n+\\\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\\\n+                  q.saturated();\\\\n+              }\\\\n+              async.setImmediate(q.process);\\\\n+          });\\\\n+        }\\\\n+\\\\n+        var workers = 0;\\\\n+        var q = {\\\\n+            tasks: [],\\\\n+            concurrency: concurrency,\\\\n+            saturated: null,\\\\n+            empty: null,\\\\n+            drain: null,\\\\n+            started: false,\\\\n+            paused: false,\\\\n+            push: function (data, callback) {\\\\n+              _insert(q, data, false, callback);\\\\n+            },\\\\n+            kill: function () {\\\\n+              q.drain = null;\\\\n+              q.tasks = [];\\\\n+            },\\\\n+            unshift: function (data, callback) {\\\\n+              _insert(q, data, true, callback);\\\\n+            },\\\\n+            process: function () {\\\\n+                if (!q.paused && workers < q.concurrency && q.tasks.length) {\\\\n+                    var task = q.tasks.shift();\\\\n+                    if (q.empty && q.tasks.length === 0) {\\\\n+                        q.empty();\\\\n+                    }\\\\n+                    workers += 1;\\\\n+                    var next = function () {\\\\n+                        workers -= 1;\\\\n+                        if (task.callback) {\\\\n+                            task.callback.apply(task, arguments);\\\\n+                        }\\\\n+                        if (q.drain && q.tasks.length + workers === 0) {\\\\n+                            q.drain();\\\\n+                        }\\\\n+                        q.process();\\\\n+                    };\\\\n+                    var cb = only_once(next);\\\\n+                    worker(task.data, cb);\\\\n+                }\\\\n+            },\\\\n+            length: function () {\\\\n+                return q.tasks.length;\\\\n+            },\\\\n+            running: function () {\\\\n+                return workers;\\\\n+            },\\\\n+            idle: function() {\\\\n+                return q.tasks.length + workers === 0;\\\\n+            },\\\\n+            pause: function () {\\\\n+                if (q.paused === true) { return; }\\\\n+                q.paused = true;\\\\n+                q.process();\\\\n+            },\\\\n+            resume: function () {\\\\n+                if (q.paused === false) { return; }\\\\n+                q.paused = false;\\\\n+                q.process();\\\\n+            }\\\\n+        };\\\\n+        return q;\\\\n+    };\\\\n+    \\\\n+    async.priorityQueue = function (worker, concurrency) {\\\\n+        \\\\n+        function _compareTasks(a, b){\\\\n+          return a.priority - b.priority;\\\\n+        };\\\\n+        \\\\n+        function _binarySearch(sequence, item, compare) {\\\\n+          var beg = -1,\\\\n+              end = sequence.length - 1;\\\\n+          while (beg < end) {\\\\n+            var mid = beg + ((end - beg + 1) >>> 1);\\\\n+            if (compare(item, sequence[mid]) >= 0) {\\\\n+              beg = mid;\\\\n+            } else {\\\\n+              end = mid - 1;\\\\n+            }\\\\n+          }\\\\n+          return beg;\\\\n+        }\\\\n+        \\\\n+        function _insert(q, data, priority, callback) {\\\\n+          if (!q.started){\\\\n+            q.started = true;\\\\n+          }\\\\n+          if (!_isArray(data)) {\\\\n+              data = [data];\\\\n+          }\\\\n+          if(data.length == 0) {\\\\n+             // call drain immediately if there are no tasks\\\\n+             return async.setImmediate(function() {\\\\n+                 if (q.drain) {\\\\n+                     q.drain();\\\\n+                 }\\\\n+             });\\\\n+          }\\\\n+          _each(data, function(task) {\\\\n+              var item = {\\\\n+                  data: task,\\\\n+                  priority: priority,\\\\n+                  callback: typeof callback === 'function' ? callback : null\\\\n+              };\\\\n+              \\\\n+              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\\\\n+\\\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\\\n+                  q.saturated();\\\\n+              }\\\\n+              async.setImmediate(q.process);\\\\n+          });\\\\n+        }\\\\n+        \\\\n+        // Start with a normal queue\\\\n+        var q = async.queue(worker, concurrency);\\\\n+        \\\\n+        // Override push to accept second parameter representing priority\\\\n+        q.push = function (data, priority, callback) {\\\\n+          _insert(q, data, priority, callback);\\\\n+        };\\\\n+        \\\\n+        // Remove unshift function\\\\n+        delete q.unshift;\\\\n+\\\\n+        return q;\\\\n+    };\\\\n+\\\\n+    async.cargo = function (worker, payload) {\\\\n+        var working     = false,\\\\n+            tasks       = [];\\\\n+\\\\n+        var cargo = {\\\\n+            tasks: tasks,\\\\n+            payload: payload,\\\\n+            saturated: null,\\\\n+            empty: null,\\\\n+            drain: null,\\\\n+            drained: true,\\\\n+            push: function (data, callback) {\\\\n+                if (!_isArray(data)) {\\\\n+                    data = [data];\\\\n+                }\\\\n+                _each(data, function(task) {\\\\n+                    tasks.push({\\\\n+                        data: task,\\\\n+                        callback: typeof callback === 'function' ? callback : null\\\\n+                    });\\\\n+                    cargo.drained = false;\\\\n+                    if (cargo.saturated && tasks.length === payload) {\\\\n+                        cargo.saturated();\\\\n+                    }\\\\n+                });\\\\n+                async.setImmediate(cargo.process);\\\\n+            },\\\\n+            process: function process() {\\\\n+                if (working) return;\\\\n+                if (tasks.length === 0) {\\\\n+                    if(cargo.drain && !cargo.drained) cargo.drain();\\\\n+                    cargo.drained = true;\\\\n+                    return;\\\\n+                }\\\\n+\\\\n+                var ts = typeof payload === 'number'\\\\n+                            ? tasks.splice(0, payload)\\\\n+                            : tasks.splice(0, tasks.length);\\\\n+\\\\n+                var ds = _map(ts, function (task) {\\\\n+                    return task.data;\\\\n+                });\\\\n+\\\\n+                if(cargo.empty) cargo.empty();\\\\n+                working = true;\\\\n+                worker(ds, function () {\\\\n+                    working = false;\\\\n+\\\\n+                    var args = arguments;\\\\n+                    _each(ts, function (data) {\\\\n+                        if (data.callback) {\\\\n+                            data.callback.apply(null, args);\\\\n+                        }\\\\n+                    });\\\\n+\\\\n+                    process();\\\\n+                });\\\\n+            },\\\\n+            length: function () {\\\\n+                return tasks.length;\\\\n+            },\\\\n+            running: function () {\\\\n+                return working;\\\\n+            }\\\\n+        };\\\\n+        return cargo;\\\\n+    };\\\\n+\\\\n+    var _console_fn = function (name) {\\\\n+        return function (fn) {\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\n+            fn.apply(null, args.concat([function (err) {\\\\n+                var args = Array.prototype.slice.call(arguments, 1);\\\\n+                if (typeof console !== 'undefined') {\\\\n+                    if (err) {\\\\n+                        if (console.error) {\\\\n+                            console.error(err);\\\\n+                        }\\\\n+                    }\\\\n+                    else if (console[name]) {\\\\n+                        _each(args, function (x) {\\\\n+                            console[name](x);\\\\n+                        });\\\\n+                    }\\\\n+                }\\\\n+            }]));\\\\n+        };\\\\n+    };\\\\n+    async.log = _console_fn('log');\\\\n+    async.dir = _console_fn('dir');\\\\n+    /*async.info = _console_fn('info');\\\\n+    async.warn = _console_fn('warn');\\\\n+    async.error = _console_fn('error');*/\\\\n+\\\\n+    async.memoize = function (fn, hasher) {\\\\n+        var memo = {};\\\\n+        var queues = {};\\\\n+        hasher = hasher || function (x) {\\\\n+            return x;\\\\n+        };\\\\n+        var memoized = function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            var callback = args.pop();\\\\n+            var key = hasher.apply(null, args);\\\\n+            if (key in memo) {\\\\n+                async.nextTick(function () {\\\\n+                    callback.apply(null, memo[key]);\\\\n+                });\\\\n+            }\\\\n+            else if (key in queues) {\\\\n+                queues[key].push(callback);\\\\n+            }\\\\n+            else {\\\\n+                queues[key] = [callback];\\\\n+                fn.apply(null, args.concat([function () {\\\\n+                    memo[key] = arguments;\\\\n+                    var q = queues[key];\\\\n+                    delete queues[key];\\\\n+                    for (var i = 0, l = q.length; i < l; i++) {\\\\n+                      q[i].apply(null, arguments);\\\\n+                    }\\\\n+                }]));\\\\n+            }\\\\n+        };\\\\n+        memoized.memo = memo;\\\\n+        memoized.unmemoized = fn;\\\\n+        return memoized;\\\\n+    };\\\\n+\\\\n+    async.unmemoize = function (fn) {\\\\n+      return function () {\\\\n+        return (fn.unmemoized || fn).apply(null, arguments);\\\\n+      };\\\\n+    };\\\\n+\\\\n+    async.times = function (count, iterator, callback) {\\\\n+        var counter = [];\\\\n+        for (var i = 0; i < count; i++) {\\\\n+            counter.push(i);\\\\n+        }\\\\n+        return async.map(counter, iterator, callback);\\\\n+    };\\\\n+\\\\n+    async.timesSeries = function (count, iterator, callback) {\\\\n+        var counter = [];\\\\n+        for (var i = 0; i < count; i++) {\\\\n+            counter.push(i);\\\\n+        }\\\\n+        return async.mapSeries(counter, iterator, callback);\\\\n+    };\\\\n+\\\\n+    async.seq = function (/* functions... */) {\\\\n+        var fns = arguments;\\\\n+        return function () {\\\\n+            var that = this;\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            var callback = args.pop();\\\\n+            async.reduce(fns, args, function (newargs, fn, cb) {\\\\n+                fn.apply(that, newargs.concat([function () {\\\\n+                    var err = arguments[0];\\\\n+                    var nextargs = Array.prototype.slice.call(arguments, 1);\\\\n+                    cb(err, nextargs);\\\\n+                }]))\\\\n+            },\\\\n+            function (err, results) {\\\\n+                callback.apply(that, [err].concat(results));\\\\n+            });\\\\n+        };\\\\n+    };\\\\n+\\\\n+    async.compose = function (/* functions... */) {\\\\n+      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\\\\n+    };\\\\n+\\\\n+    var _applyEach = function (eachfn, fns /*args...*/) {\\\\n+        var go = function () {\\\\n+            var that = this;\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            var callback = args.pop();\\\\n+            return eachfn(fns, function (fn, cb) {\\\\n+                fn.apply(that, args.concat([cb]));\\\\n+            },\\\\n+            callback);\\\\n+        };\\\\n+        if (arguments.length > 2) {\\\\n+            var args = Array.prototype.slice.call(arguments, 2);\\\\n+            return go.apply(this, args);\\\\n+        }\\\\n+        else {\\\\n+            return go;\\\\n+        }\\\\n+    };\\\\n+    async.applyEach = doParallel(_applyEach);\\\\n+    async.applyEachSeries = doSeries(_applyEach);\\\\n+\\\\n+    async.forever = function (fn, callback) {\\\\n+        function next(err) {\\\\n+            if (err) {\\\\n+                if (callback) {\\\\n+                    return callback(err);\\\\n+                }\\\\n+                throw err;\\\\n+            }\\\\n+            fn(next);\\\\n+        }\\\\n+        next();\\\\n+    };\\\\n+\\\\n+    // Node.js\\\\n+    if (typeof module !== 'undefined' && module.exports) {\\\\n+        module.exports = async;\\\\n+    }\\\\n+    // AMD / RequireJS\\\\n+    else if (typeof define !== 'undefined' && define.amd) {\\\\n+        define([], function () {\\\\n+            return async;\\\\n+        });\\\\n+    }\\\\n+    // included directly via <script> tag\\\\n+    else {\\\\n+        root.async = async;\\\\n+    }\\\\n+\\\\n+}());\\\\ndiff --git a/node_modules/async/package.json b/node_modules/async/package.json\\\\nnew file mode 100644\\\\nindex 0000000..31a5200\\\\n--- /dev/null\\\\n+++ b/node_modules/async/package.json\\\\n@@ -0,0 +1,59 @@\\\\n+{\\\\n+  \\\\\\\"name\\\\\\\": \\\\\\\"async\\\\\\\",\\\\n+  \\\\\\\"description\\\\\\\": \\\\\\\"Higher-order functions and common patterns for asynchronous code\\\\\\\",\\\\n+  \\\\\\\"main\\\\\\\": \\\\\\\"./lib/async\\\\\\\",\\\\n+  \\\\\\\"author\\\\\\\": {\\\\n+    \\\\\\\"name\\\\\\\": \\\\\\\"Caolan McMahon\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"version\\\\\\\": \\\\\\\"0.9.0\\\\\\\",\\\\n+  \\\\\\\"repository\\\\\\\": {\\\\n+    \\\\\\\"type\\\\\\\": \\\\\\\"git\\\\\\\",\\\\n+    \\\\\\\"url\\\\\\\": \\\\\\\"https://github.com/caolan/async.git\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"bugs\\\\\\\": {\\\\n+    \\\\\\\"url\\\\\\\": \\\\\\\"https://github.com/caolan/async/issues\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"licenses\\\\\\\": [\\\\n+    {\\\\n+      \\\\\\\"type\\\\\\\": \\\\\\\"MIT\\\\\\\",\\\\n+      \\\\\\\"url\\\\\\\": \\\\\\\"https://github.com/caolan/async/raw/master/LICENSE\\\\\\\"\\\\n+    }\\\\n+  ],\\\\n+  \\\\\\\"devDependencies\\\\\\\": {\\\\n+    \\\\\\\"nodeunit\\\\\\\": \\\\\\\">0.0.0\\\\\\\",\\\\n+    \\\\\\\"uglify-js\\\\\\\": \\\\\\\"1.2.x\\\\\\\",\\\\n+    \\\\\\\"nodelint\\\\\\\": \\\\\\\">0.0.0\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"jam\\\\\\\": {\\\\n+    \\\\\\\"main\\\\\\\": \\\\\\\"lib/async.js\\\\\\\",\\\\n+    \\\\\\\"include\\\\\\\": [\\\\n+      \\\\\\\"lib/async.js\\\\\\\",\\\\n+      \\\\\\\"README.md\\\\\\\",\\\\n+      \\\\\\\"LICENSE\\\\\\\"\\\\n+    ]\\\\n+  },\\\\n+  \\\\\\\"scripts\\\\\\\": {\\\\n+    \\\\\\\"test\\\\\\\": \\\\\\\"nodeunit test/test-async.js\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"homepage\\\\\\\": \\\\\\\"https://github.com/caolan/async\\\\\\\",\\\\n+  \\\\\\\"_id\\\\\\\": \\\\\\\"async@0.9.0\\\\\\\",\\\\n+  \\\\\\\"dist\\\\\\\": {\\\\n+    \\\\\\\"shasum\\\\\\\": \\\\\\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\\\\\",\\\\n+    \\\\\\\"tarball\\\\\\\": \\\\\\\"http://registry.npmjs.org/async/-/async-0.9.0.tgz\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"_from\\\\\\\": \\\\\\\"async@*\\\\\\\",\\\\n+  \\\\\\\"_npmVersion\\\\\\\": \\\\\\\"1.4.3\\\\\\\",\\\\n+  \\\\\\\"_npmUser\\\\\\\": {\\\\n+    \\\\\\\"name\\\\\\\": \\\\\\\"caolan\\\\\\\",\\\\n+    \\\\\\\"email\\\\\\\": \\\\\\\"caolan.mcmahon@gmail.com\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"maintainers\\\\\\\": [\\\\n+    {\\\\n+      \\\\\\\"name\\\\\\\": \\\\\\\"caolan\\\\\\\",\\\\n+      \\\\\\\"email\\\\\\\": \\\\\\\"caolan@caolanmcmahon.com\\\\\\\"\\\\n+    }\\\\n+  ],\\\\n+  \\\\\\\"directories\\\\\\\": {},\\\\n+  \\\\\\\"_shasum\\\\\\\": \\\\\\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\\\\\",\\\\n+  \\\\\\\"_resolved\\\\\\\": \\\\\\\"https://registry.npmjs.org/async/-/async-0.9.0.tgz\\\\\\\"\\\\n+}\\\\ndiff --git a/package.json b/package.json\\\\nindex 5f21627..6033d43 100644\\\\n--- a/package.json\\\\n+++ b/package.json\\\\n@@ -4,7 +4,8 @@\\\\n   \\\\\\\"description\\\\\\\": \\\\\\\"Sous project\\\\\\\",\\\\n   \\\\\\\"main\\\\\\\": \\\\\\\"main.js\\\\\\\",\\\\n   \\\\\\\"dependencies\\\\\\\": {\\\\n-},\\\\n+    \\\\\\\"async\\\\\\\": \\\\\\\"*\\\\\\\"\\\\n+  },\\\\n   \\\\\\\"devDependencies\\\\\\\": {},\\\\n   \\\\\\\"scripts\\\\\\\": {\\\\n     \\\\\\\"test\\\\\\\": \\\\\\\"echo \\\\\\\\\\\\\\\"Error: no test specified\\\\\\\\\\\\\\\" && exit 1\\\\\\\"\\\\ndiff --git a/patches.sousp b/patches.sousp\\\\nindex 16405a3..d71e511 100644\\\\n--- a/patches.sousp\\\\n+++ b/patches.sousp\\\\n@@ -1,31 +1 @@\\\\n-diff --git a/main.js b/main.js\\\\n-index f81b54e..744cdd5 100644\\\\n---- a/main.js\\\\n-+++ b/main.js\\\\n-@@ -35,7 +35,7 @@ fs.exists('.git', function (exists) {\\\\n-         cp.exec('git diff', function(error, stdout, stderr) {\\\\n-             console.log(stdout);\\\\n- \\\\n--            //fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", stdout);\\\\n-+            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", stdout);\\\\n- \\\\n-             if (error !== null) {\\\\n-                 console.log('stderr: ' + stderr);\\\\n-@@ -44,7 +44,7 @@ fs.exists('.git', function (exists) {\\\\n-         });\\\\n- \\\\n-         cp.exec('git log', function(error, stdout, stderr) {\\\\n--            //console.log(stdout);\\\\n-+            console.log(stdout);\\\\n- \\\\n-             var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n-             var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n-@@ -53,7 +53,7 @@ fs.exists('.git', function (exists) {\\\\n-             console.log(comments);\\\\n-             console.log(dates);\\\\n- \\\\n--            //fs.writeFileSync(\\\\\\\"comments.sousc\\\\\\\", stdout);\\\\n-+            fs.writeFileSync(\\\\\\\"comments.sousc\\\\\\\", stdout);\\\\n- \\\\n-             if (error !== null) {\\\\n-                 console.log('stderr: ' + stderr);\\\\n+[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]\\\\n\\\\\\\\ No newline at end of file\\\\ndiff --git a/test.js b/test.js\\\\nnew file mode 100644\\\\nindex 0000000..5ca759c\\\\n--- /dev/null\\\\n+++ b/test.js\\\\n@@ -0,0 +1,21 @@\\\\n+/**\\\\n+ * Created by Nick on 18.05.2015.\\\\n+ */\\\\n+var async = require('async')\\\\n+    , tasksIndex = [\\\\n+        function (callback) {\\\\n+            // Вымышленный метод который вернет 231\\\\n+            var viewsNumber = models.stat.viewsNumber();\\\\n+            callback(null, viewsNumber);\\\\n+        }\\\\n+        , function (callback) {\\\\n+            // Вымышленный метод который вернет 24\\\\n+            var growFactor = models.stat.growFactor();\\\\n+            callback(null, growFactor);\\\\n+        }\\\\n+    ];\\\\n+\\\\n+async.series(tasksIndex, function (err, results) {\\\\n+    // Результат будет массивом\\\\n+    console.log(results); // [231, 24]\\\\n+});\\\\n\\\\\\\\ No newline at end of file\\\\n\\\"}\\n\\\\ No newline at end of file\\ndiff --git a/patches.txt b/patches.txt\\nnew file mode 100644\\nindex 0000000..300c6a9\\n--- /dev/null\\n+++ b/patches.txt\\n@@ -0,0 +1 @@\\n+{\\\"commit\\\":\\\"1e947f613e976945de85ae35ed923aa470f0be72\\\",\\\"author\\\":\\\"Nick Stepanenko <massaalonso@yandex.ru>\\\",\\\"date\\\":\\\"Tue May 19 00:12:12 2015 +0800\\\",\\\"comment\\\":\\\"Latest updates\\\",\\\"content\\\":\\\"diff --git a/comments.sousc b/comments.sousc\\\\nindex 150b0f6..cb3a850 100644\\\\n--- a/comments.sousc\\\\n+++ b/comments.sousc\\\\n@@ -1,3 +1,27 @@\\\\n+commit 4420cabefc1f470af341af11ed595df67e25c51f\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 17:05:35 2015 +0800\\\\n+\\\\n+    Paste old program code\\\\n+\\\\n+commit 9ef3d25fd4c3afdbcc3107a0abf6d7a2e29cb4dd\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 17:04:52 2015 +0800\\\\n+\\\\n+    Adding new file\\\\n+\\\\n+commit 64814d140d2fab6ae153cac485008119f29bf230\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 17:03:58 2015 +0800\\\\n+\\\\n+    From clear list\\\\n+\\\\n+commit c9d318fea74ea288d544ecf72f00b12c130cf2ef\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 16:59:40 2015 +0800\\\\n+\\\\n+    Create system files\\\\n+\\\\n commit e3c853a4282dfe8f000685dc1d39bd55a4a946c4\\\\n Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n Date:   Sun May 17 16:54:58 2015 +0800\\\\ndiff --git a/main.js b/main.js\\\\nindex e34dc18..86f30c2 100644\\\\n--- a/main.js\\\\n+++ b/main.js\\\\n@@ -3,6 +3,56 @@\\\\n  */\\\\n \\\\n var fs = require('fs');\\\\n+var cp = require('child_process');\\\\n+var data = [];\\\\n+\\\\n+var async = require('async');\\\\n+    /*tasks = [\\\\n+        function (callback) {\\\\n+            cp.exec('git log', function(error, stdout, stderr) {\\\\n+                var listOfCommits = [];\\\\n+                var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n+                var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n+                var comments = findComments(stdout);\\\\n+                var commitNumbers = findCommitNumbers(stdout);\\\\n+\\\\n+                for(i=0; i<authors.length; i++) {\\\\n+                    var commit = {\\\\n+                        \\\\\\\"commit\\\\\\\": commitNumbers[i],\\\\n+                        \\\\\\\"author\\\\\\\": authors[i],\\\\n+                        \\\\\\\"date\\\\\\\": dates[i],\\\\n+                        \\\\\\\"comment\\\\\\\": comments[i],\\\\n+                        \\\\\\\"content\\\\\\\": 'Original'\\\\n+                    };\\\\n+\\\\n+                    listOfCommits[listOfCommits.length] = commit;\\\\n+                }\\\\n+\\\\n+                data = listOfCommits.reverse();\\\\n+\\\\n+                callback(null, data);\\\\n+\\\\n+                if (error !== null) {\\\\n+                    console.log('stderr: ' + stderr);\\\\n+                    console.log('exec error: ' + error);\\\\n+                }\\\\n+            });\\\\n+        }\\\\n+    ],\\\\n+    secondTasks = [\\\\n+        function some_function(callback) {\\\\n+            cp.exec('git diff', function(error, stdout, stderr) {\\\\n+                var currentContent = stdout;\\\\n+\\\\n+                if (error !== null) {\\\\n+                    console.log('stderr: ' + stderr);\\\\n+                    console.log('exec error: ' + error);\\\\n+                }\\\\n+\\\\n+                callback(null, currentContent);\\\\n+            });\\\\n+        }\\\\n+    ];*/\\\\n \\\\n function findData(text, keyword) {\\\\n     var data = [];\\\\n@@ -28,38 +78,106 @@ function findComments(text) {\\\\n     return comments;\\\\n }\\\\n \\\\n+function findCommitNumbers(text) {\\\\n+    var commits = [];\\\\n+    var splittext = text.split('\\\\\\\\n');\\\\n+\\\\n+    for(i=0; i<splittext.length; i++) {\\\\n+        if(splittext[i].slice(0, 6) == \\\\\\\"commit\\\\\\\") {\\\\n+            commits[commits.length] = splittext[i].slice(6).trim();\\\\n+        }\\\\n+    }\\\\n+\\\\n+    return commits;\\\\n+}\\\\n+\\\\n+/*function pullCommitContent(first, second) {\\\\n+\\\\n+    cp.exec('git diff' + ' ' + first + ' ' + second, function(error, stdout, stderr) {\\\\n+        var currentContent = stdout;\\\\n+\\\\n+        if (error !== null) {\\\\n+            console.log('stderr: ' + stderr);\\\\n+            console.log('exec error: ' + error);\\\\n+        }\\\\n+\\\\n+        return currentContent;\\\\n+    });\\\\n+}*/\\\\n+\\\\n+var commitsInfo = [];\\\\n+\\\\n fs.exists('.git', function (exists) {\\\\n     if(exists) {\\\\n-        var cp = require('child_process');\\\\n+        /*async.series(tasks, function(err, result) {\\\\n+            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", JSON.stringify(result));\\\\n+\\\\n+            var data = result[0];\\\\n \\\\n-        cp.exec('git diff', function(error, stdout, stderr) {\\\\n-            console.log(stdout);\\\\n+            /*function some_function(arg1, arg2, callback) {\\\\n+                cp.exec('git diff' + ' ' + arg1 + ' ' + arg2, function(error, stdout, stderr) {\\\\n+                    var currentContent = 54321;//stdout;\\\\n \\\\n-            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", stdout);\\\\n+                    if (error !== null) {\\\\n+                        console.log('stderr: ' + stderr);\\\\n+                        console.log('exec error: ' + error);\\\\n+                    }\\\\n \\\\n-            if (error !== null) {\\\\n-                console.log('stderr: ' + stderr);\\\\n-                console.log('exec error: ' + error);\\\\n+                    callback(null, currentContent);\\\\n+                });\\\\n             }\\\\n-        });\\\\n+        });*/\\\\n+\\\\n+        async.waterfall([\\\\n+            function getCommitsInfo(callback) {\\\\n+                cp.exec('git log', function(error, stdout, stderr) {\\\\n+                    var listOfCommits = [];\\\\n+                    var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n+                    var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n+                    var comments = findComments(stdout);\\\\n+                    var commitNumbers = findCommitNumbers(stdout);\\\\n \\\\n-        cp.exec('git log', function(error, stdout, stderr) {\\\\n-            console.log(stdout);\\\\n+                    for(i=0; i<authors.length; i++) {\\\\n+                        var commit = {\\\\n+                            \\\\\\\"commit\\\\\\\": commitNumbers[i],\\\\n+                            \\\\\\\"author\\\\\\\": authors[i],\\\\n+                            \\\\\\\"date\\\\\\\": dates[i],\\\\n+                            \\\\\\\"comment\\\\\\\": comments[i],\\\\n+                            \\\\\\\"content\\\\\\\": 'Original'\\\\n+                        };\\\\n+                        listOfCommits[listOfCommits.length] = commit;\\\\n+                    }\\\\n \\\\n-            var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n-            var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n-            var comments = findComments(stdout);\\\\n-            console.log(authors);\\\\n-            console.log(comments);\\\\n-            console.log(dates);\\\\n+                    callback(null, listOfCommits.reverse());\\\\n \\\\n-            fs.writeFileSync(\\\\\\\"comments.sousc\\\\\\\", stdout);\\\\n+                    if (error !== null) {\\\\n+                        console.log('stderr: ' + stderr);\\\\n+                        console.log('exec error: ' + error);\\\\n+                    }\\\\n+                });\\\\n+            },\\\\n+            function getCommitsContent(commits, callback) {\\\\n+                console.log(commits);\\\\n+                var commitsData = commits;\\\\n \\\\n-            if (error !== null) {\\\\n-                console.log('stderr: ' + stderr);\\\\n-                console.log('exec error: ' + error);\\\\n+                for(i=1; i<commitsData.length; i++) {\\\\n+                    cp.exec('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit, function(error, stdout, stderr) {\\\\n+                        commitsData[i].content = stdout;\\\\n+\\\\n+                        if (error !== null) {\\\\n+                            console.log('stderr: ' + stderr);\\\\n+                            console.log('exec error: ' + error);\\\\n+                        }\\\\n+                    });\\\\n+                }\\\\n+\\\\n+                callback(null, commitsData);\\\\n             }\\\\n+        ], function (err, result) {\\\\n+            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", result);\\\\n         });\\\\n+\\\\n+        //commitsInfo = JSON.parse(fs.readFileSync(\\\\\\\"patches.sousp\\\\\\\"));\\\\n+        //console.log(commitsInfo);\\\\n     }\\\\n-    else console.log(\\\\\\\"Error.\\\\\\\");\\\\n });\\\\n\\\\\\\\ No newline at end of file\\\\ndiff --git a/node_modules/async/.travis.yml b/node_modules/async/.travis.yml\\\\nnew file mode 100644\\\\nindex 0000000..6e5919d\\\\n--- /dev/null\\\\n+++ b/node_modules/async/.travis.yml\\\\n@@ -0,0 +1,3 @@\\\\n+language: node_js\\\\n+node_js:\\\\n+  - \\\\\\\"0.10\\\\\\\"\\\\ndiff --git a/node_modules/async/LICENSE b/node_modules/async/LICENSE\\\\nnew file mode 100644\\\\nindex 0000000..8f29698\\\\n--- /dev/null\\\\n+++ b/node_modules/async/LICENSE\\\\n@@ -0,0 +1,19 @@\\\\n+Copyright (c) 2010-2014 Caolan McMahon\\\\n+\\\\n+Permission is hereby granted, free of charge, to any person obtaining a copy\\\\n+of this software and associated documentation files (the \\\\\\\"Software\\\\\\\"), to deal\\\\n+in the Software without restriction, including without limitation the rights\\\\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\\\n+copies of the Software, and to permit persons to whom the Software is\\\\n+furnished to do so, subject to the following conditions:\\\\n+\\\\n+The above copyright notice and this permission notice shall be included in\\\\n+all copies or substantial portions of the Software.\\\\n+\\\\n+THE SOFTWARE IS PROVIDED \\\\\\\"AS IS\\\\\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\\\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\\\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\\\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\\\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\\\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\\\n+THE SOFTWARE.\\\\ndiff --git a/node_modules/async/README.md b/node_modules/async/README.md\\\\nnew file mode 100644\\\\nindex 0000000..0bea531\\\\n--- /dev/null\\\\n+++ b/node_modules/async/README.md\\\\n@@ -0,0 +1,1646 @@\\\\n+# Async.js\\\\n+\\\\n+[![Build Status via Travis CI](https://travis-ci.org/caolan/async.svg?branch=master)](https://travis-ci.org/caolan/async)\\\\n+\\\\n+\\\\n+Async is a utility module which provides straight-forward, powerful functions\\\\n+for working with asynchronous JavaScript. Although originally designed for\\\\n+use with [Node.js](http://nodejs.org), it can also be used directly in the\\\\n+browser. Also supports [component](https://github.com/component/component).\\\\n+\\\\n+Async provides around 20 functions that include the usual 'functional'\\\\n+suspects (`map`, `reduce`, `filter`, `each`…) as well as some common patterns\\\\n+for asynchronous control flow (`parallel`, `series`, `waterfall`…). All these\\\\n+functions assume you follow the Node.js convention of providing a single\\\\n+callback as the last argument of your `async` function.\\\\n+\\\\n+\\\\n+## Quick Examples\\\\n+\\\\n+```javascript\\\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\\\n+    // results is now an array of stats for each file\\\\n+});\\\\n+\\\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\\\n+    // results now equals an array of the existing files\\\\n+});\\\\n+\\\\n+async.parallel([\\\\n+    function(){ ... },\\\\n+    function(){ ... }\\\\n+], callback);\\\\n+\\\\n+async.series([\\\\n+    function(){ ... },\\\\n+    function(){ ... }\\\\n+]);\\\\n+```\\\\n+\\\\n+There are many more functions available so take a look at the docs below for a\\\\n+full list. This module aims to be comprehensive, so if you feel anything is\\\\n+missing please create a GitHub issue for it.\\\\n+\\\\n+## Common Pitfalls\\\\n+\\\\n+### Binding a context to an iterator\\\\n+\\\\n+This section is really about `bind`, not about `async`. If you are wondering how to\\\\n+make `async` execute your iterators in a given context, or are confused as to why\\\\n+a method of another library isn't working as an iterator, study this example:\\\\n+\\\\n+```js\\\\n+// Here is a simple object with an (unnecessarily roundabout) squaring method\\\\n+var AsyncSquaringLibrary = {\\\\n+  squareExponent: 2,\\\\n+  square: function(number, callback){ \\\\n+    var result = Math.pow(number, this.squareExponent);\\\\n+    setTimeout(function(){\\\\n+      callback(null, result);\\\\n+    }, 200);\\\\n+  }\\\\n+};\\\\n+\\\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square, function(err, result){\\\\n+  // result is [NaN, NaN, NaN]\\\\n+  // This fails because the `this.squareExponent` expression in the square\\\\n+  // function is not evaluated in the context of AsyncSquaringLibrary, and is\\\\n+  // therefore undefined.\\\\n+});\\\\n+\\\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), function(err, result){\\\\n+  // result is [1, 4, 9]\\\\n+  // With the help of bind we can attach a context to the iterator before\\\\n+  // passing it to async. Now the square function will be executed in its \\\\n+  // 'home' AsyncSquaringLibrary context and the value of `this.squareExponent`\\\\n+  // will be as expected.\\\\n+});\\\\n+```\\\\n+\\\\n+## Download\\\\n+\\\\n+The source is available for download from\\\\n+[GitHub](http://github.com/caolan/async).\\\\n+Alternatively, you can install using Node Package Manager (`npm`):\\\\n+\\\\n+    npm install async\\\\n+\\\\n+__Development:__ [async.js](https://github.com/caolan/async/raw/master/lib/async.js) - 29.6kb Uncompressed\\\\n+\\\\n+## In the Browser\\\\n+\\\\n+So far it's been tested in IE6, IE7, IE8, FF3.6 and Chrome 5. \\\\n+\\\\n+Usage:\\\\n+\\\\n+```html\\\\n+<script type=\\\\\\\"text/javascript\\\\\\\" src=\\\\\\\"async.js\\\\\\\"></script>\\\\n+<script type=\\\\\\\"text/javascript\\\\\\\">\\\\n+\\\\n+    async.map(data, asyncProcess, function(err, results){\\\\n+        alert(results);\\\\n+    });\\\\n+\\\\n+</script>\\\\n+```\\\\n+\\\\n+## Documentation\\\\n+\\\\n+### Collections\\\\n+\\\\n+* [`each`](#each)\\\\n+* [`eachSeries`](#eachSeries)\\\\n+* [`eachLimit`](#eachLimit)\\\\n+* [`map`](#map)\\\\n+* [`mapSeries`](#mapSeries)\\\\n+* [`mapLimit`](#mapLimit)\\\\n+* [`filter`](#filter)\\\\n+* [`filterSeries`](#filterSeries)\\\\n+* [`reject`](#reject)\\\\n+* [`rejectSeries`](#rejectSeries)\\\\n+* [`reduce`](#reduce)\\\\n+* [`reduceRight`](#reduceRight)\\\\n+* [`detect`](#detect)\\\\n+* [`detectSeries`](#detectSeries)\\\\n+* [`sortBy`](#sortBy)\\\\n+* [`some`](#some)\\\\n+* [`every`](#every)\\\\n+* [`concat`](#concat)\\\\n+* [`concatSeries`](#concatSeries)\\\\n+\\\\n+### Control Flow\\\\n+\\\\n+* [`series`](#seriestasks-callback)\\\\n+* [`parallel`](#parallel)\\\\n+* [`parallelLimit`](#parallellimittasks-limit-callback)\\\\n+* [`whilst`](#whilst)\\\\n+* [`doWhilst`](#doWhilst)\\\\n+* [`until`](#until)\\\\n+* [`doUntil`](#doUntil)\\\\n+* [`forever`](#forever)\\\\n+* [`waterfall`](#waterfall)\\\\n+* [`compose`](#compose)\\\\n+* [`seq`](#seq)\\\\n+* [`applyEach`](#applyEach)\\\\n+* [`applyEachSeries`](#applyEachSeries)\\\\n+* [`queue`](#queue)\\\\n+* [`priorityQueue`](#priorityQueue)\\\\n+* [`cargo`](#cargo)\\\\n+* [`auto`](#auto)\\\\n+* [`retry`](#retry)\\\\n+* [`iterator`](#iterator)\\\\n+* [`apply`](#apply)\\\\n+* [`nextTick`](#nextTick)\\\\n+* [`times`](#times)\\\\n+* [`timesSeries`](#timesSeries)\\\\n+\\\\n+### Utils\\\\n+\\\\n+* [`memoize`](#memoize)\\\\n+* [`unmemoize`](#unmemoize)\\\\n+* [`log`](#log)\\\\n+* [`dir`](#dir)\\\\n+* [`noConflict`](#noConflict)\\\\n+\\\\n+\\\\n+## Collections\\\\n+\\\\n+<a name=\\\\\\\"forEach\\\\\\\" />\\\\n+<a name=\\\\\\\"each\\\\\\\" />\\\\n+### each(arr, iterator, callback)\\\\n+\\\\n+Applies the function `iterator` to each item in `arr`, in parallel.\\\\n+The `iterator` is called with an item from the list, and a callback for when it\\\\n+has finished. If the `iterator` passes an error to its `callback`, the main\\\\n+`callback` (for the `each` function) is immediately called with the error.\\\\n+\\\\n+Note, that since this function applies `iterator` to each item in parallel,\\\\n+there is no guarantee that the iterator functions will complete in order.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err)` which must be called once it has \\\\n+  completed. If no error has occured, the `callback` should be run without \\\\n+  arguments or with an explicit `null` argument.\\\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\\\n+  have finished, or an error occurs.\\\\n+\\\\n+__Examples__\\\\n+\\\\n+\\\\n+```js\\\\n+// assuming openFiles is an array of file names and saveFile is a function\\\\n+// to save the modified contents of that file:\\\\n+\\\\n+async.each(openFiles, saveFile, function(err){\\\\n+    // if any of the saves produced an error, err would equal that error\\\\n+});\\\\n+```\\\\n+\\\\n+```js\\\\n+// assuming openFiles is an array of file names \\\\n+\\\\n+async.each(openFiles, function( file, callback) {\\\\n+  \\\\n+  // Perform operation on file here.\\\\n+  console.log('Processing file ' + file);\\\\n+  \\\\n+  if( file.length > 32 ) {\\\\n+    console.log('This file name is too long');\\\\n+    callback('File name too long');\\\\n+  } else {\\\\n+    // Do work to process file here\\\\n+    console.log('File processed');\\\\n+    callback();\\\\n+  }\\\\n+}, function(err){\\\\n+    // if any of the file processing produced an error, err would equal that error\\\\n+    if( err ) {\\\\n+      // One of the iterations produced an error.\\\\n+      // All processing will now stop.\\\\n+      console.log('A file failed to process');\\\\n+    } else {\\\\n+      console.log('All files have been processed successfully');\\\\n+    }\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"forEachSeries\\\\\\\" />\\\\n+<a name=\\\\\\\"eachSeries\\\\\\\" />\\\\n+### eachSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`each`](#each), only `iterator` is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+This means the `iterator` functions will complete in order.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"forEachLimit\\\\\\\" />\\\\n+<a name=\\\\\\\"eachLimit\\\\\\\" />\\\\n+### eachLimit(arr, limit, iterator, callback)\\\\n+\\\\n+The same as [`each`](#each), only no more than `limit` `iterator`s will be simultaneously \\\\n+running at any time.\\\\n+\\\\n+Note that the items in `arr` are not processed in batches, so there is no guarantee that \\\\n+the first `limit` `iterator` functions will complete before any others are started.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err)` which must be called once it has \\\\n+  completed. If no error has occured, the callback should be run without \\\\n+  arguments or with an explicit `null` argument.\\\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\\\n+  have finished, or an error occurs.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// Assume documents is an array of JSON objects and requestApi is a\\\\n+// function that interacts with a rate-limited REST api.\\\\n+\\\\n+async.eachLimit(documents, 20, requestApi, function(err){\\\\n+    // if any of the saves produced an error, err would equal that error\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"map\\\\\\\" />\\\\n+### map(arr, iterator, callback)\\\\n+\\\\n+Produces a new array of values by mapping each value in `arr` through\\\\n+the `iterator` function. The `iterator` is called with an item from `arr` and a\\\\n+callback for when it has finished processing. Each of these callback takes 2 arguments: \\\\n+an `error`, and the transformed item from `arr`. If `iterator` passes an error to this \\\\n+callback, the main `callback` (for the `map` function) is immediately called with the error.\\\\n+\\\\n+Note, that since this function applies the `iterator` to each item in parallel,\\\\n+there is no guarantee that the `iterator` functions will complete in order. \\\\n+However, the results array will be in the same order as the original `arr`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\\\n+  it has completed with an error (which can be `null`) and a transformed item.\\\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\\\n+  functions have finished, or an error occurs. Results is an array of the\\\\n+  transformed items from the `arr`.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\\\n+    // results is now an array of stats for each file\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"mapSeries\\\\\\\" />\\\\n+### mapSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`map`](#map), only the `iterator` is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+The results array will be in the same order as the original.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"mapLimit\\\\\\\" />\\\\n+### mapLimit(arr, limit, iterator, callback)\\\\n+\\\\n+The same as [`map`](#map), only no more than `limit` `iterator`s will be simultaneously \\\\n+running at any time.\\\\n+\\\\n+Note that the items are not processed in batches, so there is no guarantee that \\\\n+the first `limit` `iterator` functions will complete before any others are started.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\\\n+  it has completed with an error (which can be `null`) and a transformed item.\\\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\\\n+  calls have finished, or an error occurs. The result is an array of the\\\\n+  transformed items from the original `arr`.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.mapLimit(['file1','file2','file3'], 1, fs.stat, function(err, results){\\\\n+    // results is now an array of stats for each file\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"select\\\\\\\" />\\\\n+<a name=\\\\\\\"filter\\\\\\\" />\\\\n+### filter(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `select`\\\\n+\\\\n+Returns a new array of all the values in `arr` which pass an async truth test.\\\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\n+way node libraries work with truth tests like `fs.exists`. This operation is\\\\n+performed in parallel, but the results array will be in the same order as the\\\\n+original.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\\\n+  The `iterator` is passed a `callback(truthValue)`, which must be called with a \\\\n+  boolean argument once it has completed.\\\\n+* `callback(results)` - A callback which is called after all the `iterator`\\\\n+  functions have finished.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\\\n+    // results now equals an array of the existing files\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"selectSeries\\\\\\\" />\\\\n+<a name=\\\\\\\"filterSeries\\\\\\\" />\\\\n+### filterSeries(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `selectSeries`\\\\n+\\\\n+The same as [`filter`](#filter) only the `iterator` is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+The results array will be in the same order as the original.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"reject\\\\\\\" />\\\\n+### reject(arr, iterator, callback)\\\\n+\\\\n+The opposite of [`filter`](#filter). Removes values that pass an `async` truth test.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"rejectSeries\\\\\\\" />\\\\n+### rejectSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`reject`](#reject), only the `iterator` is applied to each item in `arr`\\\\n+in series.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"reduce\\\\\\\" />\\\\n+### reduce(arr, memo, iterator, callback)\\\\n+\\\\n+__Aliases:__ `inject`, `foldl`\\\\n+\\\\n+Reduces `arr` into a single value using an async `iterator` to return\\\\n+each successive step. `memo` is the initial state of the reduction. \\\\n+This function only operates in series. \\\\n+\\\\n+For performance reasons, it may make sense to split a call to this function into \\\\n+a parallel map, and then use the normal `Array.prototype.reduce` on the results. \\\\n+This function is for situations where each step in the reduction needs to be async; \\\\n+if you can get the data before reducing it, then it's probably a good idea to do so.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `memo` - The initial state of the reduction.\\\\n+* `iterator(memo, item, callback)` - A function applied to each item in the\\\\n+  array to produce the next step in the reduction. The `iterator` is passed a\\\\n+  `callback(err, reduction)` which accepts an optional error as its first \\\\n+  argument, and the state of the reduction as the second. If an error is \\\\n+  passed to the callback, the reduction is stopped and the main `callback` is \\\\n+  immediately called with the error.\\\\n+* `callback(err, result)` - A callback which is called after all the `iterator`\\\\n+  functions have finished. Result is the reduced value.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.reduce([1,2,3], 0, function(memo, item, callback){\\\\n+    // pointless async:\\\\n+    process.nextTick(function(){\\\\n+        callback(null, memo + item)\\\\n+    });\\\\n+}, function(err, result){\\\\n+    // result is now equal to the last value of memo, which is 6\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"reduceRight\\\\\\\" />\\\\n+### reduceRight(arr, memo, iterator, callback)\\\\n+\\\\n+__Alias:__ `foldr`\\\\n+\\\\n+Same as [`reduce`](#reduce), only operates on `arr` in reverse order.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"detect\\\\\\\" />\\\\n+### detect(arr, iterator, callback)\\\\n+\\\\n+Returns the first value in `arr` that passes an async truth test. The\\\\n+`iterator` is applied in parallel, meaning the first iterator to return `true` will\\\\n+fire the detect `callback` with that result. That means the result might not be\\\\n+the first item in the original `arr` (in terms of order) that passes the test.\\\\n+\\\\n+If order within the original `arr` is important, then look at [`detectSeries`](#detectSeries).\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(truthValue)` which must be called with a \\\\n+  boolean argument once it has completed.\\\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\\\n+  `true`, or after all the `iterator` functions have finished. Result will be\\\\n+  the first item in the array that passes the truth test (iterator) or the\\\\n+  value `undefined` if none passed.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.detect(['file1','file2','file3'], fs.exists, function(result){\\\\n+    // result now equals the first file in the list that exists\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"detectSeries\\\\\\\" />\\\\n+### detectSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`detect`](#detect), only the `iterator` is applied to each item in `arr`\\\\n+in series. This means the result is always the first in the original `arr` (in\\\\n+terms of array order) that passes the truth test.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"sortBy\\\\\\\" />\\\\n+### sortBy(arr, iterator, callback)\\\\n+\\\\n+Sorts a list by the results of running each `arr` value through an async `iterator`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, sortValue)` which must be called once it\\\\n+  has completed with an error (which can be `null`) and a value to use as the sort\\\\n+  criteria.\\\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\\\n+  functions have finished, or an error occurs. Results is the items from\\\\n+  the original `arr` sorted by the values returned by the `iterator` calls.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.sortBy(['file1','file2','file3'], function(file, callback){\\\\n+    fs.stat(file, function(err, stats){\\\\n+        callback(err, stats.mtime);\\\\n+    });\\\\n+}, function(err, results){\\\\n+    // results is now the original array of files sorted by\\\\n+    // modified date\\\\n+});\\\\n+```\\\\n+\\\\n+__Sort Order__\\\\n+\\\\n+By modifying the callback parameter the sorting order can be influenced:\\\\n+\\\\n+```js\\\\n+//ascending order\\\\n+async.sortBy([1,9,3,5], function(x, callback){\\\\n+    callback(err, x);\\\\n+}, function(err,result){\\\\n+    //result callback\\\\n+} );\\\\n+\\\\n+//descending order\\\\n+async.sortBy([1,9,3,5], function(x, callback){\\\\n+    callback(err, x*-1);    //<- x*-1 instead of x, turns the order around\\\\n+}, function(err,result){\\\\n+    //result callback\\\\n+} );\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"some\\\\\\\" />\\\\n+### some(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `any`\\\\n+\\\\n+Returns `true` if at least one element in the `arr` satisfies an async test.\\\\n+_The callback for each iterator call only accepts a single argument of `true` or\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\n+way node libraries work with truth tests like `fs.exists`. Once any iterator\\\\n+call returns `true`, the main `callback` is immediately called.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\\\n+  called with a boolean argument once it has completed.\\\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\\\n+  `true`, or after all the iterator functions have finished. Result will be\\\\n+  either `true` or `false` depending on the values of the async tests.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.some(['file1','file2','file3'], fs.exists, function(result){\\\\n+    // if result is true then at least one of the files exists\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"every\\\\\\\" />\\\\n+### every(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `all`\\\\n+\\\\n+Returns `true` if every element in `arr` satisfies an async test.\\\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\n+way node libraries work with truth tests like `fs.exists`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\\\n+  called with a  boolean argument once it has completed.\\\\n+* `callback(result)` - A callback which is called after all the `iterator`\\\\n+  functions have finished. Result will be either `true` or `false` depending on\\\\n+  the values of the async tests.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.every(['file1','file2','file3'], fs.exists, function(result){\\\\n+    // if result is true then every file exists\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"concat\\\\\\\" />\\\\n+### concat(arr, iterator, callback)\\\\n+\\\\n+Applies `iterator` to each item in `arr`, concatenating the results. Returns the\\\\n+concatenated list. The `iterator`s are called in parallel, and the results are\\\\n+concatenated as they return. There is no guarantee that the results array will\\\\n+be returned in the original order of `arr` passed to the `iterator` function.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, results)` which must be called once it \\\\n+  has completed with an error (which can be `null`) and an array of results.\\\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\\\n+  functions have finished, or an error occurs. Results is an array containing\\\\n+  the concatenated results of the `iterator` function.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files){\\\\n+    // files is now a list of filenames that exist in the 3 directories\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"concatSeries\\\\\\\" />\\\\n+### concatSeries(arr, iterator, callback)\\\\n+\\\\n+Same as [`concat`](#concat), but executes in series instead of parallel.\\\\n+\\\\n+\\\\n+## Control Flow\\\\n+\\\\n+<a name=\\\\\\\"series\\\\\\\" />\\\\n+### series(tasks, [callback])\\\\n+\\\\n+Run the functions in the `tasks` array in series, each one running once the previous\\\\n+function has completed. If any functions in the series pass an error to its\\\\n+callback, no more functions are run, and `callback` is immediately called with the value of the error. \\\\n+Otherwise, `callback` receives an array of results when `tasks` have completed.\\\\n+\\\\n+It is also possible to use an object instead of an array. Each property will be\\\\n+run as a function, and the results will be passed to the final `callback` as an object\\\\n+instead of an array. This can be a more readable way of handling results from\\\\n+[`series`](#series).\\\\n+\\\\n+**Note** that while many implementations preserve the order of object properties, the\\\\n+[ECMAScript Language Specifcation](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6) \\\\n+explicitly states that\\\\n+\\\\n+> The mechanics and order of enumerating the properties is not specified.\\\\n+\\\\n+So if you rely on the order in which your series of functions are executed, and want\\\\n+this to work on all platforms, consider using an array. \\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array or object containing functions to run, each function is passed\\\\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\\\n+  be `null`) and an optional `result` value.\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\n+  have completed. This function gets a results array (or object) containing all \\\\n+  the result arguments passed to the `task` callbacks.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.series([\\\\n+    function(callback){\\\\n+        // do some stuff ...\\\\n+        callback(null, 'one');\\\\n+    },\\\\n+    function(callback){\\\\n+        // do some more stuff ...\\\\n+        callback(null, 'two');\\\\n+    }\\\\n+],\\\\n+// optional callback\\\\n+function(err, results){\\\\n+    // results is now equal to ['one', 'two']\\\\n+});\\\\n+\\\\n+\\\\n+// an example using an object instead of an array\\\\n+async.series({\\\\n+    one: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 1);\\\\n+        }, 200);\\\\n+    },\\\\n+    two: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 2);\\\\n+        }, 100);\\\\n+    }\\\\n+},\\\\n+function(err, results) {\\\\n+    // results is now equal to: {one: 1, two: 2}\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"parallel\\\\\\\" />\\\\n+### parallel(tasks, [callback])\\\\n+\\\\n+Run the `tasks` array of functions in parallel, without waiting until the previous\\\\n+function has completed. If any of the functions pass an error to its\\\\n+callback, the main `callback` is immediately called with the value of the error.\\\\n+Once the `tasks` have completed, the results are passed to the final `callback` as an\\\\n+array.\\\\n+\\\\n+It is also possible to use an object instead of an array. Each property will be\\\\n+run as a function and the results will be passed to the final `callback` as an object\\\\n+instead of an array. This can be a more readable way of handling results from\\\\n+[`parallel`](#parallel).\\\\n+\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array or object containing functions to run. Each function is passed \\\\n+  a `callback(err, result)` which it must call on completion with an error `err` \\\\n+  (which can be `null`) and an optional `result` value.\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\n+  have completed. This function gets a results array (or object) containing all \\\\n+  the result arguments passed to the task callbacks.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.parallel([\\\\n+    function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 'one');\\\\n+        }, 200);\\\\n+    },\\\\n+    function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 'two');\\\\n+        }, 100);\\\\n+    }\\\\n+],\\\\n+// optional callback\\\\n+function(err, results){\\\\n+    // the results array will equal ['one','two'] even though\\\\n+    // the second function had a shorter timeout.\\\\n+});\\\\n+\\\\n+\\\\n+// an example using an object instead of an array\\\\n+async.parallel({\\\\n+    one: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 1);\\\\n+        }, 200);\\\\n+    },\\\\n+    two: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 2);\\\\n+        }, 100);\\\\n+    }\\\\n+},\\\\n+function(err, results) {\\\\n+    // results is now equals to: {one: 1, two: 2}\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"parallelLimit\\\\\\\" />\\\\n+### parallelLimit(tasks, limit, [callback])\\\\n+\\\\n+The same as [`parallel`](#parallel), only `tasks` are executed in parallel \\\\n+with a maximum of `limit` tasks executing at any time.\\\\n+\\\\n+Note that the `tasks` are not executed in batches, so there is no guarantee that \\\\n+the first `limit` tasks will complete before any others are started.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array or object containing functions to run, each function is passed \\\\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\\\n+  be `null`) and an optional `result` value.\\\\n+* `limit` - The maximum number of `tasks` to run at any time.\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\n+  have completed. This function gets a results array (or object) containing all \\\\n+  the result arguments passed to the `task` callbacks.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"whilst\\\\\\\" />\\\\n+### whilst(test, fn, callback)\\\\n+\\\\n+Repeatedly call `fn`, while `test` returns `true`. Calls `callback` when stopped,\\\\n+or an error occurs.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `test()` - synchronous truth test to perform before each execution of `fn`.\\\\n+* `fn(callback)` - A function which is called each time `test` passes. The function is\\\\n+  passed a `callback(err)`, which must be called once it has completed with an \\\\n+  optional `err` argument.\\\\n+* `callback(err)` - A callback which is called after the test fails and repeated\\\\n+  execution of `fn` has stopped.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var count = 0;\\\\n+\\\\n+async.whilst(\\\\n+    function () { return count < 5; },\\\\n+    function (callback) {\\\\n+        count++;\\\\n+        setTimeout(callback, 1000);\\\\n+    },\\\\n+    function (err) {\\\\n+        // 5 seconds have passed\\\\n+    }\\\\n+);\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"doWhilst\\\\\\\" />\\\\n+### doWhilst(fn, test, callback)\\\\n+\\\\n+The post-check version of [`whilst`](#whilst). To reflect the difference in \\\\n+the order of operations, the arguments `test` and `fn` are switched. \\\\n+\\\\n+`doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"until\\\\\\\" />\\\\n+### until(test, fn, callback)\\\\n+\\\\n+Repeatedly call `fn` until `test` returns `true`. Calls `callback` when stopped,\\\\n+or an error occurs.\\\\n+\\\\n+The inverse of [`whilst`](#whilst).\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"doUntil\\\\\\\" />\\\\n+### doUntil(fn, test, callback)\\\\n+\\\\n+Like [`doWhilst`](#doWhilst), except the `test` is inverted. Note the argument ordering differs from `until`.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"forever\\\\\\\" />\\\\n+### forever(fn, errback)\\\\n+\\\\n+Calls the asynchronous function `fn` with a callback parameter that allows it to\\\\n+call itself again, in series, indefinitely.\\\\n+\\\\n+If an error is passed to the callback then `errback` is called with the\\\\n+error, and execution stops, otherwise it will never be called.\\\\n+\\\\n+```js\\\\n+async.forever(\\\\n+    function(next) {\\\\n+        // next is suitable for passing to things that need a callback(err [, whatever]);\\\\n+        // it will result in this function being called again.\\\\n+    },\\\\n+    function(err) {\\\\n+        // if next is called with a value in its first parameter, it will appear\\\\n+        // in here as 'err', and execution will stop.\\\\n+    }\\\\n+);\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"waterfall\\\\\\\" />\\\\n+### waterfall(tasks, [callback])\\\\n+\\\\n+Runs the `tasks` array of functions in series, each passing their results to the next in\\\\n+the array. However, if any of the `tasks` pass an error to their own callback, the\\\\n+next function is not executed, and the main `callback` is immediately called with\\\\n+the error.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array of functions to run, each function is passed a \\\\n+  `callback(err, result1, result2, ...)` it must call on completion. The first\\\\n+  argument is an error (which can be `null`) and any further arguments will be \\\\n+  passed as arguments in order to the next task.\\\\n+* `callback(err, [results])` - An optional callback to run once all the functions\\\\n+  have completed. This will be passed the results of the last task's callback.\\\\n+\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.waterfall([\\\\n+    function(callback){\\\\n+        callback(null, 'one', 'two');\\\\n+    },\\\\n+    function(arg1, arg2, callback){\\\\n+      // arg1 now equals 'one' and arg2 now equals 'two'\\\\n+        callback(null, 'three');\\\\n+    },\\\\n+    function(arg1, callback){\\\\n+        // arg1 now equals 'three'\\\\n+        callback(null, 'done');\\\\n+    }\\\\n+], function (err, result) {\\\\n+   // result now equals 'done'    \\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+<a name=\\\\\\\"compose\\\\\\\" />\\\\n+### compose(fn1, fn2...)\\\\n+\\\\n+Creates a function which is a composition of the passed asynchronous\\\\n+functions. Each function consumes the return value of the function that\\\\n+follows. Composing functions `f()`, `g()`, and `h()` would produce the result of\\\\n+`f(g(h()))`, only this version uses callbacks to obtain the return values.\\\\n+\\\\n+Each function is executed with the `this` binding of the composed function.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `functions...` - the asynchronous functions to compose\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+function add1(n, callback) {\\\\n+    setTimeout(function () {\\\\n+        callback(null, n + 1);\\\\n+    }, 10);\\\\n+}\\\\n+\\\\n+function mul3(n, callback) {\\\\n+    setTimeout(function () {\\\\n+        callback(null, n * 3);\\\\n+    }, 10);\\\\n+}\\\\n+\\\\n+var add1mul3 = async.compose(mul3, add1);\\\\n+\\\\n+add1mul3(4, function (err, result) {\\\\n+   // result now equals 15\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+<a name=\\\\\\\"seq\\\\\\\" />\\\\n+### seq(fn1, fn2...)\\\\n+\\\\n+Version of the compose function that is more natural to read.\\\\n+Each following function consumes the return value of the latter function. \\\\n+\\\\n+Each function is executed with the `this` binding of the composed function.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* functions... - the asynchronous functions to compose\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// Requires lodash (or underscore), express3 and dresende's orm2.\\\\n+// Part of an app, that fetches cats of the logged user.\\\\n+// This example uses `seq` function to avoid overnesting and error \\\\n+// handling clutter.\\\\n+app.get('/cats', function(request, response) {\\\\n+  function handleError(err, data, callback) {\\\\n+    if (err) {\\\\n+      console.error(err);\\\\n+      response.json({ status: 'error', message: err.message });\\\\n+    }\\\\n+    else {\\\\n+      callback(data);\\\\n+    }\\\\n+  }\\\\n+  var User = request.models.User;\\\\n+  async.seq(\\\\n+    _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\\\\n+    handleError,\\\\n+    function(user, fn) {\\\\n+      user.getCats(fn);      // 'getCats' has signature (callback(err, data))\\\\n+    },\\\\n+    handleError,\\\\n+    function(cats) {\\\\n+      response.json({ status: 'ok', message: 'Cats found', data: cats });\\\\n+    }\\\\n+  )(req.session.user_id);\\\\n+  }\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+<a name=\\\\\\\"applyEach\\\\\\\" />\\\\n+### applyEach(fns, args..., callback)\\\\n+\\\\n+Applies the provided arguments to each function in the array, calling \\\\n+`callback` after all functions have completed. If you only provide the first\\\\n+argument, then it will return a function which lets you pass in the\\\\n+arguments as if it were a single function call.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `fns` - the asynchronous functions to all call with the same arguments\\\\n+* `args...` - any number of separate arguments to pass to the function\\\\n+* `callback` - the final argument should be the callback, called when all\\\\n+  functions have completed processing\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.applyEach([enableSearch, updateSchema], 'bucket', callback);\\\\n+\\\\n+// partial application example:\\\\n+async.each(\\\\n+    buckets,\\\\n+    async.applyEach([enableSearch, updateSchema]),\\\\n+    callback\\\\n+);\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"applyEachSeries\\\\\\\" />\\\\n+### applyEachSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`applyEach`](#applyEach) only the functions are applied in series.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"queue\\\\\\\" />\\\\n+### queue(worker, concurrency)\\\\n+\\\\n+Creates a `queue` object with the specified `concurrency`. Tasks added to the\\\\n+`queue` are processed in parallel (up to the `concurrency` limit). If all\\\\n+`worker`s are in progress, the task is queued until one becomes available. \\\\n+Once a `worker` completes a `task`, that `task`'s callback is called.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `worker(task, callback)` - An asynchronous function for processing a queued\\\\n+  task, which must call its `callback(err)` argument when finished, with an \\\\n+  optional `error` as an argument.\\\\n+* `concurrency` - An `integer` for determining how many `worker` functions should be\\\\n+  run in parallel.\\\\n+\\\\n+__Queue objects__\\\\n+\\\\n+The `queue` object returned by this function has the following properties and\\\\n+methods:\\\\n+\\\\n+* `length()` - a function returning the number of items waiting to be processed.\\\\n+* `started` - a function returning whether or not any items have been pushed and processed by the queue\\\\n+* `running()` - a function returning the number of items currently being processed.\\\\n+* `idle()` - a function returning false if there are items waiting or being processed, or true if not.\\\\n+* `concurrency` - an integer for determining how many `worker` functions should be\\\\n+  run in parallel. This property can be changed after a `queue` is created to\\\\n+  alter the concurrency on-the-fly.\\\\n+* `push(task, [callback])` - add a new task to the `queue`. Calls `callback` once \\\\n+  the `worker` has finished processing the task. Instead of a single task, a `tasks` array\\\\n+  can be submitted. The respective callback is used for every task in the list.\\\\n+* `unshift(task, [callback])` - add a new task to the front of the `queue`.\\\\n+* `saturated` - a callback that is called when the `queue` length hits the `concurrency` limit, \\\\n+   and further tasks will be queued.\\\\n+* `empty` - a callback that is called when the last item from the `queue` is given to a `worker`.\\\\n+* `drain` - a callback that is called when the last item from the `queue` has returned from the `worker`.\\\\n+* `paused` - a boolean for determining whether the queue is in a paused state\\\\n+* `pause()` - a function that pauses the processing of tasks until `resume()` is called.\\\\n+* `resume()` - a function that resumes the processing of queued tasks when the queue is paused.\\\\n+* `kill()` - a function that empties remaining tasks from the queue forcing it to go idle.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// create a queue object with concurrency 2\\\\n+\\\\n+var q = async.queue(function (task, callback) {\\\\n+    console.log('hello ' + task.name);\\\\n+    callback();\\\\n+}, 2);\\\\n+\\\\n+\\\\n+// assign a callback\\\\n+q.drain = function() {\\\\n+    console.log('all items have been processed');\\\\n+}\\\\n+\\\\n+// add some items to the queue\\\\n+\\\\n+q.push({name: 'foo'}, function (err) {\\\\n+    console.log('finished processing foo');\\\\n+});\\\\n+q.push({name: 'bar'}, function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+\\\\n+// add some items to the queue (batch-wise)\\\\n+\\\\n+q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+\\\\n+// add some items to the front of the queue\\\\n+\\\\n+q.unshift({name: 'bar'}, function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+```\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"priorityQueue\\\\\\\" />\\\\n+### priorityQueue(worker, concurrency)\\\\n+\\\\n+The same as [`queue`](#queue) only tasks are assigned a priority and completed in ascending priority order. There are two differences between `queue` and `priorityQueue` objects:\\\\n+\\\\n+* `push(task, priority, [callback])` - `priority` should be a number. If an array of\\\\n+  `tasks` is given, all tasks will be assigned the same priority.\\\\n+* The `unshift` method was removed.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"cargo\\\\\\\" />\\\\n+### cargo(worker, [payload])\\\\n+\\\\n+Creates a `cargo` object with the specified payload. Tasks added to the\\\\n+cargo will be processed altogether (up to the `payload` limit). If the\\\\n+`worker` is in progress, the task is queued until it becomes available. Once\\\\n+the `worker` has completed some tasks, each callback of those tasks is called.\\\\n+Check out [this animation](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) for how `cargo` and `queue` work.\\\\n+\\\\n+While [queue](#queue) passes only one task to one of a group of workers\\\\n+at a time, cargo passes an array of tasks to a single worker, repeating\\\\n+when the worker is finished.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `worker(tasks, callback)` - An asynchronous function for processing an array of\\\\n+  queued tasks, which must call its `callback(err)` argument when finished, with \\\\n+  an optional `err` argument.\\\\n+* `payload` - An optional `integer` for determining how many tasks should be\\\\n+  processed per round; if omitted, the default is unlimited.\\\\n+\\\\n+__Cargo objects__\\\\n+\\\\n+The `cargo` object returned by this function has the following properties and\\\\n+methods:\\\\n+\\\\n+* `length()` - A function returning the number of items waiting to be processed.\\\\n+* `payload` - An `integer` for determining how many tasks should be\\\\n+  process per round. This property can be changed after a `cargo` is created to\\\\n+  alter the payload on-the-fly.\\\\n+* `push(task, [callback])` - Adds `task` to the `queue`. The callback is called\\\\n+  once the `worker` has finished processing the task. Instead of a single task, an array of `tasks` \\\\n+  can be submitted. The respective callback is used for every task in the list.\\\\n+* `saturated` - A callback that is called when the `queue.length()` hits the concurrency and further tasks will be queued.\\\\n+* `empty` - A callback that is called when the last item from the `queue` is given to a `worker`.\\\\n+* `drain` - A callback that is called when the last item from the `queue` has returned from the `worker`.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// create a cargo object with payload 2\\\\n+\\\\n+var cargo = async.cargo(function (tasks, callback) {\\\\n+    for(var i=0; i<tasks.length; i++){\\\\n+      console.log('hello ' + tasks[i].name);\\\\n+    }\\\\n+    callback();\\\\n+}, 2);\\\\n+\\\\n+\\\\n+// add some items\\\\n+\\\\n+cargo.push({name: 'foo'}, function (err) {\\\\n+    console.log('finished processing foo');\\\\n+});\\\\n+cargo.push({name: 'bar'}, function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+cargo.push({name: 'baz'}, function (err) {\\\\n+    console.log('finished processing baz');\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"auto\\\\\\\" />\\\\n+### auto(tasks, [callback])\\\\n+\\\\n+Determines the best order for running the functions in `tasks`, based on their \\\\n+requirements. Each function can optionally depend on other functions being completed \\\\n+first, and each function is run as soon as its requirements are satisfied. \\\\n+\\\\n+If any of the functions pass an error to their callback, it will not \\\\n+complete (so any other functions depending on it will not run), and the main \\\\n+`callback` is immediately called with the error. Functions also receive an \\\\n+object containing the results of functions which have completed so far.\\\\n+\\\\n+Note, all functions are called with a `results` object as a second argument, \\\\n+so it is unsafe to pass functions in the `tasks` object which cannot handle the\\\\n+extra argument. \\\\n+\\\\n+For example, this snippet of code:\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+  readData: async.apply(fs.readFile, 'data.txt', 'utf-8')\\\\n+}, callback);\\\\n+```\\\\n+\\\\n+will have the effect of calling `readFile` with the results object as the last\\\\n+argument, which will fail:\\\\n+\\\\n+```js\\\\n+fs.readFile('data.txt', 'utf-8', cb, {});\\\\n+```\\\\n+\\\\n+Instead, wrap the call to `readFile` in a function which does not forward the \\\\n+`results` object:\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+  readData: function(cb, results){\\\\n+    fs.readFile('data.txt', 'utf-8', cb);\\\\n+  }\\\\n+}, callback);\\\\n+```\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An object. Each of its properties is either a function or an array of\\\\n+  requirements, with the function itself the last item in the array. The object's key\\\\n+  of a property serves as the name of the task defined by that property,\\\\n+  i.e. can be used when specifying requirements for other tasks.\\\\n+  The function receives two arguments: (1) a `callback(err, result)` which must be \\\\n+  called when finished, passing an `error` (which can be `null`) and the result of \\\\n+  the function's execution, and (2) a `results` object, containing the results of\\\\n+  the previously executed functions.\\\\n+* `callback(err, results)` - An optional callback which is called when all the\\\\n+  tasks have been completed. It receives the `err` argument if any `tasks` \\\\n+  pass an error to their callback. Results are always returned; however, if \\\\n+  an error occurs, no further `tasks` will be performed, and the results\\\\n+  object will only contain partial results.\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+    get_data: function(callback){\\\\n+        console.log('in get_data');\\\\n+        // async code to get some data\\\\n+        callback(null, 'data', 'converted to array');\\\\n+    },\\\\n+    make_folder: function(callback){\\\\n+        console.log('in make_folder');\\\\n+        // async code to create a directory to store a file in\\\\n+        // this is run at the same time as getting the data\\\\n+        callback(null, 'folder');\\\\n+    },\\\\n+    write_file: ['get_data', 'make_folder', function(callback, results){\\\\n+        console.log('in write_file', JSON.stringify(results));\\\\n+        // once there is some data and the directory exists,\\\\n+        // write the data to a file in the directory\\\\n+        callback(null, 'filename');\\\\n+    }],\\\\n+    email_link: ['write_file', function(callback, results){\\\\n+        console.log('in email_link', JSON.stringify(results));\\\\n+        // once the file is written let's email a link to it...\\\\n+        // results.write_file contains the filename returned by write_file.\\\\n+        callback(null, {'file':results.write_file, 'email':'user@example.com'});\\\\n+    }]\\\\n+}, function(err, results) {\\\\n+    console.log('err = ', err);\\\\n+    console.log('results = ', results);\\\\n+});\\\\n+```\\\\n+\\\\n+This is a fairly trivial example, but to do this using the basic parallel and\\\\n+series functions would look like this:\\\\n+\\\\n+```js\\\\n+async.parallel([\\\\n+    function(callback){\\\\n+        console.log('in get_data');\\\\n+        // async code to get some data\\\\n+        callback(null, 'data', 'converted to array');\\\\n+    },\\\\n+    function(callback){\\\\n+        console.log('in make_folder');\\\\n+        // async code to create a directory to store a file in\\\\n+        // this is run at the same time as getting the data\\\\n+        callback(null, 'folder');\\\\n+    }\\\\n+],\\\\n+function(err, results){\\\\n+    async.series([\\\\n+        function(callback){\\\\n+            console.log('in write_file', JSON.stringify(results));\\\\n+            // once there is some data and the directory exists,\\\\n+            // write the data to a file in the directory\\\\n+            results.push('filename');\\\\n+            callback(null);\\\\n+        },\\\\n+        function(callback){\\\\n+            console.log('in email_link', JSON.stringify(results));\\\\n+            // once the file is written let's email a link to it...\\\\n+            callback(null, {'file':results.pop(), 'email':'user@example.com'});\\\\n+        }\\\\n+    ]);\\\\n+});\\\\n+```\\\\n+\\\\n+For a complicated series of `async` tasks, using the [`auto`](#auto) function makes adding\\\\n+new tasks much easier (and the code more readable).\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"retry\\\\\\\" />\\\\n+### retry([times = 5], task, [callback])\\\\n+\\\\n+Attempts to get a successful response from `task` no more than `times` times before\\\\n+returning an error. If the task is successful, the `callback` will be passed the result\\\\n+of the successfull task. If all attemps fail, the callback will be passed the error and\\\\n+result (if any) of the final attempt.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `times` - An integer indicating how many times to attempt the `task` before giving up. Defaults to 5.\\\\n+* `task(callback, results)` - A function which receives two arguments: (1) a `callback(err, result)`\\\\n+  which must be called when finished, passing `err` (which can be `null`) and the `result` of \\\\n+  the function's execution, and (2) a `results` object, containing the results of\\\\n+  the previously executed functions (if nested inside another control flow).\\\\n+* `callback(err, results)` - An optional callback which is called when the\\\\n+  task has succeeded, or after the final failed attempt. It receives the `err` and `result` arguments of the last attempt at completing the `task`.\\\\n+\\\\n+The [`retry`](#retry) function can be used as a stand-alone control flow by passing a\\\\n+callback, as shown below:\\\\n+\\\\n+```js\\\\n+async.retry(3, apiMethod, function(err, result) {\\\\n+    // do something with the result\\\\n+});\\\\n+```\\\\n+\\\\n+It can also be embeded within other control flow functions to retry individual methods\\\\n+that are not as reliable, like this:\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+    users: api.getUsers.bind(api),\\\\n+    payments: async.retry(3, api.getPayments.bind(api))\\\\n+}, function(err, results) {\\\\n+  // do something with the results\\\\n+});\\\\n+```\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"iterator\\\\\\\" />\\\\n+### iterator(tasks)\\\\n+\\\\n+Creates an iterator function which calls the next function in the `tasks` array,\\\\n+returning a continuation to call the next one after that. It's also possible to\\\\n+“peek” at the next iterator with `iterator.next()`.\\\\n+\\\\n+This function is used internally by the `async` module, but can be useful when\\\\n+you want to manually control the flow of functions in series.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array of functions to run.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var iterator = async.iterator([\\\\n+    function(){ sys.p('one'); },\\\\n+    function(){ sys.p('two'); },\\\\n+    function(){ sys.p('three'); }\\\\n+]);\\\\n+\\\\n+node> var iterator2 = iterator();\\\\n+'one'\\\\n+node> var iterator3 = iterator2();\\\\n+'two'\\\\n+node> iterator3();\\\\n+'three'\\\\n+node> var nextfn = iterator2.next();\\\\n+node> nextfn();\\\\n+'three'\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"apply\\\\\\\" />\\\\n+### apply(function, arguments..)\\\\n+\\\\n+Creates a continuation function with some arguments already applied. \\\\n+\\\\n+Useful as a shorthand when combined with other control flow functions. Any arguments\\\\n+passed to the returned function are added to the arguments originally passed\\\\n+to apply.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\n+* `arguments...` - Any number of arguments to automatically apply when the\\\\n+  continuation is called.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// using apply\\\\n+\\\\n+async.parallel([\\\\n+    async.apply(fs.writeFile, 'testfile1', 'test1'),\\\\n+    async.apply(fs.writeFile, 'testfile2', 'test2'),\\\\n+]);\\\\n+\\\\n+\\\\n+// the same process without using apply\\\\n+\\\\n+async.parallel([\\\\n+    function(callback){\\\\n+        fs.writeFile('testfile1', 'test1', callback);\\\\n+    },\\\\n+    function(callback){\\\\n+        fs.writeFile('testfile2', 'test2', callback);\\\\n+    }\\\\n+]);\\\\n+```\\\\n+\\\\n+It's possible to pass any number of additional arguments when calling the\\\\n+continuation:\\\\n+\\\\n+```js\\\\n+node> var fn = async.apply(sys.puts, 'one');\\\\n+node> fn('two', 'three');\\\\n+one\\\\n+two\\\\n+three\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"nextTick\\\\\\\" />\\\\n+### nextTick(callback)\\\\n+\\\\n+Calls `callback` on a later loop around the event loop. In Node.js this just\\\\n+calls `process.nextTick`; in the browser it falls back to `setImmediate(callback)`\\\\n+if available, otherwise `setTimeout(callback, 0)`, which means other higher priority\\\\n+events may precede the execution of `callback`.\\\\n+\\\\n+This is used internally for browser-compatibility purposes.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `callback` - The function to call on a later loop around the event loop.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var call_order = [];\\\\n+async.nextTick(function(){\\\\n+    call_order.push('two');\\\\n+    // call_order now equals ['one','two']\\\\n+});\\\\n+call_order.push('one')\\\\n+```\\\\n+\\\\n+<a name=\\\\\\\"times\\\\\\\" />\\\\n+### times(n, callback)\\\\n+\\\\n+Calls the `callback` function `n` times, and accumulates results in the same manner\\\\n+you would use with [`map`](#map).\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `n` - The number of times to run the function.\\\\n+* `callback` - The function to call `n` times.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// Pretend this is some complicated async factory\\\\n+var createUser = function(id, callback) {\\\\n+  callback(null, {\\\\n+    id: 'user' + id\\\\n+  })\\\\n+}\\\\n+// generate 5 users\\\\n+async.times(5, function(n, next){\\\\n+    createUser(n, function(err, user) {\\\\n+      next(err, user)\\\\n+    })\\\\n+}, function(err, users) {\\\\n+  // we should now have 5 users\\\\n+});\\\\n+```\\\\n+\\\\n+<a name=\\\\\\\"timesSeries\\\\\\\" />\\\\n+### timesSeries(n, callback)\\\\n+\\\\n+The same as [`times`](#times), only the iterator is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+The results array will be in the same order as the original.\\\\n+\\\\n+\\\\n+## Utils\\\\n+\\\\n+<a name=\\\\\\\"memoize\\\\\\\" />\\\\n+### memoize(fn, [hasher])\\\\n+\\\\n+Caches the results of an `async` function. When creating a hash to store function\\\\n+results against, the callback is omitted from the hash and an optional hash\\\\n+function can be used.\\\\n+\\\\n+The cache of results is exposed as the `memo` property of the function returned\\\\n+by `memoize`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `fn` - The function to proxy and cache results from.\\\\n+* `hasher` - Tn optional function for generating a custom hash for storing\\\\n+  results. It has all the arguments applied to it apart from the callback, and\\\\n+  must be synchronous.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var slow_fn = function (name, callback) {\\\\n+    // do something\\\\n+    callback(null, result);\\\\n+};\\\\n+var fn = async.memoize(slow_fn);\\\\n+\\\\n+// fn can now be used as if it were slow_fn\\\\n+fn('some name', function () {\\\\n+    // callback\\\\n+});\\\\n+```\\\\n+\\\\n+<a name=\\\\\\\"unmemoize\\\\\\\" />\\\\n+### unmemoize(fn)\\\\n+\\\\n+Undoes a [`memoize`](#memoize)d function, reverting it to the original, unmemoized\\\\n+form. Handy for testing.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `fn` - the memoized function\\\\n+\\\\n+<a name=\\\\\\\"log\\\\\\\" />\\\\n+### log(function, arguments)\\\\n+\\\\n+Logs the result of an `async` function to the `console`. Only works in Node.js or\\\\n+in browsers that support `console.log` and `console.error` (such as FF and Chrome).\\\\n+If multiple arguments are returned from the async function, `console.log` is\\\\n+called on each argument in order.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\n+* `arguments...` - Any number of arguments to apply to the function.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var hello = function(name, callback){\\\\n+    setTimeout(function(){\\\\n+        callback(null, 'hello ' + name);\\\\n+    }, 1000);\\\\n+};\\\\n+```\\\\n+```js\\\\n+node> async.log(hello, 'world');\\\\n+'hello world'\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"dir\\\\\\\" />\\\\n+### dir(function, arguments)\\\\n+\\\\n+Logs the result of an `async` function to the `console` using `console.dir` to\\\\n+display the properties of the resulting object. Only works in Node.js or\\\\n+in browsers that support `console.dir` and `console.error` (such as FF and Chrome).\\\\n+If multiple arguments are returned from the async function, `console.dir` is\\\\n+called on each argument in order.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\n+* `arguments...` - Any number of arguments to apply to the function.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var hello = function(name, callback){\\\\n+    setTimeout(function(){\\\\n+        callback(null, {hello: name});\\\\n+    }, 1000);\\\\n+};\\\\n+```\\\\n+```js\\\\n+node> async.dir(hello, 'world');\\\\n+{hello: 'world'}\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"noConflict\\\\\\\" />\\\\n+### noConflict()\\\\n+\\\\n+Changes the value of `async` back to its original value, returning a reference to the\\\\n+`async` object.\\\\ndiff --git a/node_modules/async/component.json b/node_modules/async/component.json\\\\nnew file mode 100644\\\\nindex 0000000..bbb0115\\\\n--- /dev/null\\\\n+++ b/node_modules/async/component.json\\\\n@@ -0,0 +1,11 @@\\\\n+{\\\\n+  \\\\\\\"name\\\\\\\": \\\\\\\"async\\\\\\\",\\\\n+  \\\\\\\"repo\\\\\\\": \\\\\\\"caolan/async\\\\\\\",\\\\n+  \\\\\\\"description\\\\\\\": \\\\\\\"Higher-order functions and common patterns for asynchronous code\\\\\\\",\\\\n+  \\\\\\\"version\\\\\\\": \\\\\\\"0.1.23\\\\\\\",\\\\n+  \\\\\\\"keywords\\\\\\\": [],\\\\n+  \\\\\\\"dependencies\\\\\\\": {},\\\\n+  \\\\\\\"development\\\\\\\": {},\\\\n+  \\\\\\\"main\\\\\\\": \\\\\\\"lib/async.js\\\\\\\",\\\\n+  \\\\\\\"scripts\\\\\\\": [ \\\\\\\"lib/async.js\\\\\\\" ]\\\\n+}\\\\ndiff --git a/node_modules/async/lib/async.js b/node_modules/async/lib/async.js\\\\nnew file mode 100644\\\\nindex 0000000..01e8afc\\\\n--- /dev/null\\\\n+++ b/node_modules/async/lib/async.js\\\\n@@ -0,0 +1,1123 @@\\\\n+/*!\\\\n+ * async\\\\n+ * https://github.com/caolan/async\\\\n+ *\\\\n+ * Copyright 2010-2014 Caolan McMahon\\\\n+ * Released under the MIT license\\\\n+ */\\\\n+/*jshint onevar: false, indent:4 */\\\\n+/*global setImmediate: false, setTimeout: false, console: false */\\\\n+(function () {\\\\n+\\\\n+    var async = {};\\\\n+\\\\n+    // global on the server, window in the browser\\\\n+    var root, previous_async;\\\\n+\\\\n+    root = this;\\\\n+    if (root != null) {\\\\n+      previous_async = root.async;\\\\n+    }\\\\n+\\\\n+    async.noConflict = function () {\\\\n+        root.async = previous_async;\\\\n+        return async;\\\\n+    };\\\\n+\\\\n+    function only_once(fn) {\\\\n+        var called = false;\\\\n+        return function() {\\\\n+            if (called) throw new Error(\\\\\\\"Callback was already called.\\\\\\\");\\\\n+            called = true;\\\\n+            fn.apply(root, arguments);\\\\n+        }\\\\n+    }\\\\n+\\\\n+    //// cross-browser compatiblity functions ////\\\\n+\\\\n+    var _toString = Object.prototype.toString;\\\\n+\\\\n+    var _isArray = Array.isArray || function (obj) {\\\\n+        return _toString.call(obj) === '[object Array]';\\\\n+    };\\\\n+\\\\n+    var _each = function (arr, iterator) {\\\\n+        if (arr.forEach) {\\\\n+            return arr.forEach(iterator);\\\\n+        }\\\\n+        for (var i = 0; i < arr.length; i += 1) {\\\\n+            iterator(arr[i], i, arr);\\\\n+        }\\\\n+    };\\\\n+\\\\n+    var _map = function (arr, iterator) {\\\\n+        if (arr.map) {\\\\n+            return arr.map(iterator);\\\\n+        }\\\\n+        var results = [];\\\\n+        _each(arr, function (x, i, a) {\\\\n+            results.push(iterator(x, i, a));\\\\n+        });\\\\n+        return results;\\\\n+    };\\\\n+\\\\n+    var _reduce = function (arr, iterator, memo) {\\\\n+        if (arr.reduce) {\\\\n+            return arr.reduce(iterator, memo);\\\\n+        }\\\\n+        _each(arr, function (x, i, a) {\\\\n+            memo = iterator(memo, x, i, a);\\\\n+        });\\\\n+        return memo;\\\\n+    };\\\\n+\\\\n+    var _keys = function (obj) {\\\\n+        if (Object.keys) {\\\\n+            return Object.keys(obj);\\\\n+        }\\\\n+        var keys = [];\\\\n+        for (var k in obj) {\\\\n+            if (obj.hasOwnProperty(k)) {\\\\n+                keys.push(k);\\\\n+            }\\\\n+        }\\\\n+        return keys;\\\\n+    };\\\\n+\\\\n+    //// exported async module functions ////\\\\n+\\\\n+    //// nextTick implementation with browser-compatible fallback ////\\\\n+    if (typeof process === 'undefined' || !(process.nextTick)) {\\\\n+        if (typeof setImmediate === 'function') {\\\\n+            async.nextTick = function (fn) {\\\\n+                // not a direct alias for IE10 compatibility\\\\n+                setImmediate(fn);\\\\n+            };\\\\n+            async.setImmediate = async.nextTick;\\\\n+        }\\\\n+        else {\\\\n+            async.nextTick = function (fn) {\\\\n+                setTimeout(fn, 0);\\\\n+            };\\\\n+            async.setImmediate = async.nextTick;\\\\n+        }\\\\n+    }\\\\n+    else {\\\\n+        async.nextTick = process.nextTick;\\\\n+        if (typeof setImmediate !== 'undefined') {\\\\n+            async.setImmediate = function (fn) {\\\\n+              // not a direct alias for IE10 compatibility\\\\n+              setImmediate(fn);\\\\n+            };\\\\n+        }\\\\n+        else {\\\\n+            async.setImmediate = async.nextTick;\\\\n+        }\\\\n+    }\\\\n+\\\\n+    async.each = function (arr, iterator, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (!arr.length) {\\\\n+            return callback();\\\\n+        }\\\\n+        var completed = 0;\\\\n+        _each(arr, function (x) {\\\\n+            iterator(x, only_once(done) );\\\\n+        });\\\\n+        function done(err) {\\\\n+          if (err) {\\\\n+              callback(err);\\\\n+              callback = function () {};\\\\n+          }\\\\n+          else {\\\\n+              completed += 1;\\\\n+              if (completed >= arr.length) {\\\\n+                  callback();\\\\n+              }\\\\n+          }\\\\n+        }\\\\n+    };\\\\n+    async.forEach = async.each;\\\\n+\\\\n+    async.eachSeries = function (arr, iterator, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (!arr.length) {\\\\n+            return callback();\\\\n+        }\\\\n+        var completed = 0;\\\\n+        var iterate = function () {\\\\n+            iterator(arr[completed], function (err) {\\\\n+                if (err) {\\\\n+                    callback(err);\\\\n+                    callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    completed += 1;\\\\n+                    if (completed >= arr.length) {\\\\n+                        callback();\\\\n+                    }\\\\n+                    else {\\\\n+                        iterate();\\\\n+                    }\\\\n+                }\\\\n+            });\\\\n+        };\\\\n+        iterate();\\\\n+    };\\\\n+    async.forEachSeries = async.eachSeries;\\\\n+\\\\n+    async.eachLimit = function (arr, limit, iterator, callback) {\\\\n+        var fn = _eachLimit(limit);\\\\n+        fn.apply(null, [arr, iterator, callback]);\\\\n+    };\\\\n+    async.forEachLimit = async.eachLimit;\\\\n+\\\\n+    var _eachLimit = function (limit) {\\\\n+\\\\n+        return function (arr, iterator, callback) {\\\\n+            callback = callback || function () {};\\\\n+            if (!arr.length || limit <= 0) {\\\\n+                return callback();\\\\n+            }\\\\n+            var completed = 0;\\\\n+            var started = 0;\\\\n+            var running = 0;\\\\n+\\\\n+            (function replenish () {\\\\n+                if (completed >= arr.length) {\\\\n+                    return callback();\\\\n+                }\\\\n+\\\\n+                while (running < limit && started < arr.length) {\\\\n+                    started += 1;\\\\n+                    running += 1;\\\\n+                    iterator(arr[started - 1], function (err) {\\\\n+                        if (err) {\\\\n+                            callback(err);\\\\n+                            callback = function () {};\\\\n+                        }\\\\n+                        else {\\\\n+                            completed += 1;\\\\n+                            running -= 1;\\\\n+                            if (completed >= arr.length) {\\\\n+                                callback();\\\\n+                            }\\\\n+                            else {\\\\n+                                replenish();\\\\n+                            }\\\\n+                        }\\\\n+                    });\\\\n+                }\\\\n+            })();\\\\n+        };\\\\n+    };\\\\n+\\\\n+\\\\n+    var doParallel = function (fn) {\\\\n+        return function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            return fn.apply(null, [async.each].concat(args));\\\\n+        };\\\\n+    };\\\\n+    var doParallelLimit = function(limit, fn) {\\\\n+        return function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            return fn.apply(null, [_eachLimit(limit)].concat(args));\\\\n+        };\\\\n+    };\\\\n+    var doSeries = function (fn) {\\\\n+        return function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            return fn.apply(null, [async.eachSeries].concat(args));\\\\n+        };\\\\n+    };\\\\n+\\\\n+\\\\n+    var _asyncMap = function (eachfn, arr, iterator, callback) {\\\\n+        arr = _map(arr, function (x, i) {\\\\n+            return {index: i, value: x};\\\\n+        });\\\\n+        if (!callback) {\\\\n+            eachfn(arr, function (x, callback) {\\\\n+                iterator(x.value, function (err) {\\\\n+                    callback(err);\\\\n+                });\\\\n+            });\\\\n+        } else {\\\\n+            var results = [];\\\\n+            eachfn(arr, function (x, callback) {\\\\n+                iterator(x.value, function (err, v) {\\\\n+                    results[x.index] = v;\\\\n+                    callback(err);\\\\n+                });\\\\n+            }, function (err) {\\\\n+                callback(err, results);\\\\n+            });\\\\n+        }\\\\n+    };\\\\n+    async.map = doParallel(_asyncMap);\\\\n+    async.mapSeries = doSeries(_asyncMap);\\\\n+    async.mapLimit = function (arr, limit, iterator, callback) {\\\\n+        return _mapLimit(limit)(arr, iterator, callback);\\\\n+    };\\\\n+\\\\n+    var _mapLimit = function(limit) {\\\\n+        return doParallelLimit(limit, _asyncMap);\\\\n+    };\\\\n+\\\\n+    // reduce only has a series version, as doing reduce in parallel won't\\\\n+    // work in many situations.\\\\n+    async.reduce = function (arr, memo, iterator, callback) {\\\\n+        async.eachSeries(arr, function (x, callback) {\\\\n+            iterator(memo, x, function (err, v) {\\\\n+                memo = v;\\\\n+                callback(err);\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(err, memo);\\\\n+        });\\\\n+    };\\\\n+    // inject alias\\\\n+    async.inject = async.reduce;\\\\n+    // foldl alias\\\\n+    async.foldl = async.reduce;\\\\n+\\\\n+    async.reduceRight = function (arr, memo, iterator, callback) {\\\\n+        var reversed = _map(arr, function (x) {\\\\n+            return x;\\\\n+        }).reverse();\\\\n+        async.reduce(reversed, memo, iterator, callback);\\\\n+    };\\\\n+    // foldr alias\\\\n+    async.foldr = async.reduceRight;\\\\n+\\\\n+    var _filter = function (eachfn, arr, iterator, callback) {\\\\n+        var results = [];\\\\n+        arr = _map(arr, function (x, i) {\\\\n+            return {index: i, value: x};\\\\n+        });\\\\n+        eachfn(arr, function (x, callback) {\\\\n+            iterator(x.value, function (v) {\\\\n+                if (v) {\\\\n+                    results.push(x);\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(_map(results.sort(function (a, b) {\\\\n+                return a.index - b.index;\\\\n+            }), function (x) {\\\\n+                return x.value;\\\\n+            }));\\\\n+        });\\\\n+    };\\\\n+    async.filter = doParallel(_filter);\\\\n+    async.filterSeries = doSeries(_filter);\\\\n+    // select alias\\\\n+    async.select = async.filter;\\\\n+    async.selectSeries = async.filterSeries;\\\\n+\\\\n+    var _reject = function (eachfn, arr, iterator, callback) {\\\\n+        var results = [];\\\\n+        arr = _map(arr, function (x, i) {\\\\n+            return {index: i, value: x};\\\\n+        });\\\\n+        eachfn(arr, function (x, callback) {\\\\n+            iterator(x.value, function (v) {\\\\n+                if (!v) {\\\\n+                    results.push(x);\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(_map(results.sort(function (a, b) {\\\\n+                return a.index - b.index;\\\\n+            }), function (x) {\\\\n+                return x.value;\\\\n+            }));\\\\n+        });\\\\n+    };\\\\n+    async.reject = doParallel(_reject);\\\\n+    async.rejectSeries = doSeries(_reject);\\\\n+\\\\n+    var _detect = function (eachfn, arr, iterator, main_callback) {\\\\n+        eachfn(arr, function (x, callback) {\\\\n+            iterator(x, function (result) {\\\\n+                if (result) {\\\\n+                    main_callback(x);\\\\n+                    main_callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    callback();\\\\n+                }\\\\n+            });\\\\n+        }, function (err) {\\\\n+            main_callback();\\\\n+        });\\\\n+    };\\\\n+    async.detect = doParallel(_detect);\\\\n+    async.detectSeries = doSeries(_detect);\\\\n+\\\\n+    async.some = function (arr, iterator, main_callback) {\\\\n+        async.each(arr, function (x, callback) {\\\\n+            iterator(x, function (v) {\\\\n+                if (v) {\\\\n+                    main_callback(true);\\\\n+                    main_callback = function () {};\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            main_callback(false);\\\\n+        });\\\\n+    };\\\\n+    // any alias\\\\n+    async.any = async.some;\\\\n+\\\\n+    async.every = function (arr, iterator, main_callback) {\\\\n+        async.each(arr, function (x, callback) {\\\\n+            iterator(x, function (v) {\\\\n+                if (!v) {\\\\n+                    main_callback(false);\\\\n+                    main_callback = function () {};\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            main_callback(true);\\\\n+        });\\\\n+    };\\\\n+    // all alias\\\\n+    async.all = async.every;\\\\n+\\\\n+    async.sortBy = function (arr, iterator, callback) {\\\\n+        async.map(arr, function (x, callback) {\\\\n+            iterator(x, function (err, criteria) {\\\\n+                if (err) {\\\\n+                    callback(err);\\\\n+                }\\\\n+                else {\\\\n+                    callback(null, {value: x, criteria: criteria});\\\\n+                }\\\\n+            });\\\\n+        }, function (err, results) {\\\\n+            if (err) {\\\\n+                return callback(err);\\\\n+            }\\\\n+            else {\\\\n+                var fn = function (left, right) {\\\\n+                    var a = left.criteria, b = right.criteria;\\\\n+                    return a < b ? -1 : a > b ? 1 : 0;\\\\n+                };\\\\n+                callback(null, _map(results.sort(fn), function (x) {\\\\n+                    return x.value;\\\\n+                }));\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.auto = function (tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        var keys = _keys(tasks);\\\\n+        var remainingTasks = keys.length\\\\n+        if (!remainingTasks) {\\\\n+            return callback();\\\\n+        }\\\\n+\\\\n+        var results = {};\\\\n+\\\\n+        var listeners = [];\\\\n+        var addListener = function (fn) {\\\\n+            listeners.unshift(fn);\\\\n+        };\\\\n+        var removeListener = function (fn) {\\\\n+            for (var i = 0; i < listeners.length; i += 1) {\\\\n+                if (listeners[i] === fn) {\\\\n+                    listeners.splice(i, 1);\\\\n+                    return;\\\\n+                }\\\\n+            }\\\\n+        };\\\\n+        var taskComplete = function () {\\\\n+            remainingTasks--\\\\n+            _each(listeners.slice(0), function (fn) {\\\\n+                fn();\\\\n+            });\\\\n+        };\\\\n+\\\\n+        addListener(function () {\\\\n+            if (!remainingTasks) {\\\\n+                var theCallback = callback;\\\\n+                // prevent final callback from calling itself if it errors\\\\n+                callback = function () {};\\\\n+\\\\n+                theCallback(null, results);\\\\n+            }\\\\n+        });\\\\n+\\\\n+        _each(keys, function (k) {\\\\n+            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\\\\n+            var taskCallback = function (err) {\\\\n+                var args = Array.prototype.slice.call(arguments, 1);\\\\n+                if (args.length <= 1) {\\\\n+                    args = args[0];\\\\n+                }\\\\n+                if (err) {\\\\n+                    var safeResults = {};\\\\n+                    _each(_keys(results), function(rkey) {\\\\n+                        safeResults[rkey] = results[rkey];\\\\n+                    });\\\\n+                    safeResults[k] = args;\\\\n+                    callback(err, safeResults);\\\\n+                    // stop subsequent errors hitting callback multiple times\\\\n+                    callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    results[k] = args;\\\\n+                    async.setImmediate(taskComplete);\\\\n+                }\\\\n+            };\\\\n+            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\\\\n+            var ready = function () {\\\\n+                return _reduce(requires, function (a, x) {\\\\n+                    return (a && results.hasOwnProperty(x));\\\\n+                }, true) && !results.hasOwnProperty(k);\\\\n+            };\\\\n+            if (ready()) {\\\\n+                task[task.length - 1](taskCallback, results);\\\\n+            }\\\\n+            else {\\\\n+                var listener = function () {\\\\n+                    if (ready()) {\\\\n+                        removeListener(listener);\\\\n+                        task[task.length - 1](taskCallback, results);\\\\n+                    }\\\\n+                };\\\\n+                addListener(listener);\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.retry = function(times, task, callback) {\\\\n+        var DEFAULT_TIMES = 5;\\\\n+        var attempts = [];\\\\n+        // Use defaults if times not passed\\\\n+        if (typeof times === 'function') {\\\\n+            callback = task;\\\\n+            task = times;\\\\n+            times = DEFAULT_TIMES;\\\\n+        }\\\\n+        // Make sure times is a number\\\\n+        times = parseInt(times, 10) || DEFAULT_TIMES;\\\\n+        var wrappedTask = function(wrappedCallback, wrappedResults) {\\\\n+            var retryAttempt = function(task, finalAttempt) {\\\\n+                return function(seriesCallback) {\\\\n+                    task(function(err, result){\\\\n+                        seriesCallback(!err || finalAttempt, {err: err, result: result});\\\\n+                    }, wrappedResults);\\\\n+                };\\\\n+            };\\\\n+            while (times) {\\\\n+                attempts.push(retryAttempt(task, !(times-=1)));\\\\n+            }\\\\n+            async.series(attempts, function(done, data){\\\\n+                data = data[data.length - 1];\\\\n+                (wrappedCallback || callback)(data.err, data.result);\\\\n+            });\\\\n+        }\\\\n+        // If a callback is passed, run this as a controll flow\\\\n+        return callback ? wrappedTask() : wrappedTask\\\\n+    };\\\\n+\\\\n+    async.waterfall = function (tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (!_isArray(tasks)) {\\\\n+          var err = new Error('First argument to waterfall must be an array of functions');\\\\n+          return callback(err);\\\\n+        }\\\\n+        if (!tasks.length) {\\\\n+            return callback();\\\\n+        }\\\\n+        var wrapIterator = function (iterator) {\\\\n+            return function (err) {\\\\n+                if (err) {\\\\n+                    callback.apply(null, arguments);\\\\n+                    callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\n+                    var next = iterator.next();\\\\n+                    if (next) {\\\\n+                        args.push(wrapIterator(next));\\\\n+                    }\\\\n+                    else {\\\\n+                        args.push(callback);\\\\n+                    }\\\\n+                    async.setImmediate(function () {\\\\n+                        iterator.apply(null, args);\\\\n+                    });\\\\n+                }\\\\n+            };\\\\n+        };\\\\n+        wrapIterator(async.iterator(tasks))();\\\\n+    };\\\\n+\\\\n+    var _parallel = function(eachfn, tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (_isArray(tasks)) {\\\\n+            eachfn.map(tasks, function (fn, callback) {\\\\n+                if (fn) {\\\\n+                    fn(function (err) {\\\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\\\n+                        if (args.length <= 1) {\\\\n+                            args = args[0];\\\\n+                        }\\\\n+                        callback.call(null, err, args);\\\\n+                    });\\\\n+                }\\\\n+            }, callback);\\\\n+        }\\\\n+        else {\\\\n+            var results = {};\\\\n+            eachfn.each(_keys(tasks), function (k, callback) {\\\\n+                tasks[k](function (err) {\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\n+                    if (args.length <= 1) {\\\\n+                        args = args[0];\\\\n+                    }\\\\n+                    results[k] = args;\\\\n+                    callback(err);\\\\n+                });\\\\n+            }, function (err) {\\\\n+                callback(err, results);\\\\n+            });\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.parallel = function (tasks, callback) {\\\\n+        _parallel({ map: async.map, each: async.each }, tasks, callback);\\\\n+    };\\\\n+\\\\n+    async.parallelLimit = function(tasks, limit, callback) {\\\\n+        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\\\\n+    };\\\\n+\\\\n+    async.series = function (tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (_isArray(tasks)) {\\\\n+            async.mapSeries(tasks, function (fn, callback) {\\\\n+                if (fn) {\\\\n+                    fn(function (err) {\\\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\\\n+                        if (args.length <= 1) {\\\\n+                            args = args[0];\\\\n+                        }\\\\n+                        callback.call(null, err, args);\\\\n+                    });\\\\n+                }\\\\n+            }, callback);\\\\n+        }\\\\n+        else {\\\\n+            var results = {};\\\\n+            async.eachSeries(_keys(tasks), function (k, callback) {\\\\n+                tasks[k](function (err) {\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\n+                    if (args.length <= 1) {\\\\n+                        args = args[0];\\\\n+                    }\\\\n+                    results[k] = args;\\\\n+                    callback(err);\\\\n+                });\\\\n+            }, function (err) {\\\\n+                callback(err, results);\\\\n+            });\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.iterator = function (tasks) {\\\\n+        var makeCallback = function (index) {\\\\n+            var fn = function () {\\\\n+                if (tasks.length) {\\\\n+                    tasks[index].apply(null, arguments);\\\\n+                }\\\\n+                return fn.next();\\\\n+            };\\\\n+            fn.next = function () {\\\\n+                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\\\\n+            };\\\\n+            return fn;\\\\n+        };\\\\n+        return makeCallback(0);\\\\n+    };\\\\n+\\\\n+    async.apply = function (fn) {\\\\n+        var args = Array.prototype.slice.call(arguments, 1);\\\\n+        return function () {\\\\n+            return fn.apply(\\\\n+                null, args.concat(Array.prototype.slice.call(arguments))\\\\n+            );\\\\n+        };\\\\n+    };\\\\n+\\\\n+    var _concat = function (eachfn, arr, fn, callback) {\\\\n+        var r = [];\\\\n+        eachfn(arr, function (x, cb) {\\\\n+            fn(x, function (err, y) {\\\\n+                r = r.concat(y || []);\\\\n+                cb(err);\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(err, r);\\\\n+        });\\\\n+    };\\\\n+    async.concat = doParallel(_concat);\\\\n+    async.concatSeries = doSeries(_concat);\\\\n+\\\\n+    async.whilst = function (test, iterator, callback) {\\\\n+        if (test()) {\\\\n+            iterator(function (err) {\\\\n+                if (err) {\\\\n+                    return callback(err);\\\\n+                }\\\\n+                async.whilst(test, iterator, callback);\\\\n+            });\\\\n+        }\\\\n+        else {\\\\n+            callback();\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.doWhilst = function (iterator, test, callback) {\\\\n+        iterator(function (err) {\\\\n+            if (err) {\\\\n+                return callback(err);\\\\n+            }\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\n+            if (test.apply(null, args)) {\\\\n+                async.doWhilst(iterator, test, callback);\\\\n+            }\\\\n+            else {\\\\n+                callback();\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.until = function (test, iterator, callback) {\\\\n+        if (!test()) {\\\\n+            iterator(function (err) {\\\\n+                if (err) {\\\\n+                    return callback(err);\\\\n+                }\\\\n+                async.until(test, iterator, callback);\\\\n+            });\\\\n+        }\\\\n+        else {\\\\n+            callback();\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.doUntil = function (iterator, test, callback) {\\\\n+        iterator(function (err) {\\\\n+            if (err) {\\\\n+                return callback(err);\\\\n+            }\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\n+            if (!test.apply(null, args)) {\\\\n+                async.doUntil(iterator, test, callback);\\\\n+            }\\\\n+            else {\\\\n+                callback();\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.queue = function (worker, concurrency) {\\\\n+        if (concurrency === undefined) {\\\\n+            concurrency = 1;\\\\n+        }\\\\n+        function _insert(q, data, pos, callback) {\\\\n+          if (!q.started){\\\\n+            q.started = true;\\\\n+          }\\\\n+          if (!_isArray(data)) {\\\\n+              data = [data];\\\\n+          }\\\\n+          if(data.length == 0) {\\\\n+             // call drain immediately if there are no tasks\\\\n+             return async.setImmediate(function() {\\\\n+                 if (q.drain) {\\\\n+                     q.drain();\\\\n+                 }\\\\n+             });\\\\n+          }\\\\n+          _each(data, function(task) {\\\\n+              var item = {\\\\n+                  data: task,\\\\n+                  callback: typeof callback === 'function' ? callback : null\\\\n+              };\\\\n+\\\\n+              if (pos) {\\\\n+                q.tasks.unshift(item);\\\\n+              } else {\\\\n+                q.tasks.push(item);\\\\n+              }\\\\n+\\\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\\\n+                  q.saturated();\\\\n+              }\\\\n+              async.setImmediate(q.process);\\\\n+          });\\\\n+        }\\\\n+\\\\n+        var workers = 0;\\\\n+        var q = {\\\\n+            tasks: [],\\\\n+            concurrency: concurrency,\\\\n+            saturated: null,\\\\n+            empty: null,\\\\n+            drain: null,\\\\n+            started: false,\\\\n+            paused: false,\\\\n+            push: function (data, callback) {\\\\n+              _insert(q, data, false, callback);\\\\n+            },\\\\n+            kill: function () {\\\\n+              q.drain = null;\\\\n+              q.tasks = [];\\\\n+            },\\\\n+            unshift: function (data, callback) {\\\\n+              _insert(q, data, true, callback);\\\\n+            },\\\\n+            process: function () {\\\\n+                if (!q.paused && workers < q.concurrency && q.tasks.length) {\\\\n+                    var task = q.tasks.shift();\\\\n+                    if (q.empty && q.tasks.length === 0) {\\\\n+                        q.empty();\\\\n+                    }\\\\n+                    workers += 1;\\\\n+                    var next = function () {\\\\n+                        workers -= 1;\\\\n+                        if (task.callback) {\\\\n+                            task.callback.apply(task, arguments);\\\\n+                        }\\\\n+                        if (q.drain && q.tasks.length + workers === 0) {\\\\n+                            q.drain();\\\\n+                        }\\\\n+                        q.process();\\\\n+                    };\\\\n+                    var cb = only_once(next);\\\\n+                    worker(task.data, cb);\\\\n+                }\\\\n+            },\\\\n+            length: function () {\\\\n+                return q.tasks.length;\\\\n+            },\\\\n+            running: function () {\\\\n+                return workers;\\\\n+            },\\\\n+            idle: function() {\\\\n+                return q.tasks.length + workers === 0;\\\\n+            },\\\\n+            pause: function () {\\\\n+                if (q.paused === true) { return; }\\\\n+                q.paused = true;\\\\n+                q.process();\\\\n+            },\\\\n+            resume: function () {\\\\n+                if (q.paused === false) { return; }\\\\n+                q.paused = false;\\\\n+                q.process();\\\\n+            }\\\\n+        };\\\\n+        return q;\\\\n+    };\\\\n+    \\\\n+    async.priorityQueue = function (worker, concurrency) {\\\\n+        \\\\n+        function _compareTasks(a, b){\\\\n+          return a.priority - b.priority;\\\\n+        };\\\\n+        \\\\n+        function _binarySearch(sequence, item, compare) {\\\\n+          var beg = -1,\\\\n+              end = sequence.length - 1;\\\\n+          while (beg < end) {\\\\n+            var mid = beg + ((end - beg + 1) >>> 1);\\\\n+            if (compare(item, sequence[mid]) >= 0) {\\\\n+              beg = mid;\\\\n+            } else {\\\\n+              end = mid - 1;\\\\n+            }\\\\n+          }\\\\n+          return beg;\\\\n+        }\\\\n+        \\\\n+        function _insert(q, data, priority, callback) {\\\\n+          if (!q.started){\\\\n+            q.started = true;\\\\n+          }\\\\n+          if (!_isArray(data)) {\\\\n+              data = [data];\\\\n+          }\\\\n+          if(data.length == 0) {\\\\n+             // call drain immediately if there are no tasks\\\\n+             return async.setImmediate(function() {\\\\n+                 if (q.drain) {\\\\n+                     q.drain();\\\\n+                 }\\\\n+             });\\\\n+          }\\\\n+          _each(data, function(task) {\\\\n+              var item = {\\\\n+                  data: task,\\\\n+                  priority: priority,\\\\n+                  callback: typeof callback === 'function' ? callback : null\\\\n+              };\\\\n+              \\\\n+              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\\\\n+\\\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\\\n+                  q.saturated();\\\\n+              }\\\\n+              async.setImmediate(q.process);\\\\n+          });\\\\n+        }\\\\n+        \\\\n+        // Start with a normal queue\\\\n+        var q = async.queue(worker, concurrency);\\\\n+        \\\\n+        // Override push to accept second parameter representing priority\\\\n+        q.push = function (data, priority, callback) {\\\\n+          _insert(q, data, priority, callback);\\\\n+        };\\\\n+        \\\\n+        // Remove unshift function\\\\n+        delete q.unshift;\\\\n+\\\\n+        return q;\\\\n+    };\\\\n+\\\\n+    async.cargo = function (worker, payload) {\\\\n+        var working     = false,\\\\n+            tasks       = [];\\\\n+\\\\n+        var cargo = {\\\\n+            tasks: tasks,\\\\n+            payload: payload,\\\\n+            saturated: null,\\\\n+            empty: null,\\\\n+            drain: null,\\\\n+            drained: true,\\\\n+            push: function (data, callback) {\\\\n+                if (!_isArray(data)) {\\\\n+                    data = [data];\\\\n+                }\\\\n+                _each(data, function(task) {\\\\n+                    tasks.push({\\\\n+                        data: task,\\\\n+                        callback: typeof callback === 'function' ? callback : null\\\\n+                    });\\\\n+                    cargo.drained = false;\\\\n+                    if (cargo.saturated && tasks.length === payload) {\\\\n+                        cargo.saturated();\\\\n+                    }\\\\n+                });\\\\n+                async.setImmediate(cargo.process);\\\\n+            },\\\\n+            process: function process() {\\\\n+                if (working) return;\\\\n+                if (tasks.length === 0) {\\\\n+                    if(cargo.drain && !cargo.drained) cargo.drain();\\\\n+                    cargo.drained = true;\\\\n+                    return;\\\\n+                }\\\\n+\\\\n+                var ts = typeof payload === 'number'\\\\n+                            ? tasks.splice(0, payload)\\\\n+                            : tasks.splice(0, tasks.length);\\\\n+\\\\n+                var ds = _map(ts, function (task) {\\\\n+                    return task.data;\\\\n+                });\\\\n+\\\\n+                if(cargo.empty) cargo.empty();\\\\n+                working = true;\\\\n+                worker(ds, function () {\\\\n+                    working = false;\\\\n+\\\\n+                    var args = arguments;\\\\n+                    _each(ts, function (data) {\\\\n+                        if (data.callback) {\\\\n+                            data.callback.apply(null, args);\\\\n+                        }\\\\n+                    });\\\\n+\\\\n+                    process();\\\\n+                });\\\\n+            },\\\\n+            length: function () {\\\\n+                return tasks.length;\\\\n+            },\\\\n+            running: function () {\\\\n+                return working;\\\\n+            }\\\\n+        };\\\\n+        return cargo;\\\\n+    };\\\\n+\\\\n+    var _console_fn = function (name) {\\\\n+        return function (fn) {\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\n+            fn.apply(null, args.concat([function (err) {\\\\n+                var args = Array.prototype.slice.call(arguments, 1);\\\\n+                if (typeof console !== 'undefined') {\\\\n+                    if (err) {\\\\n+                        if (console.error) {\\\\n+                            console.error(err);\\\\n+                        }\\\\n+                    }\\\\n+                    else if (console[name]) {\\\\n+                        _each(args, function (x) {\\\\n+                            console[name](x);\\\\n+                        });\\\\n+                    }\\\\n+                }\\\\n+            }]));\\\\n+        };\\\\n+    };\\\\n+    async.log = _console_fn('log');\\\\n+    async.dir = _console_fn('dir');\\\\n+    /*async.info = _console_fn('info');\\\\n+    async.warn = _console_fn('warn');\\\\n+    async.error = _console_fn('error');*/\\\\n+\\\\n+    async.memoize = function (fn, hasher) {\\\\n+        var memo = {};\\\\n+        var queues = {};\\\\n+        hasher = hasher || function (x) {\\\\n+            return x;\\\\n+        };\\\\n+        var memoized = function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            var callback = args.pop();\\\\n+            var key = hasher.apply(null, args);\\\\n+            if (key in memo) {\\\\n+                async.nextTick(function () {\\\\n+                    callback.apply(null, memo[key]);\\\\n+                });\\\\n+            }\\\\n+            else if (key in queues) {\\\\n+                queues[key].push(callback);\\\\n+            }\\\\n+            else {\\\\n+                queues[key] = [callback];\\\\n+                fn.apply(null, args.concat([function () {\\\\n+                    memo[key] = arguments;\\\\n+                    var q = queues[key];\\\\n+                    delete queues[key];\\\\n+                    for (var i = 0, l = q.length; i < l; i++) {\\\\n+                      q[i].apply(null, arguments);\\\\n+                    }\\\\n+                }]));\\\\n+            }\\\\n+        };\\\\n+        memoized.memo = memo;\\\\n+        memoized.unmemoized = fn;\\\\n+        return memoized;\\\\n+    };\\\\n+\\\\n+    async.unmemoize = function (fn) {\\\\n+      return function () {\\\\n+        return (fn.unmemoized || fn).apply(null, arguments);\\\\n+      };\\\\n+    };\\\\n+\\\\n+    async.times = function (count, iterator, callback) {\\\\n+        var counter = [];\\\\n+        for (var i = 0; i < count; i++) {\\\\n+            counter.push(i);\\\\n+        }\\\\n+        return async.map(counter, iterator, callback);\\\\n+    };\\\\n+\\\\n+    async.timesSeries = function (count, iterator, callback) {\\\\n+        var counter = [];\\\\n+        for (var i = 0; i < count; i++) {\\\\n+            counter.push(i);\\\\n+        }\\\\n+        return async.mapSeries(counter, iterator, callback);\\\\n+    };\\\\n+\\\\n+    async.seq = function (/* functions... */) {\\\\n+        var fns = arguments;\\\\n+        return function () {\\\\n+            var that = this;\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            var callback = args.pop();\\\\n+            async.reduce(fns, args, function (newargs, fn, cb) {\\\\n+                fn.apply(that, newargs.concat([function () {\\\\n+                    var err = arguments[0];\\\\n+                    var nextargs = Array.prototype.slice.call(arguments, 1);\\\\n+                    cb(err, nextargs);\\\\n+                }]))\\\\n+            },\\\\n+            function (err, results) {\\\\n+                callback.apply(that, [err].concat(results));\\\\n+            });\\\\n+        };\\\\n+    };\\\\n+\\\\n+    async.compose = function (/* functions... */) {\\\\n+      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\\\\n+    };\\\\n+\\\\n+    var _applyEach = function (eachfn, fns /*args...*/) {\\\\n+        var go = function () {\\\\n+            var that = this;\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            var callback = args.pop();\\\\n+            return eachfn(fns, function (fn, cb) {\\\\n+                fn.apply(that, args.concat([cb]));\\\\n+            },\\\\n+            callback);\\\\n+        };\\\\n+        if (arguments.length > 2) {\\\\n+            var args = Array.prototype.slice.call(arguments, 2);\\\\n+            return go.apply(this, args);\\\\n+        }\\\\n+        else {\\\\n+            return go;\\\\n+        }\\\\n+    };\\\\n+    async.applyEach = doParallel(_applyEach);\\\\n+    async.applyEachSeries = doSeries(_applyEach);\\\\n+\\\\n+    async.forever = function (fn, callback) {\\\\n+        function next(err) {\\\\n+            if (err) {\\\\n+                if (callback) {\\\\n+                    return callback(err);\\\\n+                }\\\\n+                throw err;\\\\n+            }\\\\n+            fn(next);\\\\n+        }\\\\n+        next();\\\\n+    };\\\\n+\\\\n+    // Node.js\\\\n+    if (typeof module !== 'undefined' && module.exports) {\\\\n+        module.exports = async;\\\\n+    }\\\\n+    // AMD / RequireJS\\\\n+    else if (typeof define !== 'undefined' && define.amd) {\\\\n+        define([], function () {\\\\n+            return async;\\\\n+        });\\\\n+    }\\\\n+    // included directly via <script> tag\\\\n+    else {\\\\n+        root.async = async;\\\\n+    }\\\\n+\\\\n+}());\\\\ndiff --git a/node_modules/async/package.json b/node_modules/async/package.json\\\\nnew file mode 100644\\\\nindex 0000000..31a5200\\\\n--- /dev/null\\\\n+++ b/node_modules/async/package.json\\\\n@@ -0,0 +1,59 @@\\\\n+{\\\\n+  \\\\\\\"name\\\\\\\": \\\\\\\"async\\\\\\\",\\\\n+  \\\\\\\"description\\\\\\\": \\\\\\\"Higher-order functions and common patterns for asynchronous code\\\\\\\",\\\\n+  \\\\\\\"main\\\\\\\": \\\\\\\"./lib/async\\\\\\\",\\\\n+  \\\\\\\"author\\\\\\\": {\\\\n+    \\\\\\\"name\\\\\\\": \\\\\\\"Caolan McMahon\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"version\\\\\\\": \\\\\\\"0.9.0\\\\\\\",\\\\n+  \\\\\\\"repository\\\\\\\": {\\\\n+    \\\\\\\"type\\\\\\\": \\\\\\\"git\\\\\\\",\\\\n+    \\\\\\\"url\\\\\\\": \\\\\\\"https://github.com/caolan/async.git\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"bugs\\\\\\\": {\\\\n+    \\\\\\\"url\\\\\\\": \\\\\\\"https://github.com/caolan/async/issues\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"licenses\\\\\\\": [\\\\n+    {\\\\n+      \\\\\\\"type\\\\\\\": \\\\\\\"MIT\\\\\\\",\\\\n+      \\\\\\\"url\\\\\\\": \\\\\\\"https://github.com/caolan/async/raw/master/LICENSE\\\\\\\"\\\\n+    }\\\\n+  ],\\\\n+  \\\\\\\"devDependencies\\\\\\\": {\\\\n+    \\\\\\\"nodeunit\\\\\\\": \\\\\\\">0.0.0\\\\\\\",\\\\n+    \\\\\\\"uglify-js\\\\\\\": \\\\\\\"1.2.x\\\\\\\",\\\\n+    \\\\\\\"nodelint\\\\\\\": \\\\\\\">0.0.0\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"jam\\\\\\\": {\\\\n+    \\\\\\\"main\\\\\\\": \\\\\\\"lib/async.js\\\\\\\",\\\\n+    \\\\\\\"include\\\\\\\": [\\\\n+      \\\\\\\"lib/async.js\\\\\\\",\\\\n+      \\\\\\\"README.md\\\\\\\",\\\\n+      \\\\\\\"LICENSE\\\\\\\"\\\\n+    ]\\\\n+  },\\\\n+  \\\\\\\"scripts\\\\\\\": {\\\\n+    \\\\\\\"test\\\\\\\": \\\\\\\"nodeunit test/test-async.js\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"homepage\\\\\\\": \\\\\\\"https://github.com/caolan/async\\\\\\\",\\\\n+  \\\\\\\"_id\\\\\\\": \\\\\\\"async@0.9.0\\\\\\\",\\\\n+  \\\\\\\"dist\\\\\\\": {\\\\n+    \\\\\\\"shasum\\\\\\\": \\\\\\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\\\\\",\\\\n+    \\\\\\\"tarball\\\\\\\": \\\\\\\"http://registry.npmjs.org/async/-/async-0.9.0.tgz\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"_from\\\\\\\": \\\\\\\"async@*\\\\\\\",\\\\n+  \\\\\\\"_npmVersion\\\\\\\": \\\\\\\"1.4.3\\\\\\\",\\\\n+  \\\\\\\"_npmUser\\\\\\\": {\\\\n+    \\\\\\\"name\\\\\\\": \\\\\\\"caolan\\\\\\\",\\\\n+    \\\\\\\"email\\\\\\\": \\\\\\\"caolan.mcmahon@gmail.com\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"maintainers\\\\\\\": [\\\\n+    {\\\\n+      \\\\\\\"name\\\\\\\": \\\\\\\"caolan\\\\\\\",\\\\n+      \\\\\\\"email\\\\\\\": \\\\\\\"caolan@caolanmcmahon.com\\\\\\\"\\\\n+    }\\\\n+  ],\\\\n+  \\\\\\\"directories\\\\\\\": {},\\\\n+  \\\\\\\"_shasum\\\\\\\": \\\\\\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\\\\\",\\\\n+  \\\\\\\"_resolved\\\\\\\": \\\\\\\"https://registry.npmjs.org/async/-/async-0.9.0.tgz\\\\\\\"\\\\n+}\\\\ndiff --git a/package.json b/package.json\\\\nindex 5f21627..6033d43 100644\\\\n--- a/package.json\\\\n+++ b/package.json\\\\n@@ -4,7 +4,8 @@\\\\n   \\\\\\\"description\\\\\\\": \\\\\\\"Sous project\\\\\\\",\\\\n   \\\\\\\"main\\\\\\\": \\\\\\\"main.js\\\\\\\",\\\\n   \\\\\\\"dependencies\\\\\\\": {\\\\n-},\\\\n+    \\\\\\\"async\\\\\\\": \\\\\\\"*\\\\\\\"\\\\n+  },\\\\n   \\\\\\\"devDependencies\\\\\\\": {},\\\\n   \\\\\\\"scripts\\\\\\\": {\\\\n     \\\\\\\"test\\\\\\\": \\\\\\\"echo \\\\\\\\\\\\\\\"Error: no test specified\\\\\\\\\\\\\\\" && exit 1\\\\\\\"\\\\ndiff --git a/patches.sousp b/patches.sousp\\\\nindex 16405a3..d71e511 100644\\\\n--- a/patches.sousp\\\\n+++ b/patches.sousp\\\\n@@ -1,31 +1 @@\\\\n-diff --git a/main.js b/main.js\\\\n-index f81b54e..744cdd5 100644\\\\n---- a/main.js\\\\n-+++ b/main.js\\\\n-@@ -35,7 +35,7 @@ fs.exists('.git', function (exists) {\\\\n-         cp.exec('git diff', function(error, stdout, stderr) {\\\\n-             console.log(stdout);\\\\n- \\\\n--            //fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", stdout);\\\\n-+            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", stdout);\\\\n- \\\\n-             if (error !== null) {\\\\n-                 console.log('stderr: ' + stderr);\\\\n-@@ -44,7 +44,7 @@ fs.exists('.git', function (exists) {\\\\n-         });\\\\n- \\\\n-         cp.exec('git log', function(error, stdout, stderr) {\\\\n--            //console.log(stdout);\\\\n-+            console.log(stdout);\\\\n- \\\\n-             var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n-             var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n-@@ -53,7 +53,7 @@ fs.exists('.git', function (exists) {\\\\n-             console.log(comments);\\\\n-             console.log(dates);\\\\n- \\\\n--            //fs.writeFileSync(\\\\\\\"comments.sousc\\\\\\\", stdout);\\\\n-+            fs.writeFileSync(\\\\\\\"comments.sousc\\\\\\\", stdout);\\\\n- \\\\n-             if (error !== null) {\\\\n-                 console.log('stderr: ' + stderr);\\\\n+[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]\\\\n\\\\\\\\ No newline at end of file\\\\ndiff --git a/test.js b/test.js\\\\nnew file mode 100644\\\\nindex 0000000..5ca759c\\\\n--- /dev/null\\\\n+++ b/test.js\\\\n@@ -0,0 +1,21 @@\\\\n+/**\\\\n+ * Created by Nick on 18.05.2015.\\\\n+ */\\\\n+var async = require('async')\\\\n+    , tasksIndex = [\\\\n+        function (callback) {\\\\n+            // Вымышленный метод который вернет 231\\\\n+            var viewsNumber = models.stat.viewsNumber();\\\\n+            callback(null, viewsNumber);\\\\n+        }\\\\n+        , function (callback) {\\\\n+            // Вымышленный метод который вернет 24\\\\n+            var growFactor = models.stat.growFactor();\\\\n+            callback(null, growFactor);\\\\n+        }\\\\n+    ];\\\\n+\\\\n+async.series(tasksIndex, function (err, results) {\\\\n+    // Результат будет массивом\\\\n+    console.log(results); // [231, 24]\\\\n+});\\\\n\\\\\\\\ No newline at end of file\\\\n\\\"}\\n\\\\ No newline at end of file\\n\"},{\"commit\":\"b69c8e0a5203119884ebb2050c894eceb657f4f6\",\"author\":\"Nick Stepanenko <massaalonso@yandex.ru>\",\"date\":\"Tue May 19 01:44:20 2015 +0800\",\"comment\":\"Removed insignificant program code.\",\"content\":\"diff --git a/main.js b/main.js\\nindex ca7473f..eaf537f 100644\\n--- a/main.js\\n+++ b/main.js\\n@@ -4,55 +4,8 @@\\n \\n var fs = require('fs');\\n var cp = require('child_process');\\n-var data = [];\\n \\n var async = require('async');\\n-    /*tasks = [\\n-        function (callback) {\\n-            cp.exec('git log', function(error, stdout, stderr) {\\n-                var listOfCommits = [];\\n-                var authors = findData(stdout, \\\"Author:\\\");\\n-                var dates = findData(stdout, \\\"Date:\\\");\\n-                var comments = findComments(stdout);\\n-                var commitNumbers = findCommitNumbers(stdout);\\n-\\n-                for(i=0; i<authors.length; i++) {\\n-                    var commit = {\\n-                        \\\"commit\\\": commitNumbers[i],\\n-                        \\\"author\\\": authors[i],\\n-                        \\\"date\\\": dates[i],\\n-                        \\\"comment\\\": comments[i],\\n-                        \\\"content\\\": 'Original'\\n-                    };\\n-\\n-                    listOfCommits[listOfCommits.length] = commit;\\n-                }\\n-\\n-                data = listOfCommits.reverse();\\n-\\n-                callback(null, data);\\n-\\n-                if (error !== null) {\\n-                    console.log('stderr: ' + stderr);\\n-                    console.log('exec error: ' + error);\\n-                }\\n-            });\\n-        }\\n-    ],\\n-    secondTasks = [\\n-        function some_function(callback) {\\n-            cp.exec('git diff', function(error, stdout, stderr) {\\n-                var currentContent = stdout;\\n-\\n-                if (error !== null) {\\n-                    console.log('stderr: ' + stderr);\\n-                    console.log('exec error: ' + error);\\n-                }\\n-\\n-                callback(null, currentContent);\\n-            });\\n-        }\\n-    ];*/\\n \\n function findData(text, keyword) {\\n     var data = [];\\n@@ -91,43 +44,8 @@ function findCommitNumbers(text) {\\n     return commits;\\n }\\n \\n-/*function pullCommitContent(first, second) {\\n-\\n-    cp.exec('git diff' + ' ' + first + ' ' + second, function(error, stdout, stderr) {\\n-        var currentContent = stdout;\\n-\\n-        if (error !== null) {\\n-            console.log('stderr: ' + stderr);\\n-            console.log('exec error: ' + error);\\n-        }\\n-\\n-        return currentContent;\\n-    });\\n-}*/\\n-\\n-var commitsInfo = [];\\n-\\n fs.exists('.git', function (exists) {\\n     if(exists) {\\n-        /*async.series(tasks, function(err, result) {\\n-            fs.writeFileSync(\\\"patches.sousp\\\", JSON.stringify(result));\\n-\\n-            var data = result[0];\\n-\\n-            /*function some_function(arg1, arg2, callback) {\\n-                cp.exec('git diff' + ' ' + arg1 + ' ' + arg2, function(error, stdout, stderr) {\\n-                    var currentContent = 54321;//stdout;\\n-\\n-                    if (error !== null) {\\n-                        console.log('stderr: ' + stderr);\\n-                        console.log('exec error: ' + error);\\n-                    }\\n-\\n-                    callback(null, currentContent);\\n-                });\\n-            }\\n-        });*/\\n-\\n         async.waterfall([\\n             function getCommitsInfo(callback) {\\n                 cp.exec('git log', function(error, stdout, stderr) {\\n@@ -173,4 +91,4 @@ fs.exists('.git', function (exists) {\\n             }\\n         });\\n     }\\n-});\\n\\\\ No newline at end of file\\n+});\\ndiff --git a/patches.sousp b/patches.sousp\\nindex 300c6a9..11aa280 100644\\n--- a/patches.sousp\\n+++ b/patches.sousp\\n@@ -1 +1 @@\\n-{\\\"commit\\\":\\\"1e947f613e976945de85ae35ed923aa470f0be72\\\",\\\"author\\\":\\\"Nick Stepanenko <massaalonso@yandex.ru>\\\",\\\"date\\\":\\\"Tue May 19 00:12:12 2015 +0800\\\",\\\"comment\\\":\\\"Latest updates\\\",\\\"content\\\":\\\"diff --git a/comments.sousc b/comments.sousc\\\\nindex 150b0f6..cb3a850 100644\\\\n--- a/comments.sousc\\\\n+++ b/comments.sousc\\\\n@@ -1,3 +1,27 @@\\\\n+commit 4420cabefc1f470af341af11ed595df67e25c51f\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 17:05:35 2015 +0800\\\\n+\\\\n+    Paste old program code\\\\n+\\\\n+commit 9ef3d25fd4c3afdbcc3107a0abf6d7a2e29cb4dd\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 17:04:52 2015 +0800\\\\n+\\\\n+    Adding new file\\\\n+\\\\n+commit 64814d140d2fab6ae153cac485008119f29bf230\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 17:03:58 2015 +0800\\\\n+\\\\n+    From clear list\\\\n+\\\\n+commit c9d318fea74ea288d544ecf72f00b12c130cf2ef\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n+Date:   Sun May 17 16:59:40 2015 +0800\\\\n+\\\\n+    Create system files\\\\n+\\\\n commit e3c853a4282dfe8f000685dc1d39bd55a4a946c4\\\\n Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\n Date:   Sun May 17 16:54:58 2015 +0800\\\\ndiff --git a/main.js b/main.js\\\\nindex e34dc18..86f30c2 100644\\\\n--- a/main.js\\\\n+++ b/main.js\\\\n@@ -3,6 +3,56 @@\\\\n  */\\\\n \\\\n var fs = require('fs');\\\\n+var cp = require('child_process');\\\\n+var data = [];\\\\n+\\\\n+var async = require('async');\\\\n+    /*tasks = [\\\\n+        function (callback) {\\\\n+            cp.exec('git log', function(error, stdout, stderr) {\\\\n+                var listOfCommits = [];\\\\n+                var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n+                var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n+                var comments = findComments(stdout);\\\\n+                var commitNumbers = findCommitNumbers(stdout);\\\\n+\\\\n+                for(i=0; i<authors.length; i++) {\\\\n+                    var commit = {\\\\n+                        \\\\\\\"commit\\\\\\\": commitNumbers[i],\\\\n+                        \\\\\\\"author\\\\\\\": authors[i],\\\\n+                        \\\\\\\"date\\\\\\\": dates[i],\\\\n+                        \\\\\\\"comment\\\\\\\": comments[i],\\\\n+                        \\\\\\\"content\\\\\\\": 'Original'\\\\n+                    };\\\\n+\\\\n+                    listOfCommits[listOfCommits.length] = commit;\\\\n+                }\\\\n+\\\\n+                data = listOfCommits.reverse();\\\\n+\\\\n+                callback(null, data);\\\\n+\\\\n+                if (error !== null) {\\\\n+                    console.log('stderr: ' + stderr);\\\\n+                    console.log('exec error: ' + error);\\\\n+                }\\\\n+            });\\\\n+        }\\\\n+    ],\\\\n+    secondTasks = [\\\\n+        function some_function(callback) {\\\\n+            cp.exec('git diff', function(error, stdout, stderr) {\\\\n+                var currentContent = stdout;\\\\n+\\\\n+                if (error !== null) {\\\\n+                    console.log('stderr: ' + stderr);\\\\n+                    console.log('exec error: ' + error);\\\\n+                }\\\\n+\\\\n+                callback(null, currentContent);\\\\n+            });\\\\n+        }\\\\n+    ];*/\\\\n \\\\n function findData(text, keyword) {\\\\n     var data = [];\\\\n@@ -28,38 +78,106 @@ function findComments(text) {\\\\n     return comments;\\\\n }\\\\n \\\\n+function findCommitNumbers(text) {\\\\n+    var commits = [];\\\\n+    var splittext = text.split('\\\\\\\\n');\\\\n+\\\\n+    for(i=0; i<splittext.length; i++) {\\\\n+        if(splittext[i].slice(0, 6) == \\\\\\\"commit\\\\\\\") {\\\\n+            commits[commits.length] = splittext[i].slice(6).trim();\\\\n+        }\\\\n+    }\\\\n+\\\\n+    return commits;\\\\n+}\\\\n+\\\\n+/*function pullCommitContent(first, second) {\\\\n+\\\\n+    cp.exec('git diff' + ' ' + first + ' ' + second, function(error, stdout, stderr) {\\\\n+        var currentContent = stdout;\\\\n+\\\\n+        if (error !== null) {\\\\n+            console.log('stderr: ' + stderr);\\\\n+            console.log('exec error: ' + error);\\\\n+        }\\\\n+\\\\n+        return currentContent;\\\\n+    });\\\\n+}*/\\\\n+\\\\n+var commitsInfo = [];\\\\n+\\\\n fs.exists('.git', function (exists) {\\\\n     if(exists) {\\\\n-        var cp = require('child_process');\\\\n+        /*async.series(tasks, function(err, result) {\\\\n+            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", JSON.stringify(result));\\\\n+\\\\n+            var data = result[0];\\\\n \\\\n-        cp.exec('git diff', function(error, stdout, stderr) {\\\\n-            console.log(stdout);\\\\n+            /*function some_function(arg1, arg2, callback) {\\\\n+                cp.exec('git diff' + ' ' + arg1 + ' ' + arg2, function(error, stdout, stderr) {\\\\n+                    var currentContent = 54321;//stdout;\\\\n \\\\n-            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", stdout);\\\\n+                    if (error !== null) {\\\\n+                        console.log('stderr: ' + stderr);\\\\n+                        console.log('exec error: ' + error);\\\\n+                    }\\\\n \\\\n-            if (error !== null) {\\\\n-                console.log('stderr: ' + stderr);\\\\n-                console.log('exec error: ' + error);\\\\n+                    callback(null, currentContent);\\\\n+                });\\\\n             }\\\\n-        });\\\\n+        });*/\\\\n+\\\\n+        async.waterfall([\\\\n+            function getCommitsInfo(callback) {\\\\n+                cp.exec('git log', function(error, stdout, stderr) {\\\\n+                    var listOfCommits = [];\\\\n+                    var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n+                    var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n+                    var comments = findComments(stdout);\\\\n+                    var commitNumbers = findCommitNumbers(stdout);\\\\n \\\\n-        cp.exec('git log', function(error, stdout, stderr) {\\\\n-            console.log(stdout);\\\\n+                    for(i=0; i<authors.length; i++) {\\\\n+                        var commit = {\\\\n+                            \\\\\\\"commit\\\\\\\": commitNumbers[i],\\\\n+                            \\\\\\\"author\\\\\\\": authors[i],\\\\n+                            \\\\\\\"date\\\\\\\": dates[i],\\\\n+                            \\\\\\\"comment\\\\\\\": comments[i],\\\\n+                            \\\\\\\"content\\\\\\\": 'Original'\\\\n+                        };\\\\n+                        listOfCommits[listOfCommits.length] = commit;\\\\n+                    }\\\\n \\\\n-            var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n-            var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n-            var comments = findComments(stdout);\\\\n-            console.log(authors);\\\\n-            console.log(comments);\\\\n-            console.log(dates);\\\\n+                    callback(null, listOfCommits.reverse());\\\\n \\\\n-            fs.writeFileSync(\\\\\\\"comments.sousc\\\\\\\", stdout);\\\\n+                    if (error !== null) {\\\\n+                        console.log('stderr: ' + stderr);\\\\n+                        console.log('exec error: ' + error);\\\\n+                    }\\\\n+                });\\\\n+            },\\\\n+            function getCommitsContent(commits, callback) {\\\\n+                console.log(commits);\\\\n+                var commitsData = commits;\\\\n \\\\n-            if (error !== null) {\\\\n-                console.log('stderr: ' + stderr);\\\\n-                console.log('exec error: ' + error);\\\\n+                for(i=1; i<commitsData.length; i++) {\\\\n+                    cp.exec('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit, function(error, stdout, stderr) {\\\\n+                        commitsData[i].content = stdout;\\\\n+\\\\n+                        if (error !== null) {\\\\n+                            console.log('stderr: ' + stderr);\\\\n+                            console.log('exec error: ' + error);\\\\n+                        }\\\\n+                    });\\\\n+                }\\\\n+\\\\n+                callback(null, commitsData);\\\\n             }\\\\n+        ], function (err, result) {\\\\n+            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", result);\\\\n         });\\\\n+\\\\n+        //commitsInfo = JSON.parse(fs.readFileSync(\\\\\\\"patches.sousp\\\\\\\"));\\\\n+        //console.log(commitsInfo);\\\\n     }\\\\n-    else console.log(\\\\\\\"Error.\\\\\\\");\\\\n });\\\\n\\\\\\\\ No newline at end of file\\\\ndiff --git a/node_modules/async/.travis.yml b/node_modules/async/.travis.yml\\\\nnew file mode 100644\\\\nindex 0000000..6e5919d\\\\n--- /dev/null\\\\n+++ b/node_modules/async/.travis.yml\\\\n@@ -0,0 +1,3 @@\\\\n+language: node_js\\\\n+node_js:\\\\n+  - \\\\\\\"0.10\\\\\\\"\\\\ndiff --git a/node_modules/async/LICENSE b/node_modules/async/LICENSE\\\\nnew file mode 100644\\\\nindex 0000000..8f29698\\\\n--- /dev/null\\\\n+++ b/node_modules/async/LICENSE\\\\n@@ -0,0 +1,19 @@\\\\n+Copyright (c) 2010-2014 Caolan McMahon\\\\n+\\\\n+Permission is hereby granted, free of charge, to any person obtaining a copy\\\\n+of this software and associated documentation files (the \\\\\\\"Software\\\\\\\"), to deal\\\\n+in the Software without restriction, including without limitation the rights\\\\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\\\n+copies of the Software, and to permit persons to whom the Software is\\\\n+furnished to do so, subject to the following conditions:\\\\n+\\\\n+The above copyright notice and this permission notice shall be included in\\\\n+all copies or substantial portions of the Software.\\\\n+\\\\n+THE SOFTWARE IS PROVIDED \\\\\\\"AS IS\\\\\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\\\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\\\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\\\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\\\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\\\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\\\n+THE SOFTWARE.\\\\ndiff --git a/node_modules/async/README.md b/node_modules/async/README.md\\\\nnew file mode 100644\\\\nindex 0000000..0bea531\\\\n--- /dev/null\\\\n+++ b/node_modules/async/README.md\\\\n@@ -0,0 +1,1646 @@\\\\n+# Async.js\\\\n+\\\\n+[![Build Status via Travis CI](https://travis-ci.org/caolan/async.svg?branch=master)](https://travis-ci.org/caolan/async)\\\\n+\\\\n+\\\\n+Async is a utility module which provides straight-forward, powerful functions\\\\n+for working with asynchronous JavaScript. Although originally designed for\\\\n+use with [Node.js](http://nodejs.org), it can also be used directly in the\\\\n+browser. Also supports [component](https://github.com/component/component).\\\\n+\\\\n+Async provides around 20 functions that include the usual 'functional'\\\\n+suspects (`map`, `reduce`, `filter`, `each`…) as well as some common patterns\\\\n+for asynchronous control flow (`parallel`, `series`, `waterfall`…). All these\\\\n+functions assume you follow the Node.js convention of providing a single\\\\n+callback as the last argument of your `async` function.\\\\n+\\\\n+\\\\n+## Quick Examples\\\\n+\\\\n+```javascript\\\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\\\n+    // results is now an array of stats for each file\\\\n+});\\\\n+\\\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\\\n+    // results now equals an array of the existing files\\\\n+});\\\\n+\\\\n+async.parallel([\\\\n+    function(){ ... },\\\\n+    function(){ ... }\\\\n+], callback);\\\\n+\\\\n+async.series([\\\\n+    function(){ ... },\\\\n+    function(){ ... }\\\\n+]);\\\\n+```\\\\n+\\\\n+There are many more functions available so take a look at the docs below for a\\\\n+full list. This module aims to be comprehensive, so if you feel anything is\\\\n+missing please create a GitHub issue for it.\\\\n+\\\\n+## Common Pitfalls\\\\n+\\\\n+### Binding a context to an iterator\\\\n+\\\\n+This section is really about `bind`, not about `async`. If you are wondering how to\\\\n+make `async` execute your iterators in a given context, or are confused as to why\\\\n+a method of another library isn't working as an iterator, study this example:\\\\n+\\\\n+```js\\\\n+// Here is a simple object with an (unnecessarily roundabout) squaring method\\\\n+var AsyncSquaringLibrary = {\\\\n+  squareExponent: 2,\\\\n+  square: function(number, callback){ \\\\n+    var result = Math.pow(number, this.squareExponent);\\\\n+    setTimeout(function(){\\\\n+      callback(null, result);\\\\n+    }, 200);\\\\n+  }\\\\n+};\\\\n+\\\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square, function(err, result){\\\\n+  // result is [NaN, NaN, NaN]\\\\n+  // This fails because the `this.squareExponent` expression in the square\\\\n+  // function is not evaluated in the context of AsyncSquaringLibrary, and is\\\\n+  // therefore undefined.\\\\n+});\\\\n+\\\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), function(err, result){\\\\n+  // result is [1, 4, 9]\\\\n+  // With the help of bind we can attach a context to the iterator before\\\\n+  // passing it to async. Now the square function will be executed in its \\\\n+  // 'home' AsyncSquaringLibrary context and the value of `this.squareExponent`\\\\n+  // will be as expected.\\\\n+});\\\\n+```\\\\n+\\\\n+## Download\\\\n+\\\\n+The source is available for download from\\\\n+[GitHub](http://github.com/caolan/async).\\\\n+Alternatively, you can install using Node Package Manager (`npm`):\\\\n+\\\\n+    npm install async\\\\n+\\\\n+__Development:__ [async.js](https://github.com/caolan/async/raw/master/lib/async.js) - 29.6kb Uncompressed\\\\n+\\\\n+## In the Browser\\\\n+\\\\n+So far it's been tested in IE6, IE7, IE8, FF3.6 and Chrome 5. \\\\n+\\\\n+Usage:\\\\n+\\\\n+```html\\\\n+<script type=\\\\\\\"text/javascript\\\\\\\" src=\\\\\\\"async.js\\\\\\\"></script>\\\\n+<script type=\\\\\\\"text/javascript\\\\\\\">\\\\n+\\\\n+    async.map(data, asyncProcess, function(err, results){\\\\n+        alert(results);\\\\n+    });\\\\n+\\\\n+</script>\\\\n+```\\\\n+\\\\n+## Documentation\\\\n+\\\\n+### Collections\\\\n+\\\\n+* [`each`](#each)\\\\n+* [`eachSeries`](#eachSeries)\\\\n+* [`eachLimit`](#eachLimit)\\\\n+* [`map`](#map)\\\\n+* [`mapSeries`](#mapSeries)\\\\n+* [`mapLimit`](#mapLimit)\\\\n+* [`filter`](#filter)\\\\n+* [`filterSeries`](#filterSeries)\\\\n+* [`reject`](#reject)\\\\n+* [`rejectSeries`](#rejectSeries)\\\\n+* [`reduce`](#reduce)\\\\n+* [`reduceRight`](#reduceRight)\\\\n+* [`detect`](#detect)\\\\n+* [`detectSeries`](#detectSeries)\\\\n+* [`sortBy`](#sortBy)\\\\n+* [`some`](#some)\\\\n+* [`every`](#every)\\\\n+* [`concat`](#concat)\\\\n+* [`concatSeries`](#concatSeries)\\\\n+\\\\n+### Control Flow\\\\n+\\\\n+* [`series`](#seriestasks-callback)\\\\n+* [`parallel`](#parallel)\\\\n+* [`parallelLimit`](#parallellimittasks-limit-callback)\\\\n+* [`whilst`](#whilst)\\\\n+* [`doWhilst`](#doWhilst)\\\\n+* [`until`](#until)\\\\n+* [`doUntil`](#doUntil)\\\\n+* [`forever`](#forever)\\\\n+* [`waterfall`](#waterfall)\\\\n+* [`compose`](#compose)\\\\n+* [`seq`](#seq)\\\\n+* [`applyEach`](#applyEach)\\\\n+* [`applyEachSeries`](#applyEachSeries)\\\\n+* [`queue`](#queue)\\\\n+* [`priorityQueue`](#priorityQueue)\\\\n+* [`cargo`](#cargo)\\\\n+* [`auto`](#auto)\\\\n+* [`retry`](#retry)\\\\n+* [`iterator`](#iterator)\\\\n+* [`apply`](#apply)\\\\n+* [`nextTick`](#nextTick)\\\\n+* [`times`](#times)\\\\n+* [`timesSeries`](#timesSeries)\\\\n+\\\\n+### Utils\\\\n+\\\\n+* [`memoize`](#memoize)\\\\n+* [`unmemoize`](#unmemoize)\\\\n+* [`log`](#log)\\\\n+* [`dir`](#dir)\\\\n+* [`noConflict`](#noConflict)\\\\n+\\\\n+\\\\n+## Collections\\\\n+\\\\n+<a name=\\\\\\\"forEach\\\\\\\" />\\\\n+<a name=\\\\\\\"each\\\\\\\" />\\\\n+### each(arr, iterator, callback)\\\\n+\\\\n+Applies the function `iterator` to each item in `arr`, in parallel.\\\\n+The `iterator` is called with an item from the list, and a callback for when it\\\\n+has finished. If the `iterator` passes an error to its `callback`, the main\\\\n+`callback` (for the `each` function) is immediately called with the error.\\\\n+\\\\n+Note, that since this function applies `iterator` to each item in parallel,\\\\n+there is no guarantee that the iterator functions will complete in order.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err)` which must be called once it has \\\\n+  completed. If no error has occured, the `callback` should be run without \\\\n+  arguments or with an explicit `null` argument.\\\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\\\n+  have finished, or an error occurs.\\\\n+\\\\n+__Examples__\\\\n+\\\\n+\\\\n+```js\\\\n+// assuming openFiles is an array of file names and saveFile is a function\\\\n+// to save the modified contents of that file:\\\\n+\\\\n+async.each(openFiles, saveFile, function(err){\\\\n+    // if any of the saves produced an error, err would equal that error\\\\n+});\\\\n+```\\\\n+\\\\n+```js\\\\n+// assuming openFiles is an array of file names \\\\n+\\\\n+async.each(openFiles, function( file, callback) {\\\\n+  \\\\n+  // Perform operation on file here.\\\\n+  console.log('Processing file ' + file);\\\\n+  \\\\n+  if( file.length > 32 ) {\\\\n+    console.log('This file name is too long');\\\\n+    callback('File name too long');\\\\n+  } else {\\\\n+    // Do work to process file here\\\\n+    console.log('File processed');\\\\n+    callback();\\\\n+  }\\\\n+}, function(err){\\\\n+    // if any of the file processing produced an error, err would equal that error\\\\n+    if( err ) {\\\\n+      // One of the iterations produced an error.\\\\n+      // All processing will now stop.\\\\n+      console.log('A file failed to process');\\\\n+    } else {\\\\n+      console.log('All files have been processed successfully');\\\\n+    }\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"forEachSeries\\\\\\\" />\\\\n+<a name=\\\\\\\"eachSeries\\\\\\\" />\\\\n+### eachSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`each`](#each), only `iterator` is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+This means the `iterator` functions will complete in order.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"forEachLimit\\\\\\\" />\\\\n+<a name=\\\\\\\"eachLimit\\\\\\\" />\\\\n+### eachLimit(arr, limit, iterator, callback)\\\\n+\\\\n+The same as [`each`](#each), only no more than `limit` `iterator`s will be simultaneously \\\\n+running at any time.\\\\n+\\\\n+Note that the items in `arr` are not processed in batches, so there is no guarantee that \\\\n+the first `limit` `iterator` functions will complete before any others are started.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err)` which must be called once it has \\\\n+  completed. If no error has occured, the callback should be run without \\\\n+  arguments or with an explicit `null` argument.\\\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\\\n+  have finished, or an error occurs.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// Assume documents is an array of JSON objects and requestApi is a\\\\n+// function that interacts with a rate-limited REST api.\\\\n+\\\\n+async.eachLimit(documents, 20, requestApi, function(err){\\\\n+    // if any of the saves produced an error, err would equal that error\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"map\\\\\\\" />\\\\n+### map(arr, iterator, callback)\\\\n+\\\\n+Produces a new array of values by mapping each value in `arr` through\\\\n+the `iterator` function. The `iterator` is called with an item from `arr` and a\\\\n+callback for when it has finished processing. Each of these callback takes 2 arguments: \\\\n+an `error`, and the transformed item from `arr`. If `iterator` passes an error to this \\\\n+callback, the main `callback` (for the `map` function) is immediately called with the error.\\\\n+\\\\n+Note, that since this function applies the `iterator` to each item in parallel,\\\\n+there is no guarantee that the `iterator` functions will complete in order. \\\\n+However, the results array will be in the same order as the original `arr`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\\\n+  it has completed with an error (which can be `null`) and a transformed item.\\\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\\\n+  functions have finished, or an error occurs. Results is an array of the\\\\n+  transformed items from the `arr`.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\\\n+    // results is now an array of stats for each file\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"mapSeries\\\\\\\" />\\\\n+### mapSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`map`](#map), only the `iterator` is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+The results array will be in the same order as the original.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"mapLimit\\\\\\\" />\\\\n+### mapLimit(arr, limit, iterator, callback)\\\\n+\\\\n+The same as [`map`](#map), only no more than `limit` `iterator`s will be simultaneously \\\\n+running at any time.\\\\n+\\\\n+Note that the items are not processed in batches, so there is no guarantee that \\\\n+the first `limit` `iterator` functions will complete before any others are started.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\\\n+  it has completed with an error (which can be `null`) and a transformed item.\\\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\\\n+  calls have finished, or an error occurs. The result is an array of the\\\\n+  transformed items from the original `arr`.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.mapLimit(['file1','file2','file3'], 1, fs.stat, function(err, results){\\\\n+    // results is now an array of stats for each file\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"select\\\\\\\" />\\\\n+<a name=\\\\\\\"filter\\\\\\\" />\\\\n+### filter(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `select`\\\\n+\\\\n+Returns a new array of all the values in `arr` which pass an async truth test.\\\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\n+way node libraries work with truth tests like `fs.exists`. This operation is\\\\n+performed in parallel, but the results array will be in the same order as the\\\\n+original.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\\\n+  The `iterator` is passed a `callback(truthValue)`, which must be called with a \\\\n+  boolean argument once it has completed.\\\\n+* `callback(results)` - A callback which is called after all the `iterator`\\\\n+  functions have finished.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\\\n+    // results now equals an array of the existing files\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"selectSeries\\\\\\\" />\\\\n+<a name=\\\\\\\"filterSeries\\\\\\\" />\\\\n+### filterSeries(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `selectSeries`\\\\n+\\\\n+The same as [`filter`](#filter) only the `iterator` is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+The results array will be in the same order as the original.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"reject\\\\\\\" />\\\\n+### reject(arr, iterator, callback)\\\\n+\\\\n+The opposite of [`filter`](#filter). Removes values that pass an `async` truth test.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"rejectSeries\\\\\\\" />\\\\n+### rejectSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`reject`](#reject), only the `iterator` is applied to each item in `arr`\\\\n+in series.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"reduce\\\\\\\" />\\\\n+### reduce(arr, memo, iterator, callback)\\\\n+\\\\n+__Aliases:__ `inject`, `foldl`\\\\n+\\\\n+Reduces `arr` into a single value using an async `iterator` to return\\\\n+each successive step. `memo` is the initial state of the reduction. \\\\n+This function only operates in series. \\\\n+\\\\n+For performance reasons, it may make sense to split a call to this function into \\\\n+a parallel map, and then use the normal `Array.prototype.reduce` on the results. \\\\n+This function is for situations where each step in the reduction needs to be async; \\\\n+if you can get the data before reducing it, then it's probably a good idea to do so.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `memo` - The initial state of the reduction.\\\\n+* `iterator(memo, item, callback)` - A function applied to each item in the\\\\n+  array to produce the next step in the reduction. The `iterator` is passed a\\\\n+  `callback(err, reduction)` which accepts an optional error as its first \\\\n+  argument, and the state of the reduction as the second. If an error is \\\\n+  passed to the callback, the reduction is stopped and the main `callback` is \\\\n+  immediately called with the error.\\\\n+* `callback(err, result)` - A callback which is called after all the `iterator`\\\\n+  functions have finished. Result is the reduced value.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.reduce([1,2,3], 0, function(memo, item, callback){\\\\n+    // pointless async:\\\\n+    process.nextTick(function(){\\\\n+        callback(null, memo + item)\\\\n+    });\\\\n+}, function(err, result){\\\\n+    // result is now equal to the last value of memo, which is 6\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"reduceRight\\\\\\\" />\\\\n+### reduceRight(arr, memo, iterator, callback)\\\\n+\\\\n+__Alias:__ `foldr`\\\\n+\\\\n+Same as [`reduce`](#reduce), only operates on `arr` in reverse order.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"detect\\\\\\\" />\\\\n+### detect(arr, iterator, callback)\\\\n+\\\\n+Returns the first value in `arr` that passes an async truth test. The\\\\n+`iterator` is applied in parallel, meaning the first iterator to return `true` will\\\\n+fire the detect `callback` with that result. That means the result might not be\\\\n+the first item in the original `arr` (in terms of order) that passes the test.\\\\n+\\\\n+If order within the original `arr` is important, then look at [`detectSeries`](#detectSeries).\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(truthValue)` which must be called with a \\\\n+  boolean argument once it has completed.\\\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\\\n+  `true`, or after all the `iterator` functions have finished. Result will be\\\\n+  the first item in the array that passes the truth test (iterator) or the\\\\n+  value `undefined` if none passed.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.detect(['file1','file2','file3'], fs.exists, function(result){\\\\n+    // result now equals the first file in the list that exists\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"detectSeries\\\\\\\" />\\\\n+### detectSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`detect`](#detect), only the `iterator` is applied to each item in `arr`\\\\n+in series. This means the result is always the first in the original `arr` (in\\\\n+terms of array order) that passes the truth test.\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"sortBy\\\\\\\" />\\\\n+### sortBy(arr, iterator, callback)\\\\n+\\\\n+Sorts a list by the results of running each `arr` value through an async `iterator`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, sortValue)` which must be called once it\\\\n+  has completed with an error (which can be `null`) and a value to use as the sort\\\\n+  criteria.\\\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\\\n+  functions have finished, or an error occurs. Results is the items from\\\\n+  the original `arr` sorted by the values returned by the `iterator` calls.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.sortBy(['file1','file2','file3'], function(file, callback){\\\\n+    fs.stat(file, function(err, stats){\\\\n+        callback(err, stats.mtime);\\\\n+    });\\\\n+}, function(err, results){\\\\n+    // results is now the original array of files sorted by\\\\n+    // modified date\\\\n+});\\\\n+```\\\\n+\\\\n+__Sort Order__\\\\n+\\\\n+By modifying the callback parameter the sorting order can be influenced:\\\\n+\\\\n+```js\\\\n+//ascending order\\\\n+async.sortBy([1,9,3,5], function(x, callback){\\\\n+    callback(err, x);\\\\n+}, function(err,result){\\\\n+    //result callback\\\\n+} );\\\\n+\\\\n+//descending order\\\\n+async.sortBy([1,9,3,5], function(x, callback){\\\\n+    callback(err, x*-1);    //<- x*-1 instead of x, turns the order around\\\\n+}, function(err,result){\\\\n+    //result callback\\\\n+} );\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"some\\\\\\\" />\\\\n+### some(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `any`\\\\n+\\\\n+Returns `true` if at least one element in the `arr` satisfies an async test.\\\\n+_The callback for each iterator call only accepts a single argument of `true` or\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\n+way node libraries work with truth tests like `fs.exists`. Once any iterator\\\\n+call returns `true`, the main `callback` is immediately called.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\\\n+  called with a boolean argument once it has completed.\\\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\\\n+  `true`, or after all the iterator functions have finished. Result will be\\\\n+  either `true` or `false` depending on the values of the async tests.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.some(['file1','file2','file3'], fs.exists, function(result){\\\\n+    // if result is true then at least one of the files exists\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"every\\\\\\\" />\\\\n+### every(arr, iterator, callback)\\\\n+\\\\n+__Alias:__ `all`\\\\n+\\\\n+Returns `true` if every element in `arr` satisfies an async test.\\\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\n+way node libraries work with truth tests like `fs.exists`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\\\n+  called with a  boolean argument once it has completed.\\\\n+* `callback(result)` - A callback which is called after all the `iterator`\\\\n+  functions have finished. Result will be either `true` or `false` depending on\\\\n+  the values of the async tests.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.every(['file1','file2','file3'], fs.exists, function(result){\\\\n+    // if result is true then every file exists\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"concat\\\\\\\" />\\\\n+### concat(arr, iterator, callback)\\\\n+\\\\n+Applies `iterator` to each item in `arr`, concatenating the results. Returns the\\\\n+concatenated list. The `iterator`s are called in parallel, and the results are\\\\n+concatenated as they return. There is no guarantee that the results array will\\\\n+be returned in the original order of `arr` passed to the `iterator` function.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `arr` - An array to iterate over.\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\n+  The iterator is passed a `callback(err, results)` which must be called once it \\\\n+  has completed with an error (which can be `null`) and an array of results.\\\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\\\n+  functions have finished, or an error occurs. Results is an array containing\\\\n+  the concatenated results of the `iterator` function.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files){\\\\n+    // files is now a list of filenames that exist in the 3 directories\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"concatSeries\\\\\\\" />\\\\n+### concatSeries(arr, iterator, callback)\\\\n+\\\\n+Same as [`concat`](#concat), but executes in series instead of parallel.\\\\n+\\\\n+\\\\n+## Control Flow\\\\n+\\\\n+<a name=\\\\\\\"series\\\\\\\" />\\\\n+### series(tasks, [callback])\\\\n+\\\\n+Run the functions in the `tasks` array in series, each one running once the previous\\\\n+function has completed. If any functions in the series pass an error to its\\\\n+callback, no more functions are run, and `callback` is immediately called with the value of the error. \\\\n+Otherwise, `callback` receives an array of results when `tasks` have completed.\\\\n+\\\\n+It is also possible to use an object instead of an array. Each property will be\\\\n+run as a function, and the results will be passed to the final `callback` as an object\\\\n+instead of an array. This can be a more readable way of handling results from\\\\n+[`series`](#series).\\\\n+\\\\n+**Note** that while many implementations preserve the order of object properties, the\\\\n+[ECMAScript Language Specifcation](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6) \\\\n+explicitly states that\\\\n+\\\\n+> The mechanics and order of enumerating the properties is not specified.\\\\n+\\\\n+So if you rely on the order in which your series of functions are executed, and want\\\\n+this to work on all platforms, consider using an array. \\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array or object containing functions to run, each function is passed\\\\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\\\n+  be `null`) and an optional `result` value.\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\n+  have completed. This function gets a results array (or object) containing all \\\\n+  the result arguments passed to the `task` callbacks.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.series([\\\\n+    function(callback){\\\\n+        // do some stuff ...\\\\n+        callback(null, 'one');\\\\n+    },\\\\n+    function(callback){\\\\n+        // do some more stuff ...\\\\n+        callback(null, 'two');\\\\n+    }\\\\n+],\\\\n+// optional callback\\\\n+function(err, results){\\\\n+    // results is now equal to ['one', 'two']\\\\n+});\\\\n+\\\\n+\\\\n+// an example using an object instead of an array\\\\n+async.series({\\\\n+    one: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 1);\\\\n+        }, 200);\\\\n+    },\\\\n+    two: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 2);\\\\n+        }, 100);\\\\n+    }\\\\n+},\\\\n+function(err, results) {\\\\n+    // results is now equal to: {one: 1, two: 2}\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"parallel\\\\\\\" />\\\\n+### parallel(tasks, [callback])\\\\n+\\\\n+Run the `tasks` array of functions in parallel, without waiting until the previous\\\\n+function has completed. If any of the functions pass an error to its\\\\n+callback, the main `callback` is immediately called with the value of the error.\\\\n+Once the `tasks` have completed, the results are passed to the final `callback` as an\\\\n+array.\\\\n+\\\\n+It is also possible to use an object instead of an array. Each property will be\\\\n+run as a function and the results will be passed to the final `callback` as an object\\\\n+instead of an array. This can be a more readable way of handling results from\\\\n+[`parallel`](#parallel).\\\\n+\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array or object containing functions to run. Each function is passed \\\\n+  a `callback(err, result)` which it must call on completion with an error `err` \\\\n+  (which can be `null`) and an optional `result` value.\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\n+  have completed. This function gets a results array (or object) containing all \\\\n+  the result arguments passed to the task callbacks.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.parallel([\\\\n+    function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 'one');\\\\n+        }, 200);\\\\n+    },\\\\n+    function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 'two');\\\\n+        }, 100);\\\\n+    }\\\\n+],\\\\n+// optional callback\\\\n+function(err, results){\\\\n+    // the results array will equal ['one','two'] even though\\\\n+    // the second function had a shorter timeout.\\\\n+});\\\\n+\\\\n+\\\\n+// an example using an object instead of an array\\\\n+async.parallel({\\\\n+    one: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 1);\\\\n+        }, 200);\\\\n+    },\\\\n+    two: function(callback){\\\\n+        setTimeout(function(){\\\\n+            callback(null, 2);\\\\n+        }, 100);\\\\n+    }\\\\n+},\\\\n+function(err, results) {\\\\n+    // results is now equals to: {one: 1, two: 2}\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"parallelLimit\\\\\\\" />\\\\n+### parallelLimit(tasks, limit, [callback])\\\\n+\\\\n+The same as [`parallel`](#parallel), only `tasks` are executed in parallel \\\\n+with a maximum of `limit` tasks executing at any time.\\\\n+\\\\n+Note that the `tasks` are not executed in batches, so there is no guarantee that \\\\n+the first `limit` tasks will complete before any others are started.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array or object containing functions to run, each function is passed \\\\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\\\n+  be `null`) and an optional `result` value.\\\\n+* `limit` - The maximum number of `tasks` to run at any time.\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\n+  have completed. This function gets a results array (or object) containing all \\\\n+  the result arguments passed to the `task` callbacks.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"whilst\\\\\\\" />\\\\n+### whilst(test, fn, callback)\\\\n+\\\\n+Repeatedly call `fn`, while `test` returns `true`. Calls `callback` when stopped,\\\\n+or an error occurs.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `test()` - synchronous truth test to perform before each execution of `fn`.\\\\n+* `fn(callback)` - A function which is called each time `test` passes. The function is\\\\n+  passed a `callback(err)`, which must be called once it has completed with an \\\\n+  optional `err` argument.\\\\n+* `callback(err)` - A callback which is called after the test fails and repeated\\\\n+  execution of `fn` has stopped.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var count = 0;\\\\n+\\\\n+async.whilst(\\\\n+    function () { return count < 5; },\\\\n+    function (callback) {\\\\n+        count++;\\\\n+        setTimeout(callback, 1000);\\\\n+    },\\\\n+    function (err) {\\\\n+        // 5 seconds have passed\\\\n+    }\\\\n+);\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"doWhilst\\\\\\\" />\\\\n+### doWhilst(fn, test, callback)\\\\n+\\\\n+The post-check version of [`whilst`](#whilst). To reflect the difference in \\\\n+the order of operations, the arguments `test` and `fn` are switched. \\\\n+\\\\n+`doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"until\\\\\\\" />\\\\n+### until(test, fn, callback)\\\\n+\\\\n+Repeatedly call `fn` until `test` returns `true`. Calls `callback` when stopped,\\\\n+or an error occurs.\\\\n+\\\\n+The inverse of [`whilst`](#whilst).\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"doUntil\\\\\\\" />\\\\n+### doUntil(fn, test, callback)\\\\n+\\\\n+Like [`doWhilst`](#doWhilst), except the `test` is inverted. Note the argument ordering differs from `until`.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"forever\\\\\\\" />\\\\n+### forever(fn, errback)\\\\n+\\\\n+Calls the asynchronous function `fn` with a callback parameter that allows it to\\\\n+call itself again, in series, indefinitely.\\\\n+\\\\n+If an error is passed to the callback then `errback` is called with the\\\\n+error, and execution stops, otherwise it will never be called.\\\\n+\\\\n+```js\\\\n+async.forever(\\\\n+    function(next) {\\\\n+        // next is suitable for passing to things that need a callback(err [, whatever]);\\\\n+        // it will result in this function being called again.\\\\n+    },\\\\n+    function(err) {\\\\n+        // if next is called with a value in its first parameter, it will appear\\\\n+        // in here as 'err', and execution will stop.\\\\n+    }\\\\n+);\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"waterfall\\\\\\\" />\\\\n+### waterfall(tasks, [callback])\\\\n+\\\\n+Runs the `tasks` array of functions in series, each passing their results to the next in\\\\n+the array. However, if any of the `tasks` pass an error to their own callback, the\\\\n+next function is not executed, and the main `callback` is immediately called with\\\\n+the error.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array of functions to run, each function is passed a \\\\n+  `callback(err, result1, result2, ...)` it must call on completion. The first\\\\n+  argument is an error (which can be `null`) and any further arguments will be \\\\n+  passed as arguments in order to the next task.\\\\n+* `callback(err, [results])` - An optional callback to run once all the functions\\\\n+  have completed. This will be passed the results of the last task's callback.\\\\n+\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.waterfall([\\\\n+    function(callback){\\\\n+        callback(null, 'one', 'two');\\\\n+    },\\\\n+    function(arg1, arg2, callback){\\\\n+      // arg1 now equals 'one' and arg2 now equals 'two'\\\\n+        callback(null, 'three');\\\\n+    },\\\\n+    function(arg1, callback){\\\\n+        // arg1 now equals 'three'\\\\n+        callback(null, 'done');\\\\n+    }\\\\n+], function (err, result) {\\\\n+   // result now equals 'done'    \\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+<a name=\\\\\\\"compose\\\\\\\" />\\\\n+### compose(fn1, fn2...)\\\\n+\\\\n+Creates a function which is a composition of the passed asynchronous\\\\n+functions. Each function consumes the return value of the function that\\\\n+follows. Composing functions `f()`, `g()`, and `h()` would produce the result of\\\\n+`f(g(h()))`, only this version uses callbacks to obtain the return values.\\\\n+\\\\n+Each function is executed with the `this` binding of the composed function.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `functions...` - the asynchronous functions to compose\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+function add1(n, callback) {\\\\n+    setTimeout(function () {\\\\n+        callback(null, n + 1);\\\\n+    }, 10);\\\\n+}\\\\n+\\\\n+function mul3(n, callback) {\\\\n+    setTimeout(function () {\\\\n+        callback(null, n * 3);\\\\n+    }, 10);\\\\n+}\\\\n+\\\\n+var add1mul3 = async.compose(mul3, add1);\\\\n+\\\\n+add1mul3(4, function (err, result) {\\\\n+   // result now equals 15\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+<a name=\\\\\\\"seq\\\\\\\" />\\\\n+### seq(fn1, fn2...)\\\\n+\\\\n+Version of the compose function that is more natural to read.\\\\n+Each following function consumes the return value of the latter function. \\\\n+\\\\n+Each function is executed with the `this` binding of the composed function.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* functions... - the asynchronous functions to compose\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// Requires lodash (or underscore), express3 and dresende's orm2.\\\\n+// Part of an app, that fetches cats of the logged user.\\\\n+// This example uses `seq` function to avoid overnesting and error \\\\n+// handling clutter.\\\\n+app.get('/cats', function(request, response) {\\\\n+  function handleError(err, data, callback) {\\\\n+    if (err) {\\\\n+      console.error(err);\\\\n+      response.json({ status: 'error', message: err.message });\\\\n+    }\\\\n+    else {\\\\n+      callback(data);\\\\n+    }\\\\n+  }\\\\n+  var User = request.models.User;\\\\n+  async.seq(\\\\n+    _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\\\\n+    handleError,\\\\n+    function(user, fn) {\\\\n+      user.getCats(fn);      // 'getCats' has signature (callback(err, data))\\\\n+    },\\\\n+    handleError,\\\\n+    function(cats) {\\\\n+      response.json({ status: 'ok', message: 'Cats found', data: cats });\\\\n+    }\\\\n+  )(req.session.user_id);\\\\n+  }\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+<a name=\\\\\\\"applyEach\\\\\\\" />\\\\n+### applyEach(fns, args..., callback)\\\\n+\\\\n+Applies the provided arguments to each function in the array, calling \\\\n+`callback` after all functions have completed. If you only provide the first\\\\n+argument, then it will return a function which lets you pass in the\\\\n+arguments as if it were a single function call.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `fns` - the asynchronous functions to all call with the same arguments\\\\n+* `args...` - any number of separate arguments to pass to the function\\\\n+* `callback` - the final argument should be the callback, called when all\\\\n+  functions have completed processing\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.applyEach([enableSearch, updateSchema], 'bucket', callback);\\\\n+\\\\n+// partial application example:\\\\n+async.each(\\\\n+    buckets,\\\\n+    async.applyEach([enableSearch, updateSchema]),\\\\n+    callback\\\\n+);\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"applyEachSeries\\\\\\\" />\\\\n+### applyEachSeries(arr, iterator, callback)\\\\n+\\\\n+The same as [`applyEach`](#applyEach) only the functions are applied in series.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"queue\\\\\\\" />\\\\n+### queue(worker, concurrency)\\\\n+\\\\n+Creates a `queue` object with the specified `concurrency`. Tasks added to the\\\\n+`queue` are processed in parallel (up to the `concurrency` limit). If all\\\\n+`worker`s are in progress, the task is queued until one becomes available. \\\\n+Once a `worker` completes a `task`, that `task`'s callback is called.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `worker(task, callback)` - An asynchronous function for processing a queued\\\\n+  task, which must call its `callback(err)` argument when finished, with an \\\\n+  optional `error` as an argument.\\\\n+* `concurrency` - An `integer` for determining how many `worker` functions should be\\\\n+  run in parallel.\\\\n+\\\\n+__Queue objects__\\\\n+\\\\n+The `queue` object returned by this function has the following properties and\\\\n+methods:\\\\n+\\\\n+* `length()` - a function returning the number of items waiting to be processed.\\\\n+* `started` - a function returning whether or not any items have been pushed and processed by the queue\\\\n+* `running()` - a function returning the number of items currently being processed.\\\\n+* `idle()` - a function returning false if there are items waiting or being processed, or true if not.\\\\n+* `concurrency` - an integer for determining how many `worker` functions should be\\\\n+  run in parallel. This property can be changed after a `queue` is created to\\\\n+  alter the concurrency on-the-fly.\\\\n+* `push(task, [callback])` - add a new task to the `queue`. Calls `callback` once \\\\n+  the `worker` has finished processing the task. Instead of a single task, a `tasks` array\\\\n+  can be submitted. The respective callback is used for every task in the list.\\\\n+* `unshift(task, [callback])` - add a new task to the front of the `queue`.\\\\n+* `saturated` - a callback that is called when the `queue` length hits the `concurrency` limit, \\\\n+   and further tasks will be queued.\\\\n+* `empty` - a callback that is called when the last item from the `queue` is given to a `worker`.\\\\n+* `drain` - a callback that is called when the last item from the `queue` has returned from the `worker`.\\\\n+* `paused` - a boolean for determining whether the queue is in a paused state\\\\n+* `pause()` - a function that pauses the processing of tasks until `resume()` is called.\\\\n+* `resume()` - a function that resumes the processing of queued tasks when the queue is paused.\\\\n+* `kill()` - a function that empties remaining tasks from the queue forcing it to go idle.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// create a queue object with concurrency 2\\\\n+\\\\n+var q = async.queue(function (task, callback) {\\\\n+    console.log('hello ' + task.name);\\\\n+    callback();\\\\n+}, 2);\\\\n+\\\\n+\\\\n+// assign a callback\\\\n+q.drain = function() {\\\\n+    console.log('all items have been processed');\\\\n+}\\\\n+\\\\n+// add some items to the queue\\\\n+\\\\n+q.push({name: 'foo'}, function (err) {\\\\n+    console.log('finished processing foo');\\\\n+});\\\\n+q.push({name: 'bar'}, function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+\\\\n+// add some items to the queue (batch-wise)\\\\n+\\\\n+q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+\\\\n+// add some items to the front of the queue\\\\n+\\\\n+q.unshift({name: 'bar'}, function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+```\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"priorityQueue\\\\\\\" />\\\\n+### priorityQueue(worker, concurrency)\\\\n+\\\\n+The same as [`queue`](#queue) only tasks are assigned a priority and completed in ascending priority order. There are two differences between `queue` and `priorityQueue` objects:\\\\n+\\\\n+* `push(task, priority, [callback])` - `priority` should be a number. If an array of\\\\n+  `tasks` is given, all tasks will be assigned the same priority.\\\\n+* The `unshift` method was removed.\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"cargo\\\\\\\" />\\\\n+### cargo(worker, [payload])\\\\n+\\\\n+Creates a `cargo` object with the specified payload. Tasks added to the\\\\n+cargo will be processed altogether (up to the `payload` limit). If the\\\\n+`worker` is in progress, the task is queued until it becomes available. Once\\\\n+the `worker` has completed some tasks, each callback of those tasks is called.\\\\n+Check out [this animation](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) for how `cargo` and `queue` work.\\\\n+\\\\n+While [queue](#queue) passes only one task to one of a group of workers\\\\n+at a time, cargo passes an array of tasks to a single worker, repeating\\\\n+when the worker is finished.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `worker(tasks, callback)` - An asynchronous function for processing an array of\\\\n+  queued tasks, which must call its `callback(err)` argument when finished, with \\\\n+  an optional `err` argument.\\\\n+* `payload` - An optional `integer` for determining how many tasks should be\\\\n+  processed per round; if omitted, the default is unlimited.\\\\n+\\\\n+__Cargo objects__\\\\n+\\\\n+The `cargo` object returned by this function has the following properties and\\\\n+methods:\\\\n+\\\\n+* `length()` - A function returning the number of items waiting to be processed.\\\\n+* `payload` - An `integer` for determining how many tasks should be\\\\n+  process per round. This property can be changed after a `cargo` is created to\\\\n+  alter the payload on-the-fly.\\\\n+* `push(task, [callback])` - Adds `task` to the `queue`. The callback is called\\\\n+  once the `worker` has finished processing the task. Instead of a single task, an array of `tasks` \\\\n+  can be submitted. The respective callback is used for every task in the list.\\\\n+* `saturated` - A callback that is called when the `queue.length()` hits the concurrency and further tasks will be queued.\\\\n+* `empty` - A callback that is called when the last item from the `queue` is given to a `worker`.\\\\n+* `drain` - A callback that is called when the last item from the `queue` has returned from the `worker`.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// create a cargo object with payload 2\\\\n+\\\\n+var cargo = async.cargo(function (tasks, callback) {\\\\n+    for(var i=0; i<tasks.length; i++){\\\\n+      console.log('hello ' + tasks[i].name);\\\\n+    }\\\\n+    callback();\\\\n+}, 2);\\\\n+\\\\n+\\\\n+// add some items\\\\n+\\\\n+cargo.push({name: 'foo'}, function (err) {\\\\n+    console.log('finished processing foo');\\\\n+});\\\\n+cargo.push({name: 'bar'}, function (err) {\\\\n+    console.log('finished processing bar');\\\\n+});\\\\n+cargo.push({name: 'baz'}, function (err) {\\\\n+    console.log('finished processing baz');\\\\n+});\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"auto\\\\\\\" />\\\\n+### auto(tasks, [callback])\\\\n+\\\\n+Determines the best order for running the functions in `tasks`, based on their \\\\n+requirements. Each function can optionally depend on other functions being completed \\\\n+first, and each function is run as soon as its requirements are satisfied. \\\\n+\\\\n+If any of the functions pass an error to their callback, it will not \\\\n+complete (so any other functions depending on it will not run), and the main \\\\n+`callback` is immediately called with the error. Functions also receive an \\\\n+object containing the results of functions which have completed so far.\\\\n+\\\\n+Note, all functions are called with a `results` object as a second argument, \\\\n+so it is unsafe to pass functions in the `tasks` object which cannot handle the\\\\n+extra argument. \\\\n+\\\\n+For example, this snippet of code:\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+  readData: async.apply(fs.readFile, 'data.txt', 'utf-8')\\\\n+}, callback);\\\\n+```\\\\n+\\\\n+will have the effect of calling `readFile` with the results object as the last\\\\n+argument, which will fail:\\\\n+\\\\n+```js\\\\n+fs.readFile('data.txt', 'utf-8', cb, {});\\\\n+```\\\\n+\\\\n+Instead, wrap the call to `readFile` in a function which does not forward the \\\\n+`results` object:\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+  readData: function(cb, results){\\\\n+    fs.readFile('data.txt', 'utf-8', cb);\\\\n+  }\\\\n+}, callback);\\\\n+```\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An object. Each of its properties is either a function or an array of\\\\n+  requirements, with the function itself the last item in the array. The object's key\\\\n+  of a property serves as the name of the task defined by that property,\\\\n+  i.e. can be used when specifying requirements for other tasks.\\\\n+  The function receives two arguments: (1) a `callback(err, result)` which must be \\\\n+  called when finished, passing an `error` (which can be `null`) and the result of \\\\n+  the function's execution, and (2) a `results` object, containing the results of\\\\n+  the previously executed functions.\\\\n+* `callback(err, results)` - An optional callback which is called when all the\\\\n+  tasks have been completed. It receives the `err` argument if any `tasks` \\\\n+  pass an error to their callback. Results are always returned; however, if \\\\n+  an error occurs, no further `tasks` will be performed, and the results\\\\n+  object will only contain partial results.\\\\n+\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+    get_data: function(callback){\\\\n+        console.log('in get_data');\\\\n+        // async code to get some data\\\\n+        callback(null, 'data', 'converted to array');\\\\n+    },\\\\n+    make_folder: function(callback){\\\\n+        console.log('in make_folder');\\\\n+        // async code to create a directory to store a file in\\\\n+        // this is run at the same time as getting the data\\\\n+        callback(null, 'folder');\\\\n+    },\\\\n+    write_file: ['get_data', 'make_folder', function(callback, results){\\\\n+        console.log('in write_file', JSON.stringify(results));\\\\n+        // once there is some data and the directory exists,\\\\n+        // write the data to a file in the directory\\\\n+        callback(null, 'filename');\\\\n+    }],\\\\n+    email_link: ['write_file', function(callback, results){\\\\n+        console.log('in email_link', JSON.stringify(results));\\\\n+        // once the file is written let's email a link to it...\\\\n+        // results.write_file contains the filename returned by write_file.\\\\n+        callback(null, {'file':results.write_file, 'email':'user@example.com'});\\\\n+    }]\\\\n+}, function(err, results) {\\\\n+    console.log('err = ', err);\\\\n+    console.log('results = ', results);\\\\n+});\\\\n+```\\\\n+\\\\n+This is a fairly trivial example, but to do this using the basic parallel and\\\\n+series functions would look like this:\\\\n+\\\\n+```js\\\\n+async.parallel([\\\\n+    function(callback){\\\\n+        console.log('in get_data');\\\\n+        // async code to get some data\\\\n+        callback(null, 'data', 'converted to array');\\\\n+    },\\\\n+    function(callback){\\\\n+        console.log('in make_folder');\\\\n+        // async code to create a directory to store a file in\\\\n+        // this is run at the same time as getting the data\\\\n+        callback(null, 'folder');\\\\n+    }\\\\n+],\\\\n+function(err, results){\\\\n+    async.series([\\\\n+        function(callback){\\\\n+            console.log('in write_file', JSON.stringify(results));\\\\n+            // once there is some data and the directory exists,\\\\n+            // write the data to a file in the directory\\\\n+            results.push('filename');\\\\n+            callback(null);\\\\n+        },\\\\n+        function(callback){\\\\n+            console.log('in email_link', JSON.stringify(results));\\\\n+            // once the file is written let's email a link to it...\\\\n+            callback(null, {'file':results.pop(), 'email':'user@example.com'});\\\\n+        }\\\\n+    ]);\\\\n+});\\\\n+```\\\\n+\\\\n+For a complicated series of `async` tasks, using the [`auto`](#auto) function makes adding\\\\n+new tasks much easier (and the code more readable).\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"retry\\\\\\\" />\\\\n+### retry([times = 5], task, [callback])\\\\n+\\\\n+Attempts to get a successful response from `task` no more than `times` times before\\\\n+returning an error. If the task is successful, the `callback` will be passed the result\\\\n+of the successfull task. If all attemps fail, the callback will be passed the error and\\\\n+result (if any) of the final attempt.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `times` - An integer indicating how many times to attempt the `task` before giving up. Defaults to 5.\\\\n+* `task(callback, results)` - A function which receives two arguments: (1) a `callback(err, result)`\\\\n+  which must be called when finished, passing `err` (which can be `null`) and the `result` of \\\\n+  the function's execution, and (2) a `results` object, containing the results of\\\\n+  the previously executed functions (if nested inside another control flow).\\\\n+* `callback(err, results)` - An optional callback which is called when the\\\\n+  task has succeeded, or after the final failed attempt. It receives the `err` and `result` arguments of the last attempt at completing the `task`.\\\\n+\\\\n+The [`retry`](#retry) function can be used as a stand-alone control flow by passing a\\\\n+callback, as shown below:\\\\n+\\\\n+```js\\\\n+async.retry(3, apiMethod, function(err, result) {\\\\n+    // do something with the result\\\\n+});\\\\n+```\\\\n+\\\\n+It can also be embeded within other control flow functions to retry individual methods\\\\n+that are not as reliable, like this:\\\\n+\\\\n+```js\\\\n+async.auto({\\\\n+    users: api.getUsers.bind(api),\\\\n+    payments: async.retry(3, api.getPayments.bind(api))\\\\n+}, function(err, results) {\\\\n+  // do something with the results\\\\n+});\\\\n+```\\\\n+\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"iterator\\\\\\\" />\\\\n+### iterator(tasks)\\\\n+\\\\n+Creates an iterator function which calls the next function in the `tasks` array,\\\\n+returning a continuation to call the next one after that. It's also possible to\\\\n+“peek” at the next iterator with `iterator.next()`.\\\\n+\\\\n+This function is used internally by the `async` module, but can be useful when\\\\n+you want to manually control the flow of functions in series.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `tasks` - An array of functions to run.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var iterator = async.iterator([\\\\n+    function(){ sys.p('one'); },\\\\n+    function(){ sys.p('two'); },\\\\n+    function(){ sys.p('three'); }\\\\n+]);\\\\n+\\\\n+node> var iterator2 = iterator();\\\\n+'one'\\\\n+node> var iterator3 = iterator2();\\\\n+'two'\\\\n+node> iterator3();\\\\n+'three'\\\\n+node> var nextfn = iterator2.next();\\\\n+node> nextfn();\\\\n+'three'\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"apply\\\\\\\" />\\\\n+### apply(function, arguments..)\\\\n+\\\\n+Creates a continuation function with some arguments already applied. \\\\n+\\\\n+Useful as a shorthand when combined with other control flow functions. Any arguments\\\\n+passed to the returned function are added to the arguments originally passed\\\\n+to apply.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\n+* `arguments...` - Any number of arguments to automatically apply when the\\\\n+  continuation is called.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// using apply\\\\n+\\\\n+async.parallel([\\\\n+    async.apply(fs.writeFile, 'testfile1', 'test1'),\\\\n+    async.apply(fs.writeFile, 'testfile2', 'test2'),\\\\n+]);\\\\n+\\\\n+\\\\n+// the same process without using apply\\\\n+\\\\n+async.parallel([\\\\n+    function(callback){\\\\n+        fs.writeFile('testfile1', 'test1', callback);\\\\n+    },\\\\n+    function(callback){\\\\n+        fs.writeFile('testfile2', 'test2', callback);\\\\n+    }\\\\n+]);\\\\n+```\\\\n+\\\\n+It's possible to pass any number of additional arguments when calling the\\\\n+continuation:\\\\n+\\\\n+```js\\\\n+node> var fn = async.apply(sys.puts, 'one');\\\\n+node> fn('two', 'three');\\\\n+one\\\\n+two\\\\n+three\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"nextTick\\\\\\\" />\\\\n+### nextTick(callback)\\\\n+\\\\n+Calls `callback` on a later loop around the event loop. In Node.js this just\\\\n+calls `process.nextTick`; in the browser it falls back to `setImmediate(callback)`\\\\n+if available, otherwise `setTimeout(callback, 0)`, which means other higher priority\\\\n+events may precede the execution of `callback`.\\\\n+\\\\n+This is used internally for browser-compatibility purposes.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `callback` - The function to call on a later loop around the event loop.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var call_order = [];\\\\n+async.nextTick(function(){\\\\n+    call_order.push('two');\\\\n+    // call_order now equals ['one','two']\\\\n+});\\\\n+call_order.push('one')\\\\n+```\\\\n+\\\\n+<a name=\\\\\\\"times\\\\\\\" />\\\\n+### times(n, callback)\\\\n+\\\\n+Calls the `callback` function `n` times, and accumulates results in the same manner\\\\n+you would use with [`map`](#map).\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `n` - The number of times to run the function.\\\\n+* `callback` - The function to call `n` times.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+// Pretend this is some complicated async factory\\\\n+var createUser = function(id, callback) {\\\\n+  callback(null, {\\\\n+    id: 'user' + id\\\\n+  })\\\\n+}\\\\n+// generate 5 users\\\\n+async.times(5, function(n, next){\\\\n+    createUser(n, function(err, user) {\\\\n+      next(err, user)\\\\n+    })\\\\n+}, function(err, users) {\\\\n+  // we should now have 5 users\\\\n+});\\\\n+```\\\\n+\\\\n+<a name=\\\\\\\"timesSeries\\\\\\\" />\\\\n+### timesSeries(n, callback)\\\\n+\\\\n+The same as [`times`](#times), only the iterator is applied to each item in `arr` in\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\n+The results array will be in the same order as the original.\\\\n+\\\\n+\\\\n+## Utils\\\\n+\\\\n+<a name=\\\\\\\"memoize\\\\\\\" />\\\\n+### memoize(fn, [hasher])\\\\n+\\\\n+Caches the results of an `async` function. When creating a hash to store function\\\\n+results against, the callback is omitted from the hash and an optional hash\\\\n+function can be used.\\\\n+\\\\n+The cache of results is exposed as the `memo` property of the function returned\\\\n+by `memoize`.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `fn` - The function to proxy and cache results from.\\\\n+* `hasher` - Tn optional function for generating a custom hash for storing\\\\n+  results. It has all the arguments applied to it apart from the callback, and\\\\n+  must be synchronous.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var slow_fn = function (name, callback) {\\\\n+    // do something\\\\n+    callback(null, result);\\\\n+};\\\\n+var fn = async.memoize(slow_fn);\\\\n+\\\\n+// fn can now be used as if it were slow_fn\\\\n+fn('some name', function () {\\\\n+    // callback\\\\n+});\\\\n+```\\\\n+\\\\n+<a name=\\\\\\\"unmemoize\\\\\\\" />\\\\n+### unmemoize(fn)\\\\n+\\\\n+Undoes a [`memoize`](#memoize)d function, reverting it to the original, unmemoized\\\\n+form. Handy for testing.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `fn` - the memoized function\\\\n+\\\\n+<a name=\\\\\\\"log\\\\\\\" />\\\\n+### log(function, arguments)\\\\n+\\\\n+Logs the result of an `async` function to the `console`. Only works in Node.js or\\\\n+in browsers that support `console.log` and `console.error` (such as FF and Chrome).\\\\n+If multiple arguments are returned from the async function, `console.log` is\\\\n+called on each argument in order.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\n+* `arguments...` - Any number of arguments to apply to the function.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var hello = function(name, callback){\\\\n+    setTimeout(function(){\\\\n+        callback(null, 'hello ' + name);\\\\n+    }, 1000);\\\\n+};\\\\n+```\\\\n+```js\\\\n+node> async.log(hello, 'world');\\\\n+'hello world'\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"dir\\\\\\\" />\\\\n+### dir(function, arguments)\\\\n+\\\\n+Logs the result of an `async` function to the `console` using `console.dir` to\\\\n+display the properties of the resulting object. Only works in Node.js or\\\\n+in browsers that support `console.dir` and `console.error` (such as FF and Chrome).\\\\n+If multiple arguments are returned from the async function, `console.dir` is\\\\n+called on each argument in order.\\\\n+\\\\n+__Arguments__\\\\n+\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\n+* `arguments...` - Any number of arguments to apply to the function.\\\\n+\\\\n+__Example__\\\\n+\\\\n+```js\\\\n+var hello = function(name, callback){\\\\n+    setTimeout(function(){\\\\n+        callback(null, {hello: name});\\\\n+    }, 1000);\\\\n+};\\\\n+```\\\\n+```js\\\\n+node> async.dir(hello, 'world');\\\\n+{hello: 'world'}\\\\n+```\\\\n+\\\\n+---------------------------------------\\\\n+\\\\n+<a name=\\\\\\\"noConflict\\\\\\\" />\\\\n+### noConflict()\\\\n+\\\\n+Changes the value of `async` back to its original value, returning a reference to the\\\\n+`async` object.\\\\ndiff --git a/node_modules/async/component.json b/node_modules/async/component.json\\\\nnew file mode 100644\\\\nindex 0000000..bbb0115\\\\n--- /dev/null\\\\n+++ b/node_modules/async/component.json\\\\n@@ -0,0 +1,11 @@\\\\n+{\\\\n+  \\\\\\\"name\\\\\\\": \\\\\\\"async\\\\\\\",\\\\n+  \\\\\\\"repo\\\\\\\": \\\\\\\"caolan/async\\\\\\\",\\\\n+  \\\\\\\"description\\\\\\\": \\\\\\\"Higher-order functions and common patterns for asynchronous code\\\\\\\",\\\\n+  \\\\\\\"version\\\\\\\": \\\\\\\"0.1.23\\\\\\\",\\\\n+  \\\\\\\"keywords\\\\\\\": [],\\\\n+  \\\\\\\"dependencies\\\\\\\": {},\\\\n+  \\\\\\\"development\\\\\\\": {},\\\\n+  \\\\\\\"main\\\\\\\": \\\\\\\"lib/async.js\\\\\\\",\\\\n+  \\\\\\\"scripts\\\\\\\": [ \\\\\\\"lib/async.js\\\\\\\" ]\\\\n+}\\\\ndiff --git a/node_modules/async/lib/async.js b/node_modules/async/lib/async.js\\\\nnew file mode 100644\\\\nindex 0000000..01e8afc\\\\n--- /dev/null\\\\n+++ b/node_modules/async/lib/async.js\\\\n@@ -0,0 +1,1123 @@\\\\n+/*!\\\\n+ * async\\\\n+ * https://github.com/caolan/async\\\\n+ *\\\\n+ * Copyright 2010-2014 Caolan McMahon\\\\n+ * Released under the MIT license\\\\n+ */\\\\n+/*jshint onevar: false, indent:4 */\\\\n+/*global setImmediate: false, setTimeout: false, console: false */\\\\n+(function () {\\\\n+\\\\n+    var async = {};\\\\n+\\\\n+    // global on the server, window in the browser\\\\n+    var root, previous_async;\\\\n+\\\\n+    root = this;\\\\n+    if (root != null) {\\\\n+      previous_async = root.async;\\\\n+    }\\\\n+\\\\n+    async.noConflict = function () {\\\\n+        root.async = previous_async;\\\\n+        return async;\\\\n+    };\\\\n+\\\\n+    function only_once(fn) {\\\\n+        var called = false;\\\\n+        return function() {\\\\n+            if (called) throw new Error(\\\\\\\"Callback was already called.\\\\\\\");\\\\n+            called = true;\\\\n+            fn.apply(root, arguments);\\\\n+        }\\\\n+    }\\\\n+\\\\n+    //// cross-browser compatiblity functions ////\\\\n+\\\\n+    var _toString = Object.prototype.toString;\\\\n+\\\\n+    var _isArray = Array.isArray || function (obj) {\\\\n+        return _toString.call(obj) === '[object Array]';\\\\n+    };\\\\n+\\\\n+    var _each = function (arr, iterator) {\\\\n+        if (arr.forEach) {\\\\n+            return arr.forEach(iterator);\\\\n+        }\\\\n+        for (var i = 0; i < arr.length; i += 1) {\\\\n+            iterator(arr[i], i, arr);\\\\n+        }\\\\n+    };\\\\n+\\\\n+    var _map = function (arr, iterator) {\\\\n+        if (arr.map) {\\\\n+            return arr.map(iterator);\\\\n+        }\\\\n+        var results = [];\\\\n+        _each(arr, function (x, i, a) {\\\\n+            results.push(iterator(x, i, a));\\\\n+        });\\\\n+        return results;\\\\n+    };\\\\n+\\\\n+    var _reduce = function (arr, iterator, memo) {\\\\n+        if (arr.reduce) {\\\\n+            return arr.reduce(iterator, memo);\\\\n+        }\\\\n+        _each(arr, function (x, i, a) {\\\\n+            memo = iterator(memo, x, i, a);\\\\n+        });\\\\n+        return memo;\\\\n+    };\\\\n+\\\\n+    var _keys = function (obj) {\\\\n+        if (Object.keys) {\\\\n+            return Object.keys(obj);\\\\n+        }\\\\n+        var keys = [];\\\\n+        for (var k in obj) {\\\\n+            if (obj.hasOwnProperty(k)) {\\\\n+                keys.push(k);\\\\n+            }\\\\n+        }\\\\n+        return keys;\\\\n+    };\\\\n+\\\\n+    //// exported async module functions ////\\\\n+\\\\n+    //// nextTick implementation with browser-compatible fallback ////\\\\n+    if (typeof process === 'undefined' || !(process.nextTick)) {\\\\n+        if (typeof setImmediate === 'function') {\\\\n+            async.nextTick = function (fn) {\\\\n+                // not a direct alias for IE10 compatibility\\\\n+                setImmediate(fn);\\\\n+            };\\\\n+            async.setImmediate = async.nextTick;\\\\n+        }\\\\n+        else {\\\\n+            async.nextTick = function (fn) {\\\\n+                setTimeout(fn, 0);\\\\n+            };\\\\n+            async.setImmediate = async.nextTick;\\\\n+        }\\\\n+    }\\\\n+    else {\\\\n+        async.nextTick = process.nextTick;\\\\n+        if (typeof setImmediate !== 'undefined') {\\\\n+            async.setImmediate = function (fn) {\\\\n+              // not a direct alias for IE10 compatibility\\\\n+              setImmediate(fn);\\\\n+            };\\\\n+        }\\\\n+        else {\\\\n+            async.setImmediate = async.nextTick;\\\\n+        }\\\\n+    }\\\\n+\\\\n+    async.each = function (arr, iterator, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (!arr.length) {\\\\n+            return callback();\\\\n+        }\\\\n+        var completed = 0;\\\\n+        _each(arr, function (x) {\\\\n+            iterator(x, only_once(done) );\\\\n+        });\\\\n+        function done(err) {\\\\n+          if (err) {\\\\n+              callback(err);\\\\n+              callback = function () {};\\\\n+          }\\\\n+          else {\\\\n+              completed += 1;\\\\n+              if (completed >= arr.length) {\\\\n+                  callback();\\\\n+              }\\\\n+          }\\\\n+        }\\\\n+    };\\\\n+    async.forEach = async.each;\\\\n+\\\\n+    async.eachSeries = function (arr, iterator, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (!arr.length) {\\\\n+            return callback();\\\\n+        }\\\\n+        var completed = 0;\\\\n+        var iterate = function () {\\\\n+            iterator(arr[completed], function (err) {\\\\n+                if (err) {\\\\n+                    callback(err);\\\\n+                    callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    completed += 1;\\\\n+                    if (completed >= arr.length) {\\\\n+                        callback();\\\\n+                    }\\\\n+                    else {\\\\n+                        iterate();\\\\n+                    }\\\\n+                }\\\\n+            });\\\\n+        };\\\\n+        iterate();\\\\n+    };\\\\n+    async.forEachSeries = async.eachSeries;\\\\n+\\\\n+    async.eachLimit = function (arr, limit, iterator, callback) {\\\\n+        var fn = _eachLimit(limit);\\\\n+        fn.apply(null, [arr, iterator, callback]);\\\\n+    };\\\\n+    async.forEachLimit = async.eachLimit;\\\\n+\\\\n+    var _eachLimit = function (limit) {\\\\n+\\\\n+        return function (arr, iterator, callback) {\\\\n+            callback = callback || function () {};\\\\n+            if (!arr.length || limit <= 0) {\\\\n+                return callback();\\\\n+            }\\\\n+            var completed = 0;\\\\n+            var started = 0;\\\\n+            var running = 0;\\\\n+\\\\n+            (function replenish () {\\\\n+                if (completed >= arr.length) {\\\\n+                    return callback();\\\\n+                }\\\\n+\\\\n+                while (running < limit && started < arr.length) {\\\\n+                    started += 1;\\\\n+                    running += 1;\\\\n+                    iterator(arr[started - 1], function (err) {\\\\n+                        if (err) {\\\\n+                            callback(err);\\\\n+                            callback = function () {};\\\\n+                        }\\\\n+                        else {\\\\n+                            completed += 1;\\\\n+                            running -= 1;\\\\n+                            if (completed >= arr.length) {\\\\n+                                callback();\\\\n+                            }\\\\n+                            else {\\\\n+                                replenish();\\\\n+                            }\\\\n+                        }\\\\n+                    });\\\\n+                }\\\\n+            })();\\\\n+        };\\\\n+    };\\\\n+\\\\n+\\\\n+    var doParallel = function (fn) {\\\\n+        return function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            return fn.apply(null, [async.each].concat(args));\\\\n+        };\\\\n+    };\\\\n+    var doParallelLimit = function(limit, fn) {\\\\n+        return function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            return fn.apply(null, [_eachLimit(limit)].concat(args));\\\\n+        };\\\\n+    };\\\\n+    var doSeries = function (fn) {\\\\n+        return function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            return fn.apply(null, [async.eachSeries].concat(args));\\\\n+        };\\\\n+    };\\\\n+\\\\n+\\\\n+    var _asyncMap = function (eachfn, arr, iterator, callback) {\\\\n+        arr = _map(arr, function (x, i) {\\\\n+            return {index: i, value: x};\\\\n+        });\\\\n+        if (!callback) {\\\\n+            eachfn(arr, function (x, callback) {\\\\n+                iterator(x.value, function (err) {\\\\n+                    callback(err);\\\\n+                });\\\\n+            });\\\\n+        } else {\\\\n+            var results = [];\\\\n+            eachfn(arr, function (x, callback) {\\\\n+                iterator(x.value, function (err, v) {\\\\n+                    results[x.index] = v;\\\\n+                    callback(err);\\\\n+                });\\\\n+            }, function (err) {\\\\n+                callback(err, results);\\\\n+            });\\\\n+        }\\\\n+    };\\\\n+    async.map = doParallel(_asyncMap);\\\\n+    async.mapSeries = doSeries(_asyncMap);\\\\n+    async.mapLimit = function (arr, limit, iterator, callback) {\\\\n+        return _mapLimit(limit)(arr, iterator, callback);\\\\n+    };\\\\n+\\\\n+    var _mapLimit = function(limit) {\\\\n+        return doParallelLimit(limit, _asyncMap);\\\\n+    };\\\\n+\\\\n+    // reduce only has a series version, as doing reduce in parallel won't\\\\n+    // work in many situations.\\\\n+    async.reduce = function (arr, memo, iterator, callback) {\\\\n+        async.eachSeries(arr, function (x, callback) {\\\\n+            iterator(memo, x, function (err, v) {\\\\n+                memo = v;\\\\n+                callback(err);\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(err, memo);\\\\n+        });\\\\n+    };\\\\n+    // inject alias\\\\n+    async.inject = async.reduce;\\\\n+    // foldl alias\\\\n+    async.foldl = async.reduce;\\\\n+\\\\n+    async.reduceRight = function (arr, memo, iterator, callback) {\\\\n+        var reversed = _map(arr, function (x) {\\\\n+            return x;\\\\n+        }).reverse();\\\\n+        async.reduce(reversed, memo, iterator, callback);\\\\n+    };\\\\n+    // foldr alias\\\\n+    async.foldr = async.reduceRight;\\\\n+\\\\n+    var _filter = function (eachfn, arr, iterator, callback) {\\\\n+        var results = [];\\\\n+        arr = _map(arr, function (x, i) {\\\\n+            return {index: i, value: x};\\\\n+        });\\\\n+        eachfn(arr, function (x, callback) {\\\\n+            iterator(x.value, function (v) {\\\\n+                if (v) {\\\\n+                    results.push(x);\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(_map(results.sort(function (a, b) {\\\\n+                return a.index - b.index;\\\\n+            }), function (x) {\\\\n+                return x.value;\\\\n+            }));\\\\n+        });\\\\n+    };\\\\n+    async.filter = doParallel(_filter);\\\\n+    async.filterSeries = doSeries(_filter);\\\\n+    // select alias\\\\n+    async.select = async.filter;\\\\n+    async.selectSeries = async.filterSeries;\\\\n+\\\\n+    var _reject = function (eachfn, arr, iterator, callback) {\\\\n+        var results = [];\\\\n+        arr = _map(arr, function (x, i) {\\\\n+            return {index: i, value: x};\\\\n+        });\\\\n+        eachfn(arr, function (x, callback) {\\\\n+            iterator(x.value, function (v) {\\\\n+                if (!v) {\\\\n+                    results.push(x);\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(_map(results.sort(function (a, b) {\\\\n+                return a.index - b.index;\\\\n+            }), function (x) {\\\\n+                return x.value;\\\\n+            }));\\\\n+        });\\\\n+    };\\\\n+    async.reject = doParallel(_reject);\\\\n+    async.rejectSeries = doSeries(_reject);\\\\n+\\\\n+    var _detect = function (eachfn, arr, iterator, main_callback) {\\\\n+        eachfn(arr, function (x, callback) {\\\\n+            iterator(x, function (result) {\\\\n+                if (result) {\\\\n+                    main_callback(x);\\\\n+                    main_callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    callback();\\\\n+                }\\\\n+            });\\\\n+        }, function (err) {\\\\n+            main_callback();\\\\n+        });\\\\n+    };\\\\n+    async.detect = doParallel(_detect);\\\\n+    async.detectSeries = doSeries(_detect);\\\\n+\\\\n+    async.some = function (arr, iterator, main_callback) {\\\\n+        async.each(arr, function (x, callback) {\\\\n+            iterator(x, function (v) {\\\\n+                if (v) {\\\\n+                    main_callback(true);\\\\n+                    main_callback = function () {};\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            main_callback(false);\\\\n+        });\\\\n+    };\\\\n+    // any alias\\\\n+    async.any = async.some;\\\\n+\\\\n+    async.every = function (arr, iterator, main_callback) {\\\\n+        async.each(arr, function (x, callback) {\\\\n+            iterator(x, function (v) {\\\\n+                if (!v) {\\\\n+                    main_callback(false);\\\\n+                    main_callback = function () {};\\\\n+                }\\\\n+                callback();\\\\n+            });\\\\n+        }, function (err) {\\\\n+            main_callback(true);\\\\n+        });\\\\n+    };\\\\n+    // all alias\\\\n+    async.all = async.every;\\\\n+\\\\n+    async.sortBy = function (arr, iterator, callback) {\\\\n+        async.map(arr, function (x, callback) {\\\\n+            iterator(x, function (err, criteria) {\\\\n+                if (err) {\\\\n+                    callback(err);\\\\n+                }\\\\n+                else {\\\\n+                    callback(null, {value: x, criteria: criteria});\\\\n+                }\\\\n+            });\\\\n+        }, function (err, results) {\\\\n+            if (err) {\\\\n+                return callback(err);\\\\n+            }\\\\n+            else {\\\\n+                var fn = function (left, right) {\\\\n+                    var a = left.criteria, b = right.criteria;\\\\n+                    return a < b ? -1 : a > b ? 1 : 0;\\\\n+                };\\\\n+                callback(null, _map(results.sort(fn), function (x) {\\\\n+                    return x.value;\\\\n+                }));\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.auto = function (tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        var keys = _keys(tasks);\\\\n+        var remainingTasks = keys.length\\\\n+        if (!remainingTasks) {\\\\n+            return callback();\\\\n+        }\\\\n+\\\\n+        var results = {};\\\\n+\\\\n+        var listeners = [];\\\\n+        var addListener = function (fn) {\\\\n+            listeners.unshift(fn);\\\\n+        };\\\\n+        var removeListener = function (fn) {\\\\n+            for (var i = 0; i < listeners.length; i += 1) {\\\\n+                if (listeners[i] === fn) {\\\\n+                    listeners.splice(i, 1);\\\\n+                    return;\\\\n+                }\\\\n+            }\\\\n+        };\\\\n+        var taskComplete = function () {\\\\n+            remainingTasks--\\\\n+            _each(listeners.slice(0), function (fn) {\\\\n+                fn();\\\\n+            });\\\\n+        };\\\\n+\\\\n+        addListener(function () {\\\\n+            if (!remainingTasks) {\\\\n+                var theCallback = callback;\\\\n+                // prevent final callback from calling itself if it errors\\\\n+                callback = function () {};\\\\n+\\\\n+                theCallback(null, results);\\\\n+            }\\\\n+        });\\\\n+\\\\n+        _each(keys, function (k) {\\\\n+            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\\\\n+            var taskCallback = function (err) {\\\\n+                var args = Array.prototype.slice.call(arguments, 1);\\\\n+                if (args.length <= 1) {\\\\n+                    args = args[0];\\\\n+                }\\\\n+                if (err) {\\\\n+                    var safeResults = {};\\\\n+                    _each(_keys(results), function(rkey) {\\\\n+                        safeResults[rkey] = results[rkey];\\\\n+                    });\\\\n+                    safeResults[k] = args;\\\\n+                    callback(err, safeResults);\\\\n+                    // stop subsequent errors hitting callback multiple times\\\\n+                    callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    results[k] = args;\\\\n+                    async.setImmediate(taskComplete);\\\\n+                }\\\\n+            };\\\\n+            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\\\\n+            var ready = function () {\\\\n+                return _reduce(requires, function (a, x) {\\\\n+                    return (a && results.hasOwnProperty(x));\\\\n+                }, true) && !results.hasOwnProperty(k);\\\\n+            };\\\\n+            if (ready()) {\\\\n+                task[task.length - 1](taskCallback, results);\\\\n+            }\\\\n+            else {\\\\n+                var listener = function () {\\\\n+                    if (ready()) {\\\\n+                        removeListener(listener);\\\\n+                        task[task.length - 1](taskCallback, results);\\\\n+                    }\\\\n+                };\\\\n+                addListener(listener);\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.retry = function(times, task, callback) {\\\\n+        var DEFAULT_TIMES = 5;\\\\n+        var attempts = [];\\\\n+        // Use defaults if times not passed\\\\n+        if (typeof times === 'function') {\\\\n+            callback = task;\\\\n+            task = times;\\\\n+            times = DEFAULT_TIMES;\\\\n+        }\\\\n+        // Make sure times is a number\\\\n+        times = parseInt(times, 10) || DEFAULT_TIMES;\\\\n+        var wrappedTask = function(wrappedCallback, wrappedResults) {\\\\n+            var retryAttempt = function(task, finalAttempt) {\\\\n+                return function(seriesCallback) {\\\\n+                    task(function(err, result){\\\\n+                        seriesCallback(!err || finalAttempt, {err: err, result: result});\\\\n+                    }, wrappedResults);\\\\n+                };\\\\n+            };\\\\n+            while (times) {\\\\n+                attempts.push(retryAttempt(task, !(times-=1)));\\\\n+            }\\\\n+            async.series(attempts, function(done, data){\\\\n+                data = data[data.length - 1];\\\\n+                (wrappedCallback || callback)(data.err, data.result);\\\\n+            });\\\\n+        }\\\\n+        // If a callback is passed, run this as a controll flow\\\\n+        return callback ? wrappedTask() : wrappedTask\\\\n+    };\\\\n+\\\\n+    async.waterfall = function (tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (!_isArray(tasks)) {\\\\n+          var err = new Error('First argument to waterfall must be an array of functions');\\\\n+          return callback(err);\\\\n+        }\\\\n+        if (!tasks.length) {\\\\n+            return callback();\\\\n+        }\\\\n+        var wrapIterator = function (iterator) {\\\\n+            return function (err) {\\\\n+                if (err) {\\\\n+                    callback.apply(null, arguments);\\\\n+                    callback = function () {};\\\\n+                }\\\\n+                else {\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\n+                    var next = iterator.next();\\\\n+                    if (next) {\\\\n+                        args.push(wrapIterator(next));\\\\n+                    }\\\\n+                    else {\\\\n+                        args.push(callback);\\\\n+                    }\\\\n+                    async.setImmediate(function () {\\\\n+                        iterator.apply(null, args);\\\\n+                    });\\\\n+                }\\\\n+            };\\\\n+        };\\\\n+        wrapIterator(async.iterator(tasks))();\\\\n+    };\\\\n+\\\\n+    var _parallel = function(eachfn, tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (_isArray(tasks)) {\\\\n+            eachfn.map(tasks, function (fn, callback) {\\\\n+                if (fn) {\\\\n+                    fn(function (err) {\\\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\\\n+                        if (args.length <= 1) {\\\\n+                            args = args[0];\\\\n+                        }\\\\n+                        callback.call(null, err, args);\\\\n+                    });\\\\n+                }\\\\n+            }, callback);\\\\n+        }\\\\n+        else {\\\\n+            var results = {};\\\\n+            eachfn.each(_keys(tasks), function (k, callback) {\\\\n+                tasks[k](function (err) {\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\n+                    if (args.length <= 1) {\\\\n+                        args = args[0];\\\\n+                    }\\\\n+                    results[k] = args;\\\\n+                    callback(err);\\\\n+                });\\\\n+            }, function (err) {\\\\n+                callback(err, results);\\\\n+            });\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.parallel = function (tasks, callback) {\\\\n+        _parallel({ map: async.map, each: async.each }, tasks, callback);\\\\n+    };\\\\n+\\\\n+    async.parallelLimit = function(tasks, limit, callback) {\\\\n+        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\\\\n+    };\\\\n+\\\\n+    async.series = function (tasks, callback) {\\\\n+        callback = callback || function () {};\\\\n+        if (_isArray(tasks)) {\\\\n+            async.mapSeries(tasks, function (fn, callback) {\\\\n+                if (fn) {\\\\n+                    fn(function (err) {\\\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\\\n+                        if (args.length <= 1) {\\\\n+                            args = args[0];\\\\n+                        }\\\\n+                        callback.call(null, err, args);\\\\n+                    });\\\\n+                }\\\\n+            }, callback);\\\\n+        }\\\\n+        else {\\\\n+            var results = {};\\\\n+            async.eachSeries(_keys(tasks), function (k, callback) {\\\\n+                tasks[k](function (err) {\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\n+                    if (args.length <= 1) {\\\\n+                        args = args[0];\\\\n+                    }\\\\n+                    results[k] = args;\\\\n+                    callback(err);\\\\n+                });\\\\n+            }, function (err) {\\\\n+                callback(err, results);\\\\n+            });\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.iterator = function (tasks) {\\\\n+        var makeCallback = function (index) {\\\\n+            var fn = function () {\\\\n+                if (tasks.length) {\\\\n+                    tasks[index].apply(null, arguments);\\\\n+                }\\\\n+                return fn.next();\\\\n+            };\\\\n+            fn.next = function () {\\\\n+                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\\\\n+            };\\\\n+            return fn;\\\\n+        };\\\\n+        return makeCallback(0);\\\\n+    };\\\\n+\\\\n+    async.apply = function (fn) {\\\\n+        var args = Array.prototype.slice.call(arguments, 1);\\\\n+        return function () {\\\\n+            return fn.apply(\\\\n+                null, args.concat(Array.prototype.slice.call(arguments))\\\\n+            );\\\\n+        };\\\\n+    };\\\\n+\\\\n+    var _concat = function (eachfn, arr, fn, callback) {\\\\n+        var r = [];\\\\n+        eachfn(arr, function (x, cb) {\\\\n+            fn(x, function (err, y) {\\\\n+                r = r.concat(y || []);\\\\n+                cb(err);\\\\n+            });\\\\n+        }, function (err) {\\\\n+            callback(err, r);\\\\n+        });\\\\n+    };\\\\n+    async.concat = doParallel(_concat);\\\\n+    async.concatSeries = doSeries(_concat);\\\\n+\\\\n+    async.whilst = function (test, iterator, callback) {\\\\n+        if (test()) {\\\\n+            iterator(function (err) {\\\\n+                if (err) {\\\\n+                    return callback(err);\\\\n+                }\\\\n+                async.whilst(test, iterator, callback);\\\\n+            });\\\\n+        }\\\\n+        else {\\\\n+            callback();\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.doWhilst = function (iterator, test, callback) {\\\\n+        iterator(function (err) {\\\\n+            if (err) {\\\\n+                return callback(err);\\\\n+            }\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\n+            if (test.apply(null, args)) {\\\\n+                async.doWhilst(iterator, test, callback);\\\\n+            }\\\\n+            else {\\\\n+                callback();\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.until = function (test, iterator, callback) {\\\\n+        if (!test()) {\\\\n+            iterator(function (err) {\\\\n+                if (err) {\\\\n+                    return callback(err);\\\\n+                }\\\\n+                async.until(test, iterator, callback);\\\\n+            });\\\\n+        }\\\\n+        else {\\\\n+            callback();\\\\n+        }\\\\n+    };\\\\n+\\\\n+    async.doUntil = function (iterator, test, callback) {\\\\n+        iterator(function (err) {\\\\n+            if (err) {\\\\n+                return callback(err);\\\\n+            }\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\n+            if (!test.apply(null, args)) {\\\\n+                async.doUntil(iterator, test, callback);\\\\n+            }\\\\n+            else {\\\\n+                callback();\\\\n+            }\\\\n+        });\\\\n+    };\\\\n+\\\\n+    async.queue = function (worker, concurrency) {\\\\n+        if (concurrency === undefined) {\\\\n+            concurrency = 1;\\\\n+        }\\\\n+        function _insert(q, data, pos, callback) {\\\\n+          if (!q.started){\\\\n+            q.started = true;\\\\n+          }\\\\n+          if (!_isArray(data)) {\\\\n+              data = [data];\\\\n+          }\\\\n+          if(data.length == 0) {\\\\n+             // call drain immediately if there are no tasks\\\\n+             return async.setImmediate(function() {\\\\n+                 if (q.drain) {\\\\n+                     q.drain();\\\\n+                 }\\\\n+             });\\\\n+          }\\\\n+          _each(data, function(task) {\\\\n+              var item = {\\\\n+                  data: task,\\\\n+                  callback: typeof callback === 'function' ? callback : null\\\\n+              };\\\\n+\\\\n+              if (pos) {\\\\n+                q.tasks.unshift(item);\\\\n+              } else {\\\\n+                q.tasks.push(item);\\\\n+              }\\\\n+\\\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\\\n+                  q.saturated();\\\\n+              }\\\\n+              async.setImmediate(q.process);\\\\n+          });\\\\n+        }\\\\n+\\\\n+        var workers = 0;\\\\n+        var q = {\\\\n+            tasks: [],\\\\n+            concurrency: concurrency,\\\\n+            saturated: null,\\\\n+            empty: null,\\\\n+            drain: null,\\\\n+            started: false,\\\\n+            paused: false,\\\\n+            push: function (data, callback) {\\\\n+              _insert(q, data, false, callback);\\\\n+            },\\\\n+            kill: function () {\\\\n+              q.drain = null;\\\\n+              q.tasks = [];\\\\n+            },\\\\n+            unshift: function (data, callback) {\\\\n+              _insert(q, data, true, callback);\\\\n+            },\\\\n+            process: function () {\\\\n+                if (!q.paused && workers < q.concurrency && q.tasks.length) {\\\\n+                    var task = q.tasks.shift();\\\\n+                    if (q.empty && q.tasks.length === 0) {\\\\n+                        q.empty();\\\\n+                    }\\\\n+                    workers += 1;\\\\n+                    var next = function () {\\\\n+                        workers -= 1;\\\\n+                        if (task.callback) {\\\\n+                            task.callback.apply(task, arguments);\\\\n+                        }\\\\n+                        if (q.drain && q.tasks.length + workers === 0) {\\\\n+                            q.drain();\\\\n+                        }\\\\n+                        q.process();\\\\n+                    };\\\\n+                    var cb = only_once(next);\\\\n+                    worker(task.data, cb);\\\\n+                }\\\\n+            },\\\\n+            length: function () {\\\\n+                return q.tasks.length;\\\\n+            },\\\\n+            running: function () {\\\\n+                return workers;\\\\n+            },\\\\n+            idle: function() {\\\\n+                return q.tasks.length + workers === 0;\\\\n+            },\\\\n+            pause: function () {\\\\n+                if (q.paused === true) { return; }\\\\n+                q.paused = true;\\\\n+                q.process();\\\\n+            },\\\\n+            resume: function () {\\\\n+                if (q.paused === false) { return; }\\\\n+                q.paused = false;\\\\n+                q.process();\\\\n+            }\\\\n+        };\\\\n+        return q;\\\\n+    };\\\\n+    \\\\n+    async.priorityQueue = function (worker, concurrency) {\\\\n+        \\\\n+        function _compareTasks(a, b){\\\\n+          return a.priority - b.priority;\\\\n+        };\\\\n+        \\\\n+        function _binarySearch(sequence, item, compare) {\\\\n+          var beg = -1,\\\\n+              end = sequence.length - 1;\\\\n+          while (beg < end) {\\\\n+            var mid = beg + ((end - beg + 1) >>> 1);\\\\n+            if (compare(item, sequence[mid]) >= 0) {\\\\n+              beg = mid;\\\\n+            } else {\\\\n+              end = mid - 1;\\\\n+            }\\\\n+          }\\\\n+          return beg;\\\\n+        }\\\\n+        \\\\n+        function _insert(q, data, priority, callback) {\\\\n+          if (!q.started){\\\\n+            q.started = true;\\\\n+          }\\\\n+          if (!_isArray(data)) {\\\\n+              data = [data];\\\\n+          }\\\\n+          if(data.length == 0) {\\\\n+             // call drain immediately if there are no tasks\\\\n+             return async.setImmediate(function() {\\\\n+                 if (q.drain) {\\\\n+                     q.drain();\\\\n+                 }\\\\n+             });\\\\n+          }\\\\n+          _each(data, function(task) {\\\\n+              var item = {\\\\n+                  data: task,\\\\n+                  priority: priority,\\\\n+                  callback: typeof callback === 'function' ? callback : null\\\\n+              };\\\\n+              \\\\n+              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\\\\n+\\\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\\\n+                  q.saturated();\\\\n+              }\\\\n+              async.setImmediate(q.process);\\\\n+          });\\\\n+        }\\\\n+        \\\\n+        // Start with a normal queue\\\\n+        var q = async.queue(worker, concurrency);\\\\n+        \\\\n+        // Override push to accept second parameter representing priority\\\\n+        q.push = function (data, priority, callback) {\\\\n+          _insert(q, data, priority, callback);\\\\n+        };\\\\n+        \\\\n+        // Remove unshift function\\\\n+        delete q.unshift;\\\\n+\\\\n+        return q;\\\\n+    };\\\\n+\\\\n+    async.cargo = function (worker, payload) {\\\\n+        var working     = false,\\\\n+            tasks       = [];\\\\n+\\\\n+        var cargo = {\\\\n+            tasks: tasks,\\\\n+            payload: payload,\\\\n+            saturated: null,\\\\n+            empty: null,\\\\n+            drain: null,\\\\n+            drained: true,\\\\n+            push: function (data, callback) {\\\\n+                if (!_isArray(data)) {\\\\n+                    data = [data];\\\\n+                }\\\\n+                _each(data, function(task) {\\\\n+                    tasks.push({\\\\n+                        data: task,\\\\n+                        callback: typeof callback === 'function' ? callback : null\\\\n+                    });\\\\n+                    cargo.drained = false;\\\\n+                    if (cargo.saturated && tasks.length === payload) {\\\\n+                        cargo.saturated();\\\\n+                    }\\\\n+                });\\\\n+                async.setImmediate(cargo.process);\\\\n+            },\\\\n+            process: function process() {\\\\n+                if (working) return;\\\\n+                if (tasks.length === 0) {\\\\n+                    if(cargo.drain && !cargo.drained) cargo.drain();\\\\n+                    cargo.drained = true;\\\\n+                    return;\\\\n+                }\\\\n+\\\\n+                var ts = typeof payload === 'number'\\\\n+                            ? tasks.splice(0, payload)\\\\n+                            : tasks.splice(0, tasks.length);\\\\n+\\\\n+                var ds = _map(ts, function (task) {\\\\n+                    return task.data;\\\\n+                });\\\\n+\\\\n+                if(cargo.empty) cargo.empty();\\\\n+                working = true;\\\\n+                worker(ds, function () {\\\\n+                    working = false;\\\\n+\\\\n+                    var args = arguments;\\\\n+                    _each(ts, function (data) {\\\\n+                        if (data.callback) {\\\\n+                            data.callback.apply(null, args);\\\\n+                        }\\\\n+                    });\\\\n+\\\\n+                    process();\\\\n+                });\\\\n+            },\\\\n+            length: function () {\\\\n+                return tasks.length;\\\\n+            },\\\\n+            running: function () {\\\\n+                return working;\\\\n+            }\\\\n+        };\\\\n+        return cargo;\\\\n+    };\\\\n+\\\\n+    var _console_fn = function (name) {\\\\n+        return function (fn) {\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\n+            fn.apply(null, args.concat([function (err) {\\\\n+                var args = Array.prototype.slice.call(arguments, 1);\\\\n+                if (typeof console !== 'undefined') {\\\\n+                    if (err) {\\\\n+                        if (console.error) {\\\\n+                            console.error(err);\\\\n+                        }\\\\n+                    }\\\\n+                    else if (console[name]) {\\\\n+                        _each(args, function (x) {\\\\n+                            console[name](x);\\\\n+                        });\\\\n+                    }\\\\n+                }\\\\n+            }]));\\\\n+        };\\\\n+    };\\\\n+    async.log = _console_fn('log');\\\\n+    async.dir = _console_fn('dir');\\\\n+    /*async.info = _console_fn('info');\\\\n+    async.warn = _console_fn('warn');\\\\n+    async.error = _console_fn('error');*/\\\\n+\\\\n+    async.memoize = function (fn, hasher) {\\\\n+        var memo = {};\\\\n+        var queues = {};\\\\n+        hasher = hasher || function (x) {\\\\n+            return x;\\\\n+        };\\\\n+        var memoized = function () {\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            var callback = args.pop();\\\\n+            var key = hasher.apply(null, args);\\\\n+            if (key in memo) {\\\\n+                async.nextTick(function () {\\\\n+                    callback.apply(null, memo[key]);\\\\n+                });\\\\n+            }\\\\n+            else if (key in queues) {\\\\n+                queues[key].push(callback);\\\\n+            }\\\\n+            else {\\\\n+                queues[key] = [callback];\\\\n+                fn.apply(null, args.concat([function () {\\\\n+                    memo[key] = arguments;\\\\n+                    var q = queues[key];\\\\n+                    delete queues[key];\\\\n+                    for (var i = 0, l = q.length; i < l; i++) {\\\\n+                      q[i].apply(null, arguments);\\\\n+                    }\\\\n+                }]));\\\\n+            }\\\\n+        };\\\\n+        memoized.memo = memo;\\\\n+        memoized.unmemoized = fn;\\\\n+        return memoized;\\\\n+    };\\\\n+\\\\n+    async.unmemoize = function (fn) {\\\\n+      return function () {\\\\n+        return (fn.unmemoized || fn).apply(null, arguments);\\\\n+      };\\\\n+    };\\\\n+\\\\n+    async.times = function (count, iterator, callback) {\\\\n+        var counter = [];\\\\n+        for (var i = 0; i < count; i++) {\\\\n+            counter.push(i);\\\\n+        }\\\\n+        return async.map(counter, iterator, callback);\\\\n+    };\\\\n+\\\\n+    async.timesSeries = function (count, iterator, callback) {\\\\n+        var counter = [];\\\\n+        for (var i = 0; i < count; i++) {\\\\n+            counter.push(i);\\\\n+        }\\\\n+        return async.mapSeries(counter, iterator, callback);\\\\n+    };\\\\n+\\\\n+    async.seq = function (/* functions... */) {\\\\n+        var fns = arguments;\\\\n+        return function () {\\\\n+            var that = this;\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            var callback = args.pop();\\\\n+            async.reduce(fns, args, function (newargs, fn, cb) {\\\\n+                fn.apply(that, newargs.concat([function () {\\\\n+                    var err = arguments[0];\\\\n+                    var nextargs = Array.prototype.slice.call(arguments, 1);\\\\n+                    cb(err, nextargs);\\\\n+                }]))\\\\n+            },\\\\n+            function (err, results) {\\\\n+                callback.apply(that, [err].concat(results));\\\\n+            });\\\\n+        };\\\\n+    };\\\\n+\\\\n+    async.compose = function (/* functions... */) {\\\\n+      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\\\\n+    };\\\\n+\\\\n+    var _applyEach = function (eachfn, fns /*args...*/) {\\\\n+        var go = function () {\\\\n+            var that = this;\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\n+            var callback = args.pop();\\\\n+            return eachfn(fns, function (fn, cb) {\\\\n+                fn.apply(that, args.concat([cb]));\\\\n+            },\\\\n+            callback);\\\\n+        };\\\\n+        if (arguments.length > 2) {\\\\n+            var args = Array.prototype.slice.call(arguments, 2);\\\\n+            return go.apply(this, args);\\\\n+        }\\\\n+        else {\\\\n+            return go;\\\\n+        }\\\\n+    };\\\\n+    async.applyEach = doParallel(_applyEach);\\\\n+    async.applyEachSeries = doSeries(_applyEach);\\\\n+\\\\n+    async.forever = function (fn, callback) {\\\\n+        function next(err) {\\\\n+            if (err) {\\\\n+                if (callback) {\\\\n+                    return callback(err);\\\\n+                }\\\\n+                throw err;\\\\n+            }\\\\n+            fn(next);\\\\n+        }\\\\n+        next();\\\\n+    };\\\\n+\\\\n+    // Node.js\\\\n+    if (typeof module !== 'undefined' && module.exports) {\\\\n+        module.exports = async;\\\\n+    }\\\\n+    // AMD / RequireJS\\\\n+    else if (typeof define !== 'undefined' && define.amd) {\\\\n+        define([], function () {\\\\n+            return async;\\\\n+        });\\\\n+    }\\\\n+    // included directly via <script> tag\\\\n+    else {\\\\n+        root.async = async;\\\\n+    }\\\\n+\\\\n+}());\\\\ndiff --git a/node_modules/async/package.json b/node_modules/async/package.json\\\\nnew file mode 100644\\\\nindex 0000000..31a5200\\\\n--- /dev/null\\\\n+++ b/node_modules/async/package.json\\\\n@@ -0,0 +1,59 @@\\\\n+{\\\\n+  \\\\\\\"name\\\\\\\": \\\\\\\"async\\\\\\\",\\\\n+  \\\\\\\"description\\\\\\\": \\\\\\\"Higher-order functions and common patterns for asynchronous code\\\\\\\",\\\\n+  \\\\\\\"main\\\\\\\": \\\\\\\"./lib/async\\\\\\\",\\\\n+  \\\\\\\"author\\\\\\\": {\\\\n+    \\\\\\\"name\\\\\\\": \\\\\\\"Caolan McMahon\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"version\\\\\\\": \\\\\\\"0.9.0\\\\\\\",\\\\n+  \\\\\\\"repository\\\\\\\": {\\\\n+    \\\\\\\"type\\\\\\\": \\\\\\\"git\\\\\\\",\\\\n+    \\\\\\\"url\\\\\\\": \\\\\\\"https://github.com/caolan/async.git\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"bugs\\\\\\\": {\\\\n+    \\\\\\\"url\\\\\\\": \\\\\\\"https://github.com/caolan/async/issues\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"licenses\\\\\\\": [\\\\n+    {\\\\n+      \\\\\\\"type\\\\\\\": \\\\\\\"MIT\\\\\\\",\\\\n+      \\\\\\\"url\\\\\\\": \\\\\\\"https://github.com/caolan/async/raw/master/LICENSE\\\\\\\"\\\\n+    }\\\\n+  ],\\\\n+  \\\\\\\"devDependencies\\\\\\\": {\\\\n+    \\\\\\\"nodeunit\\\\\\\": \\\\\\\">0.0.0\\\\\\\",\\\\n+    \\\\\\\"uglify-js\\\\\\\": \\\\\\\"1.2.x\\\\\\\",\\\\n+    \\\\\\\"nodelint\\\\\\\": \\\\\\\">0.0.0\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"jam\\\\\\\": {\\\\n+    \\\\\\\"main\\\\\\\": \\\\\\\"lib/async.js\\\\\\\",\\\\n+    \\\\\\\"include\\\\\\\": [\\\\n+      \\\\\\\"lib/async.js\\\\\\\",\\\\n+      \\\\\\\"README.md\\\\\\\",\\\\n+      \\\\\\\"LICENSE\\\\\\\"\\\\n+    ]\\\\n+  },\\\\n+  \\\\\\\"scripts\\\\\\\": {\\\\n+    \\\\\\\"test\\\\\\\": \\\\\\\"nodeunit test/test-async.js\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"homepage\\\\\\\": \\\\\\\"https://github.com/caolan/async\\\\\\\",\\\\n+  \\\\\\\"_id\\\\\\\": \\\\\\\"async@0.9.0\\\\\\\",\\\\n+  \\\\\\\"dist\\\\\\\": {\\\\n+    \\\\\\\"shasum\\\\\\\": \\\\\\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\\\\\",\\\\n+    \\\\\\\"tarball\\\\\\\": \\\\\\\"http://registry.npmjs.org/async/-/async-0.9.0.tgz\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"_from\\\\\\\": \\\\\\\"async@*\\\\\\\",\\\\n+  \\\\\\\"_npmVersion\\\\\\\": \\\\\\\"1.4.3\\\\\\\",\\\\n+  \\\\\\\"_npmUser\\\\\\\": {\\\\n+    \\\\\\\"name\\\\\\\": \\\\\\\"caolan\\\\\\\",\\\\n+    \\\\\\\"email\\\\\\\": \\\\\\\"caolan.mcmahon@gmail.com\\\\\\\"\\\\n+  },\\\\n+  \\\\\\\"maintainers\\\\\\\": [\\\\n+    {\\\\n+      \\\\\\\"name\\\\\\\": \\\\\\\"caolan\\\\\\\",\\\\n+      \\\\\\\"email\\\\\\\": \\\\\\\"caolan@caolanmcmahon.com\\\\\\\"\\\\n+    }\\\\n+  ],\\\\n+  \\\\\\\"directories\\\\\\\": {},\\\\n+  \\\\\\\"_shasum\\\\\\\": \\\\\\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\\\\\",\\\\n+  \\\\\\\"_resolved\\\\\\\": \\\\\\\"https://registry.npmjs.org/async/-/async-0.9.0.tgz\\\\\\\"\\\\n+}\\\\ndiff --git a/package.json b/package.json\\\\nindex 5f21627..6033d43 100644\\\\n--- a/package.json\\\\n+++ b/package.json\\\\n@@ -4,7 +4,8 @@\\\\n   \\\\\\\"description\\\\\\\": \\\\\\\"Sous project\\\\\\\",\\\\n   \\\\\\\"main\\\\\\\": \\\\\\\"main.js\\\\\\\",\\\\n   \\\\\\\"dependencies\\\\\\\": {\\\\n-},\\\\n+    \\\\\\\"async\\\\\\\": \\\\\\\"*\\\\\\\"\\\\n+  },\\\\n   \\\\\\\"devDependencies\\\\\\\": {},\\\\n   \\\\\\\"scripts\\\\\\\": {\\\\n     \\\\\\\"test\\\\\\\": \\\\\\\"echo \\\\\\\\\\\\\\\"Error: no test specified\\\\\\\\\\\\\\\" && exit 1\\\\\\\"\\\\ndiff --git a/patches.sousp b/patches.sousp\\\\nindex 16405a3..d71e511 100644\\\\n--- a/patches.sousp\\\\n+++ b/patches.sousp\\\\n@@ -1,31 +1 @@\\\\n-diff --git a/main.js b/main.js\\\\n-index f81b54e..744cdd5 100644\\\\n---- a/main.js\\\\n-+++ b/main.js\\\\n-@@ -35,7 +35,7 @@ fs.exists('.git', function (exists) {\\\\n-         cp.exec('git diff', function(error, stdout, stderr) {\\\\n-             console.log(stdout);\\\\n- \\\\n--            //fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", stdout);\\\\n-+            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", stdout);\\\\n- \\\\n-             if (error !== null) {\\\\n-                 console.log('stderr: ' + stderr);\\\\n-@@ -44,7 +44,7 @@ fs.exists('.git', function (exists) {\\\\n-         });\\\\n- \\\\n-         cp.exec('git log', function(error, stdout, stderr) {\\\\n--            //console.log(stdout);\\\\n-+            console.log(stdout);\\\\n- \\\\n-             var authors = findData(stdout, \\\\\\\"Author:\\\\\\\");\\\\n-             var dates = findData(stdout, \\\\\\\"Date:\\\\\\\");\\\\n-@@ -53,7 +53,7 @@ fs.exists('.git', function (exists) {\\\\n-             console.log(comments);\\\\n-             console.log(dates);\\\\n- \\\\n--            //fs.writeFileSync(\\\\\\\"comments.sousc\\\\\\\", stdout);\\\\n-+            fs.writeFileSync(\\\\\\\"comments.sousc\\\\\\\", stdout);\\\\n- \\\\n-             if (error !== null) {\\\\n-                 console.log('stderr: ' + stderr);\\\\n+[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]\\\\n\\\\\\\\ No newline at end of file\\\\ndiff --git a/test.js b/test.js\\\\nnew file mode 100644\\\\nindex 0000000..5ca759c\\\\n--- /dev/null\\\\n+++ b/test.js\\\\n@@ -0,0 +1,21 @@\\\\n+/**\\\\n+ * Created by Nick on 18.05.2015.\\\\n+ */\\\\n+var async = require('async')\\\\n+    , tasksIndex = [\\\\n+        function (callback) {\\\\n+            // Вымышленный метод который вернет 231\\\\n+            var viewsNumber = models.stat.viewsNumber();\\\\n+            callback(null, viewsNumber);\\\\n+        }\\\\n+        , function (callback) {\\\\n+            // Вымышленный метод который вернет 24\\\\n+            var growFactor = models.stat.growFactor();\\\\n+            callback(null, growFactor);\\\\n+        }\\\\n+    ];\\\\n+\\\\n+async.series(tasksIndex, function (err, results) {\\\\n+    // Результат будет массивом\\\\n+    console.log(results); // [231, 24]\\\\n+});\\\\n\\\\\\\\ No newline at end of file\\\\n\\\"}\\n\\\\ No newline at end of file\\n+{\\\"commit\\\":\\\"dbe72b9889081e5856c1e2d72723e8ab2dc898bd\\\",\\\"author\\\":\\\"Nick Stepanenko <massaalonso@yandex.ru>\\\",\\\"date\\\":\\\"Tue May 19 01:41:21 2015 +0800\\\",\\\"comment\\\":\\\"Content will be added now.\\\",\\\"content\\\":\\\"diff --git a/main.js b/main.js\\\\nindex 86f30c2..ca7473f 100644\\\\n--- a/main.js\\\\n+++ b/main.js\\\\n@@ -148,7 +148,9 @@ fs.exists('.git', function (exists) {\\\\n                         listOfCommits[listOfCommits.length] = commit;\\\\n                     }\\\\n \\\\n-                    callback(null, listOfCommits.reverse());\\\\n+                    var commitsData = listOfCommits.reverse();\\\\n+\\\\n+                    callback(null, commitsData);\\\\n \\\\n                     if (error !== null) {\\\\n                         console.log('stderr: ' + stderr);\\\\n@@ -157,27 +159,18 @@ fs.exists('.git', function (exists) {\\\\n                 });\\\\n             },\\\\n             function getCommitsContent(commits, callback) {\\\\n-                console.log(commits);\\\\n                 var commitsData = commits;\\\\n \\\\n                 for(i=1; i<commitsData.length; i++) {\\\\n-                    cp.exec('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit, function(error, stdout, stderr) {\\\\n-                        commitsData[i].content = stdout;\\\\n-\\\\n-                        if (error !== null) {\\\\n-                            console.log('stderr: ' + stderr);\\\\n-                            console.log('exec error: ' + error);\\\\n-                        }\\\\n-                    });\\\\n+                    commitsData[i].content = cp.execSync('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit).toString('utf8');\\\\n                 }\\\\n \\\\n                 callback(null, commitsData);\\\\n             }\\\\n         ], function (err, result) {\\\\n-            fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", result);\\\\n+            for(i=0; i<result.length; i++) {\\\\n+                fs.writeFileSync(\\\\\\\"patches.sousp\\\\\\\", JSON.stringify(result[i]));\\\\n+            }\\\\n         });\\\\n-\\\\n-        //commitsInfo = JSON.parse(fs.readFileSync(\\\\\\\"patches.sousp\\\\\\\"));\\\\n-        //console.log(commitsInfo);\\\\n     }\\\\n });\\\\n\\\\\\\\ No newline at end of file\\\\ndiff --git a/patches.sousp b/patches.sousp\\\\nindex d71e511..300c6a9 100644\\\\n--- a/patches.sousp\\\\n+++ b/patches.sousp\\\\n@@ -1 +1 @@\\\\n-[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]\\\\n\\\\\\\\ No newline at end of file\\\\n+{\\\\\\\"commit\\\\\\\":\\\\\\\"1e947f613e976945de85ae35ed923aa470f0be72\\\\\\\",\\\\\\\"author\\\\\\\":\\\\\\\"Nick Stepanenko <massaalonso@yandex.ru>\\\\\\\",\\\\\\\"date\\\\\\\":\\\\\\\"Tue May 19 00:12:12 2015 +0800\\\\\\\",\\\\\\\"comment\\\\\\\":\\\\\\\"Latest updates\\\\\\\",\\\\\\\"content\\\\\\\":\\\\\\\"diff --git a/comments.sousc b/comments.sousc\\\\\\\\nindex 150b0f6..cb3a850 100644\\\\\\\\n--- a/comments.sousc\\\\\\\\n+++ b/comments.sousc\\\\\\\\n@@ -1,3 +1,27 @@\\\\\\\\n+commit 4420cabefc1f470af341af11ed595df67e25c51f\\\\\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\\\\\n+Date:   Sun May 17 17:05:35 2015 +0800\\\\\\\\n+\\\\\\\\n+    Paste old program code\\\\\\\\n+\\\\\\\\n+commit 9ef3d25fd4c3afdbcc3107a0abf6d7a2e29cb4dd\\\\\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\\\\\n+Date:   Sun May 17 17:04:52 2015 +0800\\\\\\\\n+\\\\\\\\n+    Adding new file\\\\\\\\n+\\\\\\\\n+commit 64814d140d2fab6ae153cac485008119f29bf230\\\\\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\\\\\n+Date:   Sun May 17 17:03:58 2015 +0800\\\\\\\\n+\\\\\\\\n+    From clear list\\\\\\\\n+\\\\\\\\n+commit c9d318fea74ea288d544ecf72f00b12c130cf2ef\\\\\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\\\\\n+Date:   Sun May 17 16:59:40 2015 +0800\\\\\\\\n+\\\\\\\\n+    Create system files\\\\\\\\n+\\\\\\\\n commit e3c853a4282dfe8f000685dc1d39bd55a4a946c4\\\\\\\\n Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\\\\\n Date:   Sun May 17 16:54:58 2015 +0800\\\\\\\\ndiff --git a/main.js b/main.js\\\\\\\\nindex e34dc18..86f30c2 100644\\\\\\\\n--- a/main.js\\\\\\\\n+++ b/main.js\\\\\\\\n@@ -3,6 +3,56 @@\\\\\\\\n  */\\\\\\\\n \\\\\\\\n var fs = require('fs');\\\\\\\\n+var cp = require('child_process');\\\\\\\\n+var data = [];\\\\\\\\n+\\\\\\\\n+var async = require('async');\\\\\\\\n+    /*tasks = [\\\\\\\\n+        function (callback) {\\\\\\\\n+            cp.exec('git log', function(error, stdout, stderr) {\\\\\\\\n+                var listOfCommits = [];\\\\\\\\n+                var authors = findData(stdout, \\\\\\\\\\\\\\\"Author:\\\\\\\\\\\\\\\");\\\\\\\\n+                var dates = findData(stdout, \\\\\\\\\\\\\\\"Date:\\\\\\\\\\\\\\\");\\\\\\\\n+                var comments = findComments(stdout);\\\\\\\\n+                var commitNumbers = findCommitNumbers(stdout);\\\\\\\\n+\\\\\\\\n+                for(i=0; i<authors.length; i++) {\\\\\\\\n+                    var commit = {\\\\\\\\n+                        \\\\\\\\\\\\\\\"commit\\\\\\\\\\\\\\\": commitNumbers[i],\\\\\\\\n+                        \\\\\\\\\\\\\\\"author\\\\\\\\\\\\\\\": authors[i],\\\\\\\\n+                        \\\\\\\\\\\\\\\"date\\\\\\\\\\\\\\\": dates[i],\\\\\\\\n+                        \\\\\\\\\\\\\\\"comment\\\\\\\\\\\\\\\": comments[i],\\\\\\\\n+                        \\\\\\\\\\\\\\\"content\\\\\\\\\\\\\\\": 'Original'\\\\\\\\n+                    };\\\\\\\\n+\\\\\\\\n+                    listOfCommits[listOfCommits.length] = commit;\\\\\\\\n+                }\\\\\\\\n+\\\\\\\\n+                data = listOfCommits.reverse();\\\\\\\\n+\\\\\\\\n+                callback(null, data);\\\\\\\\n+\\\\\\\\n+                if (error !== null) {\\\\\\\\n+                    console.log('stderr: ' + stderr);\\\\\\\\n+                    console.log('exec error: ' + error);\\\\\\\\n+                }\\\\\\\\n+            });\\\\\\\\n+        }\\\\\\\\n+    ],\\\\\\\\n+    secondTasks = [\\\\\\\\n+        function some_function(callback) {\\\\\\\\n+            cp.exec('git diff', function(error, stdout, stderr) {\\\\\\\\n+                var currentContent = stdout;\\\\\\\\n+\\\\\\\\n+                if (error !== null) {\\\\\\\\n+                    console.log('stderr: ' + stderr);\\\\\\\\n+                    console.log('exec error: ' + error);\\\\\\\\n+                }\\\\\\\\n+\\\\\\\\n+                callback(null, currentContent);\\\\\\\\n+            });\\\\\\\\n+        }\\\\\\\\n+    ];*/\\\\\\\\n \\\\\\\\n function findData(text, keyword) {\\\\\\\\n     var data = [];\\\\\\\\n@@ -28,38 +78,106 @@ function findComments(text) {\\\\\\\\n     return comments;\\\\\\\\n }\\\\\\\\n \\\\\\\\n+function findCommitNumbers(text) {\\\\\\\\n+    var commits = [];\\\\\\\\n+    var splittext = text.split('\\\\\\\\\\\\\\\\n');\\\\\\\\n+\\\\\\\\n+    for(i=0; i<splittext.length; i++) {\\\\\\\\n+        if(splittext[i].slice(0, 6) == \\\\\\\\\\\\\\\"commit\\\\\\\\\\\\\\\") {\\\\\\\\n+            commits[commits.length] = splittext[i].slice(6).trim();\\\\\\\\n+        }\\\\\\\\n+    }\\\\\\\\n+\\\\\\\\n+    return commits;\\\\\\\\n+}\\\\\\\\n+\\\\\\\\n+/*function pullCommitContent(first, second) {\\\\\\\\n+\\\\\\\\n+    cp.exec('git diff' + ' ' + first + ' ' + second, function(error, stdout, stderr) {\\\\\\\\n+        var currentContent = stdout;\\\\\\\\n+\\\\\\\\n+        if (error !== null) {\\\\\\\\n+            console.log('stderr: ' + stderr);\\\\\\\\n+            console.log('exec error: ' + error);\\\\\\\\n+        }\\\\\\\\n+\\\\\\\\n+        return currentContent;\\\\\\\\n+    });\\\\\\\\n+}*/\\\\\\\\n+\\\\\\\\n+var commitsInfo = [];\\\\\\\\n+\\\\\\\\n fs.exists('.git', function (exists) {\\\\\\\\n     if(exists) {\\\\\\\\n-        var cp = require('child_process');\\\\\\\\n+        /*async.series(tasks, function(err, result) {\\\\\\\\n+            fs.writeFileSync(\\\\\\\\\\\\\\\"patches.sousp\\\\\\\\\\\\\\\", JSON.stringify(result));\\\\\\\\n+\\\\\\\\n+            var data = result[0];\\\\\\\\n \\\\\\\\n-        cp.exec('git diff', function(error, stdout, stderr) {\\\\\\\\n-            console.log(stdout);\\\\\\\\n+            /*function some_function(arg1, arg2, callback) {\\\\\\\\n+                cp.exec('git diff' + ' ' + arg1 + ' ' + arg2, function(error, stdout, stderr) {\\\\\\\\n+                    var currentContent = 54321;//stdout;\\\\\\\\n \\\\\\\\n-            fs.writeFileSync(\\\\\\\\\\\\\\\"patches.sousp\\\\\\\\\\\\\\\", stdout);\\\\\\\\n+                    if (error !== null) {\\\\\\\\n+                        console.log('stderr: ' + stderr);\\\\\\\\n+                        console.log('exec error: ' + error);\\\\\\\\n+                    }\\\\\\\\n \\\\\\\\n-            if (error !== null) {\\\\\\\\n-                console.log('stderr: ' + stderr);\\\\\\\\n-                console.log('exec error: ' + error);\\\\\\\\n+                    callback(null, currentContent);\\\\\\\\n+                });\\\\\\\\n             }\\\\\\\\n-        });\\\\\\\\n+        });*/\\\\\\\\n+\\\\\\\\n+        async.waterfall([\\\\\\\\n+            function getCommitsInfo(callback) {\\\\\\\\n+                cp.exec('git log', function(error, stdout, stderr) {\\\\\\\\n+                    var listOfCommits = [];\\\\\\\\n+                    var authors = findData(stdout, \\\\\\\\\\\\\\\"Author:\\\\\\\\\\\\\\\");\\\\\\\\n+                    var dates = findData(stdout, \\\\\\\\\\\\\\\"Date:\\\\\\\\\\\\\\\");\\\\\\\\n+                    var comments = findComments(stdout);\\\\\\\\n+                    var commitNumbers = findCommitNumbers(stdout);\\\\\\\\n \\\\\\\\n-        cp.exec('git log', function(error, stdout, stderr) {\\\\\\\\n-            console.log(stdout);\\\\\\\\n+                    for(i=0; i<authors.length; i++) {\\\\\\\\n+                        var commit = {\\\\\\\\n+                            \\\\\\\\\\\\\\\"commit\\\\\\\\\\\\\\\": commitNumbers[i],\\\\\\\\n+                            \\\\\\\\\\\\\\\"author\\\\\\\\\\\\\\\": authors[i],\\\\\\\\n+                            \\\\\\\\\\\\\\\"date\\\\\\\\\\\\\\\": dates[i],\\\\\\\\n+                            \\\\\\\\\\\\\\\"comment\\\\\\\\\\\\\\\": comments[i],\\\\\\\\n+                            \\\\\\\\\\\\\\\"content\\\\\\\\\\\\\\\": 'Original'\\\\\\\\n+                        };\\\\\\\\n+                        listOfCommits[listOfCommits.length] = commit;\\\\\\\\n+                    }\\\\\\\\n \\\\\\\\n-            var authors = findData(stdout, \\\\\\\\\\\\\\\"Author:\\\\\\\\\\\\\\\");\\\\\\\\n-            var dates = findData(stdout, \\\\\\\\\\\\\\\"Date:\\\\\\\\\\\\\\\");\\\\\\\\n-            var comments = findComments(stdout);\\\\\\\\n-            console.log(authors);\\\\\\\\n-            console.log(comments);\\\\\\\\n-            console.log(dates);\\\\\\\\n+                    callback(null, listOfCommits.reverse());\\\\\\\\n \\\\\\\\n-            fs.writeFileSync(\\\\\\\\\\\\\\\"comments.sousc\\\\\\\\\\\\\\\", stdout);\\\\\\\\n+                    if (error !== null) {\\\\\\\\n+                        console.log('stderr: ' + stderr);\\\\\\\\n+                        console.log('exec error: ' + error);\\\\\\\\n+                    }\\\\\\\\n+                });\\\\\\\\n+            },\\\\\\\\n+            function getCommitsContent(commits, callback) {\\\\\\\\n+                console.log(commits);\\\\\\\\n+                var commitsData = commits;\\\\\\\\n \\\\\\\\n-            if (error !== null) {\\\\\\\\n-                console.log('stderr: ' + stderr);\\\\\\\\n-                console.log('exec error: ' + error);\\\\\\\\n+                for(i=1; i<commitsData.length; i++) {\\\\\\\\n+                    cp.exec('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit, function(error, stdout, stderr) {\\\\\\\\n+                        commitsData[i].content = stdout;\\\\\\\\n+\\\\\\\\n+                        if (error !== null) {\\\\\\\\n+                            console.log('stderr: ' + stderr);\\\\\\\\n+                            console.log('exec error: ' + error);\\\\\\\\n+                        }\\\\\\\\n+                    });\\\\\\\\n+                }\\\\\\\\n+\\\\\\\\n+                callback(null, commitsData);\\\\\\\\n             }\\\\\\\\n+        ], function (err, result) {\\\\\\\\n+            fs.writeFileSync(\\\\\\\\\\\\\\\"patches.sousp\\\\\\\\\\\\\\\", result);\\\\\\\\n         });\\\\\\\\n+\\\\\\\\n+        //commitsInfo = JSON.parse(fs.readFileSync(\\\\\\\\\\\\\\\"patches.sousp\\\\\\\\\\\\\\\"));\\\\\\\\n+        //console.log(commitsInfo);\\\\\\\\n     }\\\\\\\\n-    else console.log(\\\\\\\\\\\\\\\"Error.\\\\\\\\\\\\\\\");\\\\\\\\n });\\\\\\\\n\\\\\\\\\\\\\\\\ No newline at end of file\\\\\\\\ndiff --git a/node_modules/async/.travis.yml b/node_modules/async/.travis.yml\\\\\\\\nnew file mode 100644\\\\\\\\nindex 0000000..6e5919d\\\\\\\\n--- /dev/null\\\\\\\\n+++ b/node_modules/async/.travis.yml\\\\\\\\n@@ -0,0 +1,3 @@\\\\\\\\n+language: node_js\\\\\\\\n+node_js:\\\\\\\\n+  - \\\\\\\\\\\\\\\"0.10\\\\\\\\\\\\\\\"\\\\\\\\ndiff --git a/node_modules/async/LICENSE b/node_modules/async/LICENSE\\\\\\\\nnew file mode 100644\\\\\\\\nindex 0000000..8f29698\\\\\\\\n--- /dev/null\\\\\\\\n+++ b/node_modules/async/LICENSE\\\\\\\\n@@ -0,0 +1,19 @@\\\\\\\\n+Copyright (c) 2010-2014 Caolan McMahon\\\\\\\\n+\\\\\\\\n+Permission is hereby granted, free of charge, to any person obtaining a copy\\\\\\\\n+of this software and associated documentation files (the \\\\\\\\\\\\\\\"Software\\\\\\\\\\\\\\\"), to deal\\\\\\\\n+in the Software without restriction, including without limitation the rights\\\\\\\\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\\\\\\\n+copies of the Software, and to permit persons to whom the Software is\\\\\\\\n+furnished to do so, subject to the following conditions:\\\\\\\\n+\\\\\\\\n+The above copyright notice and this permission notice shall be included in\\\\\\\\n+all copies or substantial portions of the Software.\\\\\\\\n+\\\\\\\\n+THE SOFTWARE IS PROVIDED \\\\\\\\\\\\\\\"AS IS\\\\\\\\\\\\\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\\\\\\\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\\\\\\\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\\\\\\\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\\\\\\\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\\\\\\\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\\\\\\\n+THE SOFTWARE.\\\\\\\\ndiff --git a/node_modules/async/README.md b/node_modules/async/README.md\\\\\\\\nnew file mode 100644\\\\\\\\nindex 0000000..0bea531\\\\\\\\n--- /dev/null\\\\\\\\n+++ b/node_modules/async/README.md\\\\\\\\n@@ -0,0 +1,1646 @@\\\\\\\\n+# Async.js\\\\\\\\n+\\\\\\\\n+[![Build Status via Travis CI](https://travis-ci.org/caolan/async.svg?branch=master)](https://travis-ci.org/caolan/async)\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+Async is a utility module which provides straight-forward, powerful functions\\\\\\\\n+for working with asynchronous JavaScript. Although originally designed for\\\\\\\\n+use with [Node.js](http://nodejs.org), it can also be used directly in the\\\\\\\\n+browser. Also supports [component](https://github.com/component/component).\\\\\\\\n+\\\\\\\\n+Async provides around 20 functions that include the usual 'functional'\\\\\\\\n+suspects (`map`, `reduce`, `filter`, `each`…) as well as some common patterns\\\\\\\\n+for asynchronous control flow (`parallel`, `series`, `waterfall`…). All these\\\\\\\\n+functions assume you follow the Node.js convention of providing a single\\\\\\\\n+callback as the last argument of your `async` function.\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+## Quick Examples\\\\\\\\n+\\\\\\\\n+```javascript\\\\\\\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\\\\\\\n+    // results is now an array of stats for each file\\\\\\\\n+});\\\\\\\\n+\\\\\\\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\\\\\\\n+    // results now equals an array of the existing files\\\\\\\\n+});\\\\\\\\n+\\\\\\\\n+async.parallel([\\\\\\\\n+    function(){ ... },\\\\\\\\n+    function(){ ... }\\\\\\\\n+], callback);\\\\\\\\n+\\\\\\\\n+async.series([\\\\\\\\n+    function(){ ... },\\\\\\\\n+    function(){ ... }\\\\\\\\n+]);\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+There are many more functions available so take a look at the docs below for a\\\\\\\\n+full list. This module aims to be comprehensive, so if you feel anything is\\\\\\\\n+missing please create a GitHub issue for it.\\\\\\\\n+\\\\\\\\n+## Common Pitfalls\\\\\\\\n+\\\\\\\\n+### Binding a context to an iterator\\\\\\\\n+\\\\\\\\n+This section is really about `bind`, not about `async`. If you are wondering how to\\\\\\\\n+make `async` execute your iterators in a given context, or are confused as to why\\\\\\\\n+a method of another library isn't working as an iterator, study this example:\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+// Here is a simple object with an (unnecessarily roundabout) squaring method\\\\\\\\n+var AsyncSquaringLibrary = {\\\\\\\\n+  squareExponent: 2,\\\\\\\\n+  square: function(number, callback){ \\\\\\\\n+    var result = Math.pow(number, this.squareExponent);\\\\\\\\n+    setTimeout(function(){\\\\\\\\n+      callback(null, result);\\\\\\\\n+    }, 200);\\\\\\\\n+  }\\\\\\\\n+};\\\\\\\\n+\\\\\\\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square, function(err, result){\\\\\\\\n+  // result is [NaN, NaN, NaN]\\\\\\\\n+  // This fails because the `this.squareExponent` expression in the square\\\\\\\\n+  // function is not evaluated in the context of AsyncSquaringLibrary, and is\\\\\\\\n+  // therefore undefined.\\\\\\\\n+});\\\\\\\\n+\\\\\\\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), function(err, result){\\\\\\\\n+  // result is [1, 4, 9]\\\\\\\\n+  // With the help of bind we can attach a context to the iterator before\\\\\\\\n+  // passing it to async. Now the square function will be executed in its \\\\\\\\n+  // 'home' AsyncSquaringLibrary context and the value of `this.squareExponent`\\\\\\\\n+  // will be as expected.\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+## Download\\\\\\\\n+\\\\\\\\n+The source is available for download from\\\\\\\\n+[GitHub](http://github.com/caolan/async).\\\\\\\\n+Alternatively, you can install using Node Package Manager (`npm`):\\\\\\\\n+\\\\\\\\n+    npm install async\\\\\\\\n+\\\\\\\\n+__Development:__ [async.js](https://github.com/caolan/async/raw/master/lib/async.js) - 29.6kb Uncompressed\\\\\\\\n+\\\\\\\\n+## In the Browser\\\\\\\\n+\\\\\\\\n+So far it's been tested in IE6, IE7, IE8, FF3.6 and Chrome 5. \\\\\\\\n+\\\\\\\\n+Usage:\\\\\\\\n+\\\\\\\\n+```html\\\\\\\\n+<script type=\\\\\\\\\\\\\\\"text/javascript\\\\\\\\\\\\\\\" src=\\\\\\\\\\\\\\\"async.js\\\\\\\\\\\\\\\"></script>\\\\\\\\n+<script type=\\\\\\\\\\\\\\\"text/javascript\\\\\\\\\\\\\\\">\\\\\\\\n+\\\\\\\\n+    async.map(data, asyncProcess, function(err, results){\\\\\\\\n+        alert(results);\\\\\\\\n+    });\\\\\\\\n+\\\\\\\\n+</script>\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+## Documentation\\\\\\\\n+\\\\\\\\n+### Collections\\\\\\\\n+\\\\\\\\n+* [`each`](#each)\\\\\\\\n+* [`eachSeries`](#eachSeries)\\\\\\\\n+* [`eachLimit`](#eachLimit)\\\\\\\\n+* [`map`](#map)\\\\\\\\n+* [`mapSeries`](#mapSeries)\\\\\\\\n+* [`mapLimit`](#mapLimit)\\\\\\\\n+* [`filter`](#filter)\\\\\\\\n+* [`filterSeries`](#filterSeries)\\\\\\\\n+* [`reject`](#reject)\\\\\\\\n+* [`rejectSeries`](#rejectSeries)\\\\\\\\n+* [`reduce`](#reduce)\\\\\\\\n+* [`reduceRight`](#reduceRight)\\\\\\\\n+* [`detect`](#detect)\\\\\\\\n+* [`detectSeries`](#detectSeries)\\\\\\\\n+* [`sortBy`](#sortBy)\\\\\\\\n+* [`some`](#some)\\\\\\\\n+* [`every`](#every)\\\\\\\\n+* [`concat`](#concat)\\\\\\\\n+* [`concatSeries`](#concatSeries)\\\\\\\\n+\\\\\\\\n+### Control Flow\\\\\\\\n+\\\\\\\\n+* [`series`](#seriestasks-callback)\\\\\\\\n+* [`parallel`](#parallel)\\\\\\\\n+* [`parallelLimit`](#parallellimittasks-limit-callback)\\\\\\\\n+* [`whilst`](#whilst)\\\\\\\\n+* [`doWhilst`](#doWhilst)\\\\\\\\n+* [`until`](#until)\\\\\\\\n+* [`doUntil`](#doUntil)\\\\\\\\n+* [`forever`](#forever)\\\\\\\\n+* [`waterfall`](#waterfall)\\\\\\\\n+* [`compose`](#compose)\\\\\\\\n+* [`seq`](#seq)\\\\\\\\n+* [`applyEach`](#applyEach)\\\\\\\\n+* [`applyEachSeries`](#applyEachSeries)\\\\\\\\n+* [`queue`](#queue)\\\\\\\\n+* [`priorityQueue`](#priorityQueue)\\\\\\\\n+* [`cargo`](#cargo)\\\\\\\\n+* [`auto`](#auto)\\\\\\\\n+* [`retry`](#retry)\\\\\\\\n+* [`iterator`](#iterator)\\\\\\\\n+* [`apply`](#apply)\\\\\\\\n+* [`nextTick`](#nextTick)\\\\\\\\n+* [`times`](#times)\\\\\\\\n+* [`timesSeries`](#timesSeries)\\\\\\\\n+\\\\\\\\n+### Utils\\\\\\\\n+\\\\\\\\n+* [`memoize`](#memoize)\\\\\\\\n+* [`unmemoize`](#unmemoize)\\\\\\\\n+* [`log`](#log)\\\\\\\\n+* [`dir`](#dir)\\\\\\\\n+* [`noConflict`](#noConflict)\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+## Collections\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"forEach\\\\\\\\\\\\\\\" />\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"each\\\\\\\\\\\\\\\" />\\\\\\\\n+### each(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+Applies the function `iterator` to each item in `arr`, in parallel.\\\\\\\\n+The `iterator` is called with an item from the list, and a callback for when it\\\\\\\\n+has finished. If the `iterator` passes an error to its `callback`, the main\\\\\\\\n+`callback` (for the `each` function) is immediately called with the error.\\\\\\\\n+\\\\\\\\n+Note, that since this function applies `iterator` to each item in parallel,\\\\\\\\n+there is no guarantee that the iterator functions will complete in order.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `arr` - An array to iterate over.\\\\\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\\\\\n+  The iterator is passed a `callback(err)` which must be called once it has \\\\\\\\n+  completed. If no error has occured, the `callback` should be run without \\\\\\\\n+  arguments or with an explicit `null` argument.\\\\\\\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\\\\\\\n+  have finished, or an error occurs.\\\\\\\\n+\\\\\\\\n+__Examples__\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+// assuming openFiles is an array of file names and saveFile is a function\\\\\\\\n+// to save the modified contents of that file:\\\\\\\\n+\\\\\\\\n+async.each(openFiles, saveFile, function(err){\\\\\\\\n+    // if any of the saves produced an error, err would equal that error\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+// assuming openFiles is an array of file names \\\\\\\\n+\\\\\\\\n+async.each(openFiles, function( file, callback) {\\\\\\\\n+  \\\\\\\\n+  // Perform operation on file here.\\\\\\\\n+  console.log('Processing file ' + file);\\\\\\\\n+  \\\\\\\\n+  if( file.length > 32 ) {\\\\\\\\n+    console.log('This file name is too long');\\\\\\\\n+    callback('File name too long');\\\\\\\\n+  } else {\\\\\\\\n+    // Do work to process file here\\\\\\\\n+    console.log('File processed');\\\\\\\\n+    callback();\\\\\\\\n+  }\\\\\\\\n+}, function(err){\\\\\\\\n+    // if any of the file processing produced an error, err would equal that error\\\\\\\\n+    if( err ) {\\\\\\\\n+      // One of the iterations produced an error.\\\\\\\\n+      // All processing will now stop.\\\\\\\\n+      console.log('A file failed to process');\\\\\\\\n+    } else {\\\\\\\\n+      console.log('All files have been processed successfully');\\\\\\\\n+    }\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"forEachSeries\\\\\\\\\\\\\\\" />\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"eachSeries\\\\\\\\\\\\\\\" />\\\\\\\\n+### eachSeries(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+The same as [`each`](#each), only `iterator` is applied to each item in `arr` in\\\\\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\\\\\n+This means the `iterator` functions will complete in order.\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"forEachLimit\\\\\\\\\\\\\\\" />\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"eachLimit\\\\\\\\\\\\\\\" />\\\\\\\\n+### eachLimit(arr, limit, iterator, callback)\\\\\\\\n+\\\\\\\\n+The same as [`each`](#each), only no more than `limit` `iterator`s will be simultaneously \\\\\\\\n+running at any time.\\\\\\\\n+\\\\\\\\n+Note that the items in `arr` are not processed in batches, so there is no guarantee that \\\\\\\\n+the first `limit` `iterator` functions will complete before any others are started.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `arr` - An array to iterate over.\\\\\\\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\\\\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\\\\\n+  The iterator is passed a `callback(err)` which must be called once it has \\\\\\\\n+  completed. If no error has occured, the callback should be run without \\\\\\\\n+  arguments or with an explicit `null` argument.\\\\\\\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\\\\\\\n+  have finished, or an error occurs.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+// Assume documents is an array of JSON objects and requestApi is a\\\\\\\\n+// function that interacts with a rate-limited REST api.\\\\\\\\n+\\\\\\\\n+async.eachLimit(documents, 20, requestApi, function(err){\\\\\\\\n+    // if any of the saves produced an error, err would equal that error\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"map\\\\\\\\\\\\\\\" />\\\\\\\\n+### map(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+Produces a new array of values by mapping each value in `arr` through\\\\\\\\n+the `iterator` function. The `iterator` is called with an item from `arr` and a\\\\\\\\n+callback for when it has finished processing. Each of these callback takes 2 arguments: \\\\\\\\n+an `error`, and the transformed item from `arr`. If `iterator` passes an error to this \\\\\\\\n+callback, the main `callback` (for the `map` function) is immediately called with the error.\\\\\\\\n+\\\\\\\\n+Note, that since this function applies the `iterator` to each item in parallel,\\\\\\\\n+there is no guarantee that the `iterator` functions will complete in order. \\\\\\\\n+However, the results array will be in the same order as the original `arr`.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `arr` - An array to iterate over.\\\\\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\\\\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\\\\\\\n+  it has completed with an error (which can be `null`) and a transformed item.\\\\\\\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\\\\\\\n+  functions have finished, or an error occurs. Results is an array of the\\\\\\\\n+  transformed items from the `arr`.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\\\\\\\n+    // results is now an array of stats for each file\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"mapSeries\\\\\\\\\\\\\\\" />\\\\\\\\n+### mapSeries(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+The same as [`map`](#map), only the `iterator` is applied to each item in `arr` in\\\\\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\\\\\n+The results array will be in the same order as the original.\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"mapLimit\\\\\\\\\\\\\\\" />\\\\\\\\n+### mapLimit(arr, limit, iterator, callback)\\\\\\\\n+\\\\\\\\n+The same as [`map`](#map), only no more than `limit` `iterator`s will be simultaneously \\\\\\\\n+running at any time.\\\\\\\\n+\\\\\\\\n+Note that the items are not processed in batches, so there is no guarantee that \\\\\\\\n+the first `limit` `iterator` functions will complete before any others are started.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `arr` - An array to iterate over.\\\\\\\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\\\\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\\\\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\\\\\\\n+  it has completed with an error (which can be `null`) and a transformed item.\\\\\\\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\\\\\\\n+  calls have finished, or an error occurs. The result is an array of the\\\\\\\\n+  transformed items from the original `arr`.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.mapLimit(['file1','file2','file3'], 1, fs.stat, function(err, results){\\\\\\\\n+    // results is now an array of stats for each file\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"select\\\\\\\\\\\\\\\" />\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"filter\\\\\\\\\\\\\\\" />\\\\\\\\n+### filter(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+__Alias:__ `select`\\\\\\\\n+\\\\\\\\n+Returns a new array of all the values in `arr` which pass an async truth test.\\\\\\\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\\\\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\\\\\n+way node libraries work with truth tests like `fs.exists`. This operation is\\\\\\\\n+performed in parallel, but the results array will be in the same order as the\\\\\\\\n+original.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `arr` - An array to iterate over.\\\\\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\\\\\\\n+  The `iterator` is passed a `callback(truthValue)`, which must be called with a \\\\\\\\n+  boolean argument once it has completed.\\\\\\\\n+* `callback(results)` - A callback which is called after all the `iterator`\\\\\\\\n+  functions have finished.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\\\\\\\n+    // results now equals an array of the existing files\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"selectSeries\\\\\\\\\\\\\\\" />\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"filterSeries\\\\\\\\\\\\\\\" />\\\\\\\\n+### filterSeries(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+__Alias:__ `selectSeries`\\\\\\\\n+\\\\\\\\n+The same as [`filter`](#filter) only the `iterator` is applied to each item in `arr` in\\\\\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\\\\\n+The results array will be in the same order as the original.\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"reject\\\\\\\\\\\\\\\" />\\\\\\\\n+### reject(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+The opposite of [`filter`](#filter). Removes values that pass an `async` truth test.\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"rejectSeries\\\\\\\\\\\\\\\" />\\\\\\\\n+### rejectSeries(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+The same as [`reject`](#reject), only the `iterator` is applied to each item in `arr`\\\\\\\\n+in series.\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"reduce\\\\\\\\\\\\\\\" />\\\\\\\\n+### reduce(arr, memo, iterator, callback)\\\\\\\\n+\\\\\\\\n+__Aliases:__ `inject`, `foldl`\\\\\\\\n+\\\\\\\\n+Reduces `arr` into a single value using an async `iterator` to return\\\\\\\\n+each successive step. `memo` is the initial state of the reduction. \\\\\\\\n+This function only operates in series. \\\\\\\\n+\\\\\\\\n+For performance reasons, it may make sense to split a call to this function into \\\\\\\\n+a parallel map, and then use the normal `Array.prototype.reduce` on the results. \\\\\\\\n+This function is for situations where each step in the reduction needs to be async; \\\\\\\\n+if you can get the data before reducing it, then it's probably a good idea to do so.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `arr` - An array to iterate over.\\\\\\\\n+* `memo` - The initial state of the reduction.\\\\\\\\n+* `iterator(memo, item, callback)` - A function applied to each item in the\\\\\\\\n+  array to produce the next step in the reduction. The `iterator` is passed a\\\\\\\\n+  `callback(err, reduction)` which accepts an optional error as its first \\\\\\\\n+  argument, and the state of the reduction as the second. If an error is \\\\\\\\n+  passed to the callback, the reduction is stopped and the main `callback` is \\\\\\\\n+  immediately called with the error.\\\\\\\\n+* `callback(err, result)` - A callback which is called after all the `iterator`\\\\\\\\n+  functions have finished. Result is the reduced value.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.reduce([1,2,3], 0, function(memo, item, callback){\\\\\\\\n+    // pointless async:\\\\\\\\n+    process.nextTick(function(){\\\\\\\\n+        callback(null, memo + item)\\\\\\\\n+    });\\\\\\\\n+}, function(err, result){\\\\\\\\n+    // result is now equal to the last value of memo, which is 6\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"reduceRight\\\\\\\\\\\\\\\" />\\\\\\\\n+### reduceRight(arr, memo, iterator, callback)\\\\\\\\n+\\\\\\\\n+__Alias:__ `foldr`\\\\\\\\n+\\\\\\\\n+Same as [`reduce`](#reduce), only operates on `arr` in reverse order.\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"detect\\\\\\\\\\\\\\\" />\\\\\\\\n+### detect(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+Returns the first value in `arr` that passes an async truth test. The\\\\\\\\n+`iterator` is applied in parallel, meaning the first iterator to return `true` will\\\\\\\\n+fire the detect `callback` with that result. That means the result might not be\\\\\\\\n+the first item in the original `arr` (in terms of order) that passes the test.\\\\\\\\n+\\\\\\\\n+If order within the original `arr` is important, then look at [`detectSeries`](#detectSeries).\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `arr` - An array to iterate over.\\\\\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\\\\\\\n+  The iterator is passed a `callback(truthValue)` which must be called with a \\\\\\\\n+  boolean argument once it has completed.\\\\\\\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\\\\\\\n+  `true`, or after all the `iterator` functions have finished. Result will be\\\\\\\\n+  the first item in the array that passes the truth test (iterator) or the\\\\\\\\n+  value `undefined` if none passed.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.detect(['file1','file2','file3'], fs.exists, function(result){\\\\\\\\n+    // result now equals the first file in the list that exists\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"detectSeries\\\\\\\\\\\\\\\" />\\\\\\\\n+### detectSeries(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+The same as [`detect`](#detect), only the `iterator` is applied to each item in `arr`\\\\\\\\n+in series. This means the result is always the first in the original `arr` (in\\\\\\\\n+terms of array order) that passes the truth test.\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"sortBy\\\\\\\\\\\\\\\" />\\\\\\\\n+### sortBy(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+Sorts a list by the results of running each `arr` value through an async `iterator`.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `arr` - An array to iterate over.\\\\\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\\\\\n+  The iterator is passed a `callback(err, sortValue)` which must be called once it\\\\\\\\n+  has completed with an error (which can be `null`) and a value to use as the sort\\\\\\\\n+  criteria.\\\\\\\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\\\\\\\n+  functions have finished, or an error occurs. Results is the items from\\\\\\\\n+  the original `arr` sorted by the values returned by the `iterator` calls.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.sortBy(['file1','file2','file3'], function(file, callback){\\\\\\\\n+    fs.stat(file, function(err, stats){\\\\\\\\n+        callback(err, stats.mtime);\\\\\\\\n+    });\\\\\\\\n+}, function(err, results){\\\\\\\\n+    // results is now the original array of files sorted by\\\\\\\\n+    // modified date\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+__Sort Order__\\\\\\\\n+\\\\\\\\n+By modifying the callback parameter the sorting order can be influenced:\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+//ascending order\\\\\\\\n+async.sortBy([1,9,3,5], function(x, callback){\\\\\\\\n+    callback(err, x);\\\\\\\\n+}, function(err,result){\\\\\\\\n+    //result callback\\\\\\\\n+} );\\\\\\\\n+\\\\\\\\n+//descending order\\\\\\\\n+async.sortBy([1,9,3,5], function(x, callback){\\\\\\\\n+    callback(err, x*-1);    //<- x*-1 instead of x, turns the order around\\\\\\\\n+}, function(err,result){\\\\\\\\n+    //result callback\\\\\\\\n+} );\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"some\\\\\\\\\\\\\\\" />\\\\\\\\n+### some(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+__Alias:__ `any`\\\\\\\\n+\\\\\\\\n+Returns `true` if at least one element in the `arr` satisfies an async test.\\\\\\\\n+_The callback for each iterator call only accepts a single argument of `true` or\\\\\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\\\\\n+way node libraries work with truth tests like `fs.exists`. Once any iterator\\\\\\\\n+call returns `true`, the main `callback` is immediately called.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `arr` - An array to iterate over.\\\\\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\\\\\\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\\\\\\\n+  called with a boolean argument once it has completed.\\\\\\\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\\\\\\\n+  `true`, or after all the iterator functions have finished. Result will be\\\\\\\\n+  either `true` or `false` depending on the values of the async tests.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.some(['file1','file2','file3'], fs.exists, function(result){\\\\\\\\n+    // if result is true then at least one of the files exists\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"every\\\\\\\\\\\\\\\" />\\\\\\\\n+### every(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+__Alias:__ `all`\\\\\\\\n+\\\\\\\\n+Returns `true` if every element in `arr` satisfies an async test.\\\\\\\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\\\\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\\\\\n+way node libraries work with truth tests like `fs.exists`.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `arr` - An array to iterate over.\\\\\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\\\\\\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\\\\\\\n+  called with a  boolean argument once it has completed.\\\\\\\\n+* `callback(result)` - A callback which is called after all the `iterator`\\\\\\\\n+  functions have finished. Result will be either `true` or `false` depending on\\\\\\\\n+  the values of the async tests.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.every(['file1','file2','file3'], fs.exists, function(result){\\\\\\\\n+    // if result is true then every file exists\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"concat\\\\\\\\\\\\\\\" />\\\\\\\\n+### concat(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+Applies `iterator` to each item in `arr`, concatenating the results. Returns the\\\\\\\\n+concatenated list. The `iterator`s are called in parallel, and the results are\\\\\\\\n+concatenated as they return. There is no guarantee that the results array will\\\\\\\\n+be returned in the original order of `arr` passed to the `iterator` function.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `arr` - An array to iterate over.\\\\\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\\\\\n+  The iterator is passed a `callback(err, results)` which must be called once it \\\\\\\\n+  has completed with an error (which can be `null`) and an array of results.\\\\\\\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\\\\\\\n+  functions have finished, or an error occurs. Results is an array containing\\\\\\\\n+  the concatenated results of the `iterator` function.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files){\\\\\\\\n+    // files is now a list of filenames that exist in the 3 directories\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"concatSeries\\\\\\\\\\\\\\\" />\\\\\\\\n+### concatSeries(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+Same as [`concat`](#concat), but executes in series instead of parallel.\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+## Control Flow\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"series\\\\\\\\\\\\\\\" />\\\\\\\\n+### series(tasks, [callback])\\\\\\\\n+\\\\\\\\n+Run the functions in the `tasks` array in series, each one running once the previous\\\\\\\\n+function has completed. If any functions in the series pass an error to its\\\\\\\\n+callback, no more functions are run, and `callback` is immediately called with the value of the error. \\\\\\\\n+Otherwise, `callback` receives an array of results when `tasks` have completed.\\\\\\\\n+\\\\\\\\n+It is also possible to use an object instead of an array. Each property will be\\\\\\\\n+run as a function, and the results will be passed to the final `callback` as an object\\\\\\\\n+instead of an array. This can be a more readable way of handling results from\\\\\\\\n+[`series`](#series).\\\\\\\\n+\\\\\\\\n+**Note** that while many implementations preserve the order of object properties, the\\\\\\\\n+[ECMAScript Language Specifcation](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6) \\\\\\\\n+explicitly states that\\\\\\\\n+\\\\\\\\n+> The mechanics and order of enumerating the properties is not specified.\\\\\\\\n+\\\\\\\\n+So if you rely on the order in which your series of functions are executed, and want\\\\\\\\n+this to work on all platforms, consider using an array. \\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `tasks` - An array or object containing functions to run, each function is passed\\\\\\\\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\\\\\\\n+  be `null`) and an optional `result` value.\\\\\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\\\\\n+  have completed. This function gets a results array (or object) containing all \\\\\\\\n+  the result arguments passed to the `task` callbacks.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.series([\\\\\\\\n+    function(callback){\\\\\\\\n+        // do some stuff ...\\\\\\\\n+        callback(null, 'one');\\\\\\\\n+    },\\\\\\\\n+    function(callback){\\\\\\\\n+        // do some more stuff ...\\\\\\\\n+        callback(null, 'two');\\\\\\\\n+    }\\\\\\\\n+],\\\\\\\\n+// optional callback\\\\\\\\n+function(err, results){\\\\\\\\n+    // results is now equal to ['one', 'two']\\\\\\\\n+});\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+// an example using an object instead of an array\\\\\\\\n+async.series({\\\\\\\\n+    one: function(callback){\\\\\\\\n+        setTimeout(function(){\\\\\\\\n+            callback(null, 1);\\\\\\\\n+        }, 200);\\\\\\\\n+    },\\\\\\\\n+    two: function(callback){\\\\\\\\n+        setTimeout(function(){\\\\\\\\n+            callback(null, 2);\\\\\\\\n+        }, 100);\\\\\\\\n+    }\\\\\\\\n+},\\\\\\\\n+function(err, results) {\\\\\\\\n+    // results is now equal to: {one: 1, two: 2}\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"parallel\\\\\\\\\\\\\\\" />\\\\\\\\n+### parallel(tasks, [callback])\\\\\\\\n+\\\\\\\\n+Run the `tasks` array of functions in parallel, without waiting until the previous\\\\\\\\n+function has completed. If any of the functions pass an error to its\\\\\\\\n+callback, the main `callback` is immediately called with the value of the error.\\\\\\\\n+Once the `tasks` have completed, the results are passed to the final `callback` as an\\\\\\\\n+array.\\\\\\\\n+\\\\\\\\n+It is also possible to use an object instead of an array. Each property will be\\\\\\\\n+run as a function and the results will be passed to the final `callback` as an object\\\\\\\\n+instead of an array. This can be a more readable way of handling results from\\\\\\\\n+[`parallel`](#parallel).\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `tasks` - An array or object containing functions to run. Each function is passed \\\\\\\\n+  a `callback(err, result)` which it must call on completion with an error `err` \\\\\\\\n+  (which can be `null`) and an optional `result` value.\\\\\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\\\\\n+  have completed. This function gets a results array (or object) containing all \\\\\\\\n+  the result arguments passed to the task callbacks.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.parallel([\\\\\\\\n+    function(callback){\\\\\\\\n+        setTimeout(function(){\\\\\\\\n+            callback(null, 'one');\\\\\\\\n+        }, 200);\\\\\\\\n+    },\\\\\\\\n+    function(callback){\\\\\\\\n+        setTimeout(function(){\\\\\\\\n+            callback(null, 'two');\\\\\\\\n+        }, 100);\\\\\\\\n+    }\\\\\\\\n+],\\\\\\\\n+// optional callback\\\\\\\\n+function(err, results){\\\\\\\\n+    // the results array will equal ['one','two'] even though\\\\\\\\n+    // the second function had a shorter timeout.\\\\\\\\n+});\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+// an example using an object instead of an array\\\\\\\\n+async.parallel({\\\\\\\\n+    one: function(callback){\\\\\\\\n+        setTimeout(function(){\\\\\\\\n+            callback(null, 1);\\\\\\\\n+        }, 200);\\\\\\\\n+    },\\\\\\\\n+    two: function(callback){\\\\\\\\n+        setTimeout(function(){\\\\\\\\n+            callback(null, 2);\\\\\\\\n+        }, 100);\\\\\\\\n+    }\\\\\\\\n+},\\\\\\\\n+function(err, results) {\\\\\\\\n+    // results is now equals to: {one: 1, two: 2}\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"parallelLimit\\\\\\\\\\\\\\\" />\\\\\\\\n+### parallelLimit(tasks, limit, [callback])\\\\\\\\n+\\\\\\\\n+The same as [`parallel`](#parallel), only `tasks` are executed in parallel \\\\\\\\n+with a maximum of `limit` tasks executing at any time.\\\\\\\\n+\\\\\\\\n+Note that the `tasks` are not executed in batches, so there is no guarantee that \\\\\\\\n+the first `limit` tasks will complete before any others are started.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `tasks` - An array or object containing functions to run, each function is passed \\\\\\\\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\\\\\\\n+  be `null`) and an optional `result` value.\\\\\\\\n+* `limit` - The maximum number of `tasks` to run at any time.\\\\\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\\\\\n+  have completed. This function gets a results array (or object) containing all \\\\\\\\n+  the result arguments passed to the `task` callbacks.\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"whilst\\\\\\\\\\\\\\\" />\\\\\\\\n+### whilst(test, fn, callback)\\\\\\\\n+\\\\\\\\n+Repeatedly call `fn`, while `test` returns `true`. Calls `callback` when stopped,\\\\\\\\n+or an error occurs.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `test()` - synchronous truth test to perform before each execution of `fn`.\\\\\\\\n+* `fn(callback)` - A function which is called each time `test` passes. The function is\\\\\\\\n+  passed a `callback(err)`, which must be called once it has completed with an \\\\\\\\n+  optional `err` argument.\\\\\\\\n+* `callback(err)` - A callback which is called after the test fails and repeated\\\\\\\\n+  execution of `fn` has stopped.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+var count = 0;\\\\\\\\n+\\\\\\\\n+async.whilst(\\\\\\\\n+    function () { return count < 5; },\\\\\\\\n+    function (callback) {\\\\\\\\n+        count++;\\\\\\\\n+        setTimeout(callback, 1000);\\\\\\\\n+    },\\\\\\\\n+    function (err) {\\\\\\\\n+        // 5 seconds have passed\\\\\\\\n+    }\\\\\\\\n+);\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"doWhilst\\\\\\\\\\\\\\\" />\\\\\\\\n+### doWhilst(fn, test, callback)\\\\\\\\n+\\\\\\\\n+The post-check version of [`whilst`](#whilst). To reflect the difference in \\\\\\\\n+the order of operations, the arguments `test` and `fn` are switched. \\\\\\\\n+\\\\\\\\n+`doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"until\\\\\\\\\\\\\\\" />\\\\\\\\n+### until(test, fn, callback)\\\\\\\\n+\\\\\\\\n+Repeatedly call `fn` until `test` returns `true`. Calls `callback` when stopped,\\\\\\\\n+or an error occurs.\\\\\\\\n+\\\\\\\\n+The inverse of [`whilst`](#whilst).\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"doUntil\\\\\\\\\\\\\\\" />\\\\\\\\n+### doUntil(fn, test, callback)\\\\\\\\n+\\\\\\\\n+Like [`doWhilst`](#doWhilst), except the `test` is inverted. Note the argument ordering differs from `until`.\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"forever\\\\\\\\\\\\\\\" />\\\\\\\\n+### forever(fn, errback)\\\\\\\\n+\\\\\\\\n+Calls the asynchronous function `fn` with a callback parameter that allows it to\\\\\\\\n+call itself again, in series, indefinitely.\\\\\\\\n+\\\\\\\\n+If an error is passed to the callback then `errback` is called with the\\\\\\\\n+error, and execution stops, otherwise it will never be called.\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.forever(\\\\\\\\n+    function(next) {\\\\\\\\n+        // next is suitable for passing to things that need a callback(err [, whatever]);\\\\\\\\n+        // it will result in this function being called again.\\\\\\\\n+    },\\\\\\\\n+    function(err) {\\\\\\\\n+        // if next is called with a value in its first parameter, it will appear\\\\\\\\n+        // in here as 'err', and execution will stop.\\\\\\\\n+    }\\\\\\\\n+);\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"waterfall\\\\\\\\\\\\\\\" />\\\\\\\\n+### waterfall(tasks, [callback])\\\\\\\\n+\\\\\\\\n+Runs the `tasks` array of functions in series, each passing their results to the next in\\\\\\\\n+the array. However, if any of the `tasks` pass an error to their own callback, the\\\\\\\\n+next function is not executed, and the main `callback` is immediately called with\\\\\\\\n+the error.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `tasks` - An array of functions to run, each function is passed a \\\\\\\\n+  `callback(err, result1, result2, ...)` it must call on completion. The first\\\\\\\\n+  argument is an error (which can be `null`) and any further arguments will be \\\\\\\\n+  passed as arguments in order to the next task.\\\\\\\\n+* `callback(err, [results])` - An optional callback to run once all the functions\\\\\\\\n+  have completed. This will be passed the results of the last task's callback.\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.waterfall([\\\\\\\\n+    function(callback){\\\\\\\\n+        callback(null, 'one', 'two');\\\\\\\\n+    },\\\\\\\\n+    function(arg1, arg2, callback){\\\\\\\\n+      // arg1 now equals 'one' and arg2 now equals 'two'\\\\\\\\n+        callback(null, 'three');\\\\\\\\n+    },\\\\\\\\n+    function(arg1, callback){\\\\\\\\n+        // arg1 now equals 'three'\\\\\\\\n+        callback(null, 'done');\\\\\\\\n+    }\\\\\\\\n+], function (err, result) {\\\\\\\\n+   // result now equals 'done'    \\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"compose\\\\\\\\\\\\\\\" />\\\\\\\\n+### compose(fn1, fn2...)\\\\\\\\n+\\\\\\\\n+Creates a function which is a composition of the passed asynchronous\\\\\\\\n+functions. Each function consumes the return value of the function that\\\\\\\\n+follows. Composing functions `f()`, `g()`, and `h()` would produce the result of\\\\\\\\n+`f(g(h()))`, only this version uses callbacks to obtain the return values.\\\\\\\\n+\\\\\\\\n+Each function is executed with the `this` binding of the composed function.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `functions...` - the asynchronous functions to compose\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+function add1(n, callback) {\\\\\\\\n+    setTimeout(function () {\\\\\\\\n+        callback(null, n + 1);\\\\\\\\n+    }, 10);\\\\\\\\n+}\\\\\\\\n+\\\\\\\\n+function mul3(n, callback) {\\\\\\\\n+    setTimeout(function () {\\\\\\\\n+        callback(null, n * 3);\\\\\\\\n+    }, 10);\\\\\\\\n+}\\\\\\\\n+\\\\\\\\n+var add1mul3 = async.compose(mul3, add1);\\\\\\\\n+\\\\\\\\n+add1mul3(4, function (err, result) {\\\\\\\\n+   // result now equals 15\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"seq\\\\\\\\\\\\\\\" />\\\\\\\\n+### seq(fn1, fn2...)\\\\\\\\n+\\\\\\\\n+Version of the compose function that is more natural to read.\\\\\\\\n+Each following function consumes the return value of the latter function. \\\\\\\\n+\\\\\\\\n+Each function is executed with the `this` binding of the composed function.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* functions... - the asynchronous functions to compose\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+// Requires lodash (or underscore), express3 and dresende's orm2.\\\\\\\\n+// Part of an app, that fetches cats of the logged user.\\\\\\\\n+// This example uses `seq` function to avoid overnesting and error \\\\\\\\n+// handling clutter.\\\\\\\\n+app.get('/cats', function(request, response) {\\\\\\\\n+  function handleError(err, data, callback) {\\\\\\\\n+    if (err) {\\\\\\\\n+      console.error(err);\\\\\\\\n+      response.json({ status: 'error', message: err.message });\\\\\\\\n+    }\\\\\\\\n+    else {\\\\\\\\n+      callback(data);\\\\\\\\n+    }\\\\\\\\n+  }\\\\\\\\n+  var User = request.models.User;\\\\\\\\n+  async.seq(\\\\\\\\n+    _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\\\\\\\\n+    handleError,\\\\\\\\n+    function(user, fn) {\\\\\\\\n+      user.getCats(fn);      // 'getCats' has signature (callback(err, data))\\\\\\\\n+    },\\\\\\\\n+    handleError,\\\\\\\\n+    function(cats) {\\\\\\\\n+      response.json({ status: 'ok', message: 'Cats found', data: cats });\\\\\\\\n+    }\\\\\\\\n+  )(req.session.user_id);\\\\\\\\n+  }\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"applyEach\\\\\\\\\\\\\\\" />\\\\\\\\n+### applyEach(fns, args..., callback)\\\\\\\\n+\\\\\\\\n+Applies the provided arguments to each function in the array, calling \\\\\\\\n+`callback` after all functions have completed. If you only provide the first\\\\\\\\n+argument, then it will return a function which lets you pass in the\\\\\\\\n+arguments as if it were a single function call.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `fns` - the asynchronous functions to all call with the same arguments\\\\\\\\n+* `args...` - any number of separate arguments to pass to the function\\\\\\\\n+* `callback` - the final argument should be the callback, called when all\\\\\\\\n+  functions have completed processing\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.applyEach([enableSearch, updateSchema], 'bucket', callback);\\\\\\\\n+\\\\\\\\n+// partial application example:\\\\\\\\n+async.each(\\\\\\\\n+    buckets,\\\\\\\\n+    async.applyEach([enableSearch, updateSchema]),\\\\\\\\n+    callback\\\\\\\\n+);\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"applyEachSeries\\\\\\\\\\\\\\\" />\\\\\\\\n+### applyEachSeries(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+The same as [`applyEach`](#applyEach) only the functions are applied in series.\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"queue\\\\\\\\\\\\\\\" />\\\\\\\\n+### queue(worker, concurrency)\\\\\\\\n+\\\\\\\\n+Creates a `queue` object with the specified `concurrency`. Tasks added to the\\\\\\\\n+`queue` are processed in parallel (up to the `concurrency` limit). If all\\\\\\\\n+`worker`s are in progress, the task is queued until one becomes available. \\\\\\\\n+Once a `worker` completes a `task`, that `task`'s callback is called.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `worker(task, callback)` - An asynchronous function for processing a queued\\\\\\\\n+  task, which must call its `callback(err)` argument when finished, with an \\\\\\\\n+  optional `error` as an argument.\\\\\\\\n+* `concurrency` - An `integer` for determining how many `worker` functions should be\\\\\\\\n+  run in parallel.\\\\\\\\n+\\\\\\\\n+__Queue objects__\\\\\\\\n+\\\\\\\\n+The `queue` object returned by this function has the following properties and\\\\\\\\n+methods:\\\\\\\\n+\\\\\\\\n+* `length()` - a function returning the number of items waiting to be processed.\\\\\\\\n+* `started` - a function returning whether or not any items have been pushed and processed by the queue\\\\\\\\n+* `running()` - a function returning the number of items currently being processed.\\\\\\\\n+* `idle()` - a function returning false if there are items waiting or being processed, or true if not.\\\\\\\\n+* `concurrency` - an integer for determining how many `worker` functions should be\\\\\\\\n+  run in parallel. This property can be changed after a `queue` is created to\\\\\\\\n+  alter the concurrency on-the-fly.\\\\\\\\n+* `push(task, [callback])` - add a new task to the `queue`. Calls `callback` once \\\\\\\\n+  the `worker` has finished processing the task. Instead of a single task, a `tasks` array\\\\\\\\n+  can be submitted. The respective callback is used for every task in the list.\\\\\\\\n+* `unshift(task, [callback])` - add a new task to the front of the `queue`.\\\\\\\\n+* `saturated` - a callback that is called when the `queue` length hits the `concurrency` limit, \\\\\\\\n+   and further tasks will be queued.\\\\\\\\n+* `empty` - a callback that is called when the last item from the `queue` is given to a `worker`.\\\\\\\\n+* `drain` - a callback that is called when the last item from the `queue` has returned from the `worker`.\\\\\\\\n+* `paused` - a boolean for determining whether the queue is in a paused state\\\\\\\\n+* `pause()` - a function that pauses the processing of tasks until `resume()` is called.\\\\\\\\n+* `resume()` - a function that resumes the processing of queued tasks when the queue is paused.\\\\\\\\n+* `kill()` - a function that empties remaining tasks from the queue forcing it to go idle.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+// create a queue object with concurrency 2\\\\\\\\n+\\\\\\\\n+var q = async.queue(function (task, callback) {\\\\\\\\n+    console.log('hello ' + task.name);\\\\\\\\n+    callback();\\\\\\\\n+}, 2);\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+// assign a callback\\\\\\\\n+q.drain = function() {\\\\\\\\n+    console.log('all items have been processed');\\\\\\\\n+}\\\\\\\\n+\\\\\\\\n+// add some items to the queue\\\\\\\\n+\\\\\\\\n+q.push({name: 'foo'}, function (err) {\\\\\\\\n+    console.log('finished processing foo');\\\\\\\\n+});\\\\\\\\n+q.push({name: 'bar'}, function (err) {\\\\\\\\n+    console.log('finished processing bar');\\\\\\\\n+});\\\\\\\\n+\\\\\\\\n+// add some items to the queue (batch-wise)\\\\\\\\n+\\\\\\\\n+q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function (err) {\\\\\\\\n+    console.log('finished processing bar');\\\\\\\\n+});\\\\\\\\n+\\\\\\\\n+// add some items to the front of the queue\\\\\\\\n+\\\\\\\\n+q.unshift({name: 'bar'}, function (err) {\\\\\\\\n+    console.log('finished processing bar');\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"priorityQueue\\\\\\\\\\\\\\\" />\\\\\\\\n+### priorityQueue(worker, concurrency)\\\\\\\\n+\\\\\\\\n+The same as [`queue`](#queue) only tasks are assigned a priority and completed in ascending priority order. There are two differences between `queue` and `priorityQueue` objects:\\\\\\\\n+\\\\\\\\n+* `push(task, priority, [callback])` - `priority` should be a number. If an array of\\\\\\\\n+  `tasks` is given, all tasks will be assigned the same priority.\\\\\\\\n+* The `unshift` method was removed.\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"cargo\\\\\\\\\\\\\\\" />\\\\\\\\n+### cargo(worker, [payload])\\\\\\\\n+\\\\\\\\n+Creates a `cargo` object with the specified payload. Tasks added to the\\\\\\\\n+cargo will be processed altogether (up to the `payload` limit). If the\\\\\\\\n+`worker` is in progress, the task is queued until it becomes available. Once\\\\\\\\n+the `worker` has completed some tasks, each callback of those tasks is called.\\\\\\\\n+Check out [this animation](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) for how `cargo` and `queue` work.\\\\\\\\n+\\\\\\\\n+While [queue](#queue) passes only one task to one of a group of workers\\\\\\\\n+at a time, cargo passes an array of tasks to a single worker, repeating\\\\\\\\n+when the worker is finished.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `worker(tasks, callback)` - An asynchronous function for processing an array of\\\\\\\\n+  queued tasks, which must call its `callback(err)` argument when finished, with \\\\\\\\n+  an optional `err` argument.\\\\\\\\n+* `payload` - An optional `integer` for determining how many tasks should be\\\\\\\\n+  processed per round; if omitted, the default is unlimited.\\\\\\\\n+\\\\\\\\n+__Cargo objects__\\\\\\\\n+\\\\\\\\n+The `cargo` object returned by this function has the following properties and\\\\\\\\n+methods:\\\\\\\\n+\\\\\\\\n+* `length()` - A function returning the number of items waiting to be processed.\\\\\\\\n+* `payload` - An `integer` for determining how many tasks should be\\\\\\\\n+  process per round. This property can be changed after a `cargo` is created to\\\\\\\\n+  alter the payload on-the-fly.\\\\\\\\n+* `push(task, [callback])` - Adds `task` to the `queue`. The callback is called\\\\\\\\n+  once the `worker` has finished processing the task. Instead of a single task, an array of `tasks` \\\\\\\\n+  can be submitted. The respective callback is used for every task in the list.\\\\\\\\n+* `saturated` - A callback that is called when the `queue.length()` hits the concurrency and further tasks will be queued.\\\\\\\\n+* `empty` - A callback that is called when the last item from the `queue` is given to a `worker`.\\\\\\\\n+* `drain` - A callback that is called when the last item from the `queue` has returned from the `worker`.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+// create a cargo object with payload 2\\\\\\\\n+\\\\\\\\n+var cargo = async.cargo(function (tasks, callback) {\\\\\\\\n+    for(var i=0; i<tasks.length; i++){\\\\\\\\n+      console.log('hello ' + tasks[i].name);\\\\\\\\n+    }\\\\\\\\n+    callback();\\\\\\\\n+}, 2);\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+// add some items\\\\\\\\n+\\\\\\\\n+cargo.push({name: 'foo'}, function (err) {\\\\\\\\n+    console.log('finished processing foo');\\\\\\\\n+});\\\\\\\\n+cargo.push({name: 'bar'}, function (err) {\\\\\\\\n+    console.log('finished processing bar');\\\\\\\\n+});\\\\\\\\n+cargo.push({name: 'baz'}, function (err) {\\\\\\\\n+    console.log('finished processing baz');\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"auto\\\\\\\\\\\\\\\" />\\\\\\\\n+### auto(tasks, [callback])\\\\\\\\n+\\\\\\\\n+Determines the best order for running the functions in `tasks`, based on their \\\\\\\\n+requirements. Each function can optionally depend on other functions being completed \\\\\\\\n+first, and each function is run as soon as its requirements are satisfied. \\\\\\\\n+\\\\\\\\n+If any of the functions pass an error to their callback, it will not \\\\\\\\n+complete (so any other functions depending on it will not run), and the main \\\\\\\\n+`callback` is immediately called with the error. Functions also receive an \\\\\\\\n+object containing the results of functions which have completed so far.\\\\\\\\n+\\\\\\\\n+Note, all functions are called with a `results` object as a second argument, \\\\\\\\n+so it is unsafe to pass functions in the `tasks` object which cannot handle the\\\\\\\\n+extra argument. \\\\\\\\n+\\\\\\\\n+For example, this snippet of code:\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.auto({\\\\\\\\n+  readData: async.apply(fs.readFile, 'data.txt', 'utf-8')\\\\\\\\n+}, callback);\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+will have the effect of calling `readFile` with the results object as the last\\\\\\\\n+argument, which will fail:\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+fs.readFile('data.txt', 'utf-8', cb, {});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+Instead, wrap the call to `readFile` in a function which does not forward the \\\\\\\\n+`results` object:\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.auto({\\\\\\\\n+  readData: function(cb, results){\\\\\\\\n+    fs.readFile('data.txt', 'utf-8', cb);\\\\\\\\n+  }\\\\\\\\n+}, callback);\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `tasks` - An object. Each of its properties is either a function or an array of\\\\\\\\n+  requirements, with the function itself the last item in the array. The object's key\\\\\\\\n+  of a property serves as the name of the task defined by that property,\\\\\\\\n+  i.e. can be used when specifying requirements for other tasks.\\\\\\\\n+  The function receives two arguments: (1) a `callback(err, result)` which must be \\\\\\\\n+  called when finished, passing an `error` (which can be `null`) and the result of \\\\\\\\n+  the function's execution, and (2) a `results` object, containing the results of\\\\\\\\n+  the previously executed functions.\\\\\\\\n+* `callback(err, results)` - An optional callback which is called when all the\\\\\\\\n+  tasks have been completed. It receives the `err` argument if any `tasks` \\\\\\\\n+  pass an error to their callback. Results are always returned; however, if \\\\\\\\n+  an error occurs, no further `tasks` will be performed, and the results\\\\\\\\n+  object will only contain partial results.\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.auto({\\\\\\\\n+    get_data: function(callback){\\\\\\\\n+        console.log('in get_data');\\\\\\\\n+        // async code to get some data\\\\\\\\n+        callback(null, 'data', 'converted to array');\\\\\\\\n+    },\\\\\\\\n+    make_folder: function(callback){\\\\\\\\n+        console.log('in make_folder');\\\\\\\\n+        // async code to create a directory to store a file in\\\\\\\\n+        // this is run at the same time as getting the data\\\\\\\\n+        callback(null, 'folder');\\\\\\\\n+    },\\\\\\\\n+    write_file: ['get_data', 'make_folder', function(callback, results){\\\\\\\\n+        console.log('in write_file', JSON.stringify(results));\\\\\\\\n+        // once there is some data and the directory exists,\\\\\\\\n+        // write the data to a file in the directory\\\\\\\\n+        callback(null, 'filename');\\\\\\\\n+    }],\\\\\\\\n+    email_link: ['write_file', function(callback, results){\\\\\\\\n+        console.log('in email_link', JSON.stringify(results));\\\\\\\\n+        // once the file is written let's email a link to it...\\\\\\\\n+        // results.write_file contains the filename returned by write_file.\\\\\\\\n+        callback(null, {'file':results.write_file, 'email':'user@example.com'});\\\\\\\\n+    }]\\\\\\\\n+}, function(err, results) {\\\\\\\\n+    console.log('err = ', err);\\\\\\\\n+    console.log('results = ', results);\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+This is a fairly trivial example, but to do this using the basic parallel and\\\\\\\\n+series functions would look like this:\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.parallel([\\\\\\\\n+    function(callback){\\\\\\\\n+        console.log('in get_data');\\\\\\\\n+        // async code to get some data\\\\\\\\n+        callback(null, 'data', 'converted to array');\\\\\\\\n+    },\\\\\\\\n+    function(callback){\\\\\\\\n+        console.log('in make_folder');\\\\\\\\n+        // async code to create a directory to store a file in\\\\\\\\n+        // this is run at the same time as getting the data\\\\\\\\n+        callback(null, 'folder');\\\\\\\\n+    }\\\\\\\\n+],\\\\\\\\n+function(err, results){\\\\\\\\n+    async.series([\\\\\\\\n+        function(callback){\\\\\\\\n+            console.log('in write_file', JSON.stringify(results));\\\\\\\\n+            // once there is some data and the directory exists,\\\\\\\\n+            // write the data to a file in the directory\\\\\\\\n+            results.push('filename');\\\\\\\\n+            callback(null);\\\\\\\\n+        },\\\\\\\\n+        function(callback){\\\\\\\\n+            console.log('in email_link', JSON.stringify(results));\\\\\\\\n+            // once the file is written let's email a link to it...\\\\\\\\n+            callback(null, {'file':results.pop(), 'email':'user@example.com'});\\\\\\\\n+        }\\\\\\\\n+    ]);\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+For a complicated series of `async` tasks, using the [`auto`](#auto) function makes adding\\\\\\\\n+new tasks much easier (and the code more readable).\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"retry\\\\\\\\\\\\\\\" />\\\\\\\\n+### retry([times = 5], task, [callback])\\\\\\\\n+\\\\\\\\n+Attempts to get a successful response from `task` no more than `times` times before\\\\\\\\n+returning an error. If the task is successful, the `callback` will be passed the result\\\\\\\\n+of the successfull task. If all attemps fail, the callback will be passed the error and\\\\\\\\n+result (if any) of the final attempt.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `times` - An integer indicating how many times to attempt the `task` before giving up. Defaults to 5.\\\\\\\\n+* `task(callback, results)` - A function which receives two arguments: (1) a `callback(err, result)`\\\\\\\\n+  which must be called when finished, passing `err` (which can be `null`) and the `result` of \\\\\\\\n+  the function's execution, and (2) a `results` object, containing the results of\\\\\\\\n+  the previously executed functions (if nested inside another control flow).\\\\\\\\n+* `callback(err, results)` - An optional callback which is called when the\\\\\\\\n+  task has succeeded, or after the final failed attempt. It receives the `err` and `result` arguments of the last attempt at completing the `task`.\\\\\\\\n+\\\\\\\\n+The [`retry`](#retry) function can be used as a stand-alone control flow by passing a\\\\\\\\n+callback, as shown below:\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.retry(3, apiMethod, function(err, result) {\\\\\\\\n+    // do something with the result\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+It can also be embeded within other control flow functions to retry individual methods\\\\\\\\n+that are not as reliable, like this:\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.auto({\\\\\\\\n+    users: api.getUsers.bind(api),\\\\\\\\n+    payments: async.retry(3, api.getPayments.bind(api))\\\\\\\\n+}, function(err, results) {\\\\\\\\n+  // do something with the results\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"iterator\\\\\\\\\\\\\\\" />\\\\\\\\n+### iterator(tasks)\\\\\\\\n+\\\\\\\\n+Creates an iterator function which calls the next function in the `tasks` array,\\\\\\\\n+returning a continuation to call the next one after that. It's also possible to\\\\\\\\n+“peek” at the next iterator with `iterator.next()`.\\\\\\\\n+\\\\\\\\n+This function is used internally by the `async` module, but can be useful when\\\\\\\\n+you want to manually control the flow of functions in series.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `tasks` - An array of functions to run.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+var iterator = async.iterator([\\\\\\\\n+    function(){ sys.p('one'); },\\\\\\\\n+    function(){ sys.p('two'); },\\\\\\\\n+    function(){ sys.p('three'); }\\\\\\\\n+]);\\\\\\\\n+\\\\\\\\n+node> var iterator2 = iterator();\\\\\\\\n+'one'\\\\\\\\n+node> var iterator3 = iterator2();\\\\\\\\n+'two'\\\\\\\\n+node> iterator3();\\\\\\\\n+'three'\\\\\\\\n+node> var nextfn = iterator2.next();\\\\\\\\n+node> nextfn();\\\\\\\\n+'three'\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"apply\\\\\\\\\\\\\\\" />\\\\\\\\n+### apply(function, arguments..)\\\\\\\\n+\\\\\\\\n+Creates a continuation function with some arguments already applied. \\\\\\\\n+\\\\\\\\n+Useful as a shorthand when combined with other control flow functions. Any arguments\\\\\\\\n+passed to the returned function are added to the arguments originally passed\\\\\\\\n+to apply.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\\\\\n+* `arguments...` - Any number of arguments to automatically apply when the\\\\\\\\n+  continuation is called.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+// using apply\\\\\\\\n+\\\\\\\\n+async.parallel([\\\\\\\\n+    async.apply(fs.writeFile, 'testfile1', 'test1'),\\\\\\\\n+    async.apply(fs.writeFile, 'testfile2', 'test2'),\\\\\\\\n+]);\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+// the same process without using apply\\\\\\\\n+\\\\\\\\n+async.parallel([\\\\\\\\n+    function(callback){\\\\\\\\n+        fs.writeFile('testfile1', 'test1', callback);\\\\\\\\n+    },\\\\\\\\n+    function(callback){\\\\\\\\n+        fs.writeFile('testfile2', 'test2', callback);\\\\\\\\n+    }\\\\\\\\n+]);\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+It's possible to pass any number of additional arguments when calling the\\\\\\\\n+continuation:\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+node> var fn = async.apply(sys.puts, 'one');\\\\\\\\n+node> fn('two', 'three');\\\\\\\\n+one\\\\\\\\n+two\\\\\\\\n+three\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"nextTick\\\\\\\\\\\\\\\" />\\\\\\\\n+### nextTick(callback)\\\\\\\\n+\\\\\\\\n+Calls `callback` on a later loop around the event loop. In Node.js this just\\\\\\\\n+calls `process.nextTick`; in the browser it falls back to `setImmediate(callback)`\\\\\\\\n+if available, otherwise `setTimeout(callback, 0)`, which means other higher priority\\\\\\\\n+events may precede the execution of `callback`.\\\\\\\\n+\\\\\\\\n+This is used internally for browser-compatibility purposes.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `callback` - The function to call on a later loop around the event loop.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+var call_order = [];\\\\\\\\n+async.nextTick(function(){\\\\\\\\n+    call_order.push('two');\\\\\\\\n+    // call_order now equals ['one','two']\\\\\\\\n+});\\\\\\\\n+call_order.push('one')\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"times\\\\\\\\\\\\\\\" />\\\\\\\\n+### times(n, callback)\\\\\\\\n+\\\\\\\\n+Calls the `callback` function `n` times, and accumulates results in the same manner\\\\\\\\n+you would use with [`map`](#map).\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `n` - The number of times to run the function.\\\\\\\\n+* `callback` - The function to call `n` times.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+// Pretend this is some complicated async factory\\\\\\\\n+var createUser = function(id, callback) {\\\\\\\\n+  callback(null, {\\\\\\\\n+    id: 'user' + id\\\\\\\\n+  })\\\\\\\\n+}\\\\\\\\n+// generate 5 users\\\\\\\\n+async.times(5, function(n, next){\\\\\\\\n+    createUser(n, function(err, user) {\\\\\\\\n+      next(err, user)\\\\\\\\n+    })\\\\\\\\n+}, function(err, users) {\\\\\\\\n+  // we should now have 5 users\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"timesSeries\\\\\\\\\\\\\\\" />\\\\\\\\n+### timesSeries(n, callback)\\\\\\\\n+\\\\\\\\n+The same as [`times`](#times), only the iterator is applied to each item in `arr` in\\\\\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\\\\\n+The results array will be in the same order as the original.\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+## Utils\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"memoize\\\\\\\\\\\\\\\" />\\\\\\\\n+### memoize(fn, [hasher])\\\\\\\\n+\\\\\\\\n+Caches the results of an `async` function. When creating a hash to store function\\\\\\\\n+results against, the callback is omitted from the hash and an optional hash\\\\\\\\n+function can be used.\\\\\\\\n+\\\\\\\\n+The cache of results is exposed as the `memo` property of the function returned\\\\\\\\n+by `memoize`.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `fn` - The function to proxy and cache results from.\\\\\\\\n+* `hasher` - Tn optional function for generating a custom hash for storing\\\\\\\\n+  results. It has all the arguments applied to it apart from the callback, and\\\\\\\\n+  must be synchronous.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+var slow_fn = function (name, callback) {\\\\\\\\n+    // do something\\\\\\\\n+    callback(null, result);\\\\\\\\n+};\\\\\\\\n+var fn = async.memoize(slow_fn);\\\\\\\\n+\\\\\\\\n+// fn can now be used as if it were slow_fn\\\\\\\\n+fn('some name', function () {\\\\\\\\n+    // callback\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"unmemoize\\\\\\\\\\\\\\\" />\\\\\\\\n+### unmemoize(fn)\\\\\\\\n+\\\\\\\\n+Undoes a [`memoize`](#memoize)d function, reverting it to the original, unmemoized\\\\\\\\n+form. Handy for testing.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `fn` - the memoized function\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"log\\\\\\\\\\\\\\\" />\\\\\\\\n+### log(function, arguments)\\\\\\\\n+\\\\\\\\n+Logs the result of an `async` function to the `console`. Only works in Node.js or\\\\\\\\n+in browsers that support `console.log` and `console.error` (such as FF and Chrome).\\\\\\\\n+If multiple arguments are returned from the async function, `console.log` is\\\\\\\\n+called on each argument in order.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\\\\\n+* `arguments...` - Any number of arguments to apply to the function.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+var hello = function(name, callback){\\\\\\\\n+    setTimeout(function(){\\\\\\\\n+        callback(null, 'hello ' + name);\\\\\\\\n+    }, 1000);\\\\\\\\n+};\\\\\\\\n+```\\\\\\\\n+```js\\\\\\\\n+node> async.log(hello, 'world');\\\\\\\\n+'hello world'\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"dir\\\\\\\\\\\\\\\" />\\\\\\\\n+### dir(function, arguments)\\\\\\\\n+\\\\\\\\n+Logs the result of an `async` function to the `console` using `console.dir` to\\\\\\\\n+display the properties of the resulting object. Only works in Node.js or\\\\\\\\n+in browsers that support `console.dir` and `console.error` (such as FF and Chrome).\\\\\\\\n+If multiple arguments are returned from the async function, `console.dir` is\\\\\\\\n+called on each argument in order.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\\\\\n+* `arguments...` - Any number of arguments to apply to the function.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+var hello = function(name, callback){\\\\\\\\n+    setTimeout(function(){\\\\\\\\n+        callback(null, {hello: name});\\\\\\\\n+    }, 1000);\\\\\\\\n+};\\\\\\\\n+```\\\\\\\\n+```js\\\\\\\\n+node> async.dir(hello, 'world');\\\\\\\\n+{hello: 'world'}\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"noConflict\\\\\\\\\\\\\\\" />\\\\\\\\n+### noConflict()\\\\\\\\n+\\\\\\\\n+Changes the value of `async` back to its original value, returning a reference to the\\\\\\\\n+`async` object.\\\\\\\\ndiff --git a/node_modules/async/component.json b/node_modules/async/component.json\\\\\\\\nnew file mode 100644\\\\\\\\nindex 0000000..bbb0115\\\\\\\\n--- /dev/null\\\\\\\\n+++ b/node_modules/async/component.json\\\\\\\\n@@ -0,0 +1,11 @@\\\\\\\\n+{\\\\\\\\n+  \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"async\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"repo\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"caolan/async\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Higher-order functions and common patterns for asynchronous code\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"version\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"0.1.23\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"keywords\\\\\\\\\\\\\\\": [],\\\\\\\\n+  \\\\\\\\\\\\\\\"dependencies\\\\\\\\\\\\\\\": {},\\\\\\\\n+  \\\\\\\\\\\\\\\"development\\\\\\\\\\\\\\\": {},\\\\\\\\n+  \\\\\\\\\\\\\\\"main\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"lib/async.js\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"scripts\\\\\\\\\\\\\\\": [ \\\\\\\\\\\\\\\"lib/async.js\\\\\\\\\\\\\\\" ]\\\\\\\\n+}\\\\\\\\ndiff --git a/node_modules/async/lib/async.js b/node_modules/async/lib/async.js\\\\\\\\nnew file mode 100644\\\\\\\\nindex 0000000..01e8afc\\\\\\\\n--- /dev/null\\\\\\\\n+++ b/node_modules/async/lib/async.js\\\\\\\\n@@ -0,0 +1,1123 @@\\\\\\\\n+/*!\\\\\\\\n+ * async\\\\\\\\n+ * https://github.com/caolan/async\\\\\\\\n+ *\\\\\\\\n+ * Copyright 2010-2014 Caolan McMahon\\\\\\\\n+ * Released under the MIT license\\\\\\\\n+ */\\\\\\\\n+/*jshint onevar: false, indent:4 */\\\\\\\\n+/*global setImmediate: false, setTimeout: false, console: false */\\\\\\\\n+(function () {\\\\\\\\n+\\\\\\\\n+    var async = {};\\\\\\\\n+\\\\\\\\n+    // global on the server, window in the browser\\\\\\\\n+    var root, previous_async;\\\\\\\\n+\\\\\\\\n+    root = this;\\\\\\\\n+    if (root != null) {\\\\\\\\n+      previous_async = root.async;\\\\\\\\n+    }\\\\\\\\n+\\\\\\\\n+    async.noConflict = function () {\\\\\\\\n+        root.async = previous_async;\\\\\\\\n+        return async;\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    function only_once(fn) {\\\\\\\\n+        var called = false;\\\\\\\\n+        return function() {\\\\\\\\n+            if (called) throw new Error(\\\\\\\\\\\\\\\"Callback was already called.\\\\\\\\\\\\\\\");\\\\\\\\n+            called = true;\\\\\\\\n+            fn.apply(root, arguments);\\\\\\\\n+        }\\\\\\\\n+    }\\\\\\\\n+\\\\\\\\n+    //// cross-browser compatiblity functions ////\\\\\\\\n+\\\\\\\\n+    var _toString = Object.prototype.toString;\\\\\\\\n+\\\\\\\\n+    var _isArray = Array.isArray || function (obj) {\\\\\\\\n+        return _toString.call(obj) === '[object Array]';\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    var _each = function (arr, iterator) {\\\\\\\\n+        if (arr.forEach) {\\\\\\\\n+            return arr.forEach(iterator);\\\\\\\\n+        }\\\\\\\\n+        for (var i = 0; i < arr.length; i += 1) {\\\\\\\\n+            iterator(arr[i], i, arr);\\\\\\\\n+        }\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    var _map = function (arr, iterator) {\\\\\\\\n+        if (arr.map) {\\\\\\\\n+            return arr.map(iterator);\\\\\\\\n+        }\\\\\\\\n+        var results = [];\\\\\\\\n+        _each(arr, function (x, i, a) {\\\\\\\\n+            results.push(iterator(x, i, a));\\\\\\\\n+        });\\\\\\\\n+        return results;\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    var _reduce = function (arr, iterator, memo) {\\\\\\\\n+        if (arr.reduce) {\\\\\\\\n+            return arr.reduce(iterator, memo);\\\\\\\\n+        }\\\\\\\\n+        _each(arr, function (x, i, a) {\\\\\\\\n+            memo = iterator(memo, x, i, a);\\\\\\\\n+        });\\\\\\\\n+        return memo;\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    var _keys = function (obj) {\\\\\\\\n+        if (Object.keys) {\\\\\\\\n+            return Object.keys(obj);\\\\\\\\n+        }\\\\\\\\n+        var keys = [];\\\\\\\\n+        for (var k in obj) {\\\\\\\\n+            if (obj.hasOwnProperty(k)) {\\\\\\\\n+                keys.push(k);\\\\\\\\n+            }\\\\\\\\n+        }\\\\\\\\n+        return keys;\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    //// exported async module functions ////\\\\\\\\n+\\\\\\\\n+    //// nextTick implementation with browser-compatible fallback ////\\\\\\\\n+    if (typeof process === 'undefined' || !(process.nextTick)) {\\\\\\\\n+        if (typeof setImmediate === 'function') {\\\\\\\\n+            async.nextTick = function (fn) {\\\\\\\\n+                // not a direct alias for IE10 compatibility\\\\\\\\n+                setImmediate(fn);\\\\\\\\n+            };\\\\\\\\n+            async.setImmediate = async.nextTick;\\\\\\\\n+        }\\\\\\\\n+        else {\\\\\\\\n+            async.nextTick = function (fn) {\\\\\\\\n+                setTimeout(fn, 0);\\\\\\\\n+            };\\\\\\\\n+            async.setImmediate = async.nextTick;\\\\\\\\n+        }\\\\\\\\n+    }\\\\\\\\n+    else {\\\\\\\\n+        async.nextTick = process.nextTick;\\\\\\\\n+        if (typeof setImmediate !== 'undefined') {\\\\\\\\n+            async.setImmediate = function (fn) {\\\\\\\\n+              // not a direct alias for IE10 compatibility\\\\\\\\n+              setImmediate(fn);\\\\\\\\n+            };\\\\\\\\n+        }\\\\\\\\n+        else {\\\\\\\\n+            async.setImmediate = async.nextTick;\\\\\\\\n+        }\\\\\\\\n+    }\\\\\\\\n+\\\\\\\\n+    async.each = function (arr, iterator, callback) {\\\\\\\\n+        callback = callback || function () {};\\\\\\\\n+        if (!arr.length) {\\\\\\\\n+            return callback();\\\\\\\\n+        }\\\\\\\\n+        var completed = 0;\\\\\\\\n+        _each(arr, function (x) {\\\\\\\\n+            iterator(x, only_once(done) );\\\\\\\\n+        });\\\\\\\\n+        function done(err) {\\\\\\\\n+          if (err) {\\\\\\\\n+              callback(err);\\\\\\\\n+              callback = function () {};\\\\\\\\n+          }\\\\\\\\n+          else {\\\\\\\\n+              completed += 1;\\\\\\\\n+              if (completed >= arr.length) {\\\\\\\\n+                  callback();\\\\\\\\n+              }\\\\\\\\n+          }\\\\\\\\n+        }\\\\\\\\n+    };\\\\\\\\n+    async.forEach = async.each;\\\\\\\\n+\\\\\\\\n+    async.eachSeries = function (arr, iterator, callback) {\\\\\\\\n+        callback = callback || function () {};\\\\\\\\n+        if (!arr.length) {\\\\\\\\n+            return callback();\\\\\\\\n+        }\\\\\\\\n+        var completed = 0;\\\\\\\\n+        var iterate = function () {\\\\\\\\n+            iterator(arr[completed], function (err) {\\\\\\\\n+                if (err) {\\\\\\\\n+                    callback(err);\\\\\\\\n+                    callback = function () {};\\\\\\\\n+                }\\\\\\\\n+                else {\\\\\\\\n+                    completed += 1;\\\\\\\\n+                    if (completed >= arr.length) {\\\\\\\\n+                        callback();\\\\\\\\n+                    }\\\\\\\\n+                    else {\\\\\\\\n+                        iterate();\\\\\\\\n+                    }\\\\\\\\n+                }\\\\\\\\n+            });\\\\\\\\n+        };\\\\\\\\n+        iterate();\\\\\\\\n+    };\\\\\\\\n+    async.forEachSeries = async.eachSeries;\\\\\\\\n+\\\\\\\\n+    async.eachLimit = function (arr, limit, iterator, callback) {\\\\\\\\n+        var fn = _eachLimit(limit);\\\\\\\\n+        fn.apply(null, [arr, iterator, callback]);\\\\\\\\n+    };\\\\\\\\n+    async.forEachLimit = async.eachLimit;\\\\\\\\n+\\\\\\\\n+    var _eachLimit = function (limit) {\\\\\\\\n+\\\\\\\\n+        return function (arr, iterator, callback) {\\\\\\\\n+            callback = callback || function () {};\\\\\\\\n+            if (!arr.length || limit <= 0) {\\\\\\\\n+                return callback();\\\\\\\\n+            }\\\\\\\\n+            var completed = 0;\\\\\\\\n+            var started = 0;\\\\\\\\n+            var running = 0;\\\\\\\\n+\\\\\\\\n+            (function replenish () {\\\\\\\\n+                if (completed >= arr.length) {\\\\\\\\n+                    return callback();\\\\\\\\n+                }\\\\\\\\n+\\\\\\\\n+                while (running < limit && started < arr.length) {\\\\\\\\n+                    started += 1;\\\\\\\\n+                    running += 1;\\\\\\\\n+                    iterator(arr[started - 1], function (err) {\\\\\\\\n+                        if (err) {\\\\\\\\n+                            callback(err);\\\\\\\\n+                            callback = function () {};\\\\\\\\n+                        }\\\\\\\\n+                        else {\\\\\\\\n+                            completed += 1;\\\\\\\\n+                            running -= 1;\\\\\\\\n+                            if (completed >= arr.length) {\\\\\\\\n+                                callback();\\\\\\\\n+                            }\\\\\\\\n+                            else {\\\\\\\\n+                                replenish();\\\\\\\\n+                            }\\\\\\\\n+                        }\\\\\\\\n+                    });\\\\\\\\n+                }\\\\\\\\n+            })();\\\\\\\\n+        };\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+    var doParallel = function (fn) {\\\\\\\\n+        return function () {\\\\\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\\\\\n+            return fn.apply(null, [async.each].concat(args));\\\\\\\\n+        };\\\\\\\\n+    };\\\\\\\\n+    var doParallelLimit = function(limit, fn) {\\\\\\\\n+        return function () {\\\\\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\\\\\n+            return fn.apply(null, [_eachLimit(limit)].concat(args));\\\\\\\\n+        };\\\\\\\\n+    };\\\\\\\\n+    var doSeries = function (fn) {\\\\\\\\n+        return function () {\\\\\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\\\\\n+            return fn.apply(null, [async.eachSeries].concat(args));\\\\\\\\n+        };\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+    var _asyncMap = function (eachfn, arr, iterator, callback) {\\\\\\\\n+        arr = _map(arr, function (x, i) {\\\\\\\\n+            return {index: i, value: x};\\\\\\\\n+        });\\\\\\\\n+        if (!callback) {\\\\\\\\n+            eachfn(arr, function (x, callback) {\\\\\\\\n+                iterator(x.value, function (err) {\\\\\\\\n+                    callback(err);\\\\\\\\n+                });\\\\\\\\n+            });\\\\\\\\n+        } else {\\\\\\\\n+            var results = [];\\\\\\\\n+            eachfn(arr, function (x, callback) {\\\\\\\\n+                iterator(x.value, function (err, v) {\\\\\\\\n+                    results[x.index] = v;\\\\\\\\n+                    callback(err);\\\\\\\\n+                });\\\\\\\\n+            }, function (err) {\\\\\\\\n+                callback(err, results);\\\\\\\\n+            });\\\\\\\\n+        }\\\\\\\\n+    };\\\\\\\\n+    async.map = doParallel(_asyncMap);\\\\\\\\n+    async.mapSeries = doSeries(_asyncMap);\\\\\\\\n+    async.mapLimit = function (arr, limit, iterator, callback) {\\\\\\\\n+        return _mapLimit(limit)(arr, iterator, callback);\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    var _mapLimit = function(limit) {\\\\\\\\n+        return doParallelLimit(limit, _asyncMap);\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    // reduce only has a series version, as doing reduce in parallel won't\\\\\\\\n+    // work in many situations.\\\\\\\\n+    async.reduce = function (arr, memo, iterator, callback) {\\\\\\\\n+        async.eachSeries(arr, function (x, callback) {\\\\\\\\n+            iterator(memo, x, function (err, v) {\\\\\\\\n+                memo = v;\\\\\\\\n+                callback(err);\\\\\\\\n+            });\\\\\\\\n+        }, function (err) {\\\\\\\\n+            callback(err, memo);\\\\\\\\n+        });\\\\\\\\n+    };\\\\\\\\n+    // inject alias\\\\\\\\n+    async.inject = async.reduce;\\\\\\\\n+    // foldl alias\\\\\\\\n+    async.foldl = async.reduce;\\\\\\\\n+\\\\\\\\n+    async.reduceRight = function (arr, memo, iterator, callback) {\\\\\\\\n+        var reversed = _map(arr, function (x) {\\\\\\\\n+            return x;\\\\\\\\n+        }).reverse();\\\\\\\\n+        async.reduce(reversed, memo, iterator, callback);\\\\\\\\n+    };\\\\\\\\n+    // foldr alias\\\\\\\\n+    async.foldr = async.reduceRight;\\\\\\\\n+\\\\\\\\n+    var _filter = function (eachfn, arr, iterator, callback) {\\\\\\\\n+        var results = [];\\\\\\\\n+        arr = _map(arr, function (x, i) {\\\\\\\\n+            return {index: i, value: x};\\\\\\\\n+        });\\\\\\\\n+        eachfn(arr, function (x, callback) {\\\\\\\\n+            iterator(x.value, function (v) {\\\\\\\\n+                if (v) {\\\\\\\\n+                    results.push(x);\\\\\\\\n+                }\\\\\\\\n+                callback();\\\\\\\\n+            });\\\\\\\\n+        }, function (err) {\\\\\\\\n+            callback(_map(results.sort(function (a, b) {\\\\\\\\n+                return a.index - b.index;\\\\\\\\n+            }), function (x) {\\\\\\\\n+                return x.value;\\\\\\\\n+            }));\\\\\\\\n+        });\\\\\\\\n+    };\\\\\\\\n+    async.filter = doParallel(_filter);\\\\\\\\n+    async.filterSeries = doSeries(_filter);\\\\\\\\n+    // select alias\\\\\\\\n+    async.select = async.filter;\\\\\\\\n+    async.selectSeries = async.filterSeries;\\\\\\\\n+\\\\\\\\n+    var _reject = function (eachfn, arr, iterator, callback) {\\\\\\\\n+        var results = [];\\\\\\\\n+        arr = _map(arr, function (x, i) {\\\\\\\\n+            return {index: i, value: x};\\\\\\\\n+        });\\\\\\\\n+        eachfn(arr, function (x, callback) {\\\\\\\\n+            iterator(x.value, function (v) {\\\\\\\\n+                if (!v) {\\\\\\\\n+                    results.push(x);\\\\\\\\n+                }\\\\\\\\n+                callback();\\\\\\\\n+            });\\\\\\\\n+        }, function (err) {\\\\\\\\n+            callback(_map(results.sort(function (a, b) {\\\\\\\\n+                return a.index - b.index;\\\\\\\\n+            }), function (x) {\\\\\\\\n+                return x.value;\\\\\\\\n+            }));\\\\\\\\n+        });\\\\\\\\n+    };\\\\\\\\n+    async.reject = doParallel(_reject);\\\\\\\\n+    async.rejectSeries = doSeries(_reject);\\\\\\\\n+\\\\\\\\n+    var _detect = function (eachfn, arr, iterator, main_callback) {\\\\\\\\n+        eachfn(arr, function (x, callback) {\\\\\\\\n+            iterator(x, function (result) {\\\\\\\\n+                if (result) {\\\\\\\\n+                    main_callback(x);\\\\\\\\n+                    main_callback = function () {};\\\\\\\\n+                }\\\\\\\\n+                else {\\\\\\\\n+                    callback();\\\\\\\\n+                }\\\\\\\\n+            });\\\\\\\\n+        }, function (err) {\\\\\\\\n+            main_callback();\\\\\\\\n+        });\\\\\\\\n+    };\\\\\\\\n+    async.detect = doParallel(_detect);\\\\\\\\n+    async.detectSeries = doSeries(_detect);\\\\\\\\n+\\\\\\\\n+    async.some = function (arr, iterator, main_callback) {\\\\\\\\n+        async.each(arr, function (x, callback) {\\\\\\\\n+            iterator(x, function (v) {\\\\\\\\n+                if (v) {\\\\\\\\n+                    main_callback(true);\\\\\\\\n+                    main_callback = function () {};\\\\\\\\n+                }\\\\\\\\n+                callback();\\\\\\\\n+            });\\\\\\\\n+        }, function (err) {\\\\\\\\n+            main_callback(false);\\\\\\\\n+        });\\\\\\\\n+    };\\\\\\\\n+    // any alias\\\\\\\\n+    async.any = async.some;\\\\\\\\n+\\\\\\\\n+    async.every = function (arr, iterator, main_callback) {\\\\\\\\n+        async.each(arr, function (x, callback) {\\\\\\\\n+            iterator(x, function (v) {\\\\\\\\n+                if (!v) {\\\\\\\\n+                    main_callback(false);\\\\\\\\n+                    main_callback = function () {};\\\\\\\\n+                }\\\\\\\\n+                callback();\\\\\\\\n+            });\\\\\\\\n+        }, function (err) {\\\\\\\\n+            main_callback(true);\\\\\\\\n+        });\\\\\\\\n+    };\\\\\\\\n+    // all alias\\\\\\\\n+    async.all = async.every;\\\\\\\\n+\\\\\\\\n+    async.sortBy = function (arr, iterator, callback) {\\\\\\\\n+        async.map(arr, function (x, callback) {\\\\\\\\n+            iterator(x, function (err, criteria) {\\\\\\\\n+                if (err) {\\\\\\\\n+                    callback(err);\\\\\\\\n+                }\\\\\\\\n+                else {\\\\\\\\n+                    callback(null, {value: x, criteria: criteria});\\\\\\\\n+                }\\\\\\\\n+            });\\\\\\\\n+        }, function (err, results) {\\\\\\\\n+            if (err) {\\\\\\\\n+                return callback(err);\\\\\\\\n+            }\\\\\\\\n+            else {\\\\\\\\n+                var fn = function (left, right) {\\\\\\\\n+                    var a = left.criteria, b = right.criteria;\\\\\\\\n+                    return a < b ? -1 : a > b ? 1 : 0;\\\\\\\\n+                };\\\\\\\\n+                callback(null, _map(results.sort(fn), function (x) {\\\\\\\\n+                    return x.value;\\\\\\\\n+                }));\\\\\\\\n+            }\\\\\\\\n+        });\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.auto = function (tasks, callback) {\\\\\\\\n+        callback = callback || function () {};\\\\\\\\n+        var keys = _keys(tasks);\\\\\\\\n+        var remainingTasks = keys.length\\\\\\\\n+        if (!remainingTasks) {\\\\\\\\n+            return callback();\\\\\\\\n+        }\\\\\\\\n+\\\\\\\\n+        var results = {};\\\\\\\\n+\\\\\\\\n+        var listeners = [];\\\\\\\\n+        var addListener = function (fn) {\\\\\\\\n+            listeners.unshift(fn);\\\\\\\\n+        };\\\\\\\\n+        var removeListener = function (fn) {\\\\\\\\n+            for (var i = 0; i < listeners.length; i += 1) {\\\\\\\\n+                if (listeners[i] === fn) {\\\\\\\\n+                    listeners.splice(i, 1);\\\\\\\\n+                    return;\\\\\\\\n+                }\\\\\\\\n+            }\\\\\\\\n+        };\\\\\\\\n+        var taskComplete = function () {\\\\\\\\n+            remainingTasks--\\\\\\\\n+            _each(listeners.slice(0), function (fn) {\\\\\\\\n+                fn();\\\\\\\\n+            });\\\\\\\\n+        };\\\\\\\\n+\\\\\\\\n+        addListener(function () {\\\\\\\\n+            if (!remainingTasks) {\\\\\\\\n+                var theCallback = callback;\\\\\\\\n+                // prevent final callback from calling itself if it errors\\\\\\\\n+                callback = function () {};\\\\\\\\n+\\\\\\\\n+                theCallback(null, results);\\\\\\\\n+            }\\\\\\\\n+        });\\\\\\\\n+\\\\\\\\n+        _each(keys, function (k) {\\\\\\\\n+            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\\\\\\\\n+            var taskCallback = function (err) {\\\\\\\\n+                var args = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+                if (args.length <= 1) {\\\\\\\\n+                    args = args[0];\\\\\\\\n+                }\\\\\\\\n+                if (err) {\\\\\\\\n+                    var safeResults = {};\\\\\\\\n+                    _each(_keys(results), function(rkey) {\\\\\\\\n+                        safeResults[rkey] = results[rkey];\\\\\\\\n+                    });\\\\\\\\n+                    safeResults[k] = args;\\\\\\\\n+                    callback(err, safeResults);\\\\\\\\n+                    // stop subsequent errors hitting callback multiple times\\\\\\\\n+                    callback = function () {};\\\\\\\\n+                }\\\\\\\\n+                else {\\\\\\\\n+                    results[k] = args;\\\\\\\\n+                    async.setImmediate(taskComplete);\\\\\\\\n+                }\\\\\\\\n+            };\\\\\\\\n+            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\\\\\\\\n+            var ready = function () {\\\\\\\\n+                return _reduce(requires, function (a, x) {\\\\\\\\n+                    return (a && results.hasOwnProperty(x));\\\\\\\\n+                }, true) && !results.hasOwnProperty(k);\\\\\\\\n+            };\\\\\\\\n+            if (ready()) {\\\\\\\\n+                task[task.length - 1](taskCallback, results);\\\\\\\\n+            }\\\\\\\\n+            else {\\\\\\\\n+                var listener = function () {\\\\\\\\n+                    if (ready()) {\\\\\\\\n+                        removeListener(listener);\\\\\\\\n+                        task[task.length - 1](taskCallback, results);\\\\\\\\n+                    }\\\\\\\\n+                };\\\\\\\\n+                addListener(listener);\\\\\\\\n+            }\\\\\\\\n+        });\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.retry = function(times, task, callback) {\\\\\\\\n+        var DEFAULT_TIMES = 5;\\\\\\\\n+        var attempts = [];\\\\\\\\n+        // Use defaults if times not passed\\\\\\\\n+        if (typeof times === 'function') {\\\\\\\\n+            callback = task;\\\\\\\\n+            task = times;\\\\\\\\n+            times = DEFAULT_TIMES;\\\\\\\\n+        }\\\\\\\\n+        // Make sure times is a number\\\\\\\\n+        times = parseInt(times, 10) || DEFAULT_TIMES;\\\\\\\\n+        var wrappedTask = function(wrappedCallback, wrappedResults) {\\\\\\\\n+            var retryAttempt = function(task, finalAttempt) {\\\\\\\\n+                return function(seriesCallback) {\\\\\\\\n+                    task(function(err, result){\\\\\\\\n+                        seriesCallback(!err || finalAttempt, {err: err, result: result});\\\\\\\\n+                    }, wrappedResults);\\\\\\\\n+                };\\\\\\\\n+            };\\\\\\\\n+            while (times) {\\\\\\\\n+                attempts.push(retryAttempt(task, !(times-=1)));\\\\\\\\n+            }\\\\\\\\n+            async.series(attempts, function(done, data){\\\\\\\\n+                data = data[data.length - 1];\\\\\\\\n+                (wrappedCallback || callback)(data.err, data.result);\\\\\\\\n+            });\\\\\\\\n+        }\\\\\\\\n+        // If a callback is passed, run this as a controll flow\\\\\\\\n+        return callback ? wrappedTask() : wrappedTask\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.waterfall = function (tasks, callback) {\\\\\\\\n+        callback = callback || function () {};\\\\\\\\n+        if (!_isArray(tasks)) {\\\\\\\\n+          var err = new Error('First argument to waterfall must be an array of functions');\\\\\\\\n+          return callback(err);\\\\\\\\n+        }\\\\\\\\n+        if (!tasks.length) {\\\\\\\\n+            return callback();\\\\\\\\n+        }\\\\\\\\n+        var wrapIterator = function (iterator) {\\\\\\\\n+            return function (err) {\\\\\\\\n+                if (err) {\\\\\\\\n+                    callback.apply(null, arguments);\\\\\\\\n+                    callback = function () {};\\\\\\\\n+                }\\\\\\\\n+                else {\\\\\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+                    var next = iterator.next();\\\\\\\\n+                    if (next) {\\\\\\\\n+                        args.push(wrapIterator(next));\\\\\\\\n+                    }\\\\\\\\n+                    else {\\\\\\\\n+                        args.push(callback);\\\\\\\\n+                    }\\\\\\\\n+                    async.setImmediate(function () {\\\\\\\\n+                        iterator.apply(null, args);\\\\\\\\n+                    });\\\\\\\\n+                }\\\\\\\\n+            };\\\\\\\\n+        };\\\\\\\\n+        wrapIterator(async.iterator(tasks))();\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    var _parallel = function(eachfn, tasks, callback) {\\\\\\\\n+        callback = callback || function () {};\\\\\\\\n+        if (_isArray(tasks)) {\\\\\\\\n+            eachfn.map(tasks, function (fn, callback) {\\\\\\\\n+                if (fn) {\\\\\\\\n+                    fn(function (err) {\\\\\\\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+                        if (args.length <= 1) {\\\\\\\\n+                            args = args[0];\\\\\\\\n+                        }\\\\\\\\n+                        callback.call(null, err, args);\\\\\\\\n+                    });\\\\\\\\n+                }\\\\\\\\n+            }, callback);\\\\\\\\n+        }\\\\\\\\n+        else {\\\\\\\\n+            var results = {};\\\\\\\\n+            eachfn.each(_keys(tasks), function (k, callback) {\\\\\\\\n+                tasks[k](function (err) {\\\\\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+                    if (args.length <= 1) {\\\\\\\\n+                        args = args[0];\\\\\\\\n+                    }\\\\\\\\n+                    results[k] = args;\\\\\\\\n+                    callback(err);\\\\\\\\n+                });\\\\\\\\n+            }, function (err) {\\\\\\\\n+                callback(err, results);\\\\\\\\n+            });\\\\\\\\n+        }\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.parallel = function (tasks, callback) {\\\\\\\\n+        _parallel({ map: async.map, each: async.each }, tasks, callback);\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.parallelLimit = function(tasks, limit, callback) {\\\\\\\\n+        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.series = function (tasks, callback) {\\\\\\\\n+        callback = callback || function () {};\\\\\\\\n+        if (_isArray(tasks)) {\\\\\\\\n+            async.mapSeries(tasks, function (fn, callback) {\\\\\\\\n+                if (fn) {\\\\\\\\n+                    fn(function (err) {\\\\\\\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+                        if (args.length <= 1) {\\\\\\\\n+                            args = args[0];\\\\\\\\n+                        }\\\\\\\\n+                        callback.call(null, err, args);\\\\\\\\n+                    });\\\\\\\\n+                }\\\\\\\\n+            }, callback);\\\\\\\\n+        }\\\\\\\\n+        else {\\\\\\\\n+            var results = {};\\\\\\\\n+            async.eachSeries(_keys(tasks), function (k, callback) {\\\\\\\\n+                tasks[k](function (err) {\\\\\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+                    if (args.length <= 1) {\\\\\\\\n+                        args = args[0];\\\\\\\\n+                    }\\\\\\\\n+                    results[k] = args;\\\\\\\\n+                    callback(err);\\\\\\\\n+                });\\\\\\\\n+            }, function (err) {\\\\\\\\n+                callback(err, results);\\\\\\\\n+            });\\\\\\\\n+        }\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.iterator = function (tasks) {\\\\\\\\n+        var makeCallback = function (index) {\\\\\\\\n+            var fn = function () {\\\\\\\\n+                if (tasks.length) {\\\\\\\\n+                    tasks[index].apply(null, arguments);\\\\\\\\n+                }\\\\\\\\n+                return fn.next();\\\\\\\\n+            };\\\\\\\\n+            fn.next = function () {\\\\\\\\n+                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\\\\\\\\n+            };\\\\\\\\n+            return fn;\\\\\\\\n+        };\\\\\\\\n+        return makeCallback(0);\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.apply = function (fn) {\\\\\\\\n+        var args = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+        return function () {\\\\\\\\n+            return fn.apply(\\\\\\\\n+                null, args.concat(Array.prototype.slice.call(arguments))\\\\\\\\n+            );\\\\\\\\n+        };\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    var _concat = function (eachfn, arr, fn, callback) {\\\\\\\\n+        var r = [];\\\\\\\\n+        eachfn(arr, function (x, cb) {\\\\\\\\n+            fn(x, function (err, y) {\\\\\\\\n+                r = r.concat(y || []);\\\\\\\\n+                cb(err);\\\\\\\\n+            });\\\\\\\\n+        }, function (err) {\\\\\\\\n+            callback(err, r);\\\\\\\\n+        });\\\\\\\\n+    };\\\\\\\\n+    async.concat = doParallel(_concat);\\\\\\\\n+    async.concatSeries = doSeries(_concat);\\\\\\\\n+\\\\\\\\n+    async.whilst = function (test, iterator, callback) {\\\\\\\\n+        if (test()) {\\\\\\\\n+            iterator(function (err) {\\\\\\\\n+                if (err) {\\\\\\\\n+                    return callback(err);\\\\\\\\n+                }\\\\\\\\n+                async.whilst(test, iterator, callback);\\\\\\\\n+            });\\\\\\\\n+        }\\\\\\\\n+        else {\\\\\\\\n+            callback();\\\\\\\\n+        }\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.doWhilst = function (iterator, test, callback) {\\\\\\\\n+        iterator(function (err) {\\\\\\\\n+            if (err) {\\\\\\\\n+                return callback(err);\\\\\\\\n+            }\\\\\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+            if (test.apply(null, args)) {\\\\\\\\n+                async.doWhilst(iterator, test, callback);\\\\\\\\n+            }\\\\\\\\n+            else {\\\\\\\\n+                callback();\\\\\\\\n+            }\\\\\\\\n+        });\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.until = function (test, iterator, callback) {\\\\\\\\n+        if (!test()) {\\\\\\\\n+            iterator(function (err) {\\\\\\\\n+                if (err) {\\\\\\\\n+                    return callback(err);\\\\\\\\n+                }\\\\\\\\n+                async.until(test, iterator, callback);\\\\\\\\n+            });\\\\\\\\n+        }\\\\\\\\n+        else {\\\\\\\\n+            callback();\\\\\\\\n+        }\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.doUntil = function (iterator, test, callback) {\\\\\\\\n+        iterator(function (err) {\\\\\\\\n+            if (err) {\\\\\\\\n+                return callback(err);\\\\\\\\n+            }\\\\\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+            if (!test.apply(null, args)) {\\\\\\\\n+                async.doUntil(iterator, test, callback);\\\\\\\\n+            }\\\\\\\\n+            else {\\\\\\\\n+                callback();\\\\\\\\n+            }\\\\\\\\n+        });\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.queue = function (worker, concurrency) {\\\\\\\\n+        if (concurrency === undefined) {\\\\\\\\n+            concurrency = 1;\\\\\\\\n+        }\\\\\\\\n+        function _insert(q, data, pos, callback) {\\\\\\\\n+          if (!q.started){\\\\\\\\n+            q.started = true;\\\\\\\\n+          }\\\\\\\\n+          if (!_isArray(data)) {\\\\\\\\n+              data = [data];\\\\\\\\n+          }\\\\\\\\n+          if(data.length == 0) {\\\\\\\\n+             // call drain immediately if there are no tasks\\\\\\\\n+             return async.setImmediate(function() {\\\\\\\\n+                 if (q.drain) {\\\\\\\\n+                     q.drain();\\\\\\\\n+                 }\\\\\\\\n+             });\\\\\\\\n+          }\\\\\\\\n+          _each(data, function(task) {\\\\\\\\n+              var item = {\\\\\\\\n+                  data: task,\\\\\\\\n+                  callback: typeof callback === 'function' ? callback : null\\\\\\\\n+              };\\\\\\\\n+\\\\\\\\n+              if (pos) {\\\\\\\\n+                q.tasks.unshift(item);\\\\\\\\n+              } else {\\\\\\\\n+                q.tasks.push(item);\\\\\\\\n+              }\\\\\\\\n+\\\\\\\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\\\\\\\n+                  q.saturated();\\\\\\\\n+              }\\\\\\\\n+              async.setImmediate(q.process);\\\\\\\\n+          });\\\\\\\\n+        }\\\\\\\\n+\\\\\\\\n+        var workers = 0;\\\\\\\\n+        var q = {\\\\\\\\n+            tasks: [],\\\\\\\\n+            concurrency: concurrency,\\\\\\\\n+            saturated: null,\\\\\\\\n+            empty: null,\\\\\\\\n+            drain: null,\\\\\\\\n+            started: false,\\\\\\\\n+            paused: false,\\\\\\\\n+            push: function (data, callback) {\\\\\\\\n+              _insert(q, data, false, callback);\\\\\\\\n+            },\\\\\\\\n+            kill: function () {\\\\\\\\n+              q.drain = null;\\\\\\\\n+              q.tasks = [];\\\\\\\\n+            },\\\\\\\\n+            unshift: function (data, callback) {\\\\\\\\n+              _insert(q, data, true, callback);\\\\\\\\n+            },\\\\\\\\n+            process: function () {\\\\\\\\n+                if (!q.paused && workers < q.concurrency && q.tasks.length) {\\\\\\\\n+                    var task = q.tasks.shift();\\\\\\\\n+                    if (q.empty && q.tasks.length === 0) {\\\\\\\\n+                        q.empty();\\\\\\\\n+                    }\\\\\\\\n+                    workers += 1;\\\\\\\\n+                    var next = function () {\\\\\\\\n+                        workers -= 1;\\\\\\\\n+                        if (task.callback) {\\\\\\\\n+                            task.callback.apply(task, arguments);\\\\\\\\n+                        }\\\\\\\\n+                        if (q.drain && q.tasks.length + workers === 0) {\\\\\\\\n+                            q.drain();\\\\\\\\n+                        }\\\\\\\\n+                        q.process();\\\\\\\\n+                    };\\\\\\\\n+                    var cb = only_once(next);\\\\\\\\n+                    worker(task.data, cb);\\\\\\\\n+                }\\\\\\\\n+            },\\\\\\\\n+            length: function () {\\\\\\\\n+                return q.tasks.length;\\\\\\\\n+            },\\\\\\\\n+            running: function () {\\\\\\\\n+                return workers;\\\\\\\\n+            },\\\\\\\\n+            idle: function() {\\\\\\\\n+                return q.tasks.length + workers === 0;\\\\\\\\n+            },\\\\\\\\n+            pause: function () {\\\\\\\\n+                if (q.paused === true) { return; }\\\\\\\\n+                q.paused = true;\\\\\\\\n+                q.process();\\\\\\\\n+            },\\\\\\\\n+            resume: function () {\\\\\\\\n+                if (q.paused === false) { return; }\\\\\\\\n+                q.paused = false;\\\\\\\\n+                q.process();\\\\\\\\n+            }\\\\\\\\n+        };\\\\\\\\n+        return q;\\\\\\\\n+    };\\\\\\\\n+    \\\\\\\\n+    async.priorityQueue = function (worker, concurrency) {\\\\\\\\n+        \\\\\\\\n+        function _compareTasks(a, b){\\\\\\\\n+          return a.priority - b.priority;\\\\\\\\n+        };\\\\\\\\n+        \\\\\\\\n+        function _binarySearch(sequence, item, compare) {\\\\\\\\n+          var beg = -1,\\\\\\\\n+              end = sequence.length - 1;\\\\\\\\n+          while (beg < end) {\\\\\\\\n+            var mid = beg + ((end - beg + 1) >>> 1);\\\\\\\\n+            if (compare(item, sequence[mid]) >= 0) {\\\\\\\\n+              beg = mid;\\\\\\\\n+            } else {\\\\\\\\n+              end = mid - 1;\\\\\\\\n+            }\\\\\\\\n+          }\\\\\\\\n+          return beg;\\\\\\\\n+        }\\\\\\\\n+        \\\\\\\\n+        function _insert(q, data, priority, callback) {\\\\\\\\n+          if (!q.started){\\\\\\\\n+            q.started = true;\\\\\\\\n+          }\\\\\\\\n+          if (!_isArray(data)) {\\\\\\\\n+              data = [data];\\\\\\\\n+          }\\\\\\\\n+          if(data.length == 0) {\\\\\\\\n+             // call drain immediately if there are no tasks\\\\\\\\n+             return async.setImmediate(function() {\\\\\\\\n+                 if (q.drain) {\\\\\\\\n+                     q.drain();\\\\\\\\n+                 }\\\\\\\\n+             });\\\\\\\\n+          }\\\\\\\\n+          _each(data, function(task) {\\\\\\\\n+              var item = {\\\\\\\\n+                  data: task,\\\\\\\\n+                  priority: priority,\\\\\\\\n+                  callback: typeof callback === 'function' ? callback : null\\\\\\\\n+              };\\\\\\\\n+              \\\\\\\\n+              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\\\\\\\\n+\\\\\\\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\\\\\\\n+                  q.saturated();\\\\\\\\n+              }\\\\\\\\n+              async.setImmediate(q.process);\\\\\\\\n+          });\\\\\\\\n+        }\\\\\\\\n+        \\\\\\\\n+        // Start with a normal queue\\\\\\\\n+        var q = async.queue(worker, concurrency);\\\\\\\\n+        \\\\\\\\n+        // Override push to accept second parameter representing priority\\\\\\\\n+        q.push = function (data, priority, callback) {\\\\\\\\n+          _insert(q, data, priority, callback);\\\\\\\\n+        };\\\\\\\\n+        \\\\\\\\n+        // Remove unshift function\\\\\\\\n+        delete q.unshift;\\\\\\\\n+\\\\\\\\n+        return q;\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.cargo = function (worker, payload) {\\\\\\\\n+        var working     = false,\\\\\\\\n+            tasks       = [];\\\\\\\\n+\\\\\\\\n+        var cargo = {\\\\\\\\n+            tasks: tasks,\\\\\\\\n+            payload: payload,\\\\\\\\n+            saturated: null,\\\\\\\\n+            empty: null,\\\\\\\\n+            drain: null,\\\\\\\\n+            drained: true,\\\\\\\\n+            push: function (data, callback) {\\\\\\\\n+                if (!_isArray(data)) {\\\\\\\\n+                    data = [data];\\\\\\\\n+                }\\\\\\\\n+                _each(data, function(task) {\\\\\\\\n+                    tasks.push({\\\\\\\\n+                        data: task,\\\\\\\\n+                        callback: typeof callback === 'function' ? callback : null\\\\\\\\n+                    });\\\\\\\\n+                    cargo.drained = false;\\\\\\\\n+                    if (cargo.saturated && tasks.length === payload) {\\\\\\\\n+                        cargo.saturated();\\\\\\\\n+                    }\\\\\\\\n+                });\\\\\\\\n+                async.setImmediate(cargo.process);\\\\\\\\n+            },\\\\\\\\n+            process: function process() {\\\\\\\\n+                if (working) return;\\\\\\\\n+                if (tasks.length === 0) {\\\\\\\\n+                    if(cargo.drain && !cargo.drained) cargo.drain();\\\\\\\\n+                    cargo.drained = true;\\\\\\\\n+                    return;\\\\\\\\n+                }\\\\\\\\n+\\\\\\\\n+                var ts = typeof payload === 'number'\\\\\\\\n+                            ? tasks.splice(0, payload)\\\\\\\\n+                            : tasks.splice(0, tasks.length);\\\\\\\\n+\\\\\\\\n+                var ds = _map(ts, function (task) {\\\\\\\\n+                    return task.data;\\\\\\\\n+                });\\\\\\\\n+\\\\\\\\n+                if(cargo.empty) cargo.empty();\\\\\\\\n+                working = true;\\\\\\\\n+                worker(ds, function () {\\\\\\\\n+                    working = false;\\\\\\\\n+\\\\\\\\n+                    var args = arguments;\\\\\\\\n+                    _each(ts, function (data) {\\\\\\\\n+                        if (data.callback) {\\\\\\\\n+                            data.callback.apply(null, args);\\\\\\\\n+                        }\\\\\\\\n+                    });\\\\\\\\n+\\\\\\\\n+                    process();\\\\\\\\n+                });\\\\\\\\n+            },\\\\\\\\n+            length: function () {\\\\\\\\n+                return tasks.length;\\\\\\\\n+            },\\\\\\\\n+            running: function () {\\\\\\\\n+                return working;\\\\\\\\n+            }\\\\\\\\n+        };\\\\\\\\n+        return cargo;\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    var _console_fn = function (name) {\\\\\\\\n+        return function (fn) {\\\\\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+            fn.apply(null, args.concat([function (err) {\\\\\\\\n+                var args = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+                if (typeof console !== 'undefined') {\\\\\\\\n+                    if (err) {\\\\\\\\n+                        if (console.error) {\\\\\\\\n+                            console.error(err);\\\\\\\\n+                        }\\\\\\\\n+                    }\\\\\\\\n+                    else if (console[name]) {\\\\\\\\n+                        _each(args, function (x) {\\\\\\\\n+                            console[name](x);\\\\\\\\n+                        });\\\\\\\\n+                    }\\\\\\\\n+                }\\\\\\\\n+            }]));\\\\\\\\n+        };\\\\\\\\n+    };\\\\\\\\n+    async.log = _console_fn('log');\\\\\\\\n+    async.dir = _console_fn('dir');\\\\\\\\n+    /*async.info = _console_fn('info');\\\\\\\\n+    async.warn = _console_fn('warn');\\\\\\\\n+    async.error = _console_fn('error');*/\\\\\\\\n+\\\\\\\\n+    async.memoize = function (fn, hasher) {\\\\\\\\n+        var memo = {};\\\\\\\\n+        var queues = {};\\\\\\\\n+        hasher = hasher || function (x) {\\\\\\\\n+            return x;\\\\\\\\n+        };\\\\\\\\n+        var memoized = function () {\\\\\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\\\\\n+            var callback = args.pop();\\\\\\\\n+            var key = hasher.apply(null, args);\\\\\\\\n+            if (key in memo) {\\\\\\\\n+                async.nextTick(function () {\\\\\\\\n+                    callback.apply(null, memo[key]);\\\\\\\\n+                });\\\\\\\\n+            }\\\\\\\\n+            else if (key in queues) {\\\\\\\\n+                queues[key].push(callback);\\\\\\\\n+            }\\\\\\\\n+            else {\\\\\\\\n+                queues[key] = [callback];\\\\\\\\n+                fn.apply(null, args.concat([function () {\\\\\\\\n+                    memo[key] = arguments;\\\\\\\\n+                    var q = queues[key];\\\\\\\\n+                    delete queues[key];\\\\\\\\n+                    for (var i = 0, l = q.length; i < l; i++) {\\\\\\\\n+                      q[i].apply(null, arguments);\\\\\\\\n+                    }\\\\\\\\n+                }]));\\\\\\\\n+            }\\\\\\\\n+        };\\\\\\\\n+        memoized.memo = memo;\\\\\\\\n+        memoized.unmemoized = fn;\\\\\\\\n+        return memoized;\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.unmemoize = function (fn) {\\\\\\\\n+      return function () {\\\\\\\\n+        return (fn.unmemoized || fn).apply(null, arguments);\\\\\\\\n+      };\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.times = function (count, iterator, callback) {\\\\\\\\n+        var counter = [];\\\\\\\\n+        for (var i = 0; i < count; i++) {\\\\\\\\n+            counter.push(i);\\\\\\\\n+        }\\\\\\\\n+        return async.map(counter, iterator, callback);\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.timesSeries = function (count, iterator, callback) {\\\\\\\\n+        var counter = [];\\\\\\\\n+        for (var i = 0; i < count; i++) {\\\\\\\\n+            counter.push(i);\\\\\\\\n+        }\\\\\\\\n+        return async.mapSeries(counter, iterator, callback);\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.seq = function (/* functions... */) {\\\\\\\\n+        var fns = arguments;\\\\\\\\n+        return function () {\\\\\\\\n+            var that = this;\\\\\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\\\\\n+            var callback = args.pop();\\\\\\\\n+            async.reduce(fns, args, function (newargs, fn, cb) {\\\\\\\\n+                fn.apply(that, newargs.concat([function () {\\\\\\\\n+                    var err = arguments[0];\\\\\\\\n+                    var nextargs = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+                    cb(err, nextargs);\\\\\\\\n+                }]))\\\\\\\\n+            },\\\\\\\\n+            function (err, results) {\\\\\\\\n+                callback.apply(that, [err].concat(results));\\\\\\\\n+            });\\\\\\\\n+        };\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.compose = function (/* functions... */) {\\\\\\\\n+      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    var _applyEach = function (eachfn, fns /*args...*/) {\\\\\\\\n+        var go = function () {\\\\\\\\n+            var that = this;\\\\\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\\\\\n+            var callback = args.pop();\\\\\\\\n+            return eachfn(fns, function (fn, cb) {\\\\\\\\n+                fn.apply(that, args.concat([cb]));\\\\\\\\n+            },\\\\\\\\n+            callback);\\\\\\\\n+        };\\\\\\\\n+        if (arguments.length > 2) {\\\\\\\\n+            var args = Array.prototype.slice.call(arguments, 2);\\\\\\\\n+            return go.apply(this, args);\\\\\\\\n+        }\\\\\\\\n+        else {\\\\\\\\n+            return go;\\\\\\\\n+        }\\\\\\\\n+    };\\\\\\\\n+    async.applyEach = doParallel(_applyEach);\\\\\\\\n+    async.applyEachSeries = doSeries(_applyEach);\\\\\\\\n+\\\\\\\\n+    async.forever = function (fn, callback) {\\\\\\\\n+        function next(err) {\\\\\\\\n+            if (err) {\\\\\\\\n+                if (callback) {\\\\\\\\n+                    return callback(err);\\\\\\\\n+                }\\\\\\\\n+                throw err;\\\\\\\\n+            }\\\\\\\\n+            fn(next);\\\\\\\\n+        }\\\\\\\\n+        next();\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    // Node.js\\\\\\\\n+    if (typeof module !== 'undefined' && module.exports) {\\\\\\\\n+        module.exports = async;\\\\\\\\n+    }\\\\\\\\n+    // AMD / RequireJS\\\\\\\\n+    else if (typeof define !== 'undefined' && define.amd) {\\\\\\\\n+        define([], function () {\\\\\\\\n+            return async;\\\\\\\\n+        });\\\\\\\\n+    }\\\\\\\\n+    // included directly via <script> tag\\\\\\\\n+    else {\\\\\\\\n+        root.async = async;\\\\\\\\n+    }\\\\\\\\n+\\\\\\\\n+}());\\\\\\\\ndiff --git a/node_modules/async/package.json b/node_modules/async/package.json\\\\\\\\nnew file mode 100644\\\\\\\\nindex 0000000..31a5200\\\\\\\\n--- /dev/null\\\\\\\\n+++ b/node_modules/async/package.json\\\\\\\\n@@ -0,0 +1,59 @@\\\\\\\\n+{\\\\\\\\n+  \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"async\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Higher-order functions and common patterns for asynchronous code\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"main\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"./lib/async\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"author\\\\\\\\\\\\\\\": {\\\\\\\\n+    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Caolan McMahon\\\\\\\\\\\\\\\"\\\\\\\\n+  },\\\\\\\\n+  \\\\\\\\\\\\\\\"version\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"0.9.0\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"repository\\\\\\\\\\\\\\\": {\\\\\\\\n+    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"git\\\\\\\\\\\\\\\",\\\\\\\\n+    \\\\\\\\\\\\\\\"url\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"https://github.com/caolan/async.git\\\\\\\\\\\\\\\"\\\\\\\\n+  },\\\\\\\\n+  \\\\\\\\\\\\\\\"bugs\\\\\\\\\\\\\\\": {\\\\\\\\n+    \\\\\\\\\\\\\\\"url\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"https://github.com/caolan/async/issues\\\\\\\\\\\\\\\"\\\\\\\\n+  },\\\\\\\\n+  \\\\\\\\\\\\\\\"licenses\\\\\\\\\\\\\\\": [\\\\\\\\n+    {\\\\\\\\n+      \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"MIT\\\\\\\\\\\\\\\",\\\\\\\\n+      \\\\\\\\\\\\\\\"url\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"https://github.com/caolan/async/raw/master/LICENSE\\\\\\\\\\\\\\\"\\\\\\\\n+    }\\\\\\\\n+  ],\\\\\\\\n+  \\\\\\\\\\\\\\\"devDependencies\\\\\\\\\\\\\\\": {\\\\\\\\n+    \\\\\\\\\\\\\\\"nodeunit\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\">0.0.0\\\\\\\\\\\\\\\",\\\\\\\\n+    \\\\\\\\\\\\\\\"uglify-js\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"1.2.x\\\\\\\\\\\\\\\",\\\\\\\\n+    \\\\\\\\\\\\\\\"nodelint\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\">0.0.0\\\\\\\\\\\\\\\"\\\\\\\\n+  },\\\\\\\\n+  \\\\\\\\\\\\\\\"jam\\\\\\\\\\\\\\\": {\\\\\\\\n+    \\\\\\\\\\\\\\\"main\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"lib/async.js\\\\\\\\\\\\\\\",\\\\\\\\n+    \\\\\\\\\\\\\\\"include\\\\\\\\\\\\\\\": [\\\\\\\\n+      \\\\\\\\\\\\\\\"lib/async.js\\\\\\\\\\\\\\\",\\\\\\\\n+      \\\\\\\\\\\\\\\"README.md\\\\\\\\\\\\\\\",\\\\\\\\n+      \\\\\\\\\\\\\\\"LICENSE\\\\\\\\\\\\\\\"\\\\\\\\n+    ]\\\\\\\\n+  },\\\\\\\\n+  \\\\\\\\\\\\\\\"scripts\\\\\\\\\\\\\\\": {\\\\\\\\n+    \\\\\\\\\\\\\\\"test\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"nodeunit test/test-async.js\\\\\\\\\\\\\\\"\\\\\\\\n+  },\\\\\\\\n+  \\\\\\\\\\\\\\\"homepage\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"https://github.com/caolan/async\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"_id\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"async@0.9.0\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"dist\\\\\\\\\\\\\\\": {\\\\\\\\n+    \\\\\\\\\\\\\\\"shasum\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\\\\\\\\\\\\\",\\\\\\\\n+    \\\\\\\\\\\\\\\"tarball\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"http://registry.npmjs.org/async/-/async-0.9.0.tgz\\\\\\\\\\\\\\\"\\\\\\\\n+  },\\\\\\\\n+  \\\\\\\\\\\\\\\"_from\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"async@*\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"_npmVersion\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"1.4.3\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"_npmUser\\\\\\\\\\\\\\\": {\\\\\\\\n+    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"caolan\\\\\\\\\\\\\\\",\\\\\\\\n+    \\\\\\\\\\\\\\\"email\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"caolan.mcmahon@gmail.com\\\\\\\\\\\\\\\"\\\\\\\\n+  },\\\\\\\\n+  \\\\\\\\\\\\\\\"maintainers\\\\\\\\\\\\\\\": [\\\\\\\\n+    {\\\\\\\\n+      \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"caolan\\\\\\\\\\\\\\\",\\\\\\\\n+      \\\\\\\\\\\\\\\"email\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"caolan@caolanmcmahon.com\\\\\\\\\\\\\\\"\\\\\\\\n+    }\\\\\\\\n+  ],\\\\\\\\n+  \\\\\\\\\\\\\\\"directories\\\\\\\\\\\\\\\": {},\\\\\\\\n+  \\\\\\\\\\\\\\\"_shasum\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"_resolved\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"https://registry.npmjs.org/async/-/async-0.9.0.tgz\\\\\\\\\\\\\\\"\\\\\\\\n+}\\\\\\\\ndiff --git a/package.json b/package.json\\\\\\\\nindex 5f21627..6033d43 100644\\\\\\\\n--- a/package.json\\\\\\\\n+++ b/package.json\\\\\\\\n@@ -4,7 +4,8 @@\\\\\\\\n   \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Sous project\\\\\\\\\\\\\\\",\\\\\\\\n   \\\\\\\\\\\\\\\"main\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"main.js\\\\\\\\\\\\\\\",\\\\\\\\n   \\\\\\\\\\\\\\\"dependencies\\\\\\\\\\\\\\\": {\\\\\\\\n-},\\\\\\\\n+    \\\\\\\\\\\\\\\"async\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"*\\\\\\\\\\\\\\\"\\\\\\\\n+  },\\\\\\\\n   \\\\\\\\\\\\\\\"devDependencies\\\\\\\\\\\\\\\": {},\\\\\\\\n   \\\\\\\\\\\\\\\"scripts\\\\\\\\\\\\\\\": {\\\\\\\\n     \\\\\\\\\\\\\\\"test\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"echo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Error: no test specified\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" && exit 1\\\\\\\\\\\\\\\"\\\\\\\\ndiff --git a/patches.sousp b/patches.sousp\\\\\\\\nindex 16405a3..d71e511 100644\\\\\\\\n--- a/patches.sousp\\\\\\\\n+++ b/patches.sousp\\\\\\\\n@@ -1,31 +1 @@\\\\\\\\n-diff --git a/main.js b/main.js\\\\\\\\n-index f81b54e..744cdd5 100644\\\\\\\\n---- a/main.js\\\\\\\\n-+++ b/main.js\\\\\\\\n-@@ -35,7 +35,7 @@ fs.exists('.git', function (exists) {\\\\\\\\n-         cp.exec('git diff', function(error, stdout, stderr) {\\\\\\\\n-             console.log(stdout);\\\\\\\\n- \\\\\\\\n--            //fs.writeFileSync(\\\\\\\\\\\\\\\"patches.sousp\\\\\\\\\\\\\\\", stdout);\\\\\\\\n-+            fs.writeFileSync(\\\\\\\\\\\\\\\"patches.sousp\\\\\\\\\\\\\\\", stdout);\\\\\\\\n- \\\\\\\\n-             if (error !== null) {\\\\\\\\n-                 console.log('stderr: ' + stderr);\\\\\\\\n-@@ -44,7 +44,7 @@ fs.exists('.git', function (exists) {\\\\\\\\n-         });\\\\\\\\n- \\\\\\\\n-         cp.exec('git log', function(error, stdout, stderr) {\\\\\\\\n--            //console.log(stdout);\\\\\\\\n-+            console.log(stdout);\\\\\\\\n- \\\\\\\\n-             var authors = findData(stdout, \\\\\\\\\\\\\\\"Author:\\\\\\\\\\\\\\\");\\\\\\\\n-             var dates = findData(stdout, \\\\\\\\\\\\\\\"Date:\\\\\\\\\\\\\\\");\\\\\\\\n-@@ -53,7 +53,7 @@ fs.exists('.git', function (exists) {\\\\\\\\n-             console.log(comments);\\\\\\\\n-             console.log(dates);\\\\\\\\n- \\\\\\\\n--            //fs.writeFileSync(\\\\\\\\\\\\\\\"comments.sousc\\\\\\\\\\\\\\\", stdout);\\\\\\\\n-+            fs.writeFileSync(\\\\\\\\\\\\\\\"comments.sousc\\\\\\\\\\\\\\\", stdout);\\\\\\\\n- \\\\\\\\n-             if (error !== null) {\\\\\\\\n-                 console.log('stderr: ' + stderr);\\\\\\\\n+[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]\\\\\\\\n\\\\\\\\\\\\\\\\ No newline at end of file\\\\\\\\ndiff --git a/test.js b/test.js\\\\\\\\nnew file mode 100644\\\\\\\\nindex 0000000..5ca759c\\\\\\\\n--- /dev/null\\\\\\\\n+++ b/test.js\\\\\\\\n@@ -0,0 +1,21 @@\\\\\\\\n+/**\\\\\\\\n+ * Created by Nick on 18.05.2015.\\\\\\\\n+ */\\\\\\\\n+var async = require('async')\\\\\\\\n+    , tasksIndex = [\\\\\\\\n+        function (callback) {\\\\\\\\n+            // Вымышленный метод который вернет 231\\\\\\\\n+            var viewsNumber = models.stat.viewsNumber();\\\\\\\\n+            callback(null, viewsNumber);\\\\\\\\n+        }\\\\\\\\n+        , function (callback) {\\\\\\\\n+            // Вымышленный метод который вернет 24\\\\\\\\n+            var growFactor = models.stat.growFactor();\\\\\\\\n+            callback(null, growFactor);\\\\\\\\n+        }\\\\\\\\n+    ];\\\\\\\\n+\\\\\\\\n+async.series(tasksIndex, function (err, results) {\\\\\\\\n+    // Результат будет массивом\\\\\\\\n+    console.log(results); // [231, 24]\\\\\\\\n+});\\\\\\\\n\\\\\\\\\\\\\\\\ No newline at end of file\\\\\\\\n\\\\\\\"}\\\\n\\\\\\\\ No newline at end of file\\\\ndiff --git a/patches.txt b/patches.txt\\\\nnew file mode 100644\\\\nindex 0000000..300c6a9\\\\n--- /dev/null\\\\n+++ b/patches.txt\\\\n@@ -0,0 +1 @@\\\\n+{\\\\\\\"commit\\\\\\\":\\\\\\\"1e947f613e976945de85ae35ed923aa470f0be72\\\\\\\",\\\\\\\"author\\\\\\\":\\\\\\\"Nick Stepanenko <massaalonso@yandex.ru>\\\\\\\",\\\\\\\"date\\\\\\\":\\\\\\\"Tue May 19 00:12:12 2015 +0800\\\\\\\",\\\\\\\"comment\\\\\\\":\\\\\\\"Latest updates\\\\\\\",\\\\\\\"content\\\\\\\":\\\\\\\"diff --git a/comments.sousc b/comments.sousc\\\\\\\\nindex 150b0f6..cb3a850 100644\\\\\\\\n--- a/comments.sousc\\\\\\\\n+++ b/comments.sousc\\\\\\\\n@@ -1,3 +1,27 @@\\\\\\\\n+commit 4420cabefc1f470af341af11ed595df67e25c51f\\\\\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\\\\\n+Date:   Sun May 17 17:05:35 2015 +0800\\\\\\\\n+\\\\\\\\n+    Paste old program code\\\\\\\\n+\\\\\\\\n+commit 9ef3d25fd4c3afdbcc3107a0abf6d7a2e29cb4dd\\\\\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\\\\\n+Date:   Sun May 17 17:04:52 2015 +0800\\\\\\\\n+\\\\\\\\n+    Adding new file\\\\\\\\n+\\\\\\\\n+commit 64814d140d2fab6ae153cac485008119f29bf230\\\\\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\\\\\n+Date:   Sun May 17 17:03:58 2015 +0800\\\\\\\\n+\\\\\\\\n+    From clear list\\\\\\\\n+\\\\\\\\n+commit c9d318fea74ea288d544ecf72f00b12c130cf2ef\\\\\\\\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\\\\\n+Date:   Sun May 17 16:59:40 2015 +0800\\\\\\\\n+\\\\\\\\n+    Create system files\\\\\\\\n+\\\\\\\\n commit e3c853a4282dfe8f000685dc1d39bd55a4a946c4\\\\\\\\n Author: Nick Stepanenko <massaalonso@yandex.ru>\\\\\\\\n Date:   Sun May 17 16:54:58 2015 +0800\\\\\\\\ndiff --git a/main.js b/main.js\\\\\\\\nindex e34dc18..86f30c2 100644\\\\\\\\n--- a/main.js\\\\\\\\n+++ b/main.js\\\\\\\\n@@ -3,6 +3,56 @@\\\\\\\\n  */\\\\\\\\n \\\\\\\\n var fs = require('fs');\\\\\\\\n+var cp = require('child_process');\\\\\\\\n+var data = [];\\\\\\\\n+\\\\\\\\n+var async = require('async');\\\\\\\\n+    /*tasks = [\\\\\\\\n+        function (callback) {\\\\\\\\n+            cp.exec('git log', function(error, stdout, stderr) {\\\\\\\\n+                var listOfCommits = [];\\\\\\\\n+                var authors = findData(stdout, \\\\\\\\\\\\\\\"Author:\\\\\\\\\\\\\\\");\\\\\\\\n+                var dates = findData(stdout, \\\\\\\\\\\\\\\"Date:\\\\\\\\\\\\\\\");\\\\\\\\n+                var comments = findComments(stdout);\\\\\\\\n+                var commitNumbers = findCommitNumbers(stdout);\\\\\\\\n+\\\\\\\\n+                for(i=0; i<authors.length; i++) {\\\\\\\\n+                    var commit = {\\\\\\\\n+                        \\\\\\\\\\\\\\\"commit\\\\\\\\\\\\\\\": commitNumbers[i],\\\\\\\\n+                        \\\\\\\\\\\\\\\"author\\\\\\\\\\\\\\\": authors[i],\\\\\\\\n+                        \\\\\\\\\\\\\\\"date\\\\\\\\\\\\\\\": dates[i],\\\\\\\\n+                        \\\\\\\\\\\\\\\"comment\\\\\\\\\\\\\\\": comments[i],\\\\\\\\n+                        \\\\\\\\\\\\\\\"content\\\\\\\\\\\\\\\": 'Original'\\\\\\\\n+                    };\\\\\\\\n+\\\\\\\\n+                    listOfCommits[listOfCommits.length] = commit;\\\\\\\\n+                }\\\\\\\\n+\\\\\\\\n+                data = listOfCommits.reverse();\\\\\\\\n+\\\\\\\\n+                callback(null, data);\\\\\\\\n+\\\\\\\\n+                if (error !== null) {\\\\\\\\n+                    console.log('stderr: ' + stderr);\\\\\\\\n+                    console.log('exec error: ' + error);\\\\\\\\n+                }\\\\\\\\n+            });\\\\\\\\n+        }\\\\\\\\n+    ],\\\\\\\\n+    secondTasks = [\\\\\\\\n+        function some_function(callback) {\\\\\\\\n+            cp.exec('git diff', function(error, stdout, stderr) {\\\\\\\\n+                var currentContent = stdout;\\\\\\\\n+\\\\\\\\n+                if (error !== null) {\\\\\\\\n+                    console.log('stderr: ' + stderr);\\\\\\\\n+                    console.log('exec error: ' + error);\\\\\\\\n+                }\\\\\\\\n+\\\\\\\\n+                callback(null, currentContent);\\\\\\\\n+            });\\\\\\\\n+        }\\\\\\\\n+    ];*/\\\\\\\\n \\\\\\\\n function findData(text, keyword) {\\\\\\\\n     var data = [];\\\\\\\\n@@ -28,38 +78,106 @@ function findComments(text) {\\\\\\\\n     return comments;\\\\\\\\n }\\\\\\\\n \\\\\\\\n+function findCommitNumbers(text) {\\\\\\\\n+    var commits = [];\\\\\\\\n+    var splittext = text.split('\\\\\\\\\\\\\\\\n');\\\\\\\\n+\\\\\\\\n+    for(i=0; i<splittext.length; i++) {\\\\\\\\n+        if(splittext[i].slice(0, 6) == \\\\\\\\\\\\\\\"commit\\\\\\\\\\\\\\\") {\\\\\\\\n+            commits[commits.length] = splittext[i].slice(6).trim();\\\\\\\\n+        }\\\\\\\\n+    }\\\\\\\\n+\\\\\\\\n+    return commits;\\\\\\\\n+}\\\\\\\\n+\\\\\\\\n+/*function pullCommitContent(first, second) {\\\\\\\\n+\\\\\\\\n+    cp.exec('git diff' + ' ' + first + ' ' + second, function(error, stdout, stderr) {\\\\\\\\n+        var currentContent = stdout;\\\\\\\\n+\\\\\\\\n+        if (error !== null) {\\\\\\\\n+            console.log('stderr: ' + stderr);\\\\\\\\n+            console.log('exec error: ' + error);\\\\\\\\n+        }\\\\\\\\n+\\\\\\\\n+        return currentContent;\\\\\\\\n+    });\\\\\\\\n+}*/\\\\\\\\n+\\\\\\\\n+var commitsInfo = [];\\\\\\\\n+\\\\\\\\n fs.exists('.git', function (exists) {\\\\\\\\n     if(exists) {\\\\\\\\n-        var cp = require('child_process');\\\\\\\\n+        /*async.series(tasks, function(err, result) {\\\\\\\\n+            fs.writeFileSync(\\\\\\\\\\\\\\\"patches.sousp\\\\\\\\\\\\\\\", JSON.stringify(result));\\\\\\\\n+\\\\\\\\n+            var data = result[0];\\\\\\\\n \\\\\\\\n-        cp.exec('git diff', function(error, stdout, stderr) {\\\\\\\\n-            console.log(stdout);\\\\\\\\n+            /*function some_function(arg1, arg2, callback) {\\\\\\\\n+                cp.exec('git diff' + ' ' + arg1 + ' ' + arg2, function(error, stdout, stderr) {\\\\\\\\n+                    var currentContent = 54321;//stdout;\\\\\\\\n \\\\\\\\n-            fs.writeFileSync(\\\\\\\\\\\\\\\"patches.sousp\\\\\\\\\\\\\\\", stdout);\\\\\\\\n+                    if (error !== null) {\\\\\\\\n+                        console.log('stderr: ' + stderr);\\\\\\\\n+                        console.log('exec error: ' + error);\\\\\\\\n+                    }\\\\\\\\n \\\\\\\\n-            if (error !== null) {\\\\\\\\n-                console.log('stderr: ' + stderr);\\\\\\\\n-                console.log('exec error: ' + error);\\\\\\\\n+                    callback(null, currentContent);\\\\\\\\n+                });\\\\\\\\n             }\\\\\\\\n-        });\\\\\\\\n+        });*/\\\\\\\\n+\\\\\\\\n+        async.waterfall([\\\\\\\\n+            function getCommitsInfo(callback) {\\\\\\\\n+                cp.exec('git log', function(error, stdout, stderr) {\\\\\\\\n+                    var listOfCommits = [];\\\\\\\\n+                    var authors = findData(stdout, \\\\\\\\\\\\\\\"Author:\\\\\\\\\\\\\\\");\\\\\\\\n+                    var dates = findData(stdout, \\\\\\\\\\\\\\\"Date:\\\\\\\\\\\\\\\");\\\\\\\\n+                    var comments = findComments(stdout);\\\\\\\\n+                    var commitNumbers = findCommitNumbers(stdout);\\\\\\\\n \\\\\\\\n-        cp.exec('git log', function(error, stdout, stderr) {\\\\\\\\n-            console.log(stdout);\\\\\\\\n+                    for(i=0; i<authors.length; i++) {\\\\\\\\n+                        var commit = {\\\\\\\\n+                            \\\\\\\\\\\\\\\"commit\\\\\\\\\\\\\\\": commitNumbers[i],\\\\\\\\n+                            \\\\\\\\\\\\\\\"author\\\\\\\\\\\\\\\": authors[i],\\\\\\\\n+                            \\\\\\\\\\\\\\\"date\\\\\\\\\\\\\\\": dates[i],\\\\\\\\n+                            \\\\\\\\\\\\\\\"comment\\\\\\\\\\\\\\\": comments[i],\\\\\\\\n+                            \\\\\\\\\\\\\\\"content\\\\\\\\\\\\\\\": 'Original'\\\\\\\\n+                        };\\\\\\\\n+                        listOfCommits[listOfCommits.length] = commit;\\\\\\\\n+                    }\\\\\\\\n \\\\\\\\n-            var authors = findData(stdout, \\\\\\\\\\\\\\\"Author:\\\\\\\\\\\\\\\");\\\\\\\\n-            var dates = findData(stdout, \\\\\\\\\\\\\\\"Date:\\\\\\\\\\\\\\\");\\\\\\\\n-            var comments = findComments(stdout);\\\\\\\\n-            console.log(authors);\\\\\\\\n-            console.log(comments);\\\\\\\\n-            console.log(dates);\\\\\\\\n+                    callback(null, listOfCommits.reverse());\\\\\\\\n \\\\\\\\n-            fs.writeFileSync(\\\\\\\\\\\\\\\"comments.sousc\\\\\\\\\\\\\\\", stdout);\\\\\\\\n+                    if (error !== null) {\\\\\\\\n+                        console.log('stderr: ' + stderr);\\\\\\\\n+                        console.log('exec error: ' + error);\\\\\\\\n+                    }\\\\\\\\n+                });\\\\\\\\n+            },\\\\\\\\n+            function getCommitsContent(commits, callback) {\\\\\\\\n+                console.log(commits);\\\\\\\\n+                var commitsData = commits;\\\\\\\\n \\\\\\\\n-            if (error !== null) {\\\\\\\\n-                console.log('stderr: ' + stderr);\\\\\\\\n-                console.log('exec error: ' + error);\\\\\\\\n+                for(i=1; i<commitsData.length; i++) {\\\\\\\\n+                    cp.exec('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit, function(error, stdout, stderr) {\\\\\\\\n+                        commitsData[i].content = stdout;\\\\\\\\n+\\\\\\\\n+                        if (error !== null) {\\\\\\\\n+                            console.log('stderr: ' + stderr);\\\\\\\\n+                            console.log('exec error: ' + error);\\\\\\\\n+                        }\\\\\\\\n+                    });\\\\\\\\n+                }\\\\\\\\n+\\\\\\\\n+                callback(null, commitsData);\\\\\\\\n             }\\\\\\\\n+        ], function (err, result) {\\\\\\\\n+            fs.writeFileSync(\\\\\\\\\\\\\\\"patches.sousp\\\\\\\\\\\\\\\", result);\\\\\\\\n         });\\\\\\\\n+\\\\\\\\n+        //commitsInfo = JSON.parse(fs.readFileSync(\\\\\\\\\\\\\\\"patches.sousp\\\\\\\\\\\\\\\"));\\\\\\\\n+        //console.log(commitsInfo);\\\\\\\\n     }\\\\\\\\n-    else console.log(\\\\\\\\\\\\\\\"Error.\\\\\\\\\\\\\\\");\\\\\\\\n });\\\\\\\\n\\\\\\\\\\\\\\\\ No newline at end of file\\\\\\\\ndiff --git a/node_modules/async/.travis.yml b/node_modules/async/.travis.yml\\\\\\\\nnew file mode 100644\\\\\\\\nindex 0000000..6e5919d\\\\\\\\n--- /dev/null\\\\\\\\n+++ b/node_modules/async/.travis.yml\\\\\\\\n@@ -0,0 +1,3 @@\\\\\\\\n+language: node_js\\\\\\\\n+node_js:\\\\\\\\n+  - \\\\\\\\\\\\\\\"0.10\\\\\\\\\\\\\\\"\\\\\\\\ndiff --git a/node_modules/async/LICENSE b/node_modules/async/LICENSE\\\\\\\\nnew file mode 100644\\\\\\\\nindex 0000000..8f29698\\\\\\\\n--- /dev/null\\\\\\\\n+++ b/node_modules/async/LICENSE\\\\\\\\n@@ -0,0 +1,19 @@\\\\\\\\n+Copyright (c) 2010-2014 Caolan McMahon\\\\\\\\n+\\\\\\\\n+Permission is hereby granted, free of charge, to any person obtaining a copy\\\\\\\\n+of this software and associated documentation files (the \\\\\\\\\\\\\\\"Software\\\\\\\\\\\\\\\"), to deal\\\\\\\\n+in the Software without restriction, including without limitation the rights\\\\\\\\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\\\\\\\n+copies of the Software, and to permit persons to whom the Software is\\\\\\\\n+furnished to do so, subject to the following conditions:\\\\\\\\n+\\\\\\\\n+The above copyright notice and this permission notice shall be included in\\\\\\\\n+all copies or substantial portions of the Software.\\\\\\\\n+\\\\\\\\n+THE SOFTWARE IS PROVIDED \\\\\\\\\\\\\\\"AS IS\\\\\\\\\\\\\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\\\\\\\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\\\\\\\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\\\\\\\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\\\\\\\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\\\\\\\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\\\\\\\n+THE SOFTWARE.\\\\\\\\ndiff --git a/node_modules/async/README.md b/node_modules/async/README.md\\\\\\\\nnew file mode 100644\\\\\\\\nindex 0000000..0bea531\\\\\\\\n--- /dev/null\\\\\\\\n+++ b/node_modules/async/README.md\\\\\\\\n@@ -0,0 +1,1646 @@\\\\\\\\n+# Async.js\\\\\\\\n+\\\\\\\\n+[![Build Status via Travis CI](https://travis-ci.org/caolan/async.svg?branch=master)](https://travis-ci.org/caolan/async)\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+Async is a utility module which provides straight-forward, powerful functions\\\\\\\\n+for working with asynchronous JavaScript. Although originally designed for\\\\\\\\n+use with [Node.js](http://nodejs.org), it can also be used directly in the\\\\\\\\n+browser. Also supports [component](https://github.com/component/component).\\\\\\\\n+\\\\\\\\n+Async provides around 20 functions that include the usual 'functional'\\\\\\\\n+suspects (`map`, `reduce`, `filter`, `each`…) as well as some common patterns\\\\\\\\n+for asynchronous control flow (`parallel`, `series`, `waterfall`…). All these\\\\\\\\n+functions assume you follow the Node.js convention of providing a single\\\\\\\\n+callback as the last argument of your `async` function.\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+## Quick Examples\\\\\\\\n+\\\\\\\\n+```javascript\\\\\\\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\\\\\\\n+    // results is now an array of stats for each file\\\\\\\\n+});\\\\\\\\n+\\\\\\\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\\\\\\\n+    // results now equals an array of the existing files\\\\\\\\n+});\\\\\\\\n+\\\\\\\\n+async.parallel([\\\\\\\\n+    function(){ ... },\\\\\\\\n+    function(){ ... }\\\\\\\\n+], callback);\\\\\\\\n+\\\\\\\\n+async.series([\\\\\\\\n+    function(){ ... },\\\\\\\\n+    function(){ ... }\\\\\\\\n+]);\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+There are many more functions available so take a look at the docs below for a\\\\\\\\n+full list. This module aims to be comprehensive, so if you feel anything is\\\\\\\\n+missing please create a GitHub issue for it.\\\\\\\\n+\\\\\\\\n+## Common Pitfalls\\\\\\\\n+\\\\\\\\n+### Binding a context to an iterator\\\\\\\\n+\\\\\\\\n+This section is really about `bind`, not about `async`. If you are wondering how to\\\\\\\\n+make `async` execute your iterators in a given context, or are confused as to why\\\\\\\\n+a method of another library isn't working as an iterator, study this example:\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+// Here is a simple object with an (unnecessarily roundabout) squaring method\\\\\\\\n+var AsyncSquaringLibrary = {\\\\\\\\n+  squareExponent: 2,\\\\\\\\n+  square: function(number, callback){ \\\\\\\\n+    var result = Math.pow(number, this.squareExponent);\\\\\\\\n+    setTimeout(function(){\\\\\\\\n+      callback(null, result);\\\\\\\\n+    }, 200);\\\\\\\\n+  }\\\\\\\\n+};\\\\\\\\n+\\\\\\\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square, function(err, result){\\\\\\\\n+  // result is [NaN, NaN, NaN]\\\\\\\\n+  // This fails because the `this.squareExponent` expression in the square\\\\\\\\n+  // function is not evaluated in the context of AsyncSquaringLibrary, and is\\\\\\\\n+  // therefore undefined.\\\\\\\\n+});\\\\\\\\n+\\\\\\\\n+async.map([1, 2, 3], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), function(err, result){\\\\\\\\n+  // result is [1, 4, 9]\\\\\\\\n+  // With the help of bind we can attach a context to the iterator before\\\\\\\\n+  // passing it to async. Now the square function will be executed in its \\\\\\\\n+  // 'home' AsyncSquaringLibrary context and the value of `this.squareExponent`\\\\\\\\n+  // will be as expected.\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+## Download\\\\\\\\n+\\\\\\\\n+The source is available for download from\\\\\\\\n+[GitHub](http://github.com/caolan/async).\\\\\\\\n+Alternatively, you can install using Node Package Manager (`npm`):\\\\\\\\n+\\\\\\\\n+    npm install async\\\\\\\\n+\\\\\\\\n+__Development:__ [async.js](https://github.com/caolan/async/raw/master/lib/async.js) - 29.6kb Uncompressed\\\\\\\\n+\\\\\\\\n+## In the Browser\\\\\\\\n+\\\\\\\\n+So far it's been tested in IE6, IE7, IE8, FF3.6 and Chrome 5. \\\\\\\\n+\\\\\\\\n+Usage:\\\\\\\\n+\\\\\\\\n+```html\\\\\\\\n+<script type=\\\\\\\\\\\\\\\"text/javascript\\\\\\\\\\\\\\\" src=\\\\\\\\\\\\\\\"async.js\\\\\\\\\\\\\\\"></script>\\\\\\\\n+<script type=\\\\\\\\\\\\\\\"text/javascript\\\\\\\\\\\\\\\">\\\\\\\\n+\\\\\\\\n+    async.map(data, asyncProcess, function(err, results){\\\\\\\\n+        alert(results);\\\\\\\\n+    });\\\\\\\\n+\\\\\\\\n+</script>\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+## Documentation\\\\\\\\n+\\\\\\\\n+### Collections\\\\\\\\n+\\\\\\\\n+* [`each`](#each)\\\\\\\\n+* [`eachSeries`](#eachSeries)\\\\\\\\n+* [`eachLimit`](#eachLimit)\\\\\\\\n+* [`map`](#map)\\\\\\\\n+* [`mapSeries`](#mapSeries)\\\\\\\\n+* [`mapLimit`](#mapLimit)\\\\\\\\n+* [`filter`](#filter)\\\\\\\\n+* [`filterSeries`](#filterSeries)\\\\\\\\n+* [`reject`](#reject)\\\\\\\\n+* [`rejectSeries`](#rejectSeries)\\\\\\\\n+* [`reduce`](#reduce)\\\\\\\\n+* [`reduceRight`](#reduceRight)\\\\\\\\n+* [`detect`](#detect)\\\\\\\\n+* [`detectSeries`](#detectSeries)\\\\\\\\n+* [`sortBy`](#sortBy)\\\\\\\\n+* [`some`](#some)\\\\\\\\n+* [`every`](#every)\\\\\\\\n+* [`concat`](#concat)\\\\\\\\n+* [`concatSeries`](#concatSeries)\\\\\\\\n+\\\\\\\\n+### Control Flow\\\\\\\\n+\\\\\\\\n+* [`series`](#seriestasks-callback)\\\\\\\\n+* [`parallel`](#parallel)\\\\\\\\n+* [`parallelLimit`](#parallellimittasks-limit-callback)\\\\\\\\n+* [`whilst`](#whilst)\\\\\\\\n+* [`doWhilst`](#doWhilst)\\\\\\\\n+* [`until`](#until)\\\\\\\\n+* [`doUntil`](#doUntil)\\\\\\\\n+* [`forever`](#forever)\\\\\\\\n+* [`waterfall`](#waterfall)\\\\\\\\n+* [`compose`](#compose)\\\\\\\\n+* [`seq`](#seq)\\\\\\\\n+* [`applyEach`](#applyEach)\\\\\\\\n+* [`applyEachSeries`](#applyEachSeries)\\\\\\\\n+* [`queue`](#queue)\\\\\\\\n+* [`priorityQueue`](#priorityQueue)\\\\\\\\n+* [`cargo`](#cargo)\\\\\\\\n+* [`auto`](#auto)\\\\\\\\n+* [`retry`](#retry)\\\\\\\\n+* [`iterator`](#iterator)\\\\\\\\n+* [`apply`](#apply)\\\\\\\\n+* [`nextTick`](#nextTick)\\\\\\\\n+* [`times`](#times)\\\\\\\\n+* [`timesSeries`](#timesSeries)\\\\\\\\n+\\\\\\\\n+### Utils\\\\\\\\n+\\\\\\\\n+* [`memoize`](#memoize)\\\\\\\\n+* [`unmemoize`](#unmemoize)\\\\\\\\n+* [`log`](#log)\\\\\\\\n+* [`dir`](#dir)\\\\\\\\n+* [`noConflict`](#noConflict)\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+## Collections\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"forEach\\\\\\\\\\\\\\\" />\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"each\\\\\\\\\\\\\\\" />\\\\\\\\n+### each(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+Applies the function `iterator` to each item in `arr`, in parallel.\\\\\\\\n+The `iterator` is called with an item from the list, and a callback for when it\\\\\\\\n+has finished. If the `iterator` passes an error to its `callback`, the main\\\\\\\\n+`callback` (for the `each` function) is immediately called with the error.\\\\\\\\n+\\\\\\\\n+Note, that since this function applies `iterator` to each item in parallel,\\\\\\\\n+there is no guarantee that the iterator functions will complete in order.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `arr` - An array to iterate over.\\\\\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\\\\\n+  The iterator is passed a `callback(err)` which must be called once it has \\\\\\\\n+  completed. If no error has occured, the `callback` should be run without \\\\\\\\n+  arguments or with an explicit `null` argument.\\\\\\\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\\\\\\\n+  have finished, or an error occurs.\\\\\\\\n+\\\\\\\\n+__Examples__\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+// assuming openFiles is an array of file names and saveFile is a function\\\\\\\\n+// to save the modified contents of that file:\\\\\\\\n+\\\\\\\\n+async.each(openFiles, saveFile, function(err){\\\\\\\\n+    // if any of the saves produced an error, err would equal that error\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+// assuming openFiles is an array of file names \\\\\\\\n+\\\\\\\\n+async.each(openFiles, function( file, callback) {\\\\\\\\n+  \\\\\\\\n+  // Perform operation on file here.\\\\\\\\n+  console.log('Processing file ' + file);\\\\\\\\n+  \\\\\\\\n+  if( file.length > 32 ) {\\\\\\\\n+    console.log('This file name is too long');\\\\\\\\n+    callback('File name too long');\\\\\\\\n+  } else {\\\\\\\\n+    // Do work to process file here\\\\\\\\n+    console.log('File processed');\\\\\\\\n+    callback();\\\\\\\\n+  }\\\\\\\\n+}, function(err){\\\\\\\\n+    // if any of the file processing produced an error, err would equal that error\\\\\\\\n+    if( err ) {\\\\\\\\n+      // One of the iterations produced an error.\\\\\\\\n+      // All processing will now stop.\\\\\\\\n+      console.log('A file failed to process');\\\\\\\\n+    } else {\\\\\\\\n+      console.log('All files have been processed successfully');\\\\\\\\n+    }\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"forEachSeries\\\\\\\\\\\\\\\" />\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"eachSeries\\\\\\\\\\\\\\\" />\\\\\\\\n+### eachSeries(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+The same as [`each`](#each), only `iterator` is applied to each item in `arr` in\\\\\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\\\\\n+This means the `iterator` functions will complete in order.\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"forEachLimit\\\\\\\\\\\\\\\" />\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"eachLimit\\\\\\\\\\\\\\\" />\\\\\\\\n+### eachLimit(arr, limit, iterator, callback)\\\\\\\\n+\\\\\\\\n+The same as [`each`](#each), only no more than `limit` `iterator`s will be simultaneously \\\\\\\\n+running at any time.\\\\\\\\n+\\\\\\\\n+Note that the items in `arr` are not processed in batches, so there is no guarantee that \\\\\\\\n+the first `limit` `iterator` functions will complete before any others are started.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `arr` - An array to iterate over.\\\\\\\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\\\\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\\\\\n+  The iterator is passed a `callback(err)` which must be called once it has \\\\\\\\n+  completed. If no error has occured, the callback should be run without \\\\\\\\n+  arguments or with an explicit `null` argument.\\\\\\\\n+* `callback(err)` - A callback which is called when all `iterator` functions\\\\\\\\n+  have finished, or an error occurs.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+// Assume documents is an array of JSON objects and requestApi is a\\\\\\\\n+// function that interacts with a rate-limited REST api.\\\\\\\\n+\\\\\\\\n+async.eachLimit(documents, 20, requestApi, function(err){\\\\\\\\n+    // if any of the saves produced an error, err would equal that error\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"map\\\\\\\\\\\\\\\" />\\\\\\\\n+### map(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+Produces a new array of values by mapping each value in `arr` through\\\\\\\\n+the `iterator` function. The `iterator` is called with an item from `arr` and a\\\\\\\\n+callback for when it has finished processing. Each of these callback takes 2 arguments: \\\\\\\\n+an `error`, and the transformed item from `arr`. If `iterator` passes an error to this \\\\\\\\n+callback, the main `callback` (for the `map` function) is immediately called with the error.\\\\\\\\n+\\\\\\\\n+Note, that since this function applies the `iterator` to each item in parallel,\\\\\\\\n+there is no guarantee that the `iterator` functions will complete in order. \\\\\\\\n+However, the results array will be in the same order as the original `arr`.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `arr` - An array to iterate over.\\\\\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\\\\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\\\\\\\n+  it has completed with an error (which can be `null`) and a transformed item.\\\\\\\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\\\\\\\n+  functions have finished, or an error occurs. Results is an array of the\\\\\\\\n+  transformed items from the `arr`.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\\\\\\\\n+    // results is now an array of stats for each file\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"mapSeries\\\\\\\\\\\\\\\" />\\\\\\\\n+### mapSeries(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+The same as [`map`](#map), only the `iterator` is applied to each item in `arr` in\\\\\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\\\\\n+The results array will be in the same order as the original.\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"mapLimit\\\\\\\\\\\\\\\" />\\\\\\\\n+### mapLimit(arr, limit, iterator, callback)\\\\\\\\n+\\\\\\\\n+The same as [`map`](#map), only no more than `limit` `iterator`s will be simultaneously \\\\\\\\n+running at any time.\\\\\\\\n+\\\\\\\\n+Note that the items are not processed in batches, so there is no guarantee that \\\\\\\\n+the first `limit` `iterator` functions will complete before any others are started.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `arr` - An array to iterate over.\\\\\\\\n+* `limit` - The maximum number of `iterator`s to run at any time.\\\\\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\\\\\n+  The iterator is passed a `callback(err, transformed)` which must be called once \\\\\\\\n+  it has completed with an error (which can be `null`) and a transformed item.\\\\\\\\n+* `callback(err, results)` - A callback which is called when all `iterator`\\\\\\\\n+  calls have finished, or an error occurs. The result is an array of the\\\\\\\\n+  transformed items from the original `arr`.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.mapLimit(['file1','file2','file3'], 1, fs.stat, function(err, results){\\\\\\\\n+    // results is now an array of stats for each file\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"select\\\\\\\\\\\\\\\" />\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"filter\\\\\\\\\\\\\\\" />\\\\\\\\n+### filter(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+__Alias:__ `select`\\\\\\\\n+\\\\\\\\n+Returns a new array of all the values in `arr` which pass an async truth test.\\\\\\\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\\\\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\\\\\n+way node libraries work with truth tests like `fs.exists`. This operation is\\\\\\\\n+performed in parallel, but the results array will be in the same order as the\\\\\\\\n+original.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `arr` - An array to iterate over.\\\\\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\\\\\\\n+  The `iterator` is passed a `callback(truthValue)`, which must be called with a \\\\\\\\n+  boolean argument once it has completed.\\\\\\\\n+* `callback(results)` - A callback which is called after all the `iterator`\\\\\\\\n+  functions have finished.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\\\\\\\\n+    // results now equals an array of the existing files\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"selectSeries\\\\\\\\\\\\\\\" />\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"filterSeries\\\\\\\\\\\\\\\" />\\\\\\\\n+### filterSeries(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+__Alias:__ `selectSeries`\\\\\\\\n+\\\\\\\\n+The same as [`filter`](#filter) only the `iterator` is applied to each item in `arr` in\\\\\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\\\\\n+The results array will be in the same order as the original.\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"reject\\\\\\\\\\\\\\\" />\\\\\\\\n+### reject(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+The opposite of [`filter`](#filter). Removes values that pass an `async` truth test.\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"rejectSeries\\\\\\\\\\\\\\\" />\\\\\\\\n+### rejectSeries(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+The same as [`reject`](#reject), only the `iterator` is applied to each item in `arr`\\\\\\\\n+in series.\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"reduce\\\\\\\\\\\\\\\" />\\\\\\\\n+### reduce(arr, memo, iterator, callback)\\\\\\\\n+\\\\\\\\n+__Aliases:__ `inject`, `foldl`\\\\\\\\n+\\\\\\\\n+Reduces `arr` into a single value using an async `iterator` to return\\\\\\\\n+each successive step. `memo` is the initial state of the reduction. \\\\\\\\n+This function only operates in series. \\\\\\\\n+\\\\\\\\n+For performance reasons, it may make sense to split a call to this function into \\\\\\\\n+a parallel map, and then use the normal `Array.prototype.reduce` on the results. \\\\\\\\n+This function is for situations where each step in the reduction needs to be async; \\\\\\\\n+if you can get the data before reducing it, then it's probably a good idea to do so.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `arr` - An array to iterate over.\\\\\\\\n+* `memo` - The initial state of the reduction.\\\\\\\\n+* `iterator(memo, item, callback)` - A function applied to each item in the\\\\\\\\n+  array to produce the next step in the reduction. The `iterator` is passed a\\\\\\\\n+  `callback(err, reduction)` which accepts an optional error as its first \\\\\\\\n+  argument, and the state of the reduction as the second. If an error is \\\\\\\\n+  passed to the callback, the reduction is stopped and the main `callback` is \\\\\\\\n+  immediately called with the error.\\\\\\\\n+* `callback(err, result)` - A callback which is called after all the `iterator`\\\\\\\\n+  functions have finished. Result is the reduced value.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.reduce([1,2,3], 0, function(memo, item, callback){\\\\\\\\n+    // pointless async:\\\\\\\\n+    process.nextTick(function(){\\\\\\\\n+        callback(null, memo + item)\\\\\\\\n+    });\\\\\\\\n+}, function(err, result){\\\\\\\\n+    // result is now equal to the last value of memo, which is 6\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"reduceRight\\\\\\\\\\\\\\\" />\\\\\\\\n+### reduceRight(arr, memo, iterator, callback)\\\\\\\\n+\\\\\\\\n+__Alias:__ `foldr`\\\\\\\\n+\\\\\\\\n+Same as [`reduce`](#reduce), only operates on `arr` in reverse order.\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"detect\\\\\\\\\\\\\\\" />\\\\\\\\n+### detect(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+Returns the first value in `arr` that passes an async truth test. The\\\\\\\\n+`iterator` is applied in parallel, meaning the first iterator to return `true` will\\\\\\\\n+fire the detect `callback` with that result. That means the result might not be\\\\\\\\n+the first item in the original `arr` (in terms of order) that passes the test.\\\\\\\\n+\\\\\\\\n+If order within the original `arr` is important, then look at [`detectSeries`](#detectSeries).\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `arr` - An array to iterate over.\\\\\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\\\\\\\\n+  The iterator is passed a `callback(truthValue)` which must be called with a \\\\\\\\n+  boolean argument once it has completed.\\\\\\\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\\\\\\\n+  `true`, or after all the `iterator` functions have finished. Result will be\\\\\\\\n+  the first item in the array that passes the truth test (iterator) or the\\\\\\\\n+  value `undefined` if none passed.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.detect(['file1','file2','file3'], fs.exists, function(result){\\\\\\\\n+    // result now equals the first file in the list that exists\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"detectSeries\\\\\\\\\\\\\\\" />\\\\\\\\n+### detectSeries(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+The same as [`detect`](#detect), only the `iterator` is applied to each item in `arr`\\\\\\\\n+in series. This means the result is always the first in the original `arr` (in\\\\\\\\n+terms of array order) that passes the truth test.\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"sortBy\\\\\\\\\\\\\\\" />\\\\\\\\n+### sortBy(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+Sorts a list by the results of running each `arr` value through an async `iterator`.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `arr` - An array to iterate over.\\\\\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\\\\\n+  The iterator is passed a `callback(err, sortValue)` which must be called once it\\\\\\\\n+  has completed with an error (which can be `null`) and a value to use as the sort\\\\\\\\n+  criteria.\\\\\\\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\\\\\\\n+  functions have finished, or an error occurs. Results is the items from\\\\\\\\n+  the original `arr` sorted by the values returned by the `iterator` calls.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.sortBy(['file1','file2','file3'], function(file, callback){\\\\\\\\n+    fs.stat(file, function(err, stats){\\\\\\\\n+        callback(err, stats.mtime);\\\\\\\\n+    });\\\\\\\\n+}, function(err, results){\\\\\\\\n+    // results is now the original array of files sorted by\\\\\\\\n+    // modified date\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+__Sort Order__\\\\\\\\n+\\\\\\\\n+By modifying the callback parameter the sorting order can be influenced:\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+//ascending order\\\\\\\\n+async.sortBy([1,9,3,5], function(x, callback){\\\\\\\\n+    callback(err, x);\\\\\\\\n+}, function(err,result){\\\\\\\\n+    //result callback\\\\\\\\n+} );\\\\\\\\n+\\\\\\\\n+//descending order\\\\\\\\n+async.sortBy([1,9,3,5], function(x, callback){\\\\\\\\n+    callback(err, x*-1);    //<- x*-1 instead of x, turns the order around\\\\\\\\n+}, function(err,result){\\\\\\\\n+    //result callback\\\\\\\\n+} );\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"some\\\\\\\\\\\\\\\" />\\\\\\\\n+### some(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+__Alias:__ `any`\\\\\\\\n+\\\\\\\\n+Returns `true` if at least one element in the `arr` satisfies an async test.\\\\\\\\n+_The callback for each iterator call only accepts a single argument of `true` or\\\\\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\\\\\n+way node libraries work with truth tests like `fs.exists`. Once any iterator\\\\\\\\n+call returns `true`, the main `callback` is immediately called.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `arr` - An array to iterate over.\\\\\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\\\\\\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\\\\\\\n+  called with a boolean argument once it has completed.\\\\\\\\n+* `callback(result)` - A callback which is called as soon as any iterator returns\\\\\\\\n+  `true`, or after all the iterator functions have finished. Result will be\\\\\\\\n+  either `true` or `false` depending on the values of the async tests.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.some(['file1','file2','file3'], fs.exists, function(result){\\\\\\\\n+    // if result is true then at least one of the files exists\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"every\\\\\\\\\\\\\\\" />\\\\\\\\n+### every(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+__Alias:__ `all`\\\\\\\\n+\\\\\\\\n+Returns `true` if every element in `arr` satisfies an async test.\\\\\\\\n+_The callback for each `iterator` call only accepts a single argument of `true` or\\\\\\\\n+`false`; it does not accept an error argument first!_ This is in-line with the\\\\\\\\n+way node libraries work with truth tests like `fs.exists`.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `arr` - An array to iterate over.\\\\\\\\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\\\\\\\\n+  in parallel. The iterator is passed a callback(truthValue) which must be \\\\\\\\n+  called with a  boolean argument once it has completed.\\\\\\\\n+* `callback(result)` - A callback which is called after all the `iterator`\\\\\\\\n+  functions have finished. Result will be either `true` or `false` depending on\\\\\\\\n+  the values of the async tests.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.every(['file1','file2','file3'], fs.exists, function(result){\\\\\\\\n+    // if result is true then every file exists\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"concat\\\\\\\\\\\\\\\" />\\\\\\\\n+### concat(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+Applies `iterator` to each item in `arr`, concatenating the results. Returns the\\\\\\\\n+concatenated list. The `iterator`s are called in parallel, and the results are\\\\\\\\n+concatenated as they return. There is no guarantee that the results array will\\\\\\\\n+be returned in the original order of `arr` passed to the `iterator` function.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `arr` - An array to iterate over.\\\\\\\\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\\\\\\\\n+  The iterator is passed a `callback(err, results)` which must be called once it \\\\\\\\n+  has completed with an error (which can be `null`) and an array of results.\\\\\\\\n+* `callback(err, results)` - A callback which is called after all the `iterator`\\\\\\\\n+  functions have finished, or an error occurs. Results is an array containing\\\\\\\\n+  the concatenated results of the `iterator` function.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files){\\\\\\\\n+    // files is now a list of filenames that exist in the 3 directories\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"concatSeries\\\\\\\\\\\\\\\" />\\\\\\\\n+### concatSeries(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+Same as [`concat`](#concat), but executes in series instead of parallel.\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+## Control Flow\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"series\\\\\\\\\\\\\\\" />\\\\\\\\n+### series(tasks, [callback])\\\\\\\\n+\\\\\\\\n+Run the functions in the `tasks` array in series, each one running once the previous\\\\\\\\n+function has completed. If any functions in the series pass an error to its\\\\\\\\n+callback, no more functions are run, and `callback` is immediately called with the value of the error. \\\\\\\\n+Otherwise, `callback` receives an array of results when `tasks` have completed.\\\\\\\\n+\\\\\\\\n+It is also possible to use an object instead of an array. Each property will be\\\\\\\\n+run as a function, and the results will be passed to the final `callback` as an object\\\\\\\\n+instead of an array. This can be a more readable way of handling results from\\\\\\\\n+[`series`](#series).\\\\\\\\n+\\\\\\\\n+**Note** that while many implementations preserve the order of object properties, the\\\\\\\\n+[ECMAScript Language Specifcation](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6) \\\\\\\\n+explicitly states that\\\\\\\\n+\\\\\\\\n+> The mechanics and order of enumerating the properties is not specified.\\\\\\\\n+\\\\\\\\n+So if you rely on the order in which your series of functions are executed, and want\\\\\\\\n+this to work on all platforms, consider using an array. \\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `tasks` - An array or object containing functions to run, each function is passed\\\\\\\\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\\\\\\\n+  be `null`) and an optional `result` value.\\\\\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\\\\\n+  have completed. This function gets a results array (or object) containing all \\\\\\\\n+  the result arguments passed to the `task` callbacks.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.series([\\\\\\\\n+    function(callback){\\\\\\\\n+        // do some stuff ...\\\\\\\\n+        callback(null, 'one');\\\\\\\\n+    },\\\\\\\\n+    function(callback){\\\\\\\\n+        // do some more stuff ...\\\\\\\\n+        callback(null, 'two');\\\\\\\\n+    }\\\\\\\\n+],\\\\\\\\n+// optional callback\\\\\\\\n+function(err, results){\\\\\\\\n+    // results is now equal to ['one', 'two']\\\\\\\\n+});\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+// an example using an object instead of an array\\\\\\\\n+async.series({\\\\\\\\n+    one: function(callback){\\\\\\\\n+        setTimeout(function(){\\\\\\\\n+            callback(null, 1);\\\\\\\\n+        }, 200);\\\\\\\\n+    },\\\\\\\\n+    two: function(callback){\\\\\\\\n+        setTimeout(function(){\\\\\\\\n+            callback(null, 2);\\\\\\\\n+        }, 100);\\\\\\\\n+    }\\\\\\\\n+},\\\\\\\\n+function(err, results) {\\\\\\\\n+    // results is now equal to: {one: 1, two: 2}\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"parallel\\\\\\\\\\\\\\\" />\\\\\\\\n+### parallel(tasks, [callback])\\\\\\\\n+\\\\\\\\n+Run the `tasks` array of functions in parallel, without waiting until the previous\\\\\\\\n+function has completed. If any of the functions pass an error to its\\\\\\\\n+callback, the main `callback` is immediately called with the value of the error.\\\\\\\\n+Once the `tasks` have completed, the results are passed to the final `callback` as an\\\\\\\\n+array.\\\\\\\\n+\\\\\\\\n+It is also possible to use an object instead of an array. Each property will be\\\\\\\\n+run as a function and the results will be passed to the final `callback` as an object\\\\\\\\n+instead of an array. This can be a more readable way of handling results from\\\\\\\\n+[`parallel`](#parallel).\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `tasks` - An array or object containing functions to run. Each function is passed \\\\\\\\n+  a `callback(err, result)` which it must call on completion with an error `err` \\\\\\\\n+  (which can be `null`) and an optional `result` value.\\\\\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\\\\\n+  have completed. This function gets a results array (or object) containing all \\\\\\\\n+  the result arguments passed to the task callbacks.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.parallel([\\\\\\\\n+    function(callback){\\\\\\\\n+        setTimeout(function(){\\\\\\\\n+            callback(null, 'one');\\\\\\\\n+        }, 200);\\\\\\\\n+    },\\\\\\\\n+    function(callback){\\\\\\\\n+        setTimeout(function(){\\\\\\\\n+            callback(null, 'two');\\\\\\\\n+        }, 100);\\\\\\\\n+    }\\\\\\\\n+],\\\\\\\\n+// optional callback\\\\\\\\n+function(err, results){\\\\\\\\n+    // the results array will equal ['one','two'] even though\\\\\\\\n+    // the second function had a shorter timeout.\\\\\\\\n+});\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+// an example using an object instead of an array\\\\\\\\n+async.parallel({\\\\\\\\n+    one: function(callback){\\\\\\\\n+        setTimeout(function(){\\\\\\\\n+            callback(null, 1);\\\\\\\\n+        }, 200);\\\\\\\\n+    },\\\\\\\\n+    two: function(callback){\\\\\\\\n+        setTimeout(function(){\\\\\\\\n+            callback(null, 2);\\\\\\\\n+        }, 100);\\\\\\\\n+    }\\\\\\\\n+},\\\\\\\\n+function(err, results) {\\\\\\\\n+    // results is now equals to: {one: 1, two: 2}\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"parallelLimit\\\\\\\\\\\\\\\" />\\\\\\\\n+### parallelLimit(tasks, limit, [callback])\\\\\\\\n+\\\\\\\\n+The same as [`parallel`](#parallel), only `tasks` are executed in parallel \\\\\\\\n+with a maximum of `limit` tasks executing at any time.\\\\\\\\n+\\\\\\\\n+Note that the `tasks` are not executed in batches, so there is no guarantee that \\\\\\\\n+the first `limit` tasks will complete before any others are started.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `tasks` - An array or object containing functions to run, each function is passed \\\\\\\\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\\\\\\\\n+  be `null`) and an optional `result` value.\\\\\\\\n+* `limit` - The maximum number of `tasks` to run at any time.\\\\\\\\n+* `callback(err, results)` - An optional callback to run once all the functions\\\\\\\\n+  have completed. This function gets a results array (or object) containing all \\\\\\\\n+  the result arguments passed to the `task` callbacks.\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"whilst\\\\\\\\\\\\\\\" />\\\\\\\\n+### whilst(test, fn, callback)\\\\\\\\n+\\\\\\\\n+Repeatedly call `fn`, while `test` returns `true`. Calls `callback` when stopped,\\\\\\\\n+or an error occurs.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `test()` - synchronous truth test to perform before each execution of `fn`.\\\\\\\\n+* `fn(callback)` - A function which is called each time `test` passes. The function is\\\\\\\\n+  passed a `callback(err)`, which must be called once it has completed with an \\\\\\\\n+  optional `err` argument.\\\\\\\\n+* `callback(err)` - A callback which is called after the test fails and repeated\\\\\\\\n+  execution of `fn` has stopped.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+var count = 0;\\\\\\\\n+\\\\\\\\n+async.whilst(\\\\\\\\n+    function () { return count < 5; },\\\\\\\\n+    function (callback) {\\\\\\\\n+        count++;\\\\\\\\n+        setTimeout(callback, 1000);\\\\\\\\n+    },\\\\\\\\n+    function (err) {\\\\\\\\n+        // 5 seconds have passed\\\\\\\\n+    }\\\\\\\\n+);\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"doWhilst\\\\\\\\\\\\\\\" />\\\\\\\\n+### doWhilst(fn, test, callback)\\\\\\\\n+\\\\\\\\n+The post-check version of [`whilst`](#whilst). To reflect the difference in \\\\\\\\n+the order of operations, the arguments `test` and `fn` are switched. \\\\\\\\n+\\\\\\\\n+`doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"until\\\\\\\\\\\\\\\" />\\\\\\\\n+### until(test, fn, callback)\\\\\\\\n+\\\\\\\\n+Repeatedly call `fn` until `test` returns `true`. Calls `callback` when stopped,\\\\\\\\n+or an error occurs.\\\\\\\\n+\\\\\\\\n+The inverse of [`whilst`](#whilst).\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"doUntil\\\\\\\\\\\\\\\" />\\\\\\\\n+### doUntil(fn, test, callback)\\\\\\\\n+\\\\\\\\n+Like [`doWhilst`](#doWhilst), except the `test` is inverted. Note the argument ordering differs from `until`.\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"forever\\\\\\\\\\\\\\\" />\\\\\\\\n+### forever(fn, errback)\\\\\\\\n+\\\\\\\\n+Calls the asynchronous function `fn` with a callback parameter that allows it to\\\\\\\\n+call itself again, in series, indefinitely.\\\\\\\\n+\\\\\\\\n+If an error is passed to the callback then `errback` is called with the\\\\\\\\n+error, and execution stops, otherwise it will never be called.\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.forever(\\\\\\\\n+    function(next) {\\\\\\\\n+        // next is suitable for passing to things that need a callback(err [, whatever]);\\\\\\\\n+        // it will result in this function being called again.\\\\\\\\n+    },\\\\\\\\n+    function(err) {\\\\\\\\n+        // if next is called with a value in its first parameter, it will appear\\\\\\\\n+        // in here as 'err', and execution will stop.\\\\\\\\n+    }\\\\\\\\n+);\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"waterfall\\\\\\\\\\\\\\\" />\\\\\\\\n+### waterfall(tasks, [callback])\\\\\\\\n+\\\\\\\\n+Runs the `tasks` array of functions in series, each passing their results to the next in\\\\\\\\n+the array. However, if any of the `tasks` pass an error to their own callback, the\\\\\\\\n+next function is not executed, and the main `callback` is immediately called with\\\\\\\\n+the error.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `tasks` - An array of functions to run, each function is passed a \\\\\\\\n+  `callback(err, result1, result2, ...)` it must call on completion. The first\\\\\\\\n+  argument is an error (which can be `null`) and any further arguments will be \\\\\\\\n+  passed as arguments in order to the next task.\\\\\\\\n+* `callback(err, [results])` - An optional callback to run once all the functions\\\\\\\\n+  have completed. This will be passed the results of the last task's callback.\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.waterfall([\\\\\\\\n+    function(callback){\\\\\\\\n+        callback(null, 'one', 'two');\\\\\\\\n+    },\\\\\\\\n+    function(arg1, arg2, callback){\\\\\\\\n+      // arg1 now equals 'one' and arg2 now equals 'two'\\\\\\\\n+        callback(null, 'three');\\\\\\\\n+    },\\\\\\\\n+    function(arg1, callback){\\\\\\\\n+        // arg1 now equals 'three'\\\\\\\\n+        callback(null, 'done');\\\\\\\\n+    }\\\\\\\\n+], function (err, result) {\\\\\\\\n+   // result now equals 'done'    \\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"compose\\\\\\\\\\\\\\\" />\\\\\\\\n+### compose(fn1, fn2...)\\\\\\\\n+\\\\\\\\n+Creates a function which is a composition of the passed asynchronous\\\\\\\\n+functions. Each function consumes the return value of the function that\\\\\\\\n+follows. Composing functions `f()`, `g()`, and `h()` would produce the result of\\\\\\\\n+`f(g(h()))`, only this version uses callbacks to obtain the return values.\\\\\\\\n+\\\\\\\\n+Each function is executed with the `this` binding of the composed function.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `functions...` - the asynchronous functions to compose\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+function add1(n, callback) {\\\\\\\\n+    setTimeout(function () {\\\\\\\\n+        callback(null, n + 1);\\\\\\\\n+    }, 10);\\\\\\\\n+}\\\\\\\\n+\\\\\\\\n+function mul3(n, callback) {\\\\\\\\n+    setTimeout(function () {\\\\\\\\n+        callback(null, n * 3);\\\\\\\\n+    }, 10);\\\\\\\\n+}\\\\\\\\n+\\\\\\\\n+var add1mul3 = async.compose(mul3, add1);\\\\\\\\n+\\\\\\\\n+add1mul3(4, function (err, result) {\\\\\\\\n+   // result now equals 15\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"seq\\\\\\\\\\\\\\\" />\\\\\\\\n+### seq(fn1, fn2...)\\\\\\\\n+\\\\\\\\n+Version of the compose function that is more natural to read.\\\\\\\\n+Each following function consumes the return value of the latter function. \\\\\\\\n+\\\\\\\\n+Each function is executed with the `this` binding of the composed function.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* functions... - the asynchronous functions to compose\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+// Requires lodash (or underscore), express3 and dresende's orm2.\\\\\\\\n+// Part of an app, that fetches cats of the logged user.\\\\\\\\n+// This example uses `seq` function to avoid overnesting and error \\\\\\\\n+// handling clutter.\\\\\\\\n+app.get('/cats', function(request, response) {\\\\\\\\n+  function handleError(err, data, callback) {\\\\\\\\n+    if (err) {\\\\\\\\n+      console.error(err);\\\\\\\\n+      response.json({ status: 'error', message: err.message });\\\\\\\\n+    }\\\\\\\\n+    else {\\\\\\\\n+      callback(data);\\\\\\\\n+    }\\\\\\\\n+  }\\\\\\\\n+  var User = request.models.User;\\\\\\\\n+  async.seq(\\\\\\\\n+    _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\\\\\\\\n+    handleError,\\\\\\\\n+    function(user, fn) {\\\\\\\\n+      user.getCats(fn);      // 'getCats' has signature (callback(err, data))\\\\\\\\n+    },\\\\\\\\n+    handleError,\\\\\\\\n+    function(cats) {\\\\\\\\n+      response.json({ status: 'ok', message: 'Cats found', data: cats });\\\\\\\\n+    }\\\\\\\\n+  )(req.session.user_id);\\\\\\\\n+  }\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"applyEach\\\\\\\\\\\\\\\" />\\\\\\\\n+### applyEach(fns, args..., callback)\\\\\\\\n+\\\\\\\\n+Applies the provided arguments to each function in the array, calling \\\\\\\\n+`callback` after all functions have completed. If you only provide the first\\\\\\\\n+argument, then it will return a function which lets you pass in the\\\\\\\\n+arguments as if it were a single function call.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `fns` - the asynchronous functions to all call with the same arguments\\\\\\\\n+* `args...` - any number of separate arguments to pass to the function\\\\\\\\n+* `callback` - the final argument should be the callback, called when all\\\\\\\\n+  functions have completed processing\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.applyEach([enableSearch, updateSchema], 'bucket', callback);\\\\\\\\n+\\\\\\\\n+// partial application example:\\\\\\\\n+async.each(\\\\\\\\n+    buckets,\\\\\\\\n+    async.applyEach([enableSearch, updateSchema]),\\\\\\\\n+    callback\\\\\\\\n+);\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"applyEachSeries\\\\\\\\\\\\\\\" />\\\\\\\\n+### applyEachSeries(arr, iterator, callback)\\\\\\\\n+\\\\\\\\n+The same as [`applyEach`](#applyEach) only the functions are applied in series.\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"queue\\\\\\\\\\\\\\\" />\\\\\\\\n+### queue(worker, concurrency)\\\\\\\\n+\\\\\\\\n+Creates a `queue` object with the specified `concurrency`. Tasks added to the\\\\\\\\n+`queue` are processed in parallel (up to the `concurrency` limit). If all\\\\\\\\n+`worker`s are in progress, the task is queued until one becomes available. \\\\\\\\n+Once a `worker` completes a `task`, that `task`'s callback is called.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `worker(task, callback)` - An asynchronous function for processing a queued\\\\\\\\n+  task, which must call its `callback(err)` argument when finished, with an \\\\\\\\n+  optional `error` as an argument.\\\\\\\\n+* `concurrency` - An `integer` for determining how many `worker` functions should be\\\\\\\\n+  run in parallel.\\\\\\\\n+\\\\\\\\n+__Queue objects__\\\\\\\\n+\\\\\\\\n+The `queue` object returned by this function has the following properties and\\\\\\\\n+methods:\\\\\\\\n+\\\\\\\\n+* `length()` - a function returning the number of items waiting to be processed.\\\\\\\\n+* `started` - a function returning whether or not any items have been pushed and processed by the queue\\\\\\\\n+* `running()` - a function returning the number of items currently being processed.\\\\\\\\n+* `idle()` - a function returning false if there are items waiting or being processed, or true if not.\\\\\\\\n+* `concurrency` - an integer for determining how many `worker` functions should be\\\\\\\\n+  run in parallel. This property can be changed after a `queue` is created to\\\\\\\\n+  alter the concurrency on-the-fly.\\\\\\\\n+* `push(task, [callback])` - add a new task to the `queue`. Calls `callback` once \\\\\\\\n+  the `worker` has finished processing the task. Instead of a single task, a `tasks` array\\\\\\\\n+  can be submitted. The respective callback is used for every task in the list.\\\\\\\\n+* `unshift(task, [callback])` - add a new task to the front of the `queue`.\\\\\\\\n+* `saturated` - a callback that is called when the `queue` length hits the `concurrency` limit, \\\\\\\\n+   and further tasks will be queued.\\\\\\\\n+* `empty` - a callback that is called when the last item from the `queue` is given to a `worker`.\\\\\\\\n+* `drain` - a callback that is called when the last item from the `queue` has returned from the `worker`.\\\\\\\\n+* `paused` - a boolean for determining whether the queue is in a paused state\\\\\\\\n+* `pause()` - a function that pauses the processing of tasks until `resume()` is called.\\\\\\\\n+* `resume()` - a function that resumes the processing of queued tasks when the queue is paused.\\\\\\\\n+* `kill()` - a function that empties remaining tasks from the queue forcing it to go idle.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+// create a queue object with concurrency 2\\\\\\\\n+\\\\\\\\n+var q = async.queue(function (task, callback) {\\\\\\\\n+    console.log('hello ' + task.name);\\\\\\\\n+    callback();\\\\\\\\n+}, 2);\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+// assign a callback\\\\\\\\n+q.drain = function() {\\\\\\\\n+    console.log('all items have been processed');\\\\\\\\n+}\\\\\\\\n+\\\\\\\\n+// add some items to the queue\\\\\\\\n+\\\\\\\\n+q.push({name: 'foo'}, function (err) {\\\\\\\\n+    console.log('finished processing foo');\\\\\\\\n+});\\\\\\\\n+q.push({name: 'bar'}, function (err) {\\\\\\\\n+    console.log('finished processing bar');\\\\\\\\n+});\\\\\\\\n+\\\\\\\\n+// add some items to the queue (batch-wise)\\\\\\\\n+\\\\\\\\n+q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function (err) {\\\\\\\\n+    console.log('finished processing bar');\\\\\\\\n+});\\\\\\\\n+\\\\\\\\n+// add some items to the front of the queue\\\\\\\\n+\\\\\\\\n+q.unshift({name: 'bar'}, function (err) {\\\\\\\\n+    console.log('finished processing bar');\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"priorityQueue\\\\\\\\\\\\\\\" />\\\\\\\\n+### priorityQueue(worker, concurrency)\\\\\\\\n+\\\\\\\\n+The same as [`queue`](#queue) only tasks are assigned a priority and completed in ascending priority order. There are two differences between `queue` and `priorityQueue` objects:\\\\\\\\n+\\\\\\\\n+* `push(task, priority, [callback])` - `priority` should be a number. If an array of\\\\\\\\n+  `tasks` is given, all tasks will be assigned the same priority.\\\\\\\\n+* The `unshift` method was removed.\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"cargo\\\\\\\\\\\\\\\" />\\\\\\\\n+### cargo(worker, [payload])\\\\\\\\n+\\\\\\\\n+Creates a `cargo` object with the specified payload. Tasks added to the\\\\\\\\n+cargo will be processed altogether (up to the `payload` limit). If the\\\\\\\\n+`worker` is in progress, the task is queued until it becomes available. Once\\\\\\\\n+the `worker` has completed some tasks, each callback of those tasks is called.\\\\\\\\n+Check out [this animation](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) for how `cargo` and `queue` work.\\\\\\\\n+\\\\\\\\n+While [queue](#queue) passes only one task to one of a group of workers\\\\\\\\n+at a time, cargo passes an array of tasks to a single worker, repeating\\\\\\\\n+when the worker is finished.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `worker(tasks, callback)` - An asynchronous function for processing an array of\\\\\\\\n+  queued tasks, which must call its `callback(err)` argument when finished, with \\\\\\\\n+  an optional `err` argument.\\\\\\\\n+* `payload` - An optional `integer` for determining how many tasks should be\\\\\\\\n+  processed per round; if omitted, the default is unlimited.\\\\\\\\n+\\\\\\\\n+__Cargo objects__\\\\\\\\n+\\\\\\\\n+The `cargo` object returned by this function has the following properties and\\\\\\\\n+methods:\\\\\\\\n+\\\\\\\\n+* `length()` - A function returning the number of items waiting to be processed.\\\\\\\\n+* `payload` - An `integer` for determining how many tasks should be\\\\\\\\n+  process per round. This property can be changed after a `cargo` is created to\\\\\\\\n+  alter the payload on-the-fly.\\\\\\\\n+* `push(task, [callback])` - Adds `task` to the `queue`. The callback is called\\\\\\\\n+  once the `worker` has finished processing the task. Instead of a single task, an array of `tasks` \\\\\\\\n+  can be submitted. The respective callback is used for every task in the list.\\\\\\\\n+* `saturated` - A callback that is called when the `queue.length()` hits the concurrency and further tasks will be queued.\\\\\\\\n+* `empty` - A callback that is called when the last item from the `queue` is given to a `worker`.\\\\\\\\n+* `drain` - A callback that is called when the last item from the `queue` has returned from the `worker`.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+// create a cargo object with payload 2\\\\\\\\n+\\\\\\\\n+var cargo = async.cargo(function (tasks, callback) {\\\\\\\\n+    for(var i=0; i<tasks.length; i++){\\\\\\\\n+      console.log('hello ' + tasks[i].name);\\\\\\\\n+    }\\\\\\\\n+    callback();\\\\\\\\n+}, 2);\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+// add some items\\\\\\\\n+\\\\\\\\n+cargo.push({name: 'foo'}, function (err) {\\\\\\\\n+    console.log('finished processing foo');\\\\\\\\n+});\\\\\\\\n+cargo.push({name: 'bar'}, function (err) {\\\\\\\\n+    console.log('finished processing bar');\\\\\\\\n+});\\\\\\\\n+cargo.push({name: 'baz'}, function (err) {\\\\\\\\n+    console.log('finished processing baz');\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"auto\\\\\\\\\\\\\\\" />\\\\\\\\n+### auto(tasks, [callback])\\\\\\\\n+\\\\\\\\n+Determines the best order for running the functions in `tasks`, based on their \\\\\\\\n+requirements. Each function can optionally depend on other functions being completed \\\\\\\\n+first, and each function is run as soon as its requirements are satisfied. \\\\\\\\n+\\\\\\\\n+If any of the functions pass an error to their callback, it will not \\\\\\\\n+complete (so any other functions depending on it will not run), and the main \\\\\\\\n+`callback` is immediately called with the error. Functions also receive an \\\\\\\\n+object containing the results of functions which have completed so far.\\\\\\\\n+\\\\\\\\n+Note, all functions are called with a `results` object as a second argument, \\\\\\\\n+so it is unsafe to pass functions in the `tasks` object which cannot handle the\\\\\\\\n+extra argument. \\\\\\\\n+\\\\\\\\n+For example, this snippet of code:\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.auto({\\\\\\\\n+  readData: async.apply(fs.readFile, 'data.txt', 'utf-8')\\\\\\\\n+}, callback);\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+will have the effect of calling `readFile` with the results object as the last\\\\\\\\n+argument, which will fail:\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+fs.readFile('data.txt', 'utf-8', cb, {});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+Instead, wrap the call to `readFile` in a function which does not forward the \\\\\\\\n+`results` object:\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.auto({\\\\\\\\n+  readData: function(cb, results){\\\\\\\\n+    fs.readFile('data.txt', 'utf-8', cb);\\\\\\\\n+  }\\\\\\\\n+}, callback);\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `tasks` - An object. Each of its properties is either a function or an array of\\\\\\\\n+  requirements, with the function itself the last item in the array. The object's key\\\\\\\\n+  of a property serves as the name of the task defined by that property,\\\\\\\\n+  i.e. can be used when specifying requirements for other tasks.\\\\\\\\n+  The function receives two arguments: (1) a `callback(err, result)` which must be \\\\\\\\n+  called when finished, passing an `error` (which can be `null`) and the result of \\\\\\\\n+  the function's execution, and (2) a `results` object, containing the results of\\\\\\\\n+  the previously executed functions.\\\\\\\\n+* `callback(err, results)` - An optional callback which is called when all the\\\\\\\\n+  tasks have been completed. It receives the `err` argument if any `tasks` \\\\\\\\n+  pass an error to their callback. Results are always returned; however, if \\\\\\\\n+  an error occurs, no further `tasks` will be performed, and the results\\\\\\\\n+  object will only contain partial results.\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.auto({\\\\\\\\n+    get_data: function(callback){\\\\\\\\n+        console.log('in get_data');\\\\\\\\n+        // async code to get some data\\\\\\\\n+        callback(null, 'data', 'converted to array');\\\\\\\\n+    },\\\\\\\\n+    make_folder: function(callback){\\\\\\\\n+        console.log('in make_folder');\\\\\\\\n+        // async code to create a directory to store a file in\\\\\\\\n+        // this is run at the same time as getting the data\\\\\\\\n+        callback(null, 'folder');\\\\\\\\n+    },\\\\\\\\n+    write_file: ['get_data', 'make_folder', function(callback, results){\\\\\\\\n+        console.log('in write_file', JSON.stringify(results));\\\\\\\\n+        // once there is some data and the directory exists,\\\\\\\\n+        // write the data to a file in the directory\\\\\\\\n+        callback(null, 'filename');\\\\\\\\n+    }],\\\\\\\\n+    email_link: ['write_file', function(callback, results){\\\\\\\\n+        console.log('in email_link', JSON.stringify(results));\\\\\\\\n+        // once the file is written let's email a link to it...\\\\\\\\n+        // results.write_file contains the filename returned by write_file.\\\\\\\\n+        callback(null, {'file':results.write_file, 'email':'user@example.com'});\\\\\\\\n+    }]\\\\\\\\n+}, function(err, results) {\\\\\\\\n+    console.log('err = ', err);\\\\\\\\n+    console.log('results = ', results);\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+This is a fairly trivial example, but to do this using the basic parallel and\\\\\\\\n+series functions would look like this:\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.parallel([\\\\\\\\n+    function(callback){\\\\\\\\n+        console.log('in get_data');\\\\\\\\n+        // async code to get some data\\\\\\\\n+        callback(null, 'data', 'converted to array');\\\\\\\\n+    },\\\\\\\\n+    function(callback){\\\\\\\\n+        console.log('in make_folder');\\\\\\\\n+        // async code to create a directory to store a file in\\\\\\\\n+        // this is run at the same time as getting the data\\\\\\\\n+        callback(null, 'folder');\\\\\\\\n+    }\\\\\\\\n+],\\\\\\\\n+function(err, results){\\\\\\\\n+    async.series([\\\\\\\\n+        function(callback){\\\\\\\\n+            console.log('in write_file', JSON.stringify(results));\\\\\\\\n+            // once there is some data and the directory exists,\\\\\\\\n+            // write the data to a file in the directory\\\\\\\\n+            results.push('filename');\\\\\\\\n+            callback(null);\\\\\\\\n+        },\\\\\\\\n+        function(callback){\\\\\\\\n+            console.log('in email_link', JSON.stringify(results));\\\\\\\\n+            // once the file is written let's email a link to it...\\\\\\\\n+            callback(null, {'file':results.pop(), 'email':'user@example.com'});\\\\\\\\n+        }\\\\\\\\n+    ]);\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+For a complicated series of `async` tasks, using the [`auto`](#auto) function makes adding\\\\\\\\n+new tasks much easier (and the code more readable).\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"retry\\\\\\\\\\\\\\\" />\\\\\\\\n+### retry([times = 5], task, [callback])\\\\\\\\n+\\\\\\\\n+Attempts to get a successful response from `task` no more than `times` times before\\\\\\\\n+returning an error. If the task is successful, the `callback` will be passed the result\\\\\\\\n+of the successfull task. If all attemps fail, the callback will be passed the error and\\\\\\\\n+result (if any) of the final attempt.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `times` - An integer indicating how many times to attempt the `task` before giving up. Defaults to 5.\\\\\\\\n+* `task(callback, results)` - A function which receives two arguments: (1) a `callback(err, result)`\\\\\\\\n+  which must be called when finished, passing `err` (which can be `null`) and the `result` of \\\\\\\\n+  the function's execution, and (2) a `results` object, containing the results of\\\\\\\\n+  the previously executed functions (if nested inside another control flow).\\\\\\\\n+* `callback(err, results)` - An optional callback which is called when the\\\\\\\\n+  task has succeeded, or after the final failed attempt. It receives the `err` and `result` arguments of the last attempt at completing the `task`.\\\\\\\\n+\\\\\\\\n+The [`retry`](#retry) function can be used as a stand-alone control flow by passing a\\\\\\\\n+callback, as shown below:\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.retry(3, apiMethod, function(err, result) {\\\\\\\\n+    // do something with the result\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+It can also be embeded within other control flow functions to retry individual methods\\\\\\\\n+that are not as reliable, like this:\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+async.auto({\\\\\\\\n+    users: api.getUsers.bind(api),\\\\\\\\n+    payments: async.retry(3, api.getPayments.bind(api))\\\\\\\\n+}, function(err, results) {\\\\\\\\n+  // do something with the results\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"iterator\\\\\\\\\\\\\\\" />\\\\\\\\n+### iterator(tasks)\\\\\\\\n+\\\\\\\\n+Creates an iterator function which calls the next function in the `tasks` array,\\\\\\\\n+returning a continuation to call the next one after that. It's also possible to\\\\\\\\n+“peek” at the next iterator with `iterator.next()`.\\\\\\\\n+\\\\\\\\n+This function is used internally by the `async` module, but can be useful when\\\\\\\\n+you want to manually control the flow of functions in series.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `tasks` - An array of functions to run.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+var iterator = async.iterator([\\\\\\\\n+    function(){ sys.p('one'); },\\\\\\\\n+    function(){ sys.p('two'); },\\\\\\\\n+    function(){ sys.p('three'); }\\\\\\\\n+]);\\\\\\\\n+\\\\\\\\n+node> var iterator2 = iterator();\\\\\\\\n+'one'\\\\\\\\n+node> var iterator3 = iterator2();\\\\\\\\n+'two'\\\\\\\\n+node> iterator3();\\\\\\\\n+'three'\\\\\\\\n+node> var nextfn = iterator2.next();\\\\\\\\n+node> nextfn();\\\\\\\\n+'three'\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"apply\\\\\\\\\\\\\\\" />\\\\\\\\n+### apply(function, arguments..)\\\\\\\\n+\\\\\\\\n+Creates a continuation function with some arguments already applied. \\\\\\\\n+\\\\\\\\n+Useful as a shorthand when combined with other control flow functions. Any arguments\\\\\\\\n+passed to the returned function are added to the arguments originally passed\\\\\\\\n+to apply.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\\\\\n+* `arguments...` - Any number of arguments to automatically apply when the\\\\\\\\n+  continuation is called.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+// using apply\\\\\\\\n+\\\\\\\\n+async.parallel([\\\\\\\\n+    async.apply(fs.writeFile, 'testfile1', 'test1'),\\\\\\\\n+    async.apply(fs.writeFile, 'testfile2', 'test2'),\\\\\\\\n+]);\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+// the same process without using apply\\\\\\\\n+\\\\\\\\n+async.parallel([\\\\\\\\n+    function(callback){\\\\\\\\n+        fs.writeFile('testfile1', 'test1', callback);\\\\\\\\n+    },\\\\\\\\n+    function(callback){\\\\\\\\n+        fs.writeFile('testfile2', 'test2', callback);\\\\\\\\n+    }\\\\\\\\n+]);\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+It's possible to pass any number of additional arguments when calling the\\\\\\\\n+continuation:\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+node> var fn = async.apply(sys.puts, 'one');\\\\\\\\n+node> fn('two', 'three');\\\\\\\\n+one\\\\\\\\n+two\\\\\\\\n+three\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"nextTick\\\\\\\\\\\\\\\" />\\\\\\\\n+### nextTick(callback)\\\\\\\\n+\\\\\\\\n+Calls `callback` on a later loop around the event loop. In Node.js this just\\\\\\\\n+calls `process.nextTick`; in the browser it falls back to `setImmediate(callback)`\\\\\\\\n+if available, otherwise `setTimeout(callback, 0)`, which means other higher priority\\\\\\\\n+events may precede the execution of `callback`.\\\\\\\\n+\\\\\\\\n+This is used internally for browser-compatibility purposes.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `callback` - The function to call on a later loop around the event loop.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+var call_order = [];\\\\\\\\n+async.nextTick(function(){\\\\\\\\n+    call_order.push('two');\\\\\\\\n+    // call_order now equals ['one','two']\\\\\\\\n+});\\\\\\\\n+call_order.push('one')\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"times\\\\\\\\\\\\\\\" />\\\\\\\\n+### times(n, callback)\\\\\\\\n+\\\\\\\\n+Calls the `callback` function `n` times, and accumulates results in the same manner\\\\\\\\n+you would use with [`map`](#map).\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `n` - The number of times to run the function.\\\\\\\\n+* `callback` - The function to call `n` times.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+// Pretend this is some complicated async factory\\\\\\\\n+var createUser = function(id, callback) {\\\\\\\\n+  callback(null, {\\\\\\\\n+    id: 'user' + id\\\\\\\\n+  })\\\\\\\\n+}\\\\\\\\n+// generate 5 users\\\\\\\\n+async.times(5, function(n, next){\\\\\\\\n+    createUser(n, function(err, user) {\\\\\\\\n+      next(err, user)\\\\\\\\n+    })\\\\\\\\n+}, function(err, users) {\\\\\\\\n+  // we should now have 5 users\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"timesSeries\\\\\\\\\\\\\\\" />\\\\\\\\n+### timesSeries(n, callback)\\\\\\\\n+\\\\\\\\n+The same as [`times`](#times), only the iterator is applied to each item in `arr` in\\\\\\\\n+series. The next `iterator` is only called once the current one has completed. \\\\\\\\n+The results array will be in the same order as the original.\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+## Utils\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"memoize\\\\\\\\\\\\\\\" />\\\\\\\\n+### memoize(fn, [hasher])\\\\\\\\n+\\\\\\\\n+Caches the results of an `async` function. When creating a hash to store function\\\\\\\\n+results against, the callback is omitted from the hash and an optional hash\\\\\\\\n+function can be used.\\\\\\\\n+\\\\\\\\n+The cache of results is exposed as the `memo` property of the function returned\\\\\\\\n+by `memoize`.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `fn` - The function to proxy and cache results from.\\\\\\\\n+* `hasher` - Tn optional function for generating a custom hash for storing\\\\\\\\n+  results. It has all the arguments applied to it apart from the callback, and\\\\\\\\n+  must be synchronous.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+var slow_fn = function (name, callback) {\\\\\\\\n+    // do something\\\\\\\\n+    callback(null, result);\\\\\\\\n+};\\\\\\\\n+var fn = async.memoize(slow_fn);\\\\\\\\n+\\\\\\\\n+// fn can now be used as if it were slow_fn\\\\\\\\n+fn('some name', function () {\\\\\\\\n+    // callback\\\\\\\\n+});\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"unmemoize\\\\\\\\\\\\\\\" />\\\\\\\\n+### unmemoize(fn)\\\\\\\\n+\\\\\\\\n+Undoes a [`memoize`](#memoize)d function, reverting it to the original, unmemoized\\\\\\\\n+form. Handy for testing.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `fn` - the memoized function\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"log\\\\\\\\\\\\\\\" />\\\\\\\\n+### log(function, arguments)\\\\\\\\n+\\\\\\\\n+Logs the result of an `async` function to the `console`. Only works in Node.js or\\\\\\\\n+in browsers that support `console.log` and `console.error` (such as FF and Chrome).\\\\\\\\n+If multiple arguments are returned from the async function, `console.log` is\\\\\\\\n+called on each argument in order.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\\\\\n+* `arguments...` - Any number of arguments to apply to the function.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+var hello = function(name, callback){\\\\\\\\n+    setTimeout(function(){\\\\\\\\n+        callback(null, 'hello ' + name);\\\\\\\\n+    }, 1000);\\\\\\\\n+};\\\\\\\\n+```\\\\\\\\n+```js\\\\\\\\n+node> async.log(hello, 'world');\\\\\\\\n+'hello world'\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"dir\\\\\\\\\\\\\\\" />\\\\\\\\n+### dir(function, arguments)\\\\\\\\n+\\\\\\\\n+Logs the result of an `async` function to the `console` using `console.dir` to\\\\\\\\n+display the properties of the resulting object. Only works in Node.js or\\\\\\\\n+in browsers that support `console.dir` and `console.error` (such as FF and Chrome).\\\\\\\\n+If multiple arguments are returned from the async function, `console.dir` is\\\\\\\\n+called on each argument in order.\\\\\\\\n+\\\\\\\\n+__Arguments__\\\\\\\\n+\\\\\\\\n+* `function` - The function you want to eventually apply all arguments to.\\\\\\\\n+* `arguments...` - Any number of arguments to apply to the function.\\\\\\\\n+\\\\\\\\n+__Example__\\\\\\\\n+\\\\\\\\n+```js\\\\\\\\n+var hello = function(name, callback){\\\\\\\\n+    setTimeout(function(){\\\\\\\\n+        callback(null, {hello: name});\\\\\\\\n+    }, 1000);\\\\\\\\n+};\\\\\\\\n+```\\\\\\\\n+```js\\\\\\\\n+node> async.dir(hello, 'world');\\\\\\\\n+{hello: 'world'}\\\\\\\\n+```\\\\\\\\n+\\\\\\\\n+---------------------------------------\\\\\\\\n+\\\\\\\\n+<a name=\\\\\\\\\\\\\\\"noConflict\\\\\\\\\\\\\\\" />\\\\\\\\n+### noConflict()\\\\\\\\n+\\\\\\\\n+Changes the value of `async` back to its original value, returning a reference to the\\\\\\\\n+`async` object.\\\\\\\\ndiff --git a/node_modules/async/component.json b/node_modules/async/component.json\\\\\\\\nnew file mode 100644\\\\\\\\nindex 0000000..bbb0115\\\\\\\\n--- /dev/null\\\\\\\\n+++ b/node_modules/async/component.json\\\\\\\\n@@ -0,0 +1,11 @@\\\\\\\\n+{\\\\\\\\n+  \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"async\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"repo\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"caolan/async\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Higher-order functions and common patterns for asynchronous code\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"version\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"0.1.23\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"keywords\\\\\\\\\\\\\\\": [],\\\\\\\\n+  \\\\\\\\\\\\\\\"dependencies\\\\\\\\\\\\\\\": {},\\\\\\\\n+  \\\\\\\\\\\\\\\"development\\\\\\\\\\\\\\\": {},\\\\\\\\n+  \\\\\\\\\\\\\\\"main\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"lib/async.js\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"scripts\\\\\\\\\\\\\\\": [ \\\\\\\\\\\\\\\"lib/async.js\\\\\\\\\\\\\\\" ]\\\\\\\\n+}\\\\\\\\ndiff --git a/node_modules/async/lib/async.js b/node_modules/async/lib/async.js\\\\\\\\nnew file mode 100644\\\\\\\\nindex 0000000..01e8afc\\\\\\\\n--- /dev/null\\\\\\\\n+++ b/node_modules/async/lib/async.js\\\\\\\\n@@ -0,0 +1,1123 @@\\\\\\\\n+/*!\\\\\\\\n+ * async\\\\\\\\n+ * https://github.com/caolan/async\\\\\\\\n+ *\\\\\\\\n+ * Copyright 2010-2014 Caolan McMahon\\\\\\\\n+ * Released under the MIT license\\\\\\\\n+ */\\\\\\\\n+/*jshint onevar: false, indent:4 */\\\\\\\\n+/*global setImmediate: false, setTimeout: false, console: false */\\\\\\\\n+(function () {\\\\\\\\n+\\\\\\\\n+    var async = {};\\\\\\\\n+\\\\\\\\n+    // global on the server, window in the browser\\\\\\\\n+    var root, previous_async;\\\\\\\\n+\\\\\\\\n+    root = this;\\\\\\\\n+    if (root != null) {\\\\\\\\n+      previous_async = root.async;\\\\\\\\n+    }\\\\\\\\n+\\\\\\\\n+    async.noConflict = function () {\\\\\\\\n+        root.async = previous_async;\\\\\\\\n+        return async;\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    function only_once(fn) {\\\\\\\\n+        var called = false;\\\\\\\\n+        return function() {\\\\\\\\n+            if (called) throw new Error(\\\\\\\\\\\\\\\"Callback was already called.\\\\\\\\\\\\\\\");\\\\\\\\n+            called = true;\\\\\\\\n+            fn.apply(root, arguments);\\\\\\\\n+        }\\\\\\\\n+    }\\\\\\\\n+\\\\\\\\n+    //// cross-browser compatiblity functions ////\\\\\\\\n+\\\\\\\\n+    var _toString = Object.prototype.toString;\\\\\\\\n+\\\\\\\\n+    var _isArray = Array.isArray || function (obj) {\\\\\\\\n+        return _toString.call(obj) === '[object Array]';\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    var _each = function (arr, iterator) {\\\\\\\\n+        if (arr.forEach) {\\\\\\\\n+            return arr.forEach(iterator);\\\\\\\\n+        }\\\\\\\\n+        for (var i = 0; i < arr.length; i += 1) {\\\\\\\\n+            iterator(arr[i], i, arr);\\\\\\\\n+        }\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    var _map = function (arr, iterator) {\\\\\\\\n+        if (arr.map) {\\\\\\\\n+            return arr.map(iterator);\\\\\\\\n+        }\\\\\\\\n+        var results = [];\\\\\\\\n+        _each(arr, function (x, i, a) {\\\\\\\\n+            results.push(iterator(x, i, a));\\\\\\\\n+        });\\\\\\\\n+        return results;\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    var _reduce = function (arr, iterator, memo) {\\\\\\\\n+        if (arr.reduce) {\\\\\\\\n+            return arr.reduce(iterator, memo);\\\\\\\\n+        }\\\\\\\\n+        _each(arr, function (x, i, a) {\\\\\\\\n+            memo = iterator(memo, x, i, a);\\\\\\\\n+        });\\\\\\\\n+        return memo;\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    var _keys = function (obj) {\\\\\\\\n+        if (Object.keys) {\\\\\\\\n+            return Object.keys(obj);\\\\\\\\n+        }\\\\\\\\n+        var keys = [];\\\\\\\\n+        for (var k in obj) {\\\\\\\\n+            if (obj.hasOwnProperty(k)) {\\\\\\\\n+                keys.push(k);\\\\\\\\n+            }\\\\\\\\n+        }\\\\\\\\n+        return keys;\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    //// exported async module functions ////\\\\\\\\n+\\\\\\\\n+    //// nextTick implementation with browser-compatible fallback ////\\\\\\\\n+    if (typeof process === 'undefined' || !(process.nextTick)) {\\\\\\\\n+        if (typeof setImmediate === 'function') {\\\\\\\\n+            async.nextTick = function (fn) {\\\\\\\\n+                // not a direct alias for IE10 compatibility\\\\\\\\n+                setImmediate(fn);\\\\\\\\n+            };\\\\\\\\n+            async.setImmediate = async.nextTick;\\\\\\\\n+        }\\\\\\\\n+        else {\\\\\\\\n+            async.nextTick = function (fn) {\\\\\\\\n+                setTimeout(fn, 0);\\\\\\\\n+            };\\\\\\\\n+            async.setImmediate = async.nextTick;\\\\\\\\n+        }\\\\\\\\n+    }\\\\\\\\n+    else {\\\\\\\\n+        async.nextTick = process.nextTick;\\\\\\\\n+        if (typeof setImmediate !== 'undefined') {\\\\\\\\n+            async.setImmediate = function (fn) {\\\\\\\\n+              // not a direct alias for IE10 compatibility\\\\\\\\n+              setImmediate(fn);\\\\\\\\n+            };\\\\\\\\n+        }\\\\\\\\n+        else {\\\\\\\\n+            async.setImmediate = async.nextTick;\\\\\\\\n+        }\\\\\\\\n+    }\\\\\\\\n+\\\\\\\\n+    async.each = function (arr, iterator, callback) {\\\\\\\\n+        callback = callback || function () {};\\\\\\\\n+        if (!arr.length) {\\\\\\\\n+            return callback();\\\\\\\\n+        }\\\\\\\\n+        var completed = 0;\\\\\\\\n+        _each(arr, function (x) {\\\\\\\\n+            iterator(x, only_once(done) );\\\\\\\\n+        });\\\\\\\\n+        function done(err) {\\\\\\\\n+          if (err) {\\\\\\\\n+              callback(err);\\\\\\\\n+              callback = function () {};\\\\\\\\n+          }\\\\\\\\n+          else {\\\\\\\\n+              completed += 1;\\\\\\\\n+              if (completed >= arr.length) {\\\\\\\\n+                  callback();\\\\\\\\n+              }\\\\\\\\n+          }\\\\\\\\n+        }\\\\\\\\n+    };\\\\\\\\n+    async.forEach = async.each;\\\\\\\\n+\\\\\\\\n+    async.eachSeries = function (arr, iterator, callback) {\\\\\\\\n+        callback = callback || function () {};\\\\\\\\n+        if (!arr.length) {\\\\\\\\n+            return callback();\\\\\\\\n+        }\\\\\\\\n+        var completed = 0;\\\\\\\\n+        var iterate = function () {\\\\\\\\n+            iterator(arr[completed], function (err) {\\\\\\\\n+                if (err) {\\\\\\\\n+                    callback(err);\\\\\\\\n+                    callback = function () {};\\\\\\\\n+                }\\\\\\\\n+                else {\\\\\\\\n+                    completed += 1;\\\\\\\\n+                    if (completed >= arr.length) {\\\\\\\\n+                        callback();\\\\\\\\n+                    }\\\\\\\\n+                    else {\\\\\\\\n+                        iterate();\\\\\\\\n+                    }\\\\\\\\n+                }\\\\\\\\n+            });\\\\\\\\n+        };\\\\\\\\n+        iterate();\\\\\\\\n+    };\\\\\\\\n+    async.forEachSeries = async.eachSeries;\\\\\\\\n+\\\\\\\\n+    async.eachLimit = function (arr, limit, iterator, callback) {\\\\\\\\n+        var fn = _eachLimit(limit);\\\\\\\\n+        fn.apply(null, [arr, iterator, callback]);\\\\\\\\n+    };\\\\\\\\n+    async.forEachLimit = async.eachLimit;\\\\\\\\n+\\\\\\\\n+    var _eachLimit = function (limit) {\\\\\\\\n+\\\\\\\\n+        return function (arr, iterator, callback) {\\\\\\\\n+            callback = callback || function () {};\\\\\\\\n+            if (!arr.length || limit <= 0) {\\\\\\\\n+                return callback();\\\\\\\\n+            }\\\\\\\\n+            var completed = 0;\\\\\\\\n+            var started = 0;\\\\\\\\n+            var running = 0;\\\\\\\\n+\\\\\\\\n+            (function replenish () {\\\\\\\\n+                if (completed >= arr.length) {\\\\\\\\n+                    return callback();\\\\\\\\n+                }\\\\\\\\n+\\\\\\\\n+                while (running < limit && started < arr.length) {\\\\\\\\n+                    started += 1;\\\\\\\\n+                    running += 1;\\\\\\\\n+                    iterator(arr[started - 1], function (err) {\\\\\\\\n+                        if (err) {\\\\\\\\n+                            callback(err);\\\\\\\\n+                            callback = function () {};\\\\\\\\n+                        }\\\\\\\\n+                        else {\\\\\\\\n+                            completed += 1;\\\\\\\\n+                            running -= 1;\\\\\\\\n+                            if (completed >= arr.length) {\\\\\\\\n+                                callback();\\\\\\\\n+                            }\\\\\\\\n+                            else {\\\\\\\\n+                                replenish();\\\\\\\\n+                            }\\\\\\\\n+                        }\\\\\\\\n+                    });\\\\\\\\n+                }\\\\\\\\n+            })();\\\\\\\\n+        };\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+    var doParallel = function (fn) {\\\\\\\\n+        return function () {\\\\\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\\\\\n+            return fn.apply(null, [async.each].concat(args));\\\\\\\\n+        };\\\\\\\\n+    };\\\\\\\\n+    var doParallelLimit = function(limit, fn) {\\\\\\\\n+        return function () {\\\\\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\\\\\n+            return fn.apply(null, [_eachLimit(limit)].concat(args));\\\\\\\\n+        };\\\\\\\\n+    };\\\\\\\\n+    var doSeries = function (fn) {\\\\\\\\n+        return function () {\\\\\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\\\\\n+            return fn.apply(null, [async.eachSeries].concat(args));\\\\\\\\n+        };\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+\\\\\\\\n+    var _asyncMap = function (eachfn, arr, iterator, callback) {\\\\\\\\n+        arr = _map(arr, function (x, i) {\\\\\\\\n+            return {index: i, value: x};\\\\\\\\n+        });\\\\\\\\n+        if (!callback) {\\\\\\\\n+            eachfn(arr, function (x, callback) {\\\\\\\\n+                iterator(x.value, function (err) {\\\\\\\\n+                    callback(err);\\\\\\\\n+                });\\\\\\\\n+            });\\\\\\\\n+        } else {\\\\\\\\n+            var results = [];\\\\\\\\n+            eachfn(arr, function (x, callback) {\\\\\\\\n+                iterator(x.value, function (err, v) {\\\\\\\\n+                    results[x.index] = v;\\\\\\\\n+                    callback(err);\\\\\\\\n+                });\\\\\\\\n+            }, function (err) {\\\\\\\\n+                callback(err, results);\\\\\\\\n+            });\\\\\\\\n+        }\\\\\\\\n+    };\\\\\\\\n+    async.map = doParallel(_asyncMap);\\\\\\\\n+    async.mapSeries = doSeries(_asyncMap);\\\\\\\\n+    async.mapLimit = function (arr, limit, iterator, callback) {\\\\\\\\n+        return _mapLimit(limit)(arr, iterator, callback);\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    var _mapLimit = function(limit) {\\\\\\\\n+        return doParallelLimit(limit, _asyncMap);\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    // reduce only has a series version, as doing reduce in parallel won't\\\\\\\\n+    // work in many situations.\\\\\\\\n+    async.reduce = function (arr, memo, iterator, callback) {\\\\\\\\n+        async.eachSeries(arr, function (x, callback) {\\\\\\\\n+            iterator(memo, x, function (err, v) {\\\\\\\\n+                memo = v;\\\\\\\\n+                callback(err);\\\\\\\\n+            });\\\\\\\\n+        }, function (err) {\\\\\\\\n+            callback(err, memo);\\\\\\\\n+        });\\\\\\\\n+    };\\\\\\\\n+    // inject alias\\\\\\\\n+    async.inject = async.reduce;\\\\\\\\n+    // foldl alias\\\\\\\\n+    async.foldl = async.reduce;\\\\\\\\n+\\\\\\\\n+    async.reduceRight = function (arr, memo, iterator, callback) {\\\\\\\\n+        var reversed = _map(arr, function (x) {\\\\\\\\n+            return x;\\\\\\\\n+        }).reverse();\\\\\\\\n+        async.reduce(reversed, memo, iterator, callback);\\\\\\\\n+    };\\\\\\\\n+    // foldr alias\\\\\\\\n+    async.foldr = async.reduceRight;\\\\\\\\n+\\\\\\\\n+    var _filter = function (eachfn, arr, iterator, callback) {\\\\\\\\n+        var results = [];\\\\\\\\n+        arr = _map(arr, function (x, i) {\\\\\\\\n+            return {index: i, value: x};\\\\\\\\n+        });\\\\\\\\n+        eachfn(arr, function (x, callback) {\\\\\\\\n+            iterator(x.value, function (v) {\\\\\\\\n+                if (v) {\\\\\\\\n+                    results.push(x);\\\\\\\\n+                }\\\\\\\\n+                callback();\\\\\\\\n+            });\\\\\\\\n+        }, function (err) {\\\\\\\\n+            callback(_map(results.sort(function (a, b) {\\\\\\\\n+                return a.index - b.index;\\\\\\\\n+            }), function (x) {\\\\\\\\n+                return x.value;\\\\\\\\n+            }));\\\\\\\\n+        });\\\\\\\\n+    };\\\\\\\\n+    async.filter = doParallel(_filter);\\\\\\\\n+    async.filterSeries = doSeries(_filter);\\\\\\\\n+    // select alias\\\\\\\\n+    async.select = async.filter;\\\\\\\\n+    async.selectSeries = async.filterSeries;\\\\\\\\n+\\\\\\\\n+    var _reject = function (eachfn, arr, iterator, callback) {\\\\\\\\n+        var results = [];\\\\\\\\n+        arr = _map(arr, function (x, i) {\\\\\\\\n+            return {index: i, value: x};\\\\\\\\n+        });\\\\\\\\n+        eachfn(arr, function (x, callback) {\\\\\\\\n+            iterator(x.value, function (v) {\\\\\\\\n+                if (!v) {\\\\\\\\n+                    results.push(x);\\\\\\\\n+                }\\\\\\\\n+                callback();\\\\\\\\n+            });\\\\\\\\n+        }, function (err) {\\\\\\\\n+            callback(_map(results.sort(function (a, b) {\\\\\\\\n+                return a.index - b.index;\\\\\\\\n+            }), function (x) {\\\\\\\\n+                return x.value;\\\\\\\\n+            }));\\\\\\\\n+        });\\\\\\\\n+    };\\\\\\\\n+    async.reject = doParallel(_reject);\\\\\\\\n+    async.rejectSeries = doSeries(_reject);\\\\\\\\n+\\\\\\\\n+    var _detect = function (eachfn, arr, iterator, main_callback) {\\\\\\\\n+        eachfn(arr, function (x, callback) {\\\\\\\\n+            iterator(x, function (result) {\\\\\\\\n+                if (result) {\\\\\\\\n+                    main_callback(x);\\\\\\\\n+                    main_callback = function () {};\\\\\\\\n+                }\\\\\\\\n+                else {\\\\\\\\n+                    callback();\\\\\\\\n+                }\\\\\\\\n+            });\\\\\\\\n+        }, function (err) {\\\\\\\\n+            main_callback();\\\\\\\\n+        });\\\\\\\\n+    };\\\\\\\\n+    async.detect = doParallel(_detect);\\\\\\\\n+    async.detectSeries = doSeries(_detect);\\\\\\\\n+\\\\\\\\n+    async.some = function (arr, iterator, main_callback) {\\\\\\\\n+        async.each(arr, function (x, callback) {\\\\\\\\n+            iterator(x, function (v) {\\\\\\\\n+                if (v) {\\\\\\\\n+                    main_callback(true);\\\\\\\\n+                    main_callback = function () {};\\\\\\\\n+                }\\\\\\\\n+                callback();\\\\\\\\n+            });\\\\\\\\n+        }, function (err) {\\\\\\\\n+            main_callback(false);\\\\\\\\n+        });\\\\\\\\n+    };\\\\\\\\n+    // any alias\\\\\\\\n+    async.any = async.some;\\\\\\\\n+\\\\\\\\n+    async.every = function (arr, iterator, main_callback) {\\\\\\\\n+        async.each(arr, function (x, callback) {\\\\\\\\n+            iterator(x, function (v) {\\\\\\\\n+                if (!v) {\\\\\\\\n+                    main_callback(false);\\\\\\\\n+                    main_callback = function () {};\\\\\\\\n+                }\\\\\\\\n+                callback();\\\\\\\\n+            });\\\\\\\\n+        }, function (err) {\\\\\\\\n+            main_callback(true);\\\\\\\\n+        });\\\\\\\\n+    };\\\\\\\\n+    // all alias\\\\\\\\n+    async.all = async.every;\\\\\\\\n+\\\\\\\\n+    async.sortBy = function (arr, iterator, callback) {\\\\\\\\n+        async.map(arr, function (x, callback) {\\\\\\\\n+            iterator(x, function (err, criteria) {\\\\\\\\n+                if (err) {\\\\\\\\n+                    callback(err);\\\\\\\\n+                }\\\\\\\\n+                else {\\\\\\\\n+                    callback(null, {value: x, criteria: criteria});\\\\\\\\n+                }\\\\\\\\n+            });\\\\\\\\n+        }, function (err, results) {\\\\\\\\n+            if (err) {\\\\\\\\n+                return callback(err);\\\\\\\\n+            }\\\\\\\\n+            else {\\\\\\\\n+                var fn = function (left, right) {\\\\\\\\n+                    var a = left.criteria, b = right.criteria;\\\\\\\\n+                    return a < b ? -1 : a > b ? 1 : 0;\\\\\\\\n+                };\\\\\\\\n+                callback(null, _map(results.sort(fn), function (x) {\\\\\\\\n+                    return x.value;\\\\\\\\n+                }));\\\\\\\\n+            }\\\\\\\\n+        });\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.auto = function (tasks, callback) {\\\\\\\\n+        callback = callback || function () {};\\\\\\\\n+        var keys = _keys(tasks);\\\\\\\\n+        var remainingTasks = keys.length\\\\\\\\n+        if (!remainingTasks) {\\\\\\\\n+            return callback();\\\\\\\\n+        }\\\\\\\\n+\\\\\\\\n+        var results = {};\\\\\\\\n+\\\\\\\\n+        var listeners = [];\\\\\\\\n+        var addListener = function (fn) {\\\\\\\\n+            listeners.unshift(fn);\\\\\\\\n+        };\\\\\\\\n+        var removeListener = function (fn) {\\\\\\\\n+            for (var i = 0; i < listeners.length; i += 1) {\\\\\\\\n+                if (listeners[i] === fn) {\\\\\\\\n+                    listeners.splice(i, 1);\\\\\\\\n+                    return;\\\\\\\\n+                }\\\\\\\\n+            }\\\\\\\\n+        };\\\\\\\\n+        var taskComplete = function () {\\\\\\\\n+            remainingTasks--\\\\\\\\n+            _each(listeners.slice(0), function (fn) {\\\\\\\\n+                fn();\\\\\\\\n+            });\\\\\\\\n+        };\\\\\\\\n+\\\\\\\\n+        addListener(function () {\\\\\\\\n+            if (!remainingTasks) {\\\\\\\\n+                var theCallback = callback;\\\\\\\\n+                // prevent final callback from calling itself if it errors\\\\\\\\n+                callback = function () {};\\\\\\\\n+\\\\\\\\n+                theCallback(null, results);\\\\\\\\n+            }\\\\\\\\n+        });\\\\\\\\n+\\\\\\\\n+        _each(keys, function (k) {\\\\\\\\n+            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\\\\\\\\n+            var taskCallback = function (err) {\\\\\\\\n+                var args = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+                if (args.length <= 1) {\\\\\\\\n+                    args = args[0];\\\\\\\\n+                }\\\\\\\\n+                if (err) {\\\\\\\\n+                    var safeResults = {};\\\\\\\\n+                    _each(_keys(results), function(rkey) {\\\\\\\\n+                        safeResults[rkey] = results[rkey];\\\\\\\\n+                    });\\\\\\\\n+                    safeResults[k] = args;\\\\\\\\n+                    callback(err, safeResults);\\\\\\\\n+                    // stop subsequent errors hitting callback multiple times\\\\\\\\n+                    callback = function () {};\\\\\\\\n+                }\\\\\\\\n+                else {\\\\\\\\n+                    results[k] = args;\\\\\\\\n+                    async.setImmediate(taskComplete);\\\\\\\\n+                }\\\\\\\\n+            };\\\\\\\\n+            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\\\\\\\\n+            var ready = function () {\\\\\\\\n+                return _reduce(requires, function (a, x) {\\\\\\\\n+                    return (a && results.hasOwnProperty(x));\\\\\\\\n+                }, true) && !results.hasOwnProperty(k);\\\\\\\\n+            };\\\\\\\\n+            if (ready()) {\\\\\\\\n+                task[task.length - 1](taskCallback, results);\\\\\\\\n+            }\\\\\\\\n+            else {\\\\\\\\n+                var listener = function () {\\\\\\\\n+                    if (ready()) {\\\\\\\\n+                        removeListener(listener);\\\\\\\\n+                        task[task.length - 1](taskCallback, results);\\\\\\\\n+                    }\\\\\\\\n+                };\\\\\\\\n+                addListener(listener);\\\\\\\\n+            }\\\\\\\\n+        });\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.retry = function(times, task, callback) {\\\\\\\\n+        var DEFAULT_TIMES = 5;\\\\\\\\n+        var attempts = [];\\\\\\\\n+        // Use defaults if times not passed\\\\\\\\n+        if (typeof times === 'function') {\\\\\\\\n+            callback = task;\\\\\\\\n+            task = times;\\\\\\\\n+            times = DEFAULT_TIMES;\\\\\\\\n+        }\\\\\\\\n+        // Make sure times is a number\\\\\\\\n+        times = parseInt(times, 10) || DEFAULT_TIMES;\\\\\\\\n+        var wrappedTask = function(wrappedCallback, wrappedResults) {\\\\\\\\n+            var retryAttempt = function(task, finalAttempt) {\\\\\\\\n+                return function(seriesCallback) {\\\\\\\\n+                    task(function(err, result){\\\\\\\\n+                        seriesCallback(!err || finalAttempt, {err: err, result: result});\\\\\\\\n+                    }, wrappedResults);\\\\\\\\n+                };\\\\\\\\n+            };\\\\\\\\n+            while (times) {\\\\\\\\n+                attempts.push(retryAttempt(task, !(times-=1)));\\\\\\\\n+            }\\\\\\\\n+            async.series(attempts, function(done, data){\\\\\\\\n+                data = data[data.length - 1];\\\\\\\\n+                (wrappedCallback || callback)(data.err, data.result);\\\\\\\\n+            });\\\\\\\\n+        }\\\\\\\\n+        // If a callback is passed, run this as a controll flow\\\\\\\\n+        return callback ? wrappedTask() : wrappedTask\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.waterfall = function (tasks, callback) {\\\\\\\\n+        callback = callback || function () {};\\\\\\\\n+        if (!_isArray(tasks)) {\\\\\\\\n+          var err = new Error('First argument to waterfall must be an array of functions');\\\\\\\\n+          return callback(err);\\\\\\\\n+        }\\\\\\\\n+        if (!tasks.length) {\\\\\\\\n+            return callback();\\\\\\\\n+        }\\\\\\\\n+        var wrapIterator = function (iterator) {\\\\\\\\n+            return function (err) {\\\\\\\\n+                if (err) {\\\\\\\\n+                    callback.apply(null, arguments);\\\\\\\\n+                    callback = function () {};\\\\\\\\n+                }\\\\\\\\n+                else {\\\\\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+                    var next = iterator.next();\\\\\\\\n+                    if (next) {\\\\\\\\n+                        args.push(wrapIterator(next));\\\\\\\\n+                    }\\\\\\\\n+                    else {\\\\\\\\n+                        args.push(callback);\\\\\\\\n+                    }\\\\\\\\n+                    async.setImmediate(function () {\\\\\\\\n+                        iterator.apply(null, args);\\\\\\\\n+                    });\\\\\\\\n+                }\\\\\\\\n+            };\\\\\\\\n+        };\\\\\\\\n+        wrapIterator(async.iterator(tasks))();\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    var _parallel = function(eachfn, tasks, callback) {\\\\\\\\n+        callback = callback || function () {};\\\\\\\\n+        if (_isArray(tasks)) {\\\\\\\\n+            eachfn.map(tasks, function (fn, callback) {\\\\\\\\n+                if (fn) {\\\\\\\\n+                    fn(function (err) {\\\\\\\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+                        if (args.length <= 1) {\\\\\\\\n+                            args = args[0];\\\\\\\\n+                        }\\\\\\\\n+                        callback.call(null, err, args);\\\\\\\\n+                    });\\\\\\\\n+                }\\\\\\\\n+            }, callback);\\\\\\\\n+        }\\\\\\\\n+        else {\\\\\\\\n+            var results = {};\\\\\\\\n+            eachfn.each(_keys(tasks), function (k, callback) {\\\\\\\\n+                tasks[k](function (err) {\\\\\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+                    if (args.length <= 1) {\\\\\\\\n+                        args = args[0];\\\\\\\\n+                    }\\\\\\\\n+                    results[k] = args;\\\\\\\\n+                    callback(err);\\\\\\\\n+                });\\\\\\\\n+            }, function (err) {\\\\\\\\n+                callback(err, results);\\\\\\\\n+            });\\\\\\\\n+        }\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.parallel = function (tasks, callback) {\\\\\\\\n+        _parallel({ map: async.map, each: async.each }, tasks, callback);\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.parallelLimit = function(tasks, limit, callback) {\\\\\\\\n+        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.series = function (tasks, callback) {\\\\\\\\n+        callback = callback || function () {};\\\\\\\\n+        if (_isArray(tasks)) {\\\\\\\\n+            async.mapSeries(tasks, function (fn, callback) {\\\\\\\\n+                if (fn) {\\\\\\\\n+                    fn(function (err) {\\\\\\\\n+                        var args = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+                        if (args.length <= 1) {\\\\\\\\n+                            args = args[0];\\\\\\\\n+                        }\\\\\\\\n+                        callback.call(null, err, args);\\\\\\\\n+                    });\\\\\\\\n+                }\\\\\\\\n+            }, callback);\\\\\\\\n+        }\\\\\\\\n+        else {\\\\\\\\n+            var results = {};\\\\\\\\n+            async.eachSeries(_keys(tasks), function (k, callback) {\\\\\\\\n+                tasks[k](function (err) {\\\\\\\\n+                    var args = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+                    if (args.length <= 1) {\\\\\\\\n+                        args = args[0];\\\\\\\\n+                    }\\\\\\\\n+                    results[k] = args;\\\\\\\\n+                    callback(err);\\\\\\\\n+                });\\\\\\\\n+            }, function (err) {\\\\\\\\n+                callback(err, results);\\\\\\\\n+            });\\\\\\\\n+        }\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.iterator = function (tasks) {\\\\\\\\n+        var makeCallback = function (index) {\\\\\\\\n+            var fn = function () {\\\\\\\\n+                if (tasks.length) {\\\\\\\\n+                    tasks[index].apply(null, arguments);\\\\\\\\n+                }\\\\\\\\n+                return fn.next();\\\\\\\\n+            };\\\\\\\\n+            fn.next = function () {\\\\\\\\n+                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\\\\\\\\n+            };\\\\\\\\n+            return fn;\\\\\\\\n+        };\\\\\\\\n+        return makeCallback(0);\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.apply = function (fn) {\\\\\\\\n+        var args = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+        return function () {\\\\\\\\n+            return fn.apply(\\\\\\\\n+                null, args.concat(Array.prototype.slice.call(arguments))\\\\\\\\n+            );\\\\\\\\n+        };\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    var _concat = function (eachfn, arr, fn, callback) {\\\\\\\\n+        var r = [];\\\\\\\\n+        eachfn(arr, function (x, cb) {\\\\\\\\n+            fn(x, function (err, y) {\\\\\\\\n+                r = r.concat(y || []);\\\\\\\\n+                cb(err);\\\\\\\\n+            });\\\\\\\\n+        }, function (err) {\\\\\\\\n+            callback(err, r);\\\\\\\\n+        });\\\\\\\\n+    };\\\\\\\\n+    async.concat = doParallel(_concat);\\\\\\\\n+    async.concatSeries = doSeries(_concat);\\\\\\\\n+\\\\\\\\n+    async.whilst = function (test, iterator, callback) {\\\\\\\\n+        if (test()) {\\\\\\\\n+            iterator(function (err) {\\\\\\\\n+                if (err) {\\\\\\\\n+                    return callback(err);\\\\\\\\n+                }\\\\\\\\n+                async.whilst(test, iterator, callback);\\\\\\\\n+            });\\\\\\\\n+        }\\\\\\\\n+        else {\\\\\\\\n+            callback();\\\\\\\\n+        }\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.doWhilst = function (iterator, test, callback) {\\\\\\\\n+        iterator(function (err) {\\\\\\\\n+            if (err) {\\\\\\\\n+                return callback(err);\\\\\\\\n+            }\\\\\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+            if (test.apply(null, args)) {\\\\\\\\n+                async.doWhilst(iterator, test, callback);\\\\\\\\n+            }\\\\\\\\n+            else {\\\\\\\\n+                callback();\\\\\\\\n+            }\\\\\\\\n+        });\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.until = function (test, iterator, callback) {\\\\\\\\n+        if (!test()) {\\\\\\\\n+            iterator(function (err) {\\\\\\\\n+                if (err) {\\\\\\\\n+                    return callback(err);\\\\\\\\n+                }\\\\\\\\n+                async.until(test, iterator, callback);\\\\\\\\n+            });\\\\\\\\n+        }\\\\\\\\n+        else {\\\\\\\\n+            callback();\\\\\\\\n+        }\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.doUntil = function (iterator, test, callback) {\\\\\\\\n+        iterator(function (err) {\\\\\\\\n+            if (err) {\\\\\\\\n+                return callback(err);\\\\\\\\n+            }\\\\\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+            if (!test.apply(null, args)) {\\\\\\\\n+                async.doUntil(iterator, test, callback);\\\\\\\\n+            }\\\\\\\\n+            else {\\\\\\\\n+                callback();\\\\\\\\n+            }\\\\\\\\n+        });\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.queue = function (worker, concurrency) {\\\\\\\\n+        if (concurrency === undefined) {\\\\\\\\n+            concurrency = 1;\\\\\\\\n+        }\\\\\\\\n+        function _insert(q, data, pos, callback) {\\\\\\\\n+          if (!q.started){\\\\\\\\n+            q.started = true;\\\\\\\\n+          }\\\\\\\\n+          if (!_isArray(data)) {\\\\\\\\n+              data = [data];\\\\\\\\n+          }\\\\\\\\n+          if(data.length == 0) {\\\\\\\\n+             // call drain immediately if there are no tasks\\\\\\\\n+             return async.setImmediate(function() {\\\\\\\\n+                 if (q.drain) {\\\\\\\\n+                     q.drain();\\\\\\\\n+                 }\\\\\\\\n+             });\\\\\\\\n+          }\\\\\\\\n+          _each(data, function(task) {\\\\\\\\n+              var item = {\\\\\\\\n+                  data: task,\\\\\\\\n+                  callback: typeof callback === 'function' ? callback : null\\\\\\\\n+              };\\\\\\\\n+\\\\\\\\n+              if (pos) {\\\\\\\\n+                q.tasks.unshift(item);\\\\\\\\n+              } else {\\\\\\\\n+                q.tasks.push(item);\\\\\\\\n+              }\\\\\\\\n+\\\\\\\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\\\\\\\n+                  q.saturated();\\\\\\\\n+              }\\\\\\\\n+              async.setImmediate(q.process);\\\\\\\\n+          });\\\\\\\\n+        }\\\\\\\\n+\\\\\\\\n+        var workers = 0;\\\\\\\\n+        var q = {\\\\\\\\n+            tasks: [],\\\\\\\\n+            concurrency: concurrency,\\\\\\\\n+            saturated: null,\\\\\\\\n+            empty: null,\\\\\\\\n+            drain: null,\\\\\\\\n+            started: false,\\\\\\\\n+            paused: false,\\\\\\\\n+            push: function (data, callback) {\\\\\\\\n+              _insert(q, data, false, callback);\\\\\\\\n+            },\\\\\\\\n+            kill: function () {\\\\\\\\n+              q.drain = null;\\\\\\\\n+              q.tasks = [];\\\\\\\\n+            },\\\\\\\\n+            unshift: function (data, callback) {\\\\\\\\n+              _insert(q, data, true, callback);\\\\\\\\n+            },\\\\\\\\n+            process: function () {\\\\\\\\n+                if (!q.paused && workers < q.concurrency && q.tasks.length) {\\\\\\\\n+                    var task = q.tasks.shift();\\\\\\\\n+                    if (q.empty && q.tasks.length === 0) {\\\\\\\\n+                        q.empty();\\\\\\\\n+                    }\\\\\\\\n+                    workers += 1;\\\\\\\\n+                    var next = function () {\\\\\\\\n+                        workers -= 1;\\\\\\\\n+                        if (task.callback) {\\\\\\\\n+                            task.callback.apply(task, arguments);\\\\\\\\n+                        }\\\\\\\\n+                        if (q.drain && q.tasks.length + workers === 0) {\\\\\\\\n+                            q.drain();\\\\\\\\n+                        }\\\\\\\\n+                        q.process();\\\\\\\\n+                    };\\\\\\\\n+                    var cb = only_once(next);\\\\\\\\n+                    worker(task.data, cb);\\\\\\\\n+                }\\\\\\\\n+            },\\\\\\\\n+            length: function () {\\\\\\\\n+                return q.tasks.length;\\\\\\\\n+            },\\\\\\\\n+            running: function () {\\\\\\\\n+                return workers;\\\\\\\\n+            },\\\\\\\\n+            idle: function() {\\\\\\\\n+                return q.tasks.length + workers === 0;\\\\\\\\n+            },\\\\\\\\n+            pause: function () {\\\\\\\\n+                if (q.paused === true) { return; }\\\\\\\\n+                q.paused = true;\\\\\\\\n+                q.process();\\\\\\\\n+            },\\\\\\\\n+            resume: function () {\\\\\\\\n+                if (q.paused === false) { return; }\\\\\\\\n+                q.paused = false;\\\\\\\\n+                q.process();\\\\\\\\n+            }\\\\\\\\n+        };\\\\\\\\n+        return q;\\\\\\\\n+    };\\\\\\\\n+    \\\\\\\\n+    async.priorityQueue = function (worker, concurrency) {\\\\\\\\n+        \\\\\\\\n+        function _compareTasks(a, b){\\\\\\\\n+          return a.priority - b.priority;\\\\\\\\n+        };\\\\\\\\n+        \\\\\\\\n+        function _binarySearch(sequence, item, compare) {\\\\\\\\n+          var beg = -1,\\\\\\\\n+              end = sequence.length - 1;\\\\\\\\n+          while (beg < end) {\\\\\\\\n+            var mid = beg + ((end - beg + 1) >>> 1);\\\\\\\\n+            if (compare(item, sequence[mid]) >= 0) {\\\\\\\\n+              beg = mid;\\\\\\\\n+            } else {\\\\\\\\n+              end = mid - 1;\\\\\\\\n+            }\\\\\\\\n+          }\\\\\\\\n+          return beg;\\\\\\\\n+        }\\\\\\\\n+        \\\\\\\\n+        function _insert(q, data, priority, callback) {\\\\\\\\n+          if (!q.started){\\\\\\\\n+            q.started = true;\\\\\\\\n+          }\\\\\\\\n+          if (!_isArray(data)) {\\\\\\\\n+              data = [data];\\\\\\\\n+          }\\\\\\\\n+          if(data.length == 0) {\\\\\\\\n+             // call drain immediately if there are no tasks\\\\\\\\n+             return async.setImmediate(function() {\\\\\\\\n+                 if (q.drain) {\\\\\\\\n+                     q.drain();\\\\\\\\n+                 }\\\\\\\\n+             });\\\\\\\\n+          }\\\\\\\\n+          _each(data, function(task) {\\\\\\\\n+              var item = {\\\\\\\\n+                  data: task,\\\\\\\\n+                  priority: priority,\\\\\\\\n+                  callback: typeof callback === 'function' ? callback : null\\\\\\\\n+              };\\\\\\\\n+              \\\\\\\\n+              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\\\\\\\\n+\\\\\\\\n+              if (q.saturated && q.tasks.length === q.concurrency) {\\\\\\\\n+                  q.saturated();\\\\\\\\n+              }\\\\\\\\n+              async.setImmediate(q.process);\\\\\\\\n+          });\\\\\\\\n+        }\\\\\\\\n+        \\\\\\\\n+        // Start with a normal queue\\\\\\\\n+        var q = async.queue(worker, concurrency);\\\\\\\\n+        \\\\\\\\n+        // Override push to accept second parameter representing priority\\\\\\\\n+        q.push = function (data, priority, callback) {\\\\\\\\n+          _insert(q, data, priority, callback);\\\\\\\\n+        };\\\\\\\\n+        \\\\\\\\n+        // Remove unshift function\\\\\\\\n+        delete q.unshift;\\\\\\\\n+\\\\\\\\n+        return q;\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.cargo = function (worker, payload) {\\\\\\\\n+        var working     = false,\\\\\\\\n+            tasks       = [];\\\\\\\\n+\\\\\\\\n+        var cargo = {\\\\\\\\n+            tasks: tasks,\\\\\\\\n+            payload: payload,\\\\\\\\n+            saturated: null,\\\\\\\\n+            empty: null,\\\\\\\\n+            drain: null,\\\\\\\\n+            drained: true,\\\\\\\\n+            push: function (data, callback) {\\\\\\\\n+                if (!_isArray(data)) {\\\\\\\\n+                    data = [data];\\\\\\\\n+                }\\\\\\\\n+                _each(data, function(task) {\\\\\\\\n+                    tasks.push({\\\\\\\\n+                        data: task,\\\\\\\\n+                        callback: typeof callback === 'function' ? callback : null\\\\\\\\n+                    });\\\\\\\\n+                    cargo.drained = false;\\\\\\\\n+                    if (cargo.saturated && tasks.length === payload) {\\\\\\\\n+                        cargo.saturated();\\\\\\\\n+                    }\\\\\\\\n+                });\\\\\\\\n+                async.setImmediate(cargo.process);\\\\\\\\n+            },\\\\\\\\n+            process: function process() {\\\\\\\\n+                if (working) return;\\\\\\\\n+                if (tasks.length === 0) {\\\\\\\\n+                    if(cargo.drain && !cargo.drained) cargo.drain();\\\\\\\\n+                    cargo.drained = true;\\\\\\\\n+                    return;\\\\\\\\n+                }\\\\\\\\n+\\\\\\\\n+                var ts = typeof payload === 'number'\\\\\\\\n+                            ? tasks.splice(0, payload)\\\\\\\\n+                            : tasks.splice(0, tasks.length);\\\\\\\\n+\\\\\\\\n+                var ds = _map(ts, function (task) {\\\\\\\\n+                    return task.data;\\\\\\\\n+                });\\\\\\\\n+\\\\\\\\n+                if(cargo.empty) cargo.empty();\\\\\\\\n+                working = true;\\\\\\\\n+                worker(ds, function () {\\\\\\\\n+                    working = false;\\\\\\\\n+\\\\\\\\n+                    var args = arguments;\\\\\\\\n+                    _each(ts, function (data) {\\\\\\\\n+                        if (data.callback) {\\\\\\\\n+                            data.callback.apply(null, args);\\\\\\\\n+                        }\\\\\\\\n+                    });\\\\\\\\n+\\\\\\\\n+                    process();\\\\\\\\n+                });\\\\\\\\n+            },\\\\\\\\n+            length: function () {\\\\\\\\n+                return tasks.length;\\\\\\\\n+            },\\\\\\\\n+            running: function () {\\\\\\\\n+                return working;\\\\\\\\n+            }\\\\\\\\n+        };\\\\\\\\n+        return cargo;\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    var _console_fn = function (name) {\\\\\\\\n+        return function (fn) {\\\\\\\\n+            var args = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+            fn.apply(null, args.concat([function (err) {\\\\\\\\n+                var args = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+                if (typeof console !== 'undefined') {\\\\\\\\n+                    if (err) {\\\\\\\\n+                        if (console.error) {\\\\\\\\n+                            console.error(err);\\\\\\\\n+                        }\\\\\\\\n+                    }\\\\\\\\n+                    else if (console[name]) {\\\\\\\\n+                        _each(args, function (x) {\\\\\\\\n+                            console[name](x);\\\\\\\\n+                        });\\\\\\\\n+                    }\\\\\\\\n+                }\\\\\\\\n+            }]));\\\\\\\\n+        };\\\\\\\\n+    };\\\\\\\\n+    async.log = _console_fn('log');\\\\\\\\n+    async.dir = _console_fn('dir');\\\\\\\\n+    /*async.info = _console_fn('info');\\\\\\\\n+    async.warn = _console_fn('warn');\\\\\\\\n+    async.error = _console_fn('error');*/\\\\\\\\n+\\\\\\\\n+    async.memoize = function (fn, hasher) {\\\\\\\\n+        var memo = {};\\\\\\\\n+        var queues = {};\\\\\\\\n+        hasher = hasher || function (x) {\\\\\\\\n+            return x;\\\\\\\\n+        };\\\\\\\\n+        var memoized = function () {\\\\\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\\\\\n+            var callback = args.pop();\\\\\\\\n+            var key = hasher.apply(null, args);\\\\\\\\n+            if (key in memo) {\\\\\\\\n+                async.nextTick(function () {\\\\\\\\n+                    callback.apply(null, memo[key]);\\\\\\\\n+                });\\\\\\\\n+            }\\\\\\\\n+            else if (key in queues) {\\\\\\\\n+                queues[key].push(callback);\\\\\\\\n+            }\\\\\\\\n+            else {\\\\\\\\n+                queues[key] = [callback];\\\\\\\\n+                fn.apply(null, args.concat([function () {\\\\\\\\n+                    memo[key] = arguments;\\\\\\\\n+                    var q = queues[key];\\\\\\\\n+                    delete queues[key];\\\\\\\\n+                    for (var i = 0, l = q.length; i < l; i++) {\\\\\\\\n+                      q[i].apply(null, arguments);\\\\\\\\n+                    }\\\\\\\\n+                }]));\\\\\\\\n+            }\\\\\\\\n+        };\\\\\\\\n+        memoized.memo = memo;\\\\\\\\n+        memoized.unmemoized = fn;\\\\\\\\n+        return memoized;\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.unmemoize = function (fn) {\\\\\\\\n+      return function () {\\\\\\\\n+        return (fn.unmemoized || fn).apply(null, arguments);\\\\\\\\n+      };\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.times = function (count, iterator, callback) {\\\\\\\\n+        var counter = [];\\\\\\\\n+        for (var i = 0; i < count; i++) {\\\\\\\\n+            counter.push(i);\\\\\\\\n+        }\\\\\\\\n+        return async.map(counter, iterator, callback);\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.timesSeries = function (count, iterator, callback) {\\\\\\\\n+        var counter = [];\\\\\\\\n+        for (var i = 0; i < count; i++) {\\\\\\\\n+            counter.push(i);\\\\\\\\n+        }\\\\\\\\n+        return async.mapSeries(counter, iterator, callback);\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.seq = function (/* functions... */) {\\\\\\\\n+        var fns = arguments;\\\\\\\\n+        return function () {\\\\\\\\n+            var that = this;\\\\\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\\\\\n+            var callback = args.pop();\\\\\\\\n+            async.reduce(fns, args, function (newargs, fn, cb) {\\\\\\\\n+                fn.apply(that, newargs.concat([function () {\\\\\\\\n+                    var err = arguments[0];\\\\\\\\n+                    var nextargs = Array.prototype.slice.call(arguments, 1);\\\\\\\\n+                    cb(err, nextargs);\\\\\\\\n+                }]))\\\\\\\\n+            },\\\\\\\\n+            function (err, results) {\\\\\\\\n+                callback.apply(that, [err].concat(results));\\\\\\\\n+            });\\\\\\\\n+        };\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    async.compose = function (/* functions... */) {\\\\\\\\n+      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    var _applyEach = function (eachfn, fns /*args...*/) {\\\\\\\\n+        var go = function () {\\\\\\\\n+            var that = this;\\\\\\\\n+            var args = Array.prototype.slice.call(arguments);\\\\\\\\n+            var callback = args.pop();\\\\\\\\n+            return eachfn(fns, function (fn, cb) {\\\\\\\\n+                fn.apply(that, args.concat([cb]));\\\\\\\\n+            },\\\\\\\\n+            callback);\\\\\\\\n+        };\\\\\\\\n+        if (arguments.length > 2) {\\\\\\\\n+            var args = Array.prototype.slice.call(arguments, 2);\\\\\\\\n+            return go.apply(this, args);\\\\\\\\n+        }\\\\\\\\n+        else {\\\\\\\\n+            return go;\\\\\\\\n+        }\\\\\\\\n+    };\\\\\\\\n+    async.applyEach = doParallel(_applyEach);\\\\\\\\n+    async.applyEachSeries = doSeries(_applyEach);\\\\\\\\n+\\\\\\\\n+    async.forever = function (fn, callback) {\\\\\\\\n+        function next(err) {\\\\\\\\n+            if (err) {\\\\\\\\n+                if (callback) {\\\\\\\\n+                    return callback(err);\\\\\\\\n+                }\\\\\\\\n+                throw err;\\\\\\\\n+            }\\\\\\\\n+            fn(next);\\\\\\\\n+        }\\\\\\\\n+        next();\\\\\\\\n+    };\\\\\\\\n+\\\\\\\\n+    // Node.js\\\\\\\\n+    if (typeof module !== 'undefined' && module.exports) {\\\\\\\\n+        module.exports = async;\\\\\\\\n+    }\\\\\\\\n+    // AMD / RequireJS\\\\\\\\n+    else if (typeof define !== 'undefined' && define.amd) {\\\\\\\\n+        define([], function () {\\\\\\\\n+            return async;\\\\\\\\n+        });\\\\\\\\n+    }\\\\\\\\n+    // included directly via <script> tag\\\\\\\\n+    else {\\\\\\\\n+        root.async = async;\\\\\\\\n+    }\\\\\\\\n+\\\\\\\\n+}());\\\\\\\\ndiff --git a/node_modules/async/package.json b/node_modules/async/package.json\\\\\\\\nnew file mode 100644\\\\\\\\nindex 0000000..31a5200\\\\\\\\n--- /dev/null\\\\\\\\n+++ b/node_modules/async/package.json\\\\\\\\n@@ -0,0 +1,59 @@\\\\\\\\n+{\\\\\\\\n+  \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"async\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Higher-order functions and common patterns for asynchronous code\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"main\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"./lib/async\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"author\\\\\\\\\\\\\\\": {\\\\\\\\n+    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Caolan McMahon\\\\\\\\\\\\\\\"\\\\\\\\n+  },\\\\\\\\n+  \\\\\\\\\\\\\\\"version\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"0.9.0\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"repository\\\\\\\\\\\\\\\": {\\\\\\\\n+    \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"git\\\\\\\\\\\\\\\",\\\\\\\\n+    \\\\\\\\\\\\\\\"url\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"https://github.com/caolan/async.git\\\\\\\\\\\\\\\"\\\\\\\\n+  },\\\\\\\\n+  \\\\\\\\\\\\\\\"bugs\\\\\\\\\\\\\\\": {\\\\\\\\n+    \\\\\\\\\\\\\\\"url\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"https://github.com/caolan/async/issues\\\\\\\\\\\\\\\"\\\\\\\\n+  },\\\\\\\\n+  \\\\\\\\\\\\\\\"licenses\\\\\\\\\\\\\\\": [\\\\\\\\n+    {\\\\\\\\n+      \\\\\\\\\\\\\\\"type\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"MIT\\\\\\\\\\\\\\\",\\\\\\\\n+      \\\\\\\\\\\\\\\"url\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"https://github.com/caolan/async/raw/master/LICENSE\\\\\\\\\\\\\\\"\\\\\\\\n+    }\\\\\\\\n+  ],\\\\\\\\n+  \\\\\\\\\\\\\\\"devDependencies\\\\\\\\\\\\\\\": {\\\\\\\\n+    \\\\\\\\\\\\\\\"nodeunit\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\">0.0.0\\\\\\\\\\\\\\\",\\\\\\\\n+    \\\\\\\\\\\\\\\"uglify-js\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"1.2.x\\\\\\\\\\\\\\\",\\\\\\\\n+    \\\\\\\\\\\\\\\"nodelint\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\">0.0.0\\\\\\\\\\\\\\\"\\\\\\\\n+  },\\\\\\\\n+  \\\\\\\\\\\\\\\"jam\\\\\\\\\\\\\\\": {\\\\\\\\n+    \\\\\\\\\\\\\\\"main\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"lib/async.js\\\\\\\\\\\\\\\",\\\\\\\\n+    \\\\\\\\\\\\\\\"include\\\\\\\\\\\\\\\": [\\\\\\\\n+      \\\\\\\\\\\\\\\"lib/async.js\\\\\\\\\\\\\\\",\\\\\\\\n+      \\\\\\\\\\\\\\\"README.md\\\\\\\\\\\\\\\",\\\\\\\\n+      \\\\\\\\\\\\\\\"LICENSE\\\\\\\\\\\\\\\"\\\\\\\\n+    ]\\\\\\\\n+  },\\\\\\\\n+  \\\\\\\\\\\\\\\"scripts\\\\\\\\\\\\\\\": {\\\\\\\\n+    \\\\\\\\\\\\\\\"test\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"nodeunit test/test-async.js\\\\\\\\\\\\\\\"\\\\\\\\n+  },\\\\\\\\n+  \\\\\\\\\\\\\\\"homepage\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"https://github.com/caolan/async\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"_id\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"async@0.9.0\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"dist\\\\\\\\\\\\\\\": {\\\\\\\\n+    \\\\\\\\\\\\\\\"shasum\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\\\\\\\\\\\\\",\\\\\\\\n+    \\\\\\\\\\\\\\\"tarball\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"http://registry.npmjs.org/async/-/async-0.9.0.tgz\\\\\\\\\\\\\\\"\\\\\\\\n+  },\\\\\\\\n+  \\\\\\\\\\\\\\\"_from\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"async@*\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"_npmVersion\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"1.4.3\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"_npmUser\\\\\\\\\\\\\\\": {\\\\\\\\n+    \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"caolan\\\\\\\\\\\\\\\",\\\\\\\\n+    \\\\\\\\\\\\\\\"email\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"caolan.mcmahon@gmail.com\\\\\\\\\\\\\\\"\\\\\\\\n+  },\\\\\\\\n+  \\\\\\\\\\\\\\\"maintainers\\\\\\\\\\\\\\\": [\\\\\\\\n+    {\\\\\\\\n+      \\\\\\\\\\\\\\\"name\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"caolan\\\\\\\\\\\\\\\",\\\\\\\\n+      \\\\\\\\\\\\\\\"email\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"caolan@caolanmcmahon.com\\\\\\\\\\\\\\\"\\\\\\\\n+    }\\\\\\\\n+  ],\\\\\\\\n+  \\\\\\\\\\\\\\\"directories\\\\\\\\\\\\\\\": {},\\\\\\\\n+  \\\\\\\\\\\\\\\"_shasum\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"ac3613b1da9bed1b47510bb4651b8931e47146c7\\\\\\\\\\\\\\\",\\\\\\\\n+  \\\\\\\\\\\\\\\"_resolved\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"https://registry.npmjs.org/async/-/async-0.9.0.tgz\\\\\\\\\\\\\\\"\\\\\\\\n+}\\\\\\\\ndiff --git a/package.json b/package.json\\\\\\\\nindex 5f21627..6033d43 100644\\\\\\\\n--- a/package.json\\\\\\\\n+++ b/package.json\\\\\\\\n@@ -4,7 +4,8 @@\\\\\\\\n   \\\\\\\\\\\\\\\"description\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"Sous project\\\\\\\\\\\\\\\",\\\\\\\\n   \\\\\\\\\\\\\\\"main\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"main.js\\\\\\\\\\\\\\\",\\\\\\\\n   \\\\\\\\\\\\\\\"dependencies\\\\\\\\\\\\\\\": {\\\\\\\\n-},\\\\\\\\n+    \\\\\\\\\\\\\\\"async\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"*\\\\\\\\\\\\\\\"\\\\\\\\n+  },\\\\\\\\n   \\\\\\\\\\\\\\\"devDependencies\\\\\\\\\\\\\\\": {},\\\\\\\\n   \\\\\\\\\\\\\\\"scripts\\\\\\\\\\\\\\\": {\\\\\\\\n     \\\\\\\\\\\\\\\"test\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\"echo \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"Error: no test specified\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" && exit 1\\\\\\\\\\\\\\\"\\\\\\\\ndiff --git a/patches.sousp b/patches.sousp\\\\\\\\nindex 16405a3..d71e511 100644\\\\\\\\n--- a/patches.sousp\\\\\\\\n+++ b/patches.sousp\\\\\\\\n@@ -1,31 +1 @@\\\\\\\\n-diff --git a/main.js b/main.js\\\\\\\\n-index f81b54e..744cdd5 100644\\\\\\\\n---- a/main.js\\\\\\\\n-+++ b/main.js\\\\\\\\n-@@ -35,7 +35,7 @@ fs.exists('.git', function (exists) {\\\\\\\\n-         cp.exec('git diff', function(error, stdout, stderr) {\\\\\\\\n-             console.log(stdout);\\\\\\\\n- \\\\\\\\n--            //fs.writeFileSync(\\\\\\\\\\\\\\\"patches.sousp\\\\\\\\\\\\\\\", stdout);\\\\\\\\n-+            fs.writeFileSync(\\\\\\\\\\\\\\\"patches.sousp\\\\\\\\\\\\\\\", stdout);\\\\\\\\n- \\\\\\\\n-             if (error !== null) {\\\\\\\\n-                 console.log('stderr: ' + stderr);\\\\\\\\n-@@ -44,7 +44,7 @@ fs.exists('.git', function (exists) {\\\\\\\\n-         });\\\\\\\\n- \\\\\\\\n-         cp.exec('git log', function(error, stdout, stderr) {\\\\\\\\n--            //console.log(stdout);\\\\\\\\n-+            console.log(stdout);\\\\\\\\n- \\\\\\\\n-             var authors = findData(stdout, \\\\\\\\\\\\\\\"Author:\\\\\\\\\\\\\\\");\\\\\\\\n-             var dates = findData(stdout, \\\\\\\\\\\\\\\"Date:\\\\\\\\\\\\\\\");\\\\\\\\n-@@ -53,7 +53,7 @@ fs.exists('.git', function (exists) {\\\\\\\\n-             console.log(comments);\\\\\\\\n-             console.log(dates);\\\\\\\\n- \\\\\\\\n--            //fs.writeFileSync(\\\\\\\\\\\\\\\"comments.sousc\\\\\\\\\\\\\\\", stdout);\\\\\\\\n-+            fs.writeFileSync(\\\\\\\\\\\\\\\"comments.sousc\\\\\\\\\\\\\\\", stdout);\\\\\\\\n- \\\\\\\\n-             if (error !== null) {\\\\\\\\n-                 console.log('stderr: ' + stderr);\\\\\\\\n+[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]\\\\\\\\n\\\\\\\\\\\\\\\\ No newline at end of file\\\\\\\\ndiff --git a/test.js b/test.js\\\\\\\\nnew file mode 100644\\\\\\\\nindex 0000000..5ca759c\\\\\\\\n--- /dev/null\\\\\\\\n+++ b/test.js\\\\\\\\n@@ -0,0 +1,21 @@\\\\\\\\n+/**\\\\\\\\n+ * Created by Nick on 18.05.2015.\\\\\\\\n+ */\\\\\\\\n+var async = require('async')\\\\\\\\n+    , tasksIndex = [\\\\\\\\n+        function (callback) {\\\\\\\\n+            // Вымышленный метод который вернет 231\\\\\\\\n+            var viewsNumber = models.stat.viewsNumber();\\\\\\\\n+            callback(null, viewsNumber);\\\\\\\\n+        }\\\\\\\\n+        , function (callback) {\\\\\\\\n+            // Вымышленный метод который вернет 24\\\\\\\\n+            var growFactor = models.stat.growFactor();\\\\\\\\n+            callback(null, growFactor);\\\\\\\\n+        }\\\\\\\\n+    ];\\\\\\\\n+\\\\\\\\n+async.series(tasksIndex, function (err, results) {\\\\\\\\n+    // Результат будет массивом\\\\\\\\n+    console.log(results); // [231, 24]\\\\\\\\n+});\\\\\\\\n\\\\\\\\\\\\\\\\ No newline at end of file\\\\\\\\n\\\\\\\"}\\\\n\\\\\\\\ No newline at end of file\\\\n\\\"}\\n\\\\ No newline at end of file\\n\"}\n\\ No newline at end of file\n"}] }