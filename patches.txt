{"commit":"1e947f613e976945de85ae35ed923aa470f0be72","author":"Nick Stepanenko <massaalonso@yandex.ru>","date":"Tue May 19 00:12:12 2015 +0800","comment":"Latest updates","content":"diff --git a/comments.sousc b/comments.sousc\nindex 150b0f6..cb3a850 100644\n--- a/comments.sousc\n+++ b/comments.sousc\n@@ -1,3 +1,27 @@\n+commit 4420cabefc1f470af341af11ed595df67e25c51f\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\n+Date:   Sun May 17 17:05:35 2015 +0800\n+\n+    Paste old program code\n+\n+commit 9ef3d25fd4c3afdbcc3107a0abf6d7a2e29cb4dd\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\n+Date:   Sun May 17 17:04:52 2015 +0800\n+\n+    Adding new file\n+\n+commit 64814d140d2fab6ae153cac485008119f29bf230\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\n+Date:   Sun May 17 17:03:58 2015 +0800\n+\n+    From clear list\n+\n+commit c9d318fea74ea288d544ecf72f00b12c130cf2ef\n+Author: Nick Stepanenko <massaalonso@yandex.ru>\n+Date:   Sun May 17 16:59:40 2015 +0800\n+\n+    Create system files\n+\n commit e3c853a4282dfe8f000685dc1d39bd55a4a946c4\n Author: Nick Stepanenko <massaalonso@yandex.ru>\n Date:   Sun May 17 16:54:58 2015 +0800\ndiff --git a/main.js b/main.js\nindex e34dc18..86f30c2 100644\n--- a/main.js\n+++ b/main.js\n@@ -3,6 +3,56 @@\n  */\n \n var fs = require('fs');\n+var cp = require('child_process');\n+var data = [];\n+\n+var async = require('async');\n+    /*tasks = [\n+        function (callback) {\n+            cp.exec('git log', function(error, stdout, stderr) {\n+                var listOfCommits = [];\n+                var authors = findData(stdout, \"Author:\");\n+                var dates = findData(stdout, \"Date:\");\n+                var comments = findComments(stdout);\n+                var commitNumbers = findCommitNumbers(stdout);\n+\n+                for(i=0; i<authors.length; i++) {\n+                    var commit = {\n+                        \"commit\": commitNumbers[i],\n+                        \"author\": authors[i],\n+                        \"date\": dates[i],\n+                        \"comment\": comments[i],\n+                        \"content\": 'Original'\n+                    };\n+\n+                    listOfCommits[listOfCommits.length] = commit;\n+                }\n+\n+                data = listOfCommits.reverse();\n+\n+                callback(null, data);\n+\n+                if (error !== null) {\n+                    console.log('stderr: ' + stderr);\n+                    console.log('exec error: ' + error);\n+                }\n+            });\n+        }\n+    ],\n+    secondTasks = [\n+        function some_function(callback) {\n+            cp.exec('git diff', function(error, stdout, stderr) {\n+                var currentContent = stdout;\n+\n+                if (error !== null) {\n+                    console.log('stderr: ' + stderr);\n+                    console.log('exec error: ' + error);\n+                }\n+\n+                callback(null, currentContent);\n+            });\n+        }\n+    ];*/\n \n function findData(text, keyword) {\n     var data = [];\n@@ -28,38 +78,106 @@ function findComments(text) {\n     return comments;\n }\n \n+function findCommitNumbers(text) {\n+    var commits = [];\n+    var splittext = text.split('\\n');\n+\n+    for(i=0; i<splittext.length; i++) {\n+        if(splittext[i].slice(0, 6) == \"commit\") {\n+            commits[commits.length] = splittext[i].slice(6).trim();\n+        }\n+    }\n+\n+    return commits;\n+}\n+\n+/*function pullCommitContent(first, second) {\n+\n+    cp.exec('git diff' + ' ' + first + ' ' + second, function(error, stdout, stderr) {\n+        var currentContent = stdout;\n+\n+        if (error !== null) {\n+            console.log('stderr: ' + stderr);\n+            console.log('exec error: ' + error);\n+        }\n+\n+        return currentContent;\n+    });\n+}*/\n+\n+var commitsInfo = [];\n+\n fs.exists('.git', function (exists) {\n     if(exists) {\n-        var cp = require('child_process');\n+        /*async.series(tasks, function(err, result) {\n+            fs.writeFileSync(\"patches.sousp\", JSON.stringify(result));\n+\n+            var data = result[0];\n \n-        cp.exec('git diff', function(error, stdout, stderr) {\n-            console.log(stdout);\n+            /*function some_function(arg1, arg2, callback) {\n+                cp.exec('git diff' + ' ' + arg1 + ' ' + arg2, function(error, stdout, stderr) {\n+                    var currentContent = 54321;//stdout;\n \n-            fs.writeFileSync(\"patches.sousp\", stdout);\n+                    if (error !== null) {\n+                        console.log('stderr: ' + stderr);\n+                        console.log('exec error: ' + error);\n+                    }\n \n-            if (error !== null) {\n-                console.log('stderr: ' + stderr);\n-                console.log('exec error: ' + error);\n+                    callback(null, currentContent);\n+                });\n             }\n-        });\n+        });*/\n+\n+        async.waterfall([\n+            function getCommitsInfo(callback) {\n+                cp.exec('git log', function(error, stdout, stderr) {\n+                    var listOfCommits = [];\n+                    var authors = findData(stdout, \"Author:\");\n+                    var dates = findData(stdout, \"Date:\");\n+                    var comments = findComments(stdout);\n+                    var commitNumbers = findCommitNumbers(stdout);\n \n-        cp.exec('git log', function(error, stdout, stderr) {\n-            console.log(stdout);\n+                    for(i=0; i<authors.length; i++) {\n+                        var commit = {\n+                            \"commit\": commitNumbers[i],\n+                            \"author\": authors[i],\n+                            \"date\": dates[i],\n+                            \"comment\": comments[i],\n+                            \"content\": 'Original'\n+                        };\n+                        listOfCommits[listOfCommits.length] = commit;\n+                    }\n \n-            var authors = findData(stdout, \"Author:\");\n-            var dates = findData(stdout, \"Date:\");\n-            var comments = findComments(stdout);\n-            console.log(authors);\n-            console.log(comments);\n-            console.log(dates);\n+                    callback(null, listOfCommits.reverse());\n \n-            fs.writeFileSync(\"comments.sousc\", stdout);\n+                    if (error !== null) {\n+                        console.log('stderr: ' + stderr);\n+                        console.log('exec error: ' + error);\n+                    }\n+                });\n+            },\n+            function getCommitsContent(commits, callback) {\n+                console.log(commits);\n+                var commitsData = commits;\n \n-            if (error !== null) {\n-                console.log('stderr: ' + stderr);\n-                console.log('exec error: ' + error);\n+                for(i=1; i<commitsData.length; i++) {\n+                    cp.exec('git diff' + ' ' + commitsData[i-1].commit + ' ' + commitsData[i].commit, function(error, stdout, stderr) {\n+                        commitsData[i].content = stdout;\n+\n+                        if (error !== null) {\n+                            console.log('stderr: ' + stderr);\n+                            console.log('exec error: ' + error);\n+                        }\n+                    });\n+                }\n+\n+                callback(null, commitsData);\n             }\n+        ], function (err, result) {\n+            fs.writeFileSync(\"patches.sousp\", result);\n         });\n+\n+        //commitsInfo = JSON.parse(fs.readFileSync(\"patches.sousp\"));\n+        //console.log(commitsInfo);\n     }\n-    else console.log(\"Error.\");\n });\n\\ No newline at end of file\ndiff --git a/node_modules/async/.travis.yml b/node_modules/async/.travis.yml\nnew file mode 100644\nindex 0000000..6e5919d\n--- /dev/null\n+++ b/node_modules/async/.travis.yml\n@@ -0,0 +1,3 @@\n+language: node_js\n+node_js:\n+  - \"0.10\"\ndiff --git a/node_modules/async/LICENSE b/node_modules/async/LICENSE\nnew file mode 100644\nindex 0000000..8f29698\n--- /dev/null\n+++ b/node_modules/async/LICENSE\n@@ -0,0 +1,19 @@\n+Copyright (c) 2010-2014 Caolan McMahon\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in\n+all copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+THE SOFTWARE.\ndiff --git a/node_modules/async/README.md b/node_modules/async/README.md\nnew file mode 100644\nindex 0000000..0bea531\n--- /dev/null\n+++ b/node_modules/async/README.md\n@@ -0,0 +1,1646 @@\n+# Async.js\n+\n+[![Build Status via Travis CI](https://travis-ci.org/caolan/async.svg?branch=master)](https://travis-ci.org/caolan/async)\n+\n+\n+Async is a utility module which provides straight-forward, powerful functions\n+for working with asynchronous JavaScript. Although originally designed for\n+use with [Node.js](http://nodejs.org), it can also be used directly in the\n+browser. Also supports [component](https://github.com/component/component).\n+\n+Async provides around 20 functions that include the usual 'functional'\n+suspects (`map`, `reduce`, `filter`, `each`…) as well as some common patterns\n+for asynchronous control flow (`parallel`, `series`, `waterfall`…). All these\n+functions assume you follow the Node.js convention of providing a single\n+callback as the last argument of your `async` function.\n+\n+\n+## Quick Examples\n+\n+```javascript\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\n+    // results is now an array of stats for each file\n+});\n+\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\n+    // results now equals an array of the existing files\n+});\n+\n+async.parallel([\n+    function(){ ... },\n+    function(){ ... }\n+], callback);\n+\n+async.series([\n+    function(){ ... },\n+    function(){ ... }\n+]);\n+```\n+\n+There are many more functions available so take a look at the docs below for a\n+full list. This module aims to be comprehensive, so if you feel anything is\n+missing please create a GitHub issue for it.\n+\n+## Common Pitfalls\n+\n+### Binding a context to an iterator\n+\n+This section is really about `bind`, not about `async`. If you are wondering how to\n+make `async` execute your iterators in a given context, or are confused as to why\n+a method of another library isn't working as an iterator, study this example:\n+\n+```js\n+// Here is a simple object with an (unnecessarily roundabout) squaring method\n+var AsyncSquaringLibrary = {\n+  squareExponent: 2,\n+  square: function(number, callback){ \n+    var result = Math.pow(number, this.squareExponent);\n+    setTimeout(function(){\n+      callback(null, result);\n+    }, 200);\n+  }\n+};\n+\n+async.map([1, 2, 3], AsyncSquaringLibrary.square, function(err, result){\n+  // result is [NaN, NaN, NaN]\n+  // This fails because the `this.squareExponent` expression in the square\n+  // function is not evaluated in the context of AsyncSquaringLibrary, and is\n+  // therefore undefined.\n+});\n+\n+async.map([1, 2, 3], AsyncSquaringLibrary.square.bind(AsyncSquaringLibrary), function(err, result){\n+  // result is [1, 4, 9]\n+  // With the help of bind we can attach a context to the iterator before\n+  // passing it to async. Now the square function will be executed in its \n+  // 'home' AsyncSquaringLibrary context and the value of `this.squareExponent`\n+  // will be as expected.\n+});\n+```\n+\n+## Download\n+\n+The source is available for download from\n+[GitHub](http://github.com/caolan/async).\n+Alternatively, you can install using Node Package Manager (`npm`):\n+\n+    npm install async\n+\n+__Development:__ [async.js](https://github.com/caolan/async/raw/master/lib/async.js) - 29.6kb Uncompressed\n+\n+## In the Browser\n+\n+So far it's been tested in IE6, IE7, IE8, FF3.6 and Chrome 5. \n+\n+Usage:\n+\n+```html\n+<script type=\"text/javascript\" src=\"async.js\"></script>\n+<script type=\"text/javascript\">\n+\n+    async.map(data, asyncProcess, function(err, results){\n+        alert(results);\n+    });\n+\n+</script>\n+```\n+\n+## Documentation\n+\n+### Collections\n+\n+* [`each`](#each)\n+* [`eachSeries`](#eachSeries)\n+* [`eachLimit`](#eachLimit)\n+* [`map`](#map)\n+* [`mapSeries`](#mapSeries)\n+* [`mapLimit`](#mapLimit)\n+* [`filter`](#filter)\n+* [`filterSeries`](#filterSeries)\n+* [`reject`](#reject)\n+* [`rejectSeries`](#rejectSeries)\n+* [`reduce`](#reduce)\n+* [`reduceRight`](#reduceRight)\n+* [`detect`](#detect)\n+* [`detectSeries`](#detectSeries)\n+* [`sortBy`](#sortBy)\n+* [`some`](#some)\n+* [`every`](#every)\n+* [`concat`](#concat)\n+* [`concatSeries`](#concatSeries)\n+\n+### Control Flow\n+\n+* [`series`](#seriestasks-callback)\n+* [`parallel`](#parallel)\n+* [`parallelLimit`](#parallellimittasks-limit-callback)\n+* [`whilst`](#whilst)\n+* [`doWhilst`](#doWhilst)\n+* [`until`](#until)\n+* [`doUntil`](#doUntil)\n+* [`forever`](#forever)\n+* [`waterfall`](#waterfall)\n+* [`compose`](#compose)\n+* [`seq`](#seq)\n+* [`applyEach`](#applyEach)\n+* [`applyEachSeries`](#applyEachSeries)\n+* [`queue`](#queue)\n+* [`priorityQueue`](#priorityQueue)\n+* [`cargo`](#cargo)\n+* [`auto`](#auto)\n+* [`retry`](#retry)\n+* [`iterator`](#iterator)\n+* [`apply`](#apply)\n+* [`nextTick`](#nextTick)\n+* [`times`](#times)\n+* [`timesSeries`](#timesSeries)\n+\n+### Utils\n+\n+* [`memoize`](#memoize)\n+* [`unmemoize`](#unmemoize)\n+* [`log`](#log)\n+* [`dir`](#dir)\n+* [`noConflict`](#noConflict)\n+\n+\n+## Collections\n+\n+<a name=\"forEach\" />\n+<a name=\"each\" />\n+### each(arr, iterator, callback)\n+\n+Applies the function `iterator` to each item in `arr`, in parallel.\n+The `iterator` is called with an item from the list, and a callback for when it\n+has finished. If the `iterator` passes an error to its `callback`, the main\n+`callback` (for the `each` function) is immediately called with the error.\n+\n+Note, that since this function applies `iterator` to each item in parallel,\n+there is no guarantee that the iterator functions will complete in order.\n+\n+__Arguments__\n+\n+* `arr` - An array to iterate over.\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\n+  The iterator is passed a `callback(err)` which must be called once it has \n+  completed. If no error has occured, the `callback` should be run without \n+  arguments or with an explicit `null` argument.\n+* `callback(err)` - A callback which is called when all `iterator` functions\n+  have finished, or an error occurs.\n+\n+__Examples__\n+\n+\n+```js\n+// assuming openFiles is an array of file names and saveFile is a function\n+// to save the modified contents of that file:\n+\n+async.each(openFiles, saveFile, function(err){\n+    // if any of the saves produced an error, err would equal that error\n+});\n+```\n+\n+```js\n+// assuming openFiles is an array of file names \n+\n+async.each(openFiles, function( file, callback) {\n+  \n+  // Perform operation on file here.\n+  console.log('Processing file ' + file);\n+  \n+  if( file.length > 32 ) {\n+    console.log('This file name is too long');\n+    callback('File name too long');\n+  } else {\n+    // Do work to process file here\n+    console.log('File processed');\n+    callback();\n+  }\n+}, function(err){\n+    // if any of the file processing produced an error, err would equal that error\n+    if( err ) {\n+      // One of the iterations produced an error.\n+      // All processing will now stop.\n+      console.log('A file failed to process');\n+    } else {\n+      console.log('All files have been processed successfully');\n+    }\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"forEachSeries\" />\n+<a name=\"eachSeries\" />\n+### eachSeries(arr, iterator, callback)\n+\n+The same as [`each`](#each), only `iterator` is applied to each item in `arr` in\n+series. The next `iterator` is only called once the current one has completed. \n+This means the `iterator` functions will complete in order.\n+\n+\n+---------------------------------------\n+\n+<a name=\"forEachLimit\" />\n+<a name=\"eachLimit\" />\n+### eachLimit(arr, limit, iterator, callback)\n+\n+The same as [`each`](#each), only no more than `limit` `iterator`s will be simultaneously \n+running at any time.\n+\n+Note that the items in `arr` are not processed in batches, so there is no guarantee that \n+the first `limit` `iterator` functions will complete before any others are started.\n+\n+__Arguments__\n+\n+* `arr` - An array to iterate over.\n+* `limit` - The maximum number of `iterator`s to run at any time.\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\n+  The iterator is passed a `callback(err)` which must be called once it has \n+  completed. If no error has occured, the callback should be run without \n+  arguments or with an explicit `null` argument.\n+* `callback(err)` - A callback which is called when all `iterator` functions\n+  have finished, or an error occurs.\n+\n+__Example__\n+\n+```js\n+// Assume documents is an array of JSON objects and requestApi is a\n+// function that interacts with a rate-limited REST api.\n+\n+async.eachLimit(documents, 20, requestApi, function(err){\n+    // if any of the saves produced an error, err would equal that error\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"map\" />\n+### map(arr, iterator, callback)\n+\n+Produces a new array of values by mapping each value in `arr` through\n+the `iterator` function. The `iterator` is called with an item from `arr` and a\n+callback for when it has finished processing. Each of these callback takes 2 arguments: \n+an `error`, and the transformed item from `arr`. If `iterator` passes an error to this \n+callback, the main `callback` (for the `map` function) is immediately called with the error.\n+\n+Note, that since this function applies the `iterator` to each item in parallel,\n+there is no guarantee that the `iterator` functions will complete in order. \n+However, the results array will be in the same order as the original `arr`.\n+\n+__Arguments__\n+\n+* `arr` - An array to iterate over.\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\n+  The iterator is passed a `callback(err, transformed)` which must be called once \n+  it has completed with an error (which can be `null`) and a transformed item.\n+* `callback(err, results)` - A callback which is called when all `iterator`\n+  functions have finished, or an error occurs. Results is an array of the\n+  transformed items from the `arr`.\n+\n+__Example__\n+\n+```js\n+async.map(['file1','file2','file3'], fs.stat, function(err, results){\n+    // results is now an array of stats for each file\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"mapSeries\" />\n+### mapSeries(arr, iterator, callback)\n+\n+The same as [`map`](#map), only the `iterator` is applied to each item in `arr` in\n+series. The next `iterator` is only called once the current one has completed. \n+The results array will be in the same order as the original.\n+\n+\n+---------------------------------------\n+\n+<a name=\"mapLimit\" />\n+### mapLimit(arr, limit, iterator, callback)\n+\n+The same as [`map`](#map), only no more than `limit` `iterator`s will be simultaneously \n+running at any time.\n+\n+Note that the items are not processed in batches, so there is no guarantee that \n+the first `limit` `iterator` functions will complete before any others are started.\n+\n+__Arguments__\n+\n+* `arr` - An array to iterate over.\n+* `limit` - The maximum number of `iterator`s to run at any time.\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\n+  The iterator is passed a `callback(err, transformed)` which must be called once \n+  it has completed with an error (which can be `null`) and a transformed item.\n+* `callback(err, results)` - A callback which is called when all `iterator`\n+  calls have finished, or an error occurs. The result is an array of the\n+  transformed items from the original `arr`.\n+\n+__Example__\n+\n+```js\n+async.mapLimit(['file1','file2','file3'], 1, fs.stat, function(err, results){\n+    // results is now an array of stats for each file\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"select\" />\n+<a name=\"filter\" />\n+### filter(arr, iterator, callback)\n+\n+__Alias:__ `select`\n+\n+Returns a new array of all the values in `arr` which pass an async truth test.\n+_The callback for each `iterator` call only accepts a single argument of `true` or\n+`false`; it does not accept an error argument first!_ This is in-line with the\n+way node libraries work with truth tests like `fs.exists`. This operation is\n+performed in parallel, but the results array will be in the same order as the\n+original.\n+\n+__Arguments__\n+\n+* `arr` - An array to iterate over.\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\n+  The `iterator` is passed a `callback(truthValue)`, which must be called with a \n+  boolean argument once it has completed.\n+* `callback(results)` - A callback which is called after all the `iterator`\n+  functions have finished.\n+\n+__Example__\n+\n+```js\n+async.filter(['file1','file2','file3'], fs.exists, function(results){\n+    // results now equals an array of the existing files\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"selectSeries\" />\n+<a name=\"filterSeries\" />\n+### filterSeries(arr, iterator, callback)\n+\n+__Alias:__ `selectSeries`\n+\n+The same as [`filter`](#filter) only the `iterator` is applied to each item in `arr` in\n+series. The next `iterator` is only called once the current one has completed. \n+The results array will be in the same order as the original.\n+\n+---------------------------------------\n+\n+<a name=\"reject\" />\n+### reject(arr, iterator, callback)\n+\n+The opposite of [`filter`](#filter). Removes values that pass an `async` truth test.\n+\n+---------------------------------------\n+\n+<a name=\"rejectSeries\" />\n+### rejectSeries(arr, iterator, callback)\n+\n+The same as [`reject`](#reject), only the `iterator` is applied to each item in `arr`\n+in series.\n+\n+\n+---------------------------------------\n+\n+<a name=\"reduce\" />\n+### reduce(arr, memo, iterator, callback)\n+\n+__Aliases:__ `inject`, `foldl`\n+\n+Reduces `arr` into a single value using an async `iterator` to return\n+each successive step. `memo` is the initial state of the reduction. \n+This function only operates in series. \n+\n+For performance reasons, it may make sense to split a call to this function into \n+a parallel map, and then use the normal `Array.prototype.reduce` on the results. \n+This function is for situations where each step in the reduction needs to be async; \n+if you can get the data before reducing it, then it's probably a good idea to do so.\n+\n+__Arguments__\n+\n+* `arr` - An array to iterate over.\n+* `memo` - The initial state of the reduction.\n+* `iterator(memo, item, callback)` - A function applied to each item in the\n+  array to produce the next step in the reduction. The `iterator` is passed a\n+  `callback(err, reduction)` which accepts an optional error as its first \n+  argument, and the state of the reduction as the second. If an error is \n+  passed to the callback, the reduction is stopped and the main `callback` is \n+  immediately called with the error.\n+* `callback(err, result)` - A callback which is called after all the `iterator`\n+  functions have finished. Result is the reduced value.\n+\n+__Example__\n+\n+```js\n+async.reduce([1,2,3], 0, function(memo, item, callback){\n+    // pointless async:\n+    process.nextTick(function(){\n+        callback(null, memo + item)\n+    });\n+}, function(err, result){\n+    // result is now equal to the last value of memo, which is 6\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"reduceRight\" />\n+### reduceRight(arr, memo, iterator, callback)\n+\n+__Alias:__ `foldr`\n+\n+Same as [`reduce`](#reduce), only operates on `arr` in reverse order.\n+\n+\n+---------------------------------------\n+\n+<a name=\"detect\" />\n+### detect(arr, iterator, callback)\n+\n+Returns the first value in `arr` that passes an async truth test. The\n+`iterator` is applied in parallel, meaning the first iterator to return `true` will\n+fire the detect `callback` with that result. That means the result might not be\n+the first item in the original `arr` (in terms of order) that passes the test.\n+\n+If order within the original `arr` is important, then look at [`detectSeries`](#detectSeries).\n+\n+__Arguments__\n+\n+* `arr` - An array to iterate over.\n+* `iterator(item, callback)` - A truth test to apply to each item in `arr`.\n+  The iterator is passed a `callback(truthValue)` which must be called with a \n+  boolean argument once it has completed.\n+* `callback(result)` - A callback which is called as soon as any iterator returns\n+  `true`, or after all the `iterator` functions have finished. Result will be\n+  the first item in the array that passes the truth test (iterator) or the\n+  value `undefined` if none passed.\n+\n+__Example__\n+\n+```js\n+async.detect(['file1','file2','file3'], fs.exists, function(result){\n+    // result now equals the first file in the list that exists\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"detectSeries\" />\n+### detectSeries(arr, iterator, callback)\n+\n+The same as [`detect`](#detect), only the `iterator` is applied to each item in `arr`\n+in series. This means the result is always the first in the original `arr` (in\n+terms of array order) that passes the truth test.\n+\n+\n+---------------------------------------\n+\n+<a name=\"sortBy\" />\n+### sortBy(arr, iterator, callback)\n+\n+Sorts a list by the results of running each `arr` value through an async `iterator`.\n+\n+__Arguments__\n+\n+* `arr` - An array to iterate over.\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\n+  The iterator is passed a `callback(err, sortValue)` which must be called once it\n+  has completed with an error (which can be `null`) and a value to use as the sort\n+  criteria.\n+* `callback(err, results)` - A callback which is called after all the `iterator`\n+  functions have finished, or an error occurs. Results is the items from\n+  the original `arr` sorted by the values returned by the `iterator` calls.\n+\n+__Example__\n+\n+```js\n+async.sortBy(['file1','file2','file3'], function(file, callback){\n+    fs.stat(file, function(err, stats){\n+        callback(err, stats.mtime);\n+    });\n+}, function(err, results){\n+    // results is now the original array of files sorted by\n+    // modified date\n+});\n+```\n+\n+__Sort Order__\n+\n+By modifying the callback parameter the sorting order can be influenced:\n+\n+```js\n+//ascending order\n+async.sortBy([1,9,3,5], function(x, callback){\n+    callback(err, x);\n+}, function(err,result){\n+    //result callback\n+} );\n+\n+//descending order\n+async.sortBy([1,9,3,5], function(x, callback){\n+    callback(err, x*-1);    //<- x*-1 instead of x, turns the order around\n+}, function(err,result){\n+    //result callback\n+} );\n+```\n+\n+---------------------------------------\n+\n+<a name=\"some\" />\n+### some(arr, iterator, callback)\n+\n+__Alias:__ `any`\n+\n+Returns `true` if at least one element in the `arr` satisfies an async test.\n+_The callback for each iterator call only accepts a single argument of `true` or\n+`false`; it does not accept an error argument first!_ This is in-line with the\n+way node libraries work with truth tests like `fs.exists`. Once any iterator\n+call returns `true`, the main `callback` is immediately called.\n+\n+__Arguments__\n+\n+* `arr` - An array to iterate over.\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\n+  in parallel. The iterator is passed a callback(truthValue) which must be \n+  called with a boolean argument once it has completed.\n+* `callback(result)` - A callback which is called as soon as any iterator returns\n+  `true`, or after all the iterator functions have finished. Result will be\n+  either `true` or `false` depending on the values of the async tests.\n+\n+__Example__\n+\n+```js\n+async.some(['file1','file2','file3'], fs.exists, function(result){\n+    // if result is true then at least one of the files exists\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"every\" />\n+### every(arr, iterator, callback)\n+\n+__Alias:__ `all`\n+\n+Returns `true` if every element in `arr` satisfies an async test.\n+_The callback for each `iterator` call only accepts a single argument of `true` or\n+`false`; it does not accept an error argument first!_ This is in-line with the\n+way node libraries work with truth tests like `fs.exists`.\n+\n+__Arguments__\n+\n+* `arr` - An array to iterate over.\n+* `iterator(item, callback)` - A truth test to apply to each item in the array\n+  in parallel. The iterator is passed a callback(truthValue) which must be \n+  called with a  boolean argument once it has completed.\n+* `callback(result)` - A callback which is called after all the `iterator`\n+  functions have finished. Result will be either `true` or `false` depending on\n+  the values of the async tests.\n+\n+__Example__\n+\n+```js\n+async.every(['file1','file2','file3'], fs.exists, function(result){\n+    // if result is true then every file exists\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"concat\" />\n+### concat(arr, iterator, callback)\n+\n+Applies `iterator` to each item in `arr`, concatenating the results. Returns the\n+concatenated list. The `iterator`s are called in parallel, and the results are\n+concatenated as they return. There is no guarantee that the results array will\n+be returned in the original order of `arr` passed to the `iterator` function.\n+\n+__Arguments__\n+\n+* `arr` - An array to iterate over.\n+* `iterator(item, callback)` - A function to apply to each item in `arr`.\n+  The iterator is passed a `callback(err, results)` which must be called once it \n+  has completed with an error (which can be `null`) and an array of results.\n+* `callback(err, results)` - A callback which is called after all the `iterator`\n+  functions have finished, or an error occurs. Results is an array containing\n+  the concatenated results of the `iterator` function.\n+\n+__Example__\n+\n+```js\n+async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files){\n+    // files is now a list of filenames that exist in the 3 directories\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"concatSeries\" />\n+### concatSeries(arr, iterator, callback)\n+\n+Same as [`concat`](#concat), but executes in series instead of parallel.\n+\n+\n+## Control Flow\n+\n+<a name=\"series\" />\n+### series(tasks, [callback])\n+\n+Run the functions in the `tasks` array in series, each one running once the previous\n+function has completed. If any functions in the series pass an error to its\n+callback, no more functions are run, and `callback` is immediately called with the value of the error. \n+Otherwise, `callback` receives an array of results when `tasks` have completed.\n+\n+It is also possible to use an object instead of an array. Each property will be\n+run as a function, and the results will be passed to the final `callback` as an object\n+instead of an array. This can be a more readable way of handling results from\n+[`series`](#series).\n+\n+**Note** that while many implementations preserve the order of object properties, the\n+[ECMAScript Language Specifcation](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6) \n+explicitly states that\n+\n+> The mechanics and order of enumerating the properties is not specified.\n+\n+So if you rely on the order in which your series of functions are executed, and want\n+this to work on all platforms, consider using an array. \n+\n+__Arguments__\n+\n+* `tasks` - An array or object containing functions to run, each function is passed\n+  a `callback(err, result)` it must call on completion with an error `err` (which can\n+  be `null`) and an optional `result` value.\n+* `callback(err, results)` - An optional callback to run once all the functions\n+  have completed. This function gets a results array (or object) containing all \n+  the result arguments passed to the `task` callbacks.\n+\n+__Example__\n+\n+```js\n+async.series([\n+    function(callback){\n+        // do some stuff ...\n+        callback(null, 'one');\n+    },\n+    function(callback){\n+        // do some more stuff ...\n+        callback(null, 'two');\n+    }\n+],\n+// optional callback\n+function(err, results){\n+    // results is now equal to ['one', 'two']\n+});\n+\n+\n+// an example using an object instead of an array\n+async.series({\n+    one: function(callback){\n+        setTimeout(function(){\n+            callback(null, 1);\n+        }, 200);\n+    },\n+    two: function(callback){\n+        setTimeout(function(){\n+            callback(null, 2);\n+        }, 100);\n+    }\n+},\n+function(err, results) {\n+    // results is now equal to: {one: 1, two: 2}\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"parallel\" />\n+### parallel(tasks, [callback])\n+\n+Run the `tasks` array of functions in parallel, without waiting until the previous\n+function has completed. If any of the functions pass an error to its\n+callback, the main `callback` is immediately called with the value of the error.\n+Once the `tasks` have completed, the results are passed to the final `callback` as an\n+array.\n+\n+It is also possible to use an object instead of an array. Each property will be\n+run as a function and the results will be passed to the final `callback` as an object\n+instead of an array. This can be a more readable way of handling results from\n+[`parallel`](#parallel).\n+\n+\n+__Arguments__\n+\n+* `tasks` - An array or object containing functions to run. Each function is passed \n+  a `callback(err, result)` which it must call on completion with an error `err` \n+  (which can be `null`) and an optional `result` value.\n+* `callback(err, results)` - An optional callback to run once all the functions\n+  have completed. This function gets a results array (or object) containing all \n+  the result arguments passed to the task callbacks.\n+\n+__Example__\n+\n+```js\n+async.parallel([\n+    function(callback){\n+        setTimeout(function(){\n+            callback(null, 'one');\n+        }, 200);\n+    },\n+    function(callback){\n+        setTimeout(function(){\n+            callback(null, 'two');\n+        }, 100);\n+    }\n+],\n+// optional callback\n+function(err, results){\n+    // the results array will equal ['one','two'] even though\n+    // the second function had a shorter timeout.\n+});\n+\n+\n+// an example using an object instead of an array\n+async.parallel({\n+    one: function(callback){\n+        setTimeout(function(){\n+            callback(null, 1);\n+        }, 200);\n+    },\n+    two: function(callback){\n+        setTimeout(function(){\n+            callback(null, 2);\n+        }, 100);\n+    }\n+},\n+function(err, results) {\n+    // results is now equals to: {one: 1, two: 2}\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"parallelLimit\" />\n+### parallelLimit(tasks, limit, [callback])\n+\n+The same as [`parallel`](#parallel), only `tasks` are executed in parallel \n+with a maximum of `limit` tasks executing at any time.\n+\n+Note that the `tasks` are not executed in batches, so there is no guarantee that \n+the first `limit` tasks will complete before any others are started.\n+\n+__Arguments__\n+\n+* `tasks` - An array or object containing functions to run, each function is passed \n+  a `callback(err, result)` it must call on completion with an error `err` (which can\n+  be `null`) and an optional `result` value.\n+* `limit` - The maximum number of `tasks` to run at any time.\n+* `callback(err, results)` - An optional callback to run once all the functions\n+  have completed. This function gets a results array (or object) containing all \n+  the result arguments passed to the `task` callbacks.\n+\n+---------------------------------------\n+\n+<a name=\"whilst\" />\n+### whilst(test, fn, callback)\n+\n+Repeatedly call `fn`, while `test` returns `true`. Calls `callback` when stopped,\n+or an error occurs.\n+\n+__Arguments__\n+\n+* `test()` - synchronous truth test to perform before each execution of `fn`.\n+* `fn(callback)` - A function which is called each time `test` passes. The function is\n+  passed a `callback(err)`, which must be called once it has completed with an \n+  optional `err` argument.\n+* `callback(err)` - A callback which is called after the test fails and repeated\n+  execution of `fn` has stopped.\n+\n+__Example__\n+\n+```js\n+var count = 0;\n+\n+async.whilst(\n+    function () { return count < 5; },\n+    function (callback) {\n+        count++;\n+        setTimeout(callback, 1000);\n+    },\n+    function (err) {\n+        // 5 seconds have passed\n+    }\n+);\n+```\n+\n+---------------------------------------\n+\n+<a name=\"doWhilst\" />\n+### doWhilst(fn, test, callback)\n+\n+The post-check version of [`whilst`](#whilst). To reflect the difference in \n+the order of operations, the arguments `test` and `fn` are switched. \n+\n+`doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.\n+\n+---------------------------------------\n+\n+<a name=\"until\" />\n+### until(test, fn, callback)\n+\n+Repeatedly call `fn` until `test` returns `true`. Calls `callback` when stopped,\n+or an error occurs.\n+\n+The inverse of [`whilst`](#whilst).\n+\n+---------------------------------------\n+\n+<a name=\"doUntil\" />\n+### doUntil(fn, test, callback)\n+\n+Like [`doWhilst`](#doWhilst), except the `test` is inverted. Note the argument ordering differs from `until`.\n+\n+---------------------------------------\n+\n+<a name=\"forever\" />\n+### forever(fn, errback)\n+\n+Calls the asynchronous function `fn` with a callback parameter that allows it to\n+call itself again, in series, indefinitely.\n+\n+If an error is passed to the callback then `errback` is called with the\n+error, and execution stops, otherwise it will never be called.\n+\n+```js\n+async.forever(\n+    function(next) {\n+        // next is suitable for passing to things that need a callback(err [, whatever]);\n+        // it will result in this function being called again.\n+    },\n+    function(err) {\n+        // if next is called with a value in its first parameter, it will appear\n+        // in here as 'err', and execution will stop.\n+    }\n+);\n+```\n+\n+---------------------------------------\n+\n+<a name=\"waterfall\" />\n+### waterfall(tasks, [callback])\n+\n+Runs the `tasks` array of functions in series, each passing their results to the next in\n+the array. However, if any of the `tasks` pass an error to their own callback, the\n+next function is not executed, and the main `callback` is immediately called with\n+the error.\n+\n+__Arguments__\n+\n+* `tasks` - An array of functions to run, each function is passed a \n+  `callback(err, result1, result2, ...)` it must call on completion. The first\n+  argument is an error (which can be `null`) and any further arguments will be \n+  passed as arguments in order to the next task.\n+* `callback(err, [results])` - An optional callback to run once all the functions\n+  have completed. This will be passed the results of the last task's callback.\n+\n+\n+\n+__Example__\n+\n+```js\n+async.waterfall([\n+    function(callback){\n+        callback(null, 'one', 'two');\n+    },\n+    function(arg1, arg2, callback){\n+      // arg1 now equals 'one' and arg2 now equals 'two'\n+        callback(null, 'three');\n+    },\n+    function(arg1, callback){\n+        // arg1 now equals 'three'\n+        callback(null, 'done');\n+    }\n+], function (err, result) {\n+   // result now equals 'done'    \n+});\n+```\n+\n+---------------------------------------\n+<a name=\"compose\" />\n+### compose(fn1, fn2...)\n+\n+Creates a function which is a composition of the passed asynchronous\n+functions. Each function consumes the return value of the function that\n+follows. Composing functions `f()`, `g()`, and `h()` would produce the result of\n+`f(g(h()))`, only this version uses callbacks to obtain the return values.\n+\n+Each function is executed with the `this` binding of the composed function.\n+\n+__Arguments__\n+\n+* `functions...` - the asynchronous functions to compose\n+\n+\n+__Example__\n+\n+```js\n+function add1(n, callback) {\n+    setTimeout(function () {\n+        callback(null, n + 1);\n+    }, 10);\n+}\n+\n+function mul3(n, callback) {\n+    setTimeout(function () {\n+        callback(null, n * 3);\n+    }, 10);\n+}\n+\n+var add1mul3 = async.compose(mul3, add1);\n+\n+add1mul3(4, function (err, result) {\n+   // result now equals 15\n+});\n+```\n+\n+---------------------------------------\n+<a name=\"seq\" />\n+### seq(fn1, fn2...)\n+\n+Version of the compose function that is more natural to read.\n+Each following function consumes the return value of the latter function. \n+\n+Each function is executed with the `this` binding of the composed function.\n+\n+__Arguments__\n+\n+* functions... - the asynchronous functions to compose\n+\n+\n+__Example__\n+\n+```js\n+// Requires lodash (or underscore), express3 and dresende's orm2.\n+// Part of an app, that fetches cats of the logged user.\n+// This example uses `seq` function to avoid overnesting and error \n+// handling clutter.\n+app.get('/cats', function(request, response) {\n+  function handleError(err, data, callback) {\n+    if (err) {\n+      console.error(err);\n+      response.json({ status: 'error', message: err.message });\n+    }\n+    else {\n+      callback(data);\n+    }\n+  }\n+  var User = request.models.User;\n+  async.seq(\n+    _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))\n+    handleError,\n+    function(user, fn) {\n+      user.getCats(fn);      // 'getCats' has signature (callback(err, data))\n+    },\n+    handleError,\n+    function(cats) {\n+      response.json({ status: 'ok', message: 'Cats found', data: cats });\n+    }\n+  )(req.session.user_id);\n+  }\n+});\n+```\n+\n+---------------------------------------\n+<a name=\"applyEach\" />\n+### applyEach(fns, args..., callback)\n+\n+Applies the provided arguments to each function in the array, calling \n+`callback` after all functions have completed. If you only provide the first\n+argument, then it will return a function which lets you pass in the\n+arguments as if it were a single function call.\n+\n+__Arguments__\n+\n+* `fns` - the asynchronous functions to all call with the same arguments\n+* `args...` - any number of separate arguments to pass to the function\n+* `callback` - the final argument should be the callback, called when all\n+  functions have completed processing\n+\n+\n+__Example__\n+\n+```js\n+async.applyEach([enableSearch, updateSchema], 'bucket', callback);\n+\n+// partial application example:\n+async.each(\n+    buckets,\n+    async.applyEach([enableSearch, updateSchema]),\n+    callback\n+);\n+```\n+\n+---------------------------------------\n+\n+<a name=\"applyEachSeries\" />\n+### applyEachSeries(arr, iterator, callback)\n+\n+The same as [`applyEach`](#applyEach) only the functions are applied in series.\n+\n+---------------------------------------\n+\n+<a name=\"queue\" />\n+### queue(worker, concurrency)\n+\n+Creates a `queue` object with the specified `concurrency`. Tasks added to the\n+`queue` are processed in parallel (up to the `concurrency` limit). If all\n+`worker`s are in progress, the task is queued until one becomes available. \n+Once a `worker` completes a `task`, that `task`'s callback is called.\n+\n+__Arguments__\n+\n+* `worker(task, callback)` - An asynchronous function for processing a queued\n+  task, which must call its `callback(err)` argument when finished, with an \n+  optional `error` as an argument.\n+* `concurrency` - An `integer` for determining how many `worker` functions should be\n+  run in parallel.\n+\n+__Queue objects__\n+\n+The `queue` object returned by this function has the following properties and\n+methods:\n+\n+* `length()` - a function returning the number of items waiting to be processed.\n+* `started` - a function returning whether or not any items have been pushed and processed by the queue\n+* `running()` - a function returning the number of items currently being processed.\n+* `idle()` - a function returning false if there are items waiting or being processed, or true if not.\n+* `concurrency` - an integer for determining how many `worker` functions should be\n+  run in parallel. This property can be changed after a `queue` is created to\n+  alter the concurrency on-the-fly.\n+* `push(task, [callback])` - add a new task to the `queue`. Calls `callback` once \n+  the `worker` has finished processing the task. Instead of a single task, a `tasks` array\n+  can be submitted. The respective callback is used for every task in the list.\n+* `unshift(task, [callback])` - add a new task to the front of the `queue`.\n+* `saturated` - a callback that is called when the `queue` length hits the `concurrency` limit, \n+   and further tasks will be queued.\n+* `empty` - a callback that is called when the last item from the `queue` is given to a `worker`.\n+* `drain` - a callback that is called when the last item from the `queue` has returned from the `worker`.\n+* `paused` - a boolean for determining whether the queue is in a paused state\n+* `pause()` - a function that pauses the processing of tasks until `resume()` is called.\n+* `resume()` - a function that resumes the processing of queued tasks when the queue is paused.\n+* `kill()` - a function that empties remaining tasks from the queue forcing it to go idle.\n+\n+__Example__\n+\n+```js\n+// create a queue object with concurrency 2\n+\n+var q = async.queue(function (task, callback) {\n+    console.log('hello ' + task.name);\n+    callback();\n+}, 2);\n+\n+\n+// assign a callback\n+q.drain = function() {\n+    console.log('all items have been processed');\n+}\n+\n+// add some items to the queue\n+\n+q.push({name: 'foo'}, function (err) {\n+    console.log('finished processing foo');\n+});\n+q.push({name: 'bar'}, function (err) {\n+    console.log('finished processing bar');\n+});\n+\n+// add some items to the queue (batch-wise)\n+\n+q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function (err) {\n+    console.log('finished processing bar');\n+});\n+\n+// add some items to the front of the queue\n+\n+q.unshift({name: 'bar'}, function (err) {\n+    console.log('finished processing bar');\n+});\n+```\n+\n+\n+---------------------------------------\n+\n+<a name=\"priorityQueue\" />\n+### priorityQueue(worker, concurrency)\n+\n+The same as [`queue`](#queue) only tasks are assigned a priority and completed in ascending priority order. There are two differences between `queue` and `priorityQueue` objects:\n+\n+* `push(task, priority, [callback])` - `priority` should be a number. If an array of\n+  `tasks` is given, all tasks will be assigned the same priority.\n+* The `unshift` method was removed.\n+\n+---------------------------------------\n+\n+<a name=\"cargo\" />\n+### cargo(worker, [payload])\n+\n+Creates a `cargo` object with the specified payload. Tasks added to the\n+cargo will be processed altogether (up to the `payload` limit). If the\n+`worker` is in progress, the task is queued until it becomes available. Once\n+the `worker` has completed some tasks, each callback of those tasks is called.\n+Check out [this animation](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) for how `cargo` and `queue` work.\n+\n+While [queue](#queue) passes only one task to one of a group of workers\n+at a time, cargo passes an array of tasks to a single worker, repeating\n+when the worker is finished.\n+\n+__Arguments__\n+\n+* `worker(tasks, callback)` - An asynchronous function for processing an array of\n+  queued tasks, which must call its `callback(err)` argument when finished, with \n+  an optional `err` argument.\n+* `payload` - An optional `integer` for determining how many tasks should be\n+  processed per round; if omitted, the default is unlimited.\n+\n+__Cargo objects__\n+\n+The `cargo` object returned by this function has the following properties and\n+methods:\n+\n+* `length()` - A function returning the number of items waiting to be processed.\n+* `payload` - An `integer` for determining how many tasks should be\n+  process per round. This property can be changed after a `cargo` is created to\n+  alter the payload on-the-fly.\n+* `push(task, [callback])` - Adds `task` to the `queue`. The callback is called\n+  once the `worker` has finished processing the task. Instead of a single task, an array of `tasks` \n+  can be submitted. The respective callback is used for every task in the list.\n+* `saturated` - A callback that is called when the `queue.length()` hits the concurrency and further tasks will be queued.\n+* `empty` - A callback that is called when the last item from the `queue` is given to a `worker`.\n+* `drain` - A callback that is called when the last item from the `queue` has returned from the `worker`.\n+\n+__Example__\n+\n+```js\n+// create a cargo object with payload 2\n+\n+var cargo = async.cargo(function (tasks, callback) {\n+    for(var i=0; i<tasks.length; i++){\n+      console.log('hello ' + tasks[i].name);\n+    }\n+    callback();\n+}, 2);\n+\n+\n+// add some items\n+\n+cargo.push({name: 'foo'}, function (err) {\n+    console.log('finished processing foo');\n+});\n+cargo.push({name: 'bar'}, function (err) {\n+    console.log('finished processing bar');\n+});\n+cargo.push({name: 'baz'}, function (err) {\n+    console.log('finished processing baz');\n+});\n+```\n+\n+---------------------------------------\n+\n+<a name=\"auto\" />\n+### auto(tasks, [callback])\n+\n+Determines the best order for running the functions in `tasks`, based on their \n+requirements. Each function can optionally depend on other functions being completed \n+first, and each function is run as soon as its requirements are satisfied. \n+\n+If any of the functions pass an error to their callback, it will not \n+complete (so any other functions depending on it will not run), and the main \n+`callback` is immediately called with the error. Functions also receive an \n+object containing the results of functions which have completed so far.\n+\n+Note, all functions are called with a `results` object as a second argument, \n+so it is unsafe to pass functions in the `tasks` object which cannot handle the\n+extra argument. \n+\n+For example, this snippet of code:\n+\n+```js\n+async.auto({\n+  readData: async.apply(fs.readFile, 'data.txt', 'utf-8')\n+}, callback);\n+```\n+\n+will have the effect of calling `readFile` with the results object as the last\n+argument, which will fail:\n+\n+```js\n+fs.readFile('data.txt', 'utf-8', cb, {});\n+```\n+\n+Instead, wrap the call to `readFile` in a function which does not forward the \n+`results` object:\n+\n+```js\n+async.auto({\n+  readData: function(cb, results){\n+    fs.readFile('data.txt', 'utf-8', cb);\n+  }\n+}, callback);\n+```\n+\n+__Arguments__\n+\n+* `tasks` - An object. Each of its properties is either a function or an array of\n+  requirements, with the function itself the last item in the array. The object's key\n+  of a property serves as the name of the task defined by that property,\n+  i.e. can be used when specifying requirements for other tasks.\n+  The function receives two arguments: (1) a `callback(err, result)` which must be \n+  called when finished, passing an `error` (which can be `null`) and the result of \n+  the function's execution, and (2) a `results` object, containing the results of\n+  the previously executed functions.\n+* `callback(err, results)` - An optional callback which is called when all the\n+  tasks have been completed. It receives the `err` argument if any `tasks` \n+  pass an error to their callback. Results are always returned; however, if \n+  an error occurs, no further `tasks` will be performed, and the results\n+  object will only contain partial results.\n+\n+\n+__Example__\n+\n+```js\n+async.auto({\n+    get_data: function(callback){\n+        console.log('in get_data');\n+        // async code to get some data\n+        callback(null, 'data', 'converted to array');\n+    },\n+    make_folder: function(callback){\n+        console.log('in make_folder');\n+        // async code to create a directory to store a file in\n+        // this is run at the same time as getting the data\n+        callback(null, 'folder');\n+    },\n+    write_file: ['get_data', 'make_folder', function(callback, results){\n+        console.log('in write_file', JSON.stringify(results));\n+        // once there is some data and the directory exists,\n+        // write the data to a file in the directory\n+        callback(null, 'filename');\n+    }],\n+    email_link: ['write_file', function(callback, results){\n+        console.log('in email_link', JSON.stringify(results));\n+        // once the file is written let's email a link to it...\n+        // results.write_file contains the filename returned by write_file.\n+        callback(null, {'file':results.write_file, 'email':'user@example.com'});\n+    }]\n+}, function(err, results) {\n+    console.log('err = ', err);\n+    console.log('results = ', results);\n+});\n+```\n+\n+This is a fairly trivial example, but to do this using the basic parallel and\n+series functions would look like this:\n+\n+```js\n+async.parallel([\n+    function(callback){\n+        console.log('in get_data');\n+        // async code to get some data\n+        callback(null, 'data', 'converted to array');\n+    },\n+    function(callback){\n+        console.log('in make_folder');\n+        // async code to create a directory to store a file in\n+        // this is run at the same time as getting the data\n+        callback(null, 'folder');\n+    }\n+],\n+function(err, results){\n+    async.series([\n+        function(callback){\n+            console.log('in write_file', JSON.stringify(results));\n+            // once there is some data and the directory exists,\n+            // write the data to a file in the directory\n+            results.push('filename');\n+            callback(null);\n+        },\n+        function(callback){\n+            console.log('in email_link', JSON.stringify(results));\n+            // once the file is written let's email a link to it...\n+            callback(null, {'file':results.pop(), 'email':'user@example.com'});\n+        }\n+    ]);\n+});\n+```\n+\n+For a complicated series of `async` tasks, using the [`auto`](#auto) function makes adding\n+new tasks much easier (and the code more readable).\n+\n+\n+---------------------------------------\n+\n+<a name=\"retry\" />\n+### retry([times = 5], task, [callback])\n+\n+Attempts to get a successful response from `task` no more than `times` times before\n+returning an error. If the task is successful, the `callback` will be passed the result\n+of the successfull task. If all attemps fail, the callback will be passed the error and\n+result (if any) of the final attempt.\n+\n+__Arguments__\n+\n+* `times` - An integer indicating how many times to attempt the `task` before giving up. Defaults to 5.\n+* `task(callback, results)` - A function which receives two arguments: (1) a `callback(err, result)`\n+  which must be called when finished, passing `err` (which can be `null`) and the `result` of \n+  the function's execution, and (2) a `results` object, containing the results of\n+  the previously executed functions (if nested inside another control flow).\n+* `callback(err, results)` - An optional callback which is called when the\n+  task has succeeded, or after the final failed attempt. It receives the `err` and `result` arguments of the last attempt at completing the `task`.\n+\n+The [`retry`](#retry) function can be used as a stand-alone control flow by passing a\n+callback, as shown below:\n+\n+```js\n+async.retry(3, apiMethod, function(err, result) {\n+    // do something with the result\n+});\n+```\n+\n+It can also be embeded within other control flow functions to retry individual methods\n+that are not as reliable, like this:\n+\n+```js\n+async.auto({\n+    users: api.getUsers.bind(api),\n+    payments: async.retry(3, api.getPayments.bind(api))\n+}, function(err, results) {\n+  // do something with the results\n+});\n+```\n+\n+\n+---------------------------------------\n+\n+<a name=\"iterator\" />\n+### iterator(tasks)\n+\n+Creates an iterator function which calls the next function in the `tasks` array,\n+returning a continuation to call the next one after that. It's also possible to\n+“peek” at the next iterator with `iterator.next()`.\n+\n+This function is used internally by the `async` module, but can be useful when\n+you want to manually control the flow of functions in series.\n+\n+__Arguments__\n+\n+* `tasks` - An array of functions to run.\n+\n+__Example__\n+\n+```js\n+var iterator = async.iterator([\n+    function(){ sys.p('one'); },\n+    function(){ sys.p('two'); },\n+    function(){ sys.p('three'); }\n+]);\n+\n+node> var iterator2 = iterator();\n+'one'\n+node> var iterator3 = iterator2();\n+'two'\n+node> iterator3();\n+'three'\n+node> var nextfn = iterator2.next();\n+node> nextfn();\n+'three'\n+```\n+\n+---------------------------------------\n+\n+<a name=\"apply\" />\n+### apply(function, arguments..)\n+\n+Creates a continuation function with some arguments already applied. \n+\n+Useful as a shorthand when combined with other control flow functions. Any arguments\n+passed to the returned function are added to the arguments originally passed\n+to apply.\n+\n+__Arguments__\n+\n+* `function` - The function you want to eventually apply all arguments to.\n+* `arguments...` - Any number of arguments to automatically apply when the\n+  continuation is called.\n+\n+__Example__\n+\n+```js\n+// using apply\n+\n+async.parallel([\n+    async.apply(fs.writeFile, 'testfile1', 'test1'),\n+    async.apply(fs.writeFile, 'testfile2', 'test2'),\n+]);\n+\n+\n+// the same process without using apply\n+\n+async.parallel([\n+    function(callback){\n+        fs.writeFile('testfile1', 'test1', callback);\n+    },\n+    function(callback){\n+        fs.writeFile('testfile2', 'test2', callback);\n+    }\n+]);\n+```\n+\n+It's possible to pass any number of additional arguments when calling the\n+continuation:\n+\n+```js\n+node> var fn = async.apply(sys.puts, 'one');\n+node> fn('two', 'three');\n+one\n+two\n+three\n+```\n+\n+---------------------------------------\n+\n+<a name=\"nextTick\" />\n+### nextTick(callback)\n+\n+Calls `callback` on a later loop around the event loop. In Node.js this just\n+calls `process.nextTick`; in the browser it falls back to `setImmediate(callback)`\n+if available, otherwise `setTimeout(callback, 0)`, which means other higher priority\n+events may precede the execution of `callback`.\n+\n+This is used internally for browser-compatibility purposes.\n+\n+__Arguments__\n+\n+* `callback` - The function to call on a later loop around the event loop.\n+\n+__Example__\n+\n+```js\n+var call_order = [];\n+async.nextTick(function(){\n+    call_order.push('two');\n+    // call_order now equals ['one','two']\n+});\n+call_order.push('one')\n+```\n+\n+<a name=\"times\" />\n+### times(n, callback)\n+\n+Calls the `callback` function `n` times, and accumulates results in the same manner\n+you would use with [`map`](#map).\n+\n+__Arguments__\n+\n+* `n` - The number of times to run the function.\n+* `callback` - The function to call `n` times.\n+\n+__Example__\n+\n+```js\n+// Pretend this is some complicated async factory\n+var createUser = function(id, callback) {\n+  callback(null, {\n+    id: 'user' + id\n+  })\n+}\n+// generate 5 users\n+async.times(5, function(n, next){\n+    createUser(n, function(err, user) {\n+      next(err, user)\n+    })\n+}, function(err, users) {\n+  // we should now have 5 users\n+});\n+```\n+\n+<a name=\"timesSeries\" />\n+### timesSeries(n, callback)\n+\n+The same as [`times`](#times), only the iterator is applied to each item in `arr` in\n+series. The next `iterator` is only called once the current one has completed. \n+The results array will be in the same order as the original.\n+\n+\n+## Utils\n+\n+<a name=\"memoize\" />\n+### memoize(fn, [hasher])\n+\n+Caches the results of an `async` function. When creating a hash to store function\n+results against, the callback is omitted from the hash and an optional hash\n+function can be used.\n+\n+The cache of results is exposed as the `memo` property of the function returned\n+by `memoize`.\n+\n+__Arguments__\n+\n+* `fn` - The function to proxy and cache results from.\n+* `hasher` - Tn optional function for generating a custom hash for storing\n+  results. It has all the arguments applied to it apart from the callback, and\n+  must be synchronous.\n+\n+__Example__\n+\n+```js\n+var slow_fn = function (name, callback) {\n+    // do something\n+    callback(null, result);\n+};\n+var fn = async.memoize(slow_fn);\n+\n+// fn can now be used as if it were slow_fn\n+fn('some name', function () {\n+    // callback\n+});\n+```\n+\n+<a name=\"unmemoize\" />\n+### unmemoize(fn)\n+\n+Undoes a [`memoize`](#memoize)d function, reverting it to the original, unmemoized\n+form. Handy for testing.\n+\n+__Arguments__\n+\n+* `fn` - the memoized function\n+\n+<a name=\"log\" />\n+### log(function, arguments)\n+\n+Logs the result of an `async` function to the `console`. Only works in Node.js or\n+in browsers that support `console.log` and `console.error` (such as FF and Chrome).\n+If multiple arguments are returned from the async function, `console.log` is\n+called on each argument in order.\n+\n+__Arguments__\n+\n+* `function` - The function you want to eventually apply all arguments to.\n+* `arguments...` - Any number of arguments to apply to the function.\n+\n+__Example__\n+\n+```js\n+var hello = function(name, callback){\n+    setTimeout(function(){\n+        callback(null, 'hello ' + name);\n+    }, 1000);\n+};\n+```\n+```js\n+node> async.log(hello, 'world');\n+'hello world'\n+```\n+\n+---------------------------------------\n+\n+<a name=\"dir\" />\n+### dir(function, arguments)\n+\n+Logs the result of an `async` function to the `console` using `console.dir` to\n+display the properties of the resulting object. Only works in Node.js or\n+in browsers that support `console.dir` and `console.error` (such as FF and Chrome).\n+If multiple arguments are returned from the async function, `console.dir` is\n+called on each argument in order.\n+\n+__Arguments__\n+\n+* `function` - The function you want to eventually apply all arguments to.\n+* `arguments...` - Any number of arguments to apply to the function.\n+\n+__Example__\n+\n+```js\n+var hello = function(name, callback){\n+    setTimeout(function(){\n+        callback(null, {hello: name});\n+    }, 1000);\n+};\n+```\n+```js\n+node> async.dir(hello, 'world');\n+{hello: 'world'}\n+```\n+\n+---------------------------------------\n+\n+<a name=\"noConflict\" />\n+### noConflict()\n+\n+Changes the value of `async` back to its original value, returning a reference to the\n+`async` object.\ndiff --git a/node_modules/async/component.json b/node_modules/async/component.json\nnew file mode 100644\nindex 0000000..bbb0115\n--- /dev/null\n+++ b/node_modules/async/component.json\n@@ -0,0 +1,11 @@\n+{\n+  \"name\": \"async\",\n+  \"repo\": \"caolan/async\",\n+  \"description\": \"Higher-order functions and common patterns for asynchronous code\",\n+  \"version\": \"0.1.23\",\n+  \"keywords\": [],\n+  \"dependencies\": {},\n+  \"development\": {},\n+  \"main\": \"lib/async.js\",\n+  \"scripts\": [ \"lib/async.js\" ]\n+}\ndiff --git a/node_modules/async/lib/async.js b/node_modules/async/lib/async.js\nnew file mode 100644\nindex 0000000..01e8afc\n--- /dev/null\n+++ b/node_modules/async/lib/async.js\n@@ -0,0 +1,1123 @@\n+/*!\n+ * async\n+ * https://github.com/caolan/async\n+ *\n+ * Copyright 2010-2014 Caolan McMahon\n+ * Released under the MIT license\n+ */\n+/*jshint onevar: false, indent:4 */\n+/*global setImmediate: false, setTimeout: false, console: false */\n+(function () {\n+\n+    var async = {};\n+\n+    // global on the server, window in the browser\n+    var root, previous_async;\n+\n+    root = this;\n+    if (root != null) {\n+      previous_async = root.async;\n+    }\n+\n+    async.noConflict = function () {\n+        root.async = previous_async;\n+        return async;\n+    };\n+\n+    function only_once(fn) {\n+        var called = false;\n+        return function() {\n+            if (called) throw new Error(\"Callback was already called.\");\n+            called = true;\n+            fn.apply(root, arguments);\n+        }\n+    }\n+\n+    //// cross-browser compatiblity functions ////\n+\n+    var _toString = Object.prototype.toString;\n+\n+    var _isArray = Array.isArray || function (obj) {\n+        return _toString.call(obj) === '[object Array]';\n+    };\n+\n+    var _each = function (arr, iterator) {\n+        if (arr.forEach) {\n+            return arr.forEach(iterator);\n+        }\n+        for (var i = 0; i < arr.length; i += 1) {\n+            iterator(arr[i], i, arr);\n+        }\n+    };\n+\n+    var _map = function (arr, iterator) {\n+        if (arr.map) {\n+            return arr.map(iterator);\n+        }\n+        var results = [];\n+        _each(arr, function (x, i, a) {\n+            results.push(iterator(x, i, a));\n+        });\n+        return results;\n+    };\n+\n+    var _reduce = function (arr, iterator, memo) {\n+        if (arr.reduce) {\n+            return arr.reduce(iterator, memo);\n+        }\n+        _each(arr, function (x, i, a) {\n+            memo = iterator(memo, x, i, a);\n+        });\n+        return memo;\n+    };\n+\n+    var _keys = function (obj) {\n+        if (Object.keys) {\n+            return Object.keys(obj);\n+        }\n+        var keys = [];\n+        for (var k in obj) {\n+            if (obj.hasOwnProperty(k)) {\n+                keys.push(k);\n+            }\n+        }\n+        return keys;\n+    };\n+\n+    //// exported async module functions ////\n+\n+    //// nextTick implementation with browser-compatible fallback ////\n+    if (typeof process === 'undefined' || !(process.nextTick)) {\n+        if (typeof setImmediate === 'function') {\n+            async.nextTick = function (fn) {\n+                // not a direct alias for IE10 compatibility\n+                setImmediate(fn);\n+            };\n+            async.setImmediate = async.nextTick;\n+        }\n+        else {\n+            async.nextTick = function (fn) {\n+                setTimeout(fn, 0);\n+            };\n+            async.setImmediate = async.nextTick;\n+        }\n+    }\n+    else {\n+        async.nextTick = process.nextTick;\n+        if (typeof setImmediate !== 'undefined') {\n+            async.setImmediate = function (fn) {\n+              // not a direct alias for IE10 compatibility\n+              setImmediate(fn);\n+            };\n+        }\n+        else {\n+            async.setImmediate = async.nextTick;\n+        }\n+    }\n+\n+    async.each = function (arr, iterator, callback) {\n+        callback = callback || function () {};\n+        if (!arr.length) {\n+            return callback();\n+        }\n+        var completed = 0;\n+        _each(arr, function (x) {\n+            iterator(x, only_once(done) );\n+        });\n+        function done(err) {\n+          if (err) {\n+              callback(err);\n+              callback = function () {};\n+          }\n+          else {\n+              completed += 1;\n+              if (completed >= arr.length) {\n+                  callback();\n+              }\n+          }\n+        }\n+    };\n+    async.forEach = async.each;\n+\n+    async.eachSeries = function (arr, iterator, callback) {\n+        callback = callback || function () {};\n+        if (!arr.length) {\n+            return callback();\n+        }\n+        var completed = 0;\n+        var iterate = function () {\n+            iterator(arr[completed], function (err) {\n+                if (err) {\n+                    callback(err);\n+                    callback = function () {};\n+                }\n+                else {\n+                    completed += 1;\n+                    if (completed >= arr.length) {\n+                        callback();\n+                    }\n+                    else {\n+                        iterate();\n+                    }\n+                }\n+            });\n+        };\n+        iterate();\n+    };\n+    async.forEachSeries = async.eachSeries;\n+\n+    async.eachLimit = function (arr, limit, iterator, callback) {\n+        var fn = _eachLimit(limit);\n+        fn.apply(null, [arr, iterator, callback]);\n+    };\n+    async.forEachLimit = async.eachLimit;\n+\n+    var _eachLimit = function (limit) {\n+\n+        return function (arr, iterator, callback) {\n+            callback = callback || function () {};\n+            if (!arr.length || limit <= 0) {\n+                return callback();\n+            }\n+            var completed = 0;\n+            var started = 0;\n+            var running = 0;\n+\n+            (function replenish () {\n+                if (completed >= arr.length) {\n+                    return callback();\n+                }\n+\n+                while (running < limit && started < arr.length) {\n+                    started += 1;\n+                    running += 1;\n+                    iterator(arr[started - 1], function (err) {\n+                        if (err) {\n+                            callback(err);\n+                            callback = function () {};\n+                        }\n+                        else {\n+                            completed += 1;\n+                            running -= 1;\n+                            if (completed >= arr.length) {\n+                                callback();\n+                            }\n+                            else {\n+                                replenish();\n+                            }\n+                        }\n+                    });\n+                }\n+            })();\n+        };\n+    };\n+\n+\n+    var doParallel = function (fn) {\n+        return function () {\n+            var args = Array.prototype.slice.call(arguments);\n+            return fn.apply(null, [async.each].concat(args));\n+        };\n+    };\n+    var doParallelLimit = function(limit, fn) {\n+        return function () {\n+            var args = Array.prototype.slice.call(arguments);\n+            return fn.apply(null, [_eachLimit(limit)].concat(args));\n+        };\n+    };\n+    var doSeries = function (fn) {\n+        return function () {\n+            var args = Array.prototype.slice.call(arguments);\n+            return fn.apply(null, [async.eachSeries].concat(args));\n+        };\n+    };\n+\n+\n+    var _asyncMap = function (eachfn, arr, iterator, callback) {\n+        arr = _map(arr, function (x, i) {\n+            return {index: i, value: x};\n+        });\n+        if (!callback) {\n+            eachfn(arr, function (x, callback) {\n+                iterator(x.value, function (err) {\n+                    callback(err);\n+                });\n+            });\n+        } else {\n+            var results = [];\n+            eachfn(arr, function (x, callback) {\n+                iterator(x.value, function (err, v) {\n+                    results[x.index] = v;\n+                    callback(err);\n+                });\n+            }, function (err) {\n+                callback(err, results);\n+            });\n+        }\n+    };\n+    async.map = doParallel(_asyncMap);\n+    async.mapSeries = doSeries(_asyncMap);\n+    async.mapLimit = function (arr, limit, iterator, callback) {\n+        return _mapLimit(limit)(arr, iterator, callback);\n+    };\n+\n+    var _mapLimit = function(limit) {\n+        return doParallelLimit(limit, _asyncMap);\n+    };\n+\n+    // reduce only has a series version, as doing reduce in parallel won't\n+    // work in many situations.\n+    async.reduce = function (arr, memo, iterator, callback) {\n+        async.eachSeries(arr, function (x, callback) {\n+            iterator(memo, x, function (err, v) {\n+                memo = v;\n+                callback(err);\n+            });\n+        }, function (err) {\n+            callback(err, memo);\n+        });\n+    };\n+    // inject alias\n+    async.inject = async.reduce;\n+    // foldl alias\n+    async.foldl = async.reduce;\n+\n+    async.reduceRight = function (arr, memo, iterator, callback) {\n+        var reversed = _map(arr, function (x) {\n+            return x;\n+        }).reverse();\n+        async.reduce(reversed, memo, iterator, callback);\n+    };\n+    // foldr alias\n+    async.foldr = async.reduceRight;\n+\n+    var _filter = function (eachfn, arr, iterator, callback) {\n+        var results = [];\n+        arr = _map(arr, function (x, i) {\n+            return {index: i, value: x};\n+        });\n+        eachfn(arr, function (x, callback) {\n+            iterator(x.value, function (v) {\n+                if (v) {\n+                    results.push(x);\n+                }\n+                callback();\n+            });\n+        }, function (err) {\n+            callback(_map(results.sort(function (a, b) {\n+                return a.index - b.index;\n+            }), function (x) {\n+                return x.value;\n+            }));\n+        });\n+    };\n+    async.filter = doParallel(_filter);\n+    async.filterSeries = doSeries(_filter);\n+    // select alias\n+    async.select = async.filter;\n+    async.selectSeries = async.filterSeries;\n+\n+    var _reject = function (eachfn, arr, iterator, callback) {\n+        var results = [];\n+        arr = _map(arr, function (x, i) {\n+            return {index: i, value: x};\n+        });\n+        eachfn(arr, function (x, callback) {\n+            iterator(x.value, function (v) {\n+                if (!v) {\n+                    results.push(x);\n+                }\n+                callback();\n+            });\n+        }, function (err) {\n+            callback(_map(results.sort(function (a, b) {\n+                return a.index - b.index;\n+            }), function (x) {\n+                return x.value;\n+            }));\n+        });\n+    };\n+    async.reject = doParallel(_reject);\n+    async.rejectSeries = doSeries(_reject);\n+\n+    var _detect = function (eachfn, arr, iterator, main_callback) {\n+        eachfn(arr, function (x, callback) {\n+            iterator(x, function (result) {\n+                if (result) {\n+                    main_callback(x);\n+                    main_callback = function () {};\n+                }\n+                else {\n+                    callback();\n+                }\n+            });\n+        }, function (err) {\n+            main_callback();\n+        });\n+    };\n+    async.detect = doParallel(_detect);\n+    async.detectSeries = doSeries(_detect);\n+\n+    async.some = function (arr, iterator, main_callback) {\n+        async.each(arr, function (x, callback) {\n+            iterator(x, function (v) {\n+                if (v) {\n+                    main_callback(true);\n+                    main_callback = function () {};\n+                }\n+                callback();\n+            });\n+        }, function (err) {\n+            main_callback(false);\n+        });\n+    };\n+    // any alias\n+    async.any = async.some;\n+\n+    async.every = function (arr, iterator, main_callback) {\n+        async.each(arr, function (x, callback) {\n+            iterator(x, function (v) {\n+                if (!v) {\n+                    main_callback(false);\n+                    main_callback = function () {};\n+                }\n+                callback();\n+            });\n+        }, function (err) {\n+            main_callback(true);\n+        });\n+    };\n+    // all alias\n+    async.all = async.every;\n+\n+    async.sortBy = function (arr, iterator, callback) {\n+        async.map(arr, function (x, callback) {\n+            iterator(x, function (err, criteria) {\n+                if (err) {\n+                    callback(err);\n+                }\n+                else {\n+                    callback(null, {value: x, criteria: criteria});\n+                }\n+            });\n+        }, function (err, results) {\n+            if (err) {\n+                return callback(err);\n+            }\n+            else {\n+                var fn = function (left, right) {\n+                    var a = left.criteria, b = right.criteria;\n+                    return a < b ? -1 : a > b ? 1 : 0;\n+                };\n+                callback(null, _map(results.sort(fn), function (x) {\n+                    return x.value;\n+                }));\n+            }\n+        });\n+    };\n+\n+    async.auto = function (tasks, callback) {\n+        callback = callback || function () {};\n+        var keys = _keys(tasks);\n+        var remainingTasks = keys.length\n+        if (!remainingTasks) {\n+            return callback();\n+        }\n+\n+        var results = {};\n+\n+        var listeners = [];\n+        var addListener = function (fn) {\n+            listeners.unshift(fn);\n+        };\n+        var removeListener = function (fn) {\n+            for (var i = 0; i < listeners.length; i += 1) {\n+                if (listeners[i] === fn) {\n+                    listeners.splice(i, 1);\n+                    return;\n+                }\n+            }\n+        };\n+        var taskComplete = function () {\n+            remainingTasks--\n+            _each(listeners.slice(0), function (fn) {\n+                fn();\n+            });\n+        };\n+\n+        addListener(function () {\n+            if (!remainingTasks) {\n+                var theCallback = callback;\n+                // prevent final callback from calling itself if it errors\n+                callback = function () {};\n+\n+                theCallback(null, results);\n+            }\n+        });\n+\n+        _each(keys, function (k) {\n+            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];\n+            var taskCallback = function (err) {\n+                var args = Array.prototype.slice.call(arguments, 1);\n+                if (args.length <= 1) {\n+                    args = args[0];\n+                }\n+                if (err) {\n+                    var safeResults = {};\n+                    _each(_keys(results), function(rkey) {\n+                        safeResults[rkey] = results[rkey];\n+                    });\n+                    safeResults[k] = args;\n+                    callback(err, safeResults);\n+                    // stop subsequent errors hitting callback multiple times\n+                    callback = function () {};\n+                }\n+                else {\n+                    results[k] = args;\n+                    async.setImmediate(taskComplete);\n+                }\n+            };\n+            var requires = task.slice(0, Math.abs(task.length - 1)) || [];\n+            var ready = function () {\n+                return _reduce(requires, function (a, x) {\n+                    return (a && results.hasOwnProperty(x));\n+                }, true) && !results.hasOwnProperty(k);\n+            };\n+            if (ready()) {\n+                task[task.length - 1](taskCallback, results);\n+            }\n+            else {\n+                var listener = function () {\n+                    if (ready()) {\n+                        removeListener(listener);\n+                        task[task.length - 1](taskCallback, results);\n+                    }\n+                };\n+                addListener(listener);\n+            }\n+        });\n+    };\n+\n+    async.retry = function(times, task, callback) {\n+        var DEFAULT_TIMES = 5;\n+        var attempts = [];\n+        // Use defaults if times not passed\n+        if (typeof times === 'function') {\n+            callback = task;\n+            task = times;\n+            times = DEFAULT_TIMES;\n+        }\n+        // Make sure times is a number\n+        times = parseInt(times, 10) || DEFAULT_TIMES;\n+        var wrappedTask = function(wrappedCallback, wrappedResults) {\n+            var retryAttempt = function(task, finalAttempt) {\n+                return function(seriesCallback) {\n+                    task(function(err, result){\n+                        seriesCallback(!err || finalAttempt, {err: err, result: result});\n+                    }, wrappedResults);\n+                };\n+            };\n+            while (times) {\n+                attempts.push(retryAttempt(task, !(times-=1)));\n+            }\n+            async.series(attempts, function(done, data){\n+                data = data[data.length - 1];\n+                (wrappedCallback || callback)(data.err, data.result);\n+            });\n+        }\n+        // If a callback is passed, run this as a controll flow\n+        return callback ? wrappedTask() : wrappedTask\n+    };\n+\n+    async.waterfall = function (tasks, callback) {\n+        callback = callback || function () {};\n+        if (!_isArray(tasks)) {\n+          var err = new Error('First argument to waterfall must be an array of functions');\n+          return callback(err);\n+        }\n+        if (!tasks.length) {\n+            return callback();\n+        }\n+        var wrapIterator = function (iterator) {\n+            return function (err) {\n+                if (err) {\n+                    callback.apply(null, arguments);\n+                    callback = function () {};\n+                }\n+                else {\n+                    var args = Array.prototype.slice.call(arguments, 1);\n+                    var next = iterator.next();\n+                    if (next) {\n+                        args.push(wrapIterator(next));\n+                    }\n+                    else {\n+                        args.push(callback);\n+                    }\n+                    async.setImmediate(function () {\n+                        iterator.apply(null, args);\n+                    });\n+                }\n+            };\n+        };\n+        wrapIterator(async.iterator(tasks))();\n+    };\n+\n+    var _parallel = function(eachfn, tasks, callback) {\n+        callback = callback || function () {};\n+        if (_isArray(tasks)) {\n+            eachfn.map(tasks, function (fn, callback) {\n+                if (fn) {\n+                    fn(function (err) {\n+                        var args = Array.prototype.slice.call(arguments, 1);\n+                        if (args.length <= 1) {\n+                            args = args[0];\n+                        }\n+                        callback.call(null, err, args);\n+                    });\n+                }\n+            }, callback);\n+        }\n+        else {\n+            var results = {};\n+            eachfn.each(_keys(tasks), function (k, callback) {\n+                tasks[k](function (err) {\n+                    var args = Array.prototype.slice.call(arguments, 1);\n+                    if (args.length <= 1) {\n+                        args = args[0];\n+                    }\n+                    results[k] = args;\n+                    callback(err);\n+                });\n+            }, function (err) {\n+                callback(err, results);\n+            });\n+        }\n+    };\n+\n+    async.parallel = function (tasks, callback) {\n+        _parallel({ map: async.map, each: async.each }, tasks, callback);\n+    };\n+\n+    async.parallelLimit = function(tasks, limit, callback) {\n+        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);\n+    };\n+\n+    async.series = function (tasks, callback) {\n+        callback = callback || function () {};\n+        if (_isArray(tasks)) {\n+            async.mapSeries(tasks, function (fn, callback) {\n+                if (fn) {\n+                    fn(function (err) {\n+                        var args = Array.prototype.slice.call(arguments, 1);\n+                        if (args.length <= 1) {\n+                            args = args[0];\n+                        }\n+                        callback.call(null, err, args);\n+                    });\n+                }\n+            }, callback);\n+        }\n+        else {\n+            var results = {};\n+            async.eachSeries(_keys(tasks), function (k, callback) {\n+                tasks[k](function (err) {\n+                    var args = Array.prototype.slice.call(arguments, 1);\n+                    if (args.length <= 1) {\n+                        args = args[0];\n+                    }\n+                    results[k] = args;\n+                    callback(err);\n+                });\n+            }, function (err) {\n+                callback(err, results);\n+            });\n+        }\n+    };\n+\n+    async.iterator = function (tasks) {\n+        var makeCallback = function (index) {\n+            var fn = function () {\n+                if (tasks.length) {\n+                    tasks[index].apply(null, arguments);\n+                }\n+                return fn.next();\n+            };\n+            fn.next = function () {\n+                return (index < tasks.length - 1) ? makeCallback(index + 1): null;\n+            };\n+            return fn;\n+        };\n+        return makeCallback(0);\n+    };\n+\n+    async.apply = function (fn) {\n+        var args = Array.prototype.slice.call(arguments, 1);\n+        return function () {\n+            return fn.apply(\n+                null, args.concat(Array.prototype.slice.call(arguments))\n+            );\n+        };\n+    };\n+\n+    var _concat = function (eachfn, arr, fn, callback) {\n+        var r = [];\n+        eachfn(arr, function (x, cb) {\n+            fn(x, function (err, y) {\n+                r = r.concat(y || []);\n+                cb(err);\n+            });\n+        }, function (err) {\n+            callback(err, r);\n+        });\n+    };\n+    async.concat = doParallel(_concat);\n+    async.concatSeries = doSeries(_concat);\n+\n+    async.whilst = function (test, iterator, callback) {\n+        if (test()) {\n+            iterator(function (err) {\n+                if (err) {\n+                    return callback(err);\n+                }\n+                async.whilst(test, iterator, callback);\n+            });\n+        }\n+        else {\n+            callback();\n+        }\n+    };\n+\n+    async.doWhilst = function (iterator, test, callback) {\n+        iterator(function (err) {\n+            if (err) {\n+                return callback(err);\n+            }\n+            var args = Array.prototype.slice.call(arguments, 1);\n+            if (test.apply(null, args)) {\n+                async.doWhilst(iterator, test, callback);\n+            }\n+            else {\n+                callback();\n+            }\n+        });\n+    };\n+\n+    async.until = function (test, iterator, callback) {\n+        if (!test()) {\n+            iterator(function (err) {\n+                if (err) {\n+                    return callback(err);\n+                }\n+                async.until(test, iterator, callback);\n+            });\n+        }\n+        else {\n+            callback();\n+        }\n+    };\n+\n+    async.doUntil = function (iterator, test, callback) {\n+        iterator(function (err) {\n+            if (err) {\n+                return callback(err);\n+            }\n+            var args = Array.prototype.slice.call(arguments, 1);\n+            if (!test.apply(null, args)) {\n+                async.doUntil(iterator, test, callback);\n+            }\n+            else {\n+                callback();\n+            }\n+        });\n+    };\n+\n+    async.queue = function (worker, concurrency) {\n+        if (concurrency === undefined) {\n+            concurrency = 1;\n+        }\n+        function _insert(q, data, pos, callback) {\n+          if (!q.started){\n+            q.started = true;\n+          }\n+          if (!_isArray(data)) {\n+              data = [data];\n+          }\n+          if(data.length == 0) {\n+             // call drain immediately if there are no tasks\n+             return async.setImmediate(function() {\n+                 if (q.drain) {\n+                     q.drain();\n+                 }\n+             });\n+          }\n+          _each(data, function(task) {\n+              var item = {\n+                  data: task,\n+                  callback: typeof callback === 'function' ? callback : null\n+              };\n+\n+              if (pos) {\n+                q.tasks.unshift(item);\n+              } else {\n+                q.tasks.push(item);\n+              }\n+\n+              if (q.saturated && q.tasks.length === q.concurrency) {\n+                  q.saturated();\n+              }\n+              async.setImmediate(q.process);\n+          });\n+        }\n+\n+        var workers = 0;\n+        var q = {\n+            tasks: [],\n+            concurrency: concurrency,\n+            saturated: null,\n+            empty: null,\n+            drain: null,\n+            started: false,\n+            paused: false,\n+            push: function (data, callback) {\n+              _insert(q, data, false, callback);\n+            },\n+            kill: function () {\n+              q.drain = null;\n+              q.tasks = [];\n+            },\n+            unshift: function (data, callback) {\n+              _insert(q, data, true, callback);\n+            },\n+            process: function () {\n+                if (!q.paused && workers < q.concurrency && q.tasks.length) {\n+                    var task = q.tasks.shift();\n+                    if (q.empty && q.tasks.length === 0) {\n+                        q.empty();\n+                    }\n+                    workers += 1;\n+                    var next = function () {\n+                        workers -= 1;\n+                        if (task.callback) {\n+                            task.callback.apply(task, arguments);\n+                        }\n+                        if (q.drain && q.tasks.length + workers === 0) {\n+                            q.drain();\n+                        }\n+                        q.process();\n+                    };\n+                    var cb = only_once(next);\n+                    worker(task.data, cb);\n+                }\n+            },\n+            length: function () {\n+                return q.tasks.length;\n+            },\n+            running: function () {\n+                return workers;\n+            },\n+            idle: function() {\n+                return q.tasks.length + workers === 0;\n+            },\n+            pause: function () {\n+                if (q.paused === true) { return; }\n+                q.paused = true;\n+                q.process();\n+            },\n+            resume: function () {\n+                if (q.paused === false) { return; }\n+                q.paused = false;\n+                q.process();\n+            }\n+        };\n+        return q;\n+    };\n+    \n+    async.priorityQueue = function (worker, concurrency) {\n+        \n+        function _compareTasks(a, b){\n+          return a.priority - b.priority;\n+        };\n+        \n+        function _binarySearch(sequence, item, compare) {\n+          var beg = -1,\n+              end = sequence.length - 1;\n+          while (beg < end) {\n+            var mid = beg + ((end - beg + 1) >>> 1);\n+            if (compare(item, sequence[mid]) >= 0) {\n+              beg = mid;\n+            } else {\n+              end = mid - 1;\n+            }\n+          }\n+          return beg;\n+        }\n+        \n+        function _insert(q, data, priority, callback) {\n+          if (!q.started){\n+            q.started = true;\n+          }\n+          if (!_isArray(data)) {\n+              data = [data];\n+          }\n+          if(data.length == 0) {\n+             // call drain immediately if there are no tasks\n+             return async.setImmediate(function() {\n+                 if (q.drain) {\n+                     q.drain();\n+                 }\n+             });\n+          }\n+          _each(data, function(task) {\n+              var item = {\n+                  data: task,\n+                  priority: priority,\n+                  callback: typeof callback === 'function' ? callback : null\n+              };\n+              \n+              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);\n+\n+              if (q.saturated && q.tasks.length === q.concurrency) {\n+                  q.saturated();\n+              }\n+              async.setImmediate(q.process);\n+          });\n+        }\n+        \n+        // Start with a normal queue\n+        var q = async.queue(worker, concurrency);\n+        \n+        // Override push to accept second parameter representing priority\n+        q.push = function (data, priority, callback) {\n+          _insert(q, data, priority, callback);\n+        };\n+        \n+        // Remove unshift function\n+        delete q.unshift;\n+\n+        return q;\n+    };\n+\n+    async.cargo = function (worker, payload) {\n+        var working     = false,\n+            tasks       = [];\n+\n+        var cargo = {\n+            tasks: tasks,\n+            payload: payload,\n+            saturated: null,\n+            empty: null,\n+            drain: null,\n+            drained: true,\n+            push: function (data, callback) {\n+                if (!_isArray(data)) {\n+                    data = [data];\n+                }\n+                _each(data, function(task) {\n+                    tasks.push({\n+                        data: task,\n+                        callback: typeof callback === 'function' ? callback : null\n+                    });\n+                    cargo.drained = false;\n+                    if (cargo.saturated && tasks.length === payload) {\n+                        cargo.saturated();\n+                    }\n+                });\n+                async.setImmediate(cargo.process);\n+            },\n+            process: function process() {\n+                if (working) return;\n+                if (tasks.length === 0) {\n+                    if(cargo.drain && !cargo.drained) cargo.drain();\n+                    cargo.drained = true;\n+                    return;\n+                }\n+\n+                var ts = typeof payload === 'number'\n+                            ? tasks.splice(0, payload)\n+                            : tasks.splice(0, tasks.length);\n+\n+                var ds = _map(ts, function (task) {\n+                    return task.data;\n+                });\n+\n+                if(cargo.empty) cargo.empty();\n+                working = true;\n+                worker(ds, function () {\n+                    working = false;\n+\n+                    var args = arguments;\n+                    _each(ts, function (data) {\n+                        if (data.callback) {\n+                            data.callback.apply(null, args);\n+                        }\n+                    });\n+\n+                    process();\n+                });\n+            },\n+            length: function () {\n+                return tasks.length;\n+            },\n+            running: function () {\n+                return working;\n+            }\n+        };\n+        return cargo;\n+    };\n+\n+    var _console_fn = function (name) {\n+        return function (fn) {\n+            var args = Array.prototype.slice.call(arguments, 1);\n+            fn.apply(null, args.concat([function (err) {\n+                var args = Array.prototype.slice.call(arguments, 1);\n+                if (typeof console !== 'undefined') {\n+                    if (err) {\n+                        if (console.error) {\n+                            console.error(err);\n+                        }\n+                    }\n+                    else if (console[name]) {\n+                        _each(args, function (x) {\n+                            console[name](x);\n+                        });\n+                    }\n+                }\n+            }]));\n+        };\n+    };\n+    async.log = _console_fn('log');\n+    async.dir = _console_fn('dir');\n+    /*async.info = _console_fn('info');\n+    async.warn = _console_fn('warn');\n+    async.error = _console_fn('error');*/\n+\n+    async.memoize = function (fn, hasher) {\n+        var memo = {};\n+        var queues = {};\n+        hasher = hasher || function (x) {\n+            return x;\n+        };\n+        var memoized = function () {\n+            var args = Array.prototype.slice.call(arguments);\n+            var callback = args.pop();\n+            var key = hasher.apply(null, args);\n+            if (key in memo) {\n+                async.nextTick(function () {\n+                    callback.apply(null, memo[key]);\n+                });\n+            }\n+            else if (key in queues) {\n+                queues[key].push(callback);\n+            }\n+            else {\n+                queues[key] = [callback];\n+                fn.apply(null, args.concat([function () {\n+                    memo[key] = arguments;\n+                    var q = queues[key];\n+                    delete queues[key];\n+                    for (var i = 0, l = q.length; i < l; i++) {\n+                      q[i].apply(null, arguments);\n+                    }\n+                }]));\n+            }\n+        };\n+        memoized.memo = memo;\n+        memoized.unmemoized = fn;\n+        return memoized;\n+    };\n+\n+    async.unmemoize = function (fn) {\n+      return function () {\n+        return (fn.unmemoized || fn).apply(null, arguments);\n+      };\n+    };\n+\n+    async.times = function (count, iterator, callback) {\n+        var counter = [];\n+        for (var i = 0; i < count; i++) {\n+            counter.push(i);\n+        }\n+        return async.map(counter, iterator, callback);\n+    };\n+\n+    async.timesSeries = function (count, iterator, callback) {\n+        var counter = [];\n+        for (var i = 0; i < count; i++) {\n+            counter.push(i);\n+        }\n+        return async.mapSeries(counter, iterator, callback);\n+    };\n+\n+    async.seq = function (/* functions... */) {\n+        var fns = arguments;\n+        return function () {\n+            var that = this;\n+            var args = Array.prototype.slice.call(arguments);\n+            var callback = args.pop();\n+            async.reduce(fns, args, function (newargs, fn, cb) {\n+                fn.apply(that, newargs.concat([function () {\n+                    var err = arguments[0];\n+                    var nextargs = Array.prototype.slice.call(arguments, 1);\n+                    cb(err, nextargs);\n+                }]))\n+            },\n+            function (err, results) {\n+                callback.apply(that, [err].concat(results));\n+            });\n+        };\n+    };\n+\n+    async.compose = function (/* functions... */) {\n+      return async.seq.apply(null, Array.prototype.reverse.call(arguments));\n+    };\n+\n+    var _applyEach = function (eachfn, fns /*args...*/) {\n+        var go = function () {\n+            var that = this;\n+            var args = Array.prototype.slice.call(arguments);\n+            var callback = args.pop();\n+            return eachfn(fns, function (fn, cb) {\n+                fn.apply(that, args.concat([cb]));\n+            },\n+            callback);\n+        };\n+        if (arguments.length > 2) {\n+            var args = Array.prototype.slice.call(arguments, 2);\n+            return go.apply(this, args);\n+        }\n+        else {\n+            return go;\n+        }\n+    };\n+    async.applyEach = doParallel(_applyEach);\n+    async.applyEachSeries = doSeries(_applyEach);\n+\n+    async.forever = function (fn, callback) {\n+        function next(err) {\n+            if (err) {\n+                if (callback) {\n+                    return callback(err);\n+                }\n+                throw err;\n+            }\n+            fn(next);\n+        }\n+        next();\n+    };\n+\n+    // Node.js\n+    if (typeof module !== 'undefined' && module.exports) {\n+        module.exports = async;\n+    }\n+    // AMD / RequireJS\n+    else if (typeof define !== 'undefined' && define.amd) {\n+        define([], function () {\n+            return async;\n+        });\n+    }\n+    // included directly via <script> tag\n+    else {\n+        root.async = async;\n+    }\n+\n+}());\ndiff --git a/node_modules/async/package.json b/node_modules/async/package.json\nnew file mode 100644\nindex 0000000..31a5200\n--- /dev/null\n+++ b/node_modules/async/package.json\n@@ -0,0 +1,59 @@\n+{\n+  \"name\": \"async\",\n+  \"description\": \"Higher-order functions and common patterns for asynchronous code\",\n+  \"main\": \"./lib/async\",\n+  \"author\": {\n+    \"name\": \"Caolan McMahon\"\n+  },\n+  \"version\": \"0.9.0\",\n+  \"repository\": {\n+    \"type\": \"git\",\n+    \"url\": \"https://github.com/caolan/async.git\"\n+  },\n+  \"bugs\": {\n+    \"url\": \"https://github.com/caolan/async/issues\"\n+  },\n+  \"licenses\": [\n+    {\n+      \"type\": \"MIT\",\n+      \"url\": \"https://github.com/caolan/async/raw/master/LICENSE\"\n+    }\n+  ],\n+  \"devDependencies\": {\n+    \"nodeunit\": \">0.0.0\",\n+    \"uglify-js\": \"1.2.x\",\n+    \"nodelint\": \">0.0.0\"\n+  },\n+  \"jam\": {\n+    \"main\": \"lib/async.js\",\n+    \"include\": [\n+      \"lib/async.js\",\n+      \"README.md\",\n+      \"LICENSE\"\n+    ]\n+  },\n+  \"scripts\": {\n+    \"test\": \"nodeunit test/test-async.js\"\n+  },\n+  \"homepage\": \"https://github.com/caolan/async\",\n+  \"_id\": \"async@0.9.0\",\n+  \"dist\": {\n+    \"shasum\": \"ac3613b1da9bed1b47510bb4651b8931e47146c7\",\n+    \"tarball\": \"http://registry.npmjs.org/async/-/async-0.9.0.tgz\"\n+  },\n+  \"_from\": \"async@*\",\n+  \"_npmVersion\": \"1.4.3\",\n+  \"_npmUser\": {\n+    \"name\": \"caolan\",\n+    \"email\": \"caolan.mcmahon@gmail.com\"\n+  },\n+  \"maintainers\": [\n+    {\n+      \"name\": \"caolan\",\n+      \"email\": \"caolan@caolanmcmahon.com\"\n+    }\n+  ],\n+  \"directories\": {},\n+  \"_shasum\": \"ac3613b1da9bed1b47510bb4651b8931e47146c7\",\n+  \"_resolved\": \"https://registry.npmjs.org/async/-/async-0.9.0.tgz\"\n+}\ndiff --git a/package.json b/package.json\nindex 5f21627..6033d43 100644\n--- a/package.json\n+++ b/package.json\n@@ -4,7 +4,8 @@\n   \"description\": \"Sous project\",\n   \"main\": \"main.js\",\n   \"dependencies\": {\n-},\n+    \"async\": \"*\"\n+  },\n   \"devDependencies\": {},\n   \"scripts\": {\n     \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\ndiff --git a/patches.sousp b/patches.sousp\nindex 16405a3..d71e511 100644\n--- a/patches.sousp\n+++ b/patches.sousp\n@@ -1,31 +1 @@\n-diff --git a/main.js b/main.js\n-index f81b54e..744cdd5 100644\n---- a/main.js\n-+++ b/main.js\n-@@ -35,7 +35,7 @@ fs.exists('.git', function (exists) {\n-         cp.exec('git diff', function(error, stdout, stderr) {\n-             console.log(stdout);\n- \n--            //fs.writeFileSync(\"patches.sousp\", stdout);\n-+            fs.writeFileSync(\"patches.sousp\", stdout);\n- \n-             if (error !== null) {\n-                 console.log('stderr: ' + stderr);\n-@@ -44,7 +44,7 @@ fs.exists('.git', function (exists) {\n-         });\n- \n-         cp.exec('git log', function(error, stdout, stderr) {\n--            //console.log(stdout);\n-+            console.log(stdout);\n- \n-             var authors = findData(stdout, \"Author:\");\n-             var dates = findData(stdout, \"Date:\");\n-@@ -53,7 +53,7 @@ fs.exists('.git', function (exists) {\n-             console.log(comments);\n-             console.log(dates);\n- \n--            //fs.writeFileSync(\"comments.sousc\", stdout);\n-+            fs.writeFileSync(\"comments.sousc\", stdout);\n- \n-             if (error !== null) {\n-                 console.log('stderr: ' + stderr);\n+[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]\n\\ No newline at end of file\ndiff --git a/test.js b/test.js\nnew file mode 100644\nindex 0000000..5ca759c\n--- /dev/null\n+++ b/test.js\n@@ -0,0 +1,21 @@\n+/**\n+ * Created by Nick on 18.05.2015.\n+ */\n+var async = require('async')\n+    , tasksIndex = [\n+        function (callback) {\n+            // Вымышленный метод который вернет 231\n+            var viewsNumber = models.stat.viewsNumber();\n+            callback(null, viewsNumber);\n+        }\n+        , function (callback) {\n+            // Вымышленный метод который вернет 24\n+            var growFactor = models.stat.growFactor();\n+            callback(null, growFactor);\n+        }\n+    ];\n+\n+async.series(tasksIndex, function (err, results) {\n+    // Результат будет массивом\n+    console.log(results); // [231, 24]\n+});\n\\ No newline at end of file\n"}